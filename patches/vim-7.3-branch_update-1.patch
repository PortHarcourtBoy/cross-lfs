Submitted By: Joe Ciccone <jciccone@gmail.com>
Date: 01-08-2010
Initial Package Version: 7.3
Origin: Upstream
Upstream Status: From Upstream
Description: Contains all upstream patches between 7.3.001 and 7.3.099

diff -Naur vim73.orig/runtime/doc/eval.txt vim73/runtime/doc/eval.txt
--- vim73.orig/runtime/doc/eval.txt	2010-08-15 08:23:20.000000000 -0400
+++ vim73/runtime/doc/eval.txt	2011-01-08 21:01:18.986656145 -0500
@@ -1657,6 +1657,15 @@
 					*v:warningmsg* *warningmsg-variable*
 v:warningmsg	Last given warning message.  It's allowed to set this variable.
 
+					*v:windowid* *windowid-variable*
+v:windowid	When any X11 based GUI is running or when running in a
+		terminal and Vim connects to the X server (|-X|) this will be
+		set to the window ID.
+		When an MS-Windows GUI is running this will be set to the
+		window handle.
+		Otherwise the value is zero.
+		Note: for windows inside Vim use |winnr()|.
+
 ==============================================================================
 4. Builtin Functions					*functions*
 
@@ -1822,7 +1831,7 @@
 log( {expr})			Float	natural logarithm (base e) of {expr}
 log10( {expr})			Float	logarithm of Float {expr} to base 10
 map( {expr}, {string})		List/Dict  change each item in {expr} to {expr}
-maparg( {name}[, {mode} [, {abbr}]])
+maparg( {name}[, {mode} [, {abbr} [, {dict}]]])
 				String	rhs of mapping {name} in mode {mode}
 mapcheck( {name}[, {mode} [, {abbr}]])
 				String	check for mappings matching {name}
@@ -3966,23 +3975,51 @@
 		further items in {expr} are processed.
 
 
-maparg({name}[, {mode} [, {abbr}]])			*maparg()*
-		Return the rhs of mapping {name} in mode {mode}.  When there
-		is no mapping for {name}, an empty String is returned.
+maparg({name}[, {mode} [, {abbr} [, {dict}]]])			*maparg()*
+		When {dict} is omitted or zero: Return the rhs of mapping
+		{name} in mode {mode}.  The returned String has special
+		characters translated like in the output of the ":map" command
+		listing.
+		
+		When there is no mapping for {name}, an empty String is
+		returned.
+
+		The {name} can have special key names, like in the ":map"
+		command.
+
 		{mode} can be one of these strings:
 			"n"	Normal
-			"v"	Visual
+			"v"	Visual (including Select)
 			"o"	Operator-pending
 			"i"	Insert
 			"c"	Cmd-line
+			"s"	Select
+			"x"	Visual
 			"l"	langmap |language-mapping|
 			""	Normal, Visual and Operator-pending
 		When {mode} is omitted, the modes for "" are used.
+
 		When {abbr} is there and it is non-zero use abbreviations
 		instead of mappings.
-		The {name} can have special key names, like in the ":map"
-		command.  The returned String has special characters
-		translated like in the output of the ":map" command listing.
+
+		When {dict} is there and it is non-zero return a dictionary
+		containing all the information of the mapping with the
+		following items:
+		  "lhs"	     The {lhs} of the mapping.
+		  "rhs"	     The {rhs} of the mapping as typed.
+		  "silent"   1 for a |:map-silent| mapping, else 0.
+		  "noremap"  1 if the {rhs} of the mapping is remappable.
+		  "expr"     1 for an expression mapping (|:map-<expr>|).
+		  "buffer"   1 for a buffer local mapping (|:map-local|).
+		  "mode"     Modes for which the mapping is defined. In
+			     addition to the modes mentioned above, these
+			     characters will be used:
+			     " "     Normal, Visual and Operator-pending
+			     "!"     Insert and Commandline mode
+				     (|mapmpde-ic|)
+		  "sid"	     the Script local ID, used for <sid> mappings
+			     (|<SID>|)
+
 		The mappings local to the current buffer are checked first,
 		then the global mappings.
 		This function can be used to map a key even when it's already
diff -Naur vim73.orig/runtime/doc/netbeans.txt vim73/runtime/doc/netbeans.txt
--- vim73.orig/runtime/doc/netbeans.txt	2010-08-15 08:23:21.000000000 -0400
+++ vim73/runtime/doc/netbeans.txt	2011-01-08 21:01:18.782656702 -0500
@@ -1,4 +1,4 @@
-*netbeans.txt*  For Vim version 7.3.  Last change: 2010 Jul 20
+*netbeans.txt*  For Vim version 7.3.  Last change: 2010 Aug 20
 
 
 		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
@@ -118,7 +118,8 @@
 uncommenting a line with "--disable-netbeans" in the Makefile.
 
 Currently the NetBeans interface is supported by Vim running in a terminal and
-by GVim when it is run with one of the following GUIs: GTK, GNOME, and Motif.
+by GVim when it is run with one of the following GUIs: GTK, GNOME, Windows,
+Athena and Motif.
 
 If Motif support is required the user must supply XPM libraries.  See
 |workshop-xpm| for details on obtaining the latest version of XPM.
diff -Naur vim73.orig/runtime/doc/options.txt vim73/runtime/doc/options.txt
--- vim73.orig/runtime/doc/options.txt	2010-08-15 08:23:21.000000000 -0400
+++ vim73/runtime/doc/options.txt	2011-01-08 21:01:19.258656350 -0500
@@ -1434,6 +1434,15 @@
 			explicitly accessed using the "* notation.  Also see
 			|gui-clipboard|.
 
+	unnamedplus	A variant of "unnamed" flag which uses the clipboard
+			register '+' (|quoteplus|) instead of register '*' for
+			all operations except yank.  Yank shall copy the text
+			into register '+' and also into '*' when "unnamed" is
+			included.
+			Only available with the |+x11| feature.
+			Availability can be checked with: >
+				if has('unnamedplus')
+<
 	autoselect	Works like the 'a' flag in 'guioptions': If present,
 			then whenever Visual mode is started, or the Visual
 			area extended, Vim tries to become the owner of the
@@ -7530,8 +7539,9 @@
 	!	When included, save and restore global variables that start
 		with an uppercase letter, and don't contain a lowercase
 		letter.  Thus "KEEPTHIS and "K_L_M" are stored, but "KeepThis"
-		and "_K_L_M" are not.  Only String and Number types are
-		stored.
+		and "_K_L_M" are not.  Nested List and Dict items may not be
+		read back correctly, you end up with a string representation
+		instead.
 	"	Maximum number of lines saved for each register.  Old name of
 		the '<' item, with the disadvantage that you need to put a
 		backslash before the ", otherwise it will be recognized as the
@@ -7747,6 +7757,17 @@
 	a pattern from the list.  This avoids problems when a future version
 	uses another default.
 
+
+			*'wildignorecase* *'wic'* *'nowildignorecase* *'nowic'*
+'wildignorecase' 'wic'	boolean	(default off)
+			global
+			{not in Vi}
+	When set case is ignored when completing file names and directories.
+	Has no effect on systems where file name case is generally ignored.
+	Does not apply when the shell is used to expand wildcards, which
+	happens when there are special characters.
+
+
 				*'wildmenu'* *'wmnu'* *'nowildmenu'* *'nowmnu'*
 'wildmenu' 'wmnu'	boolean	(default off)
 			global
diff -Naur vim73.orig/src/GvimExt/Make_ming.mak vim73/src/GvimExt/Make_ming.mak
--- vim73.orig/src/GvimExt/Make_ming.mak	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/GvimExt/Make_ming.mak	2011-01-08 21:01:19.490656530 -0500
@@ -17,6 +17,17 @@
 # check also the executables
 MINGWOLD = no
 
+# Link against the shared versions of libgcc/libstdc++ by default.  Set
+# STATIC_STDCPLUS to "yes" to link against static versions instead.
+STATIC_STDCPLUS=no
+#STATIC_STDCPLUS=yes
+
+# Note: -static-libstdc++ is not available until gcc 4.5.x.
+LDFLAGS += -shared
+ifeq (yes, $(STATIC_STDCPLUS))
+LDFLAGS += -static-libgcc -static-libstdc++
+endif
+
 ifeq ($(CROSS),yes)
 DEL = rm
 ifeq ($(MINGWOLD),yes)
@@ -34,6 +45,8 @@
 endif
 CXX := $(CROSS_COMPILE)g++
 WINDRES := $(CROSS_COMPILE)windres
+WINDRES_CXX = $(CXX)
+WINDRES_FLAGS = --preprocessor="$(WINDRES_CXX) -E -xc" -DRC_INVOKED
 LIBS :=  -luuid
 RES  := gvimext.res
 DEFFILE = gvimext_ming.def
@@ -46,7 +59,7 @@
 all: all-before $(DLL) all-after
 
 $(DLL): $(OBJ) $(RES) $(DEFFILE)
-	$(CXX) -shared $(CXXFLAGS) -s -o $@ \
+	$(CXX) $(LDFLAGS) $(CXXFLAGS) -s -o $@ \
 		-Wl,--enable-auto-image-base \
 		-Wl,--enable-auto-import \
 		-Wl,--whole-archive \
@@ -58,7 +71,7 @@
 	$(CXX) $(CXXFLAGS) -DFEAT_GETTEXT -c $? -o $@
 
 $(RES): gvimext_ming.rc
-	$(WINDRES) --input-format=rc --output-format=coff -DMING $? -o $@
+	$(WINDRES) $(WINDRES_FLAGS) --input-format=rc --output-format=coff -DMING $? -o $@
 
 clean: clean-custom
 	-$(DEL)  $(OBJ) $(RES) $(DLL)
diff -Naur vim73.orig/src/Make_cyg.mak vim73/src/Make_cyg.mak
--- vim73.orig/src/Make_cyg.mak	2010-08-02 15:09:22.000000000 -0400
+++ vim73/src/Make_cyg.mak	2011-01-08 21:01:19.102656144 -0500
@@ -1,6 +1,6 @@
 #
 # Makefile for VIM on Win32, using Cygnus gcc
-# Last updated by Dan Sharp.  Last Change: 2010 Feb 24
+# Last updated by Dan Sharp.  Last Change: 2010 Nov 03
 #
 # Also read INSTALLpc.txt!
 #
@@ -27,6 +27,7 @@
 #   MZSCHEME_VER      define to version of MzScheme being used (209_000)
 #   DYNAMIC_MZSCHEME  no or yes: use yes to load the MzScheme DLLs dynamically (yes)
 #   MZSCHEME_DLLS     path to MzScheme DLLs (libmzgc and libmzsch), for "static" build.
+#   MZSCHEME_USE_RACKET  define to use "racket" instead of "mzsch".
 # LUA	define to path to Lua dir to get Lua support (not defined)
 #   LUA_VER	    define to version of Lua being used (51)
 #   DYNAMIC_LUA  no or yes: use yes to load the Lua DLL dynamically (yes)
@@ -254,16 +255,22 @@
 MZSCHEME_GENERATE_BASE=no
 endif
 
+ifndef MZSCHEME_USE_RACKET
+MZSCHEME_MAIN_LIB=mzsch
+else
+MZSCHEME_MAIN_LIB=racket
+endif
+
 ifeq (yes, $(DYNAMIC_MZSCHEME))
-DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
+DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 else
 ifndef MZSCHEME_DLLS
 MZSCHEME_DLLS = $(MZSCHEME)
 endif
 ifeq (yes,$(MZSCHEME_PRECISE_GC))
-MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+MZSCHEME_LIB=-l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER)
 else
-MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+MZSCHEME_LIB = -l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
 endif
 EXTRA_LIBS += -L$(MZSCHEME_DLLS) -L$(MZSCHEME_DLLS)/lib $(MZSCHEME_LIB)
 endif
diff -Naur vim73.orig/src/Make_ming.mak vim73/src/Make_ming.mak
--- vim73.orig/src/Make_ming.mak	2010-08-02 15:09:43.000000000 -0400
+++ vim73/src/Make_ming.mak	2011-01-08 21:01:19.490656530 -0500
@@ -56,6 +56,12 @@
 NETBEANS=$(GUI)
 
 
+# Link against the shared version of libstdc++ by default.  Set
+# STATIC_STDCPLUS to "yes" to link against static version instead.
+ifndef STATIC_STDCPLUS
+STATIC_STDCPLUS=no
+endif
+
 # If the user doesn't want gettext, undefine it.
 ifeq (no, $(GETTEXT))
 GETTEXT=
@@ -141,11 +147,17 @@
 MZSCHEME_GENERATE_BASE=no
 endif
 
+ifndef MZSCHEME_USE_RACKET
+MZSCHEME_MAIN_LIB=mzsch
+else
+MZSCHEME_MAIN_LIB=racket
+endif
+
 ifeq (no,$(DYNAMIC_MZSCHEME))
 ifeq (yes,$(MZSCHEME_PRECISE_GC))
-MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+MZSCHEME_LIB=-l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER)
 else
-MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+MZSCHEME_LIB = -l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
 endif
 # the modern MinGW can dynamically link to dlls directly.
 # point MZSCHEME_DLLS to where you put libmzschXXXXXXX.dll and libgcXXXXXXX.dll
@@ -304,11 +316,13 @@
 endif
 CC := $(CROSS_COMPILE)gcc
 WINDRES := $(CROSS_COMPILE)windres
+WINDRES_CC = $(CC)
 
 #>>>>> end of choices
 ###########################################################################
 
 CFLAGS = -Iproto $(DEFINES) -pipe -w -march=$(ARCH) -Wall
+WINDRES_FLAGS = --preprocessor="$(WINDRES_CC) -E -xc" -DRC_INVOKED
 
 ifdef GETTEXT
 DEFINES += -DHAVE_GETTEXT -DHAVE_LOCALE_H
@@ -343,7 +357,7 @@
 ifdef MZSCHEME
 CFLAGS += -I$(MZSCHEME)/include -DFEAT_MZSCHEME -DMZSCHEME_COLLECTS=\"$(MZSCHEME)/collects\"
 ifeq (yes, $(DYNAMIC_MZSCHEME))
-CFLAGS += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
+CFLAGS += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 endif
 endif
 
@@ -571,8 +585,13 @@
 endif
 
 ifeq (yes, $(OLE))
-LIB += -loleaut32 -lstdc++
+LIB += -loleaut32
 OBJ += $(OUTDIR)/if_ole.o
+ifeq (yes, $(STATIC_STDCPLUS))
+LIB += -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+else
+LIB += -lstdc++
+endif
 endif
 
 ifeq (yes, $(MBYTE))
@@ -650,10 +669,10 @@
 	$(CC) -c $(CFLAGS) $< -o $@
 
 $(OUTDIR)/vimres.res: vim.rc version.h gui_w32_rc.h
-	$(WINDRES) $(DEFINES) vim.rc $(OUTDIR)/vimres.res
+	$(WINDRES) $(WINDRES_FLAGS) $(DEFINES) vim.rc $(OUTDIR)/vimres.res
 
 $(OUTDIR)/vimrc.o: $(OUTDIR)/vimres.res
-	$(WINDRES) $(OUTDIR)/vimres.res $(OUTDIR)/vimrc.o
+	$(WINDRES) $(WINDRES_FLAGS) $(OUTDIR)/vimres.res $(OUTDIR)/vimrc.o
 
 $(OUTDIR):
 	$(MKDIR) $(OUTDIR)
diff -Naur vim73.orig/src/Make_mvc.mak vim73/src/Make_mvc.mak
--- vim73.orig/src/Make_mvc.mak	2010-07-18 15:24:20.000000000 -0400
+++ vim73/src/Make_mvc.mak	2011-01-08 21:01:19.314657721 -0500
@@ -380,9 +380,6 @@
 !if "$(_NMAKE_VER)" == "10.00.30319.01"
 MSVCVER = 10.0
 !endif
-!if "$(_NMAKE_VER)" == "9.00.30729.01"
-MSVCVER = 9.0
-!endif
 !endif
 
 # Abort bulding VIM if version of VC is unrecognised.
@@ -705,12 +702,18 @@
 MZSCHEME_VER = 205_000
 !endif
 CFLAGS = $(CFLAGS) -DFEAT_MZSCHEME -I $(MZSCHEME)\include
-!if EXIST("$(MZSCHEME)\collects\scheme\base.ss")
-# for MzScheme 4.x we need to include byte code for basic Scheme stuff
+!if EXIST("$(MZSCHEME)\collects\scheme\base.ss") \
+	|| EXIST("$(MZSCHEME)\collects\scheme\base.rkt") 
+# for MzScheme >= 4 we need to include byte code for basic Scheme stuff
 MZSCHEME_EXTRA_DEP = mzscheme_base.c
 CFLAGS = $(CFLAGS) -DINCLUDE_MZSCHEME_BASE
 !endif
-!if EXIST("$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib") \
+!if EXIST("$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib")
+MZSCHEME_MAIN_LIB=mzsch
+!else
+MZSCHEME_MAIN_LIB=racket
+!endif
+!if EXIST("$(MZSCHEME)\lib\msvc\lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).lib") \
 	&& !EXIST("$(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib")
 !message Building with Precise GC
 MZSCHEME_PRECISE_GC = yes
@@ -722,7 +725,7 @@
 !endif
 !message MzScheme DLLs will be loaded dynamically
 CFLAGS = $(CFLAGS) -DDYNAMIC_MZSCHEME \
-		-DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" \
+		-DDYNAMIC_MZSCH_DLL=\"lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).dll\" \
 		-DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 !else
 !if "$(MZSCHEME_DEBUG)" == "yes"
@@ -730,10 +733,10 @@
 !endif
 !if "$(MZSCHEME_PRECISE_GC)" == "yes"
 # Precise GC does not use separate dll
-MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
+MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).lib
 !else
 MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib \
-		$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
+		$(MZSCHEME)\lib\msvc\lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).lib
 !endif
 !endif
 MZSCHEME_OBJ = $(OUTDIR)\if_mzsch.obj
diff -Naur vim73.orig/src/Makefile vim73/src/Makefile
--- vim73.orig/src/Makefile	2010-08-15 08:56:15.000000000 -0400
+++ vim73/src/Makefile	2011-01-08 21:01:19.114655467 -0500
@@ -414,12 +414,16 @@
 # However, this may still cause problems, such as "import termios" failing.
 # Build two separate versions of Vim in that case.
 #CONF_OPT_PYTHON = --enable-pythoninterp
+#CONF_OPT_PYTHON = --enable-pythoninterp=dynamic
 #CONF_OPT_PYTHON3 = --enable-python3interp
+#CONF_OPT_PYTHON3 = --enable-python3interp=dynamic
 
 # RUBY
 # Uncomment this when you want to include the Ruby interface.
+# First one for static linking, second one for loading when used.
 # Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).
 #CONF_OPT_RUBY = --enable-rubyinterp
+#CONF_OPT_RUBY = --enable-rubyinterp=dynamic
 #CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1
 
 # TCL
@@ -1047,8 +1051,9 @@
 INSTALL_DATA	= cp
 INSTALL_DATA_R	= cp -r
 
-### Program to run on installed binary
+### Program to run on installed binary.  Use the second one to disable strip.
 #STRIP = strip
+#STRIP = /bin/true
 
 ### Permissions for binaries  {{{1
 BINMOD = 755
@@ -1321,7 +1326,7 @@
 .SUFFIXES: .c .o .pro
 
 PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
-POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(TCL_CFLAGS) $(RUBY_CFLAGS) $(EXTRA_DEFS)
+POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(TCL_CFLAGS) $(EXTRA_DEFS)
 
 ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(POST_DEFS)
 
@@ -1329,7 +1334,7 @@
 # with "-E".
 OSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)
 
-LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
+LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
 
 LINT_EXTRA = -DUSE_SNIFF -DHANGUL_INPUT -D"__attribute__(x)="
 
@@ -1695,7 +1700,8 @@
 	$(CCC) version.c -o objects/version.o
 	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
 		-o $(VIMTARGET) $(OBJ) objects/version.o $(ALL_LIBS)" \
-		MAKE="$(MAKE)" sh $(srcdir)/link.sh
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
 
 xxd/xxd$(EXEEXT): xxd/xxd.c
 	cd xxd; CC="$(CC)" CFLAGS="$(CPPFLAGS) $(CFLAGS)" \
@@ -2532,7 +2538,7 @@
 	$(CCC) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) -o $@ if_python3.c
 
 objects/if_ruby.o: if_ruby.c
-	$(CCC) -o $@ if_ruby.c
+	$(CCC) $(RUBY_CFLAGS) -o $@ if_ruby.c
 
 objects/if_sniff.o: if_sniff.c
 	$(CCC) -o $@ if_sniff.c
diff -Naur vim73.orig/src/auto/configure vim73/src/auto/configure
--- vim73.orig/src/auto/configure	2010-08-13 10:17:15.000000000 -0400
+++ vim73/src/auto/configure	2011-01-08 21:01:19.190656939 -0500
@@ -593,6 +593,7 @@
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+LINK_AS_NEEDED
 DEPEND_CFLAGS_FILTER
 MAKEMO
 MSGFMT
@@ -1427,7 +1428,7 @@
   --enable-pythoninterp=OPTS   Include Python interpreter. default=no OPTS=no/yes/dynamic
   --enable-python3interp=OPTS   Include Python3 interpreter. default=no OPTS=no/yes/dynamic
   --enable-tclinterp      Include Tcl interpreter.
-  --enable-rubyinterp     Include Ruby interpreter.
+  --enable-rubyinterp=OPTS     Include Ruby interpreter.  default=no OPTS=no/yes/dynamic
   --enable-cscope         Include cscope interface.
   --enable-workshop       Include Sun Visual Workshop support.
   --disable-netbeans      Disable NetBeans integration support.
@@ -4862,16 +4863,36 @@
       else
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/plt/" >&5
-$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
-	if test -f /usr/include/plt/scheme.h; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket... " >&6; }
+	if test -f $vi_cv_path_mzscheme_pfx/include/racket/scheme.h; then
 	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
-	  SCHEME_INC=/usr/include/plt
+	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
 	else
 	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	  vi_cv_path_mzscheme_pfx=
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/plt/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
+	  if test -f /usr/include/plt/scheme.h; then
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	    SCHEME_INC=/usr/include/plt
+	  else
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/racket/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/racket/... " >&6; }
+	    if test -f /usr/include/racket/scheme.h; then
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	      SCHEME_INC=/usr/include/racket
+	    else
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	      vi_cv_path_mzscheme_pfx=
+	    fi
+	  fi
 	fi
       fi
     fi
@@ -4883,12 +4904,22 @@
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
-    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
             if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket -lmzgc"
       else
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
       fi
@@ -4901,10 +4932,20 @@
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
+    else
+      if test -d $vi_cv_path_mzscheme_pfx/lib/racket/collects; then
+	SCHEME_COLLECTS=lib/racket/
+      fi
     fi
     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
-            MZSCHEME_EXTRA="mzscheme_base.c"
-      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      MZSCHEME_EXTRA="mzscheme_base.c"
+    else
+      if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+	MZSCHEME_EXTRA="mzscheme_base.c"
+      fi
+    fi
+    if test "X$MZSCHEME_EXTRA" != "X" ; then
+            MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
     fi
     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
@@ -5285,9 +5326,9 @@
 
 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	else
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	fi
 	PYTHON_SRC="if_python.c"
 		if test "x$MACOSX" = "xyes"; then
@@ -5298,7 +5339,7 @@
 	if test "${vi_cv_var_python_version}" = "1.4"; then
 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
 	fi
-	PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+    PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
 
 								{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if -pthread should be used" >&5
 $as_echo_n "checking if -pthread should be used... " >&6; }
@@ -5560,9 +5601,9 @@
 
       PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
       if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       else
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       fi
       PYTHON3_SRC="if_python3.c"
             if test "x$MACOSX" = "xyes"; then
@@ -5667,10 +5708,10 @@
 
   $as_echo "#define DYNAMIC_PYTHON3 1" >>confdefs.h
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL" >&5
-$as_echo_n "checking whether we can do without RTLD_GLOBAL... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL for Python" >&5
+$as_echo_n "checking whether we can do without RTLD_GLOBAL for Python... " >&6; }
   cflags_save=$CFLAGS
-  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS"
   ldflags_save=$LDFLAGS
   LDFLAGS="$LDFLAGS -ldl"
   if test "$cross_compiling" = yes; then :
@@ -5689,15 +5730,17 @@
      * Only the first pyhton version used will be switched on.
      */
 
-    int no_rtl_global_needed_for(char *python_instsoname)
+    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
     {
       int needed = 0;
       void* pylib = dlopen(python_instsoname, RTLD_LAZY);
       if (pylib != 0)
       {
+          void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
           void (*init)(void) = dlsym(pylib, "Py_Initialize");
           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
           (*init)();
           needed = (*simple)("import termios") == -1;
           (*final)();
@@ -5709,7 +5752,7 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("libpython2.7.so.1.0") && no_rtl_global_needed_for("libpython3.1.so.1.0"))
+      if (no_rtl_global_needed_for("${python_INSTSONAME}", "${vi_cv_path_python_pfx}"))
             not_needed = 1;
       return !not_needed;
     }
@@ -5726,8 +5769,76 @@
   conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
+
   CFLAGS=$cflags_save
   LDFLAGS=$ldflags_save
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL for Python3" >&5
+$as_echo_n "checking whether we can do without RTLD_GLOBAL for Python3... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  ldflags_save=$LDFLAGS
+  LDFLAGS="$LDFLAGS -ldl"
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot run test program while cross compiling
+See \`config.log' for more details." "$LINENO" 5; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+    #include <dlfcn.h>
+    #include <wchar.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first pyhton version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY);
+      if (pylib != 0)
+      {
+          void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${python3_INSTSONAME}", L"${vi_cv_path_python3_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };$as_echo "#define PY3_NO_RTLD_GLOBAL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+  CFLAGS=$cflags_save
+  LDFLAGS=$ldflags_save
+
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
@@ -6103,7 +6214,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_rubyinterp" >&5
 $as_echo "$enable_rubyinterp" >&6; }
-if test "$enable_rubyinterp" = "yes"; then
+if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-ruby-command argument" >&5
 $as_echo_n "checking --with-ruby-command argument... " >&6; }
 
@@ -6209,6 +6320,13 @@
 	RUBY_PRO="if_ruby.pro"
 	$as_echo "#define FEAT_RUBY 1" >>confdefs.h
 
+	if test "$enable_rubyinterp" = "dynamic"; then
+	  libruby=`$vi_cv_path_ruby -r rbconfig -e 'printf "lib%s.%s\n", Config::CONFIG["RUBY_SO_NAME"], Config::CONFIG["DLEXT"]'`
+	  $as_echo "#define DYNAMIC_RUBY 1" >>confdefs.h
+
+	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+	  RUBY_LIBS=
+	fi
       else
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found; disabling Ruby" >&5
 $as_echo "not found; disabling Ruby" >&6; }
@@ -12357,6 +12475,23 @@
 fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking linker --as-needed support" >&5
+$as_echo_n "checking linker --as-needed support... " >&6; }
+LINK_AS_NEEDED=
+# Check if linker supports --as-needed and --no-as-needed options
+if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+  LDFLAGS="$LDFLAGS -Wl,--as-needed"
+  LINK_AS_NEEDED=yes
+fi
+if test "$LINK_AS_NEEDED" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 ac_config_files="$ac_config_files auto/config.mk:config.mk.in"
 
 cat >confcache <<\_ACEOF
diff -Naur vim73.orig/src/buffer.c vim73/src/buffer.c
--- vim73.orig/src/buffer.c	2010-08-13 05:14:35.000000000 -0400
+++ vim73/src/buffer.c	2011-01-08 21:01:19.026657243 -0500
@@ -639,6 +639,9 @@
     {
 	clear_wininfo(buf);		/* including window-local options */
 	free_buf_options(buf, TRUE);
+#ifdef FEAT_SPELL
+	ga_clear(&buf->b_s.b_langp);
+#endif
     }
 #ifdef FEAT_EVAL
     vars_clear(&buf->b_vars.dv_hashtab); /* free all internal variables */
@@ -661,9 +664,6 @@
     vim_free(buf->b_start_fenc);
     buf->b_start_fenc = NULL;
 #endif
-#ifdef FEAT_SPELL
-    ga_clear(&buf->b_s.b_langp);
-#endif
 }
 
 /*
@@ -1288,9 +1288,12 @@
     /* Go to the other buffer. */
     set_curbuf(buf, action);
 
-#if defined(FEAT_LISTCMDS) && defined(FEAT_SCROLLBIND)
+#if defined(FEAT_LISTCMDS) \
+	&& (defined(FEAT_SCROLLBIND) || defined(FEAT_CURSORBIND))
     if (action == DOBUF_SPLIT)
-	curwin->w_p_scb = FALSE;	/* reset 'scrollbind' */
+    {
+	RESET_BINDING(curwin);	/* reset 'scrollbind' and 'cursorbind' */
+    }
 #endif
 
 #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
@@ -1917,9 +1920,7 @@
 		tabpage_new();
 	    else if (win_split(0, 0) == FAIL)	/* Open in a new window */
 		return FAIL;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;
-# endif
+	    RESET_BINDING(curwin);
 	}
     }
 #endif
diff -Naur vim73.orig/src/config.h.in vim73/src/config.h.in
--- vim73.orig/src/config.h.in	2010-08-13 09:45:27.000000000 -0400
+++ vim73/src/config.h.in	2011-01-08 21:01:19.038657206 -0500
@@ -349,6 +349,9 @@
 /* Define if you want to include the Ruby interpreter. */
 #undef FEAT_RUBY
 
+/* Define for linking via dlopen() or LoadLibrary() */
+#undef DYNAMIC_RUBY
+
 /* Define if you want to include the Tcl interpreter. */
 #undef FEAT_TCL
 
diff -Naur vim73.orig/src/config.mk.in vim73/src/config.mk.in
--- vim73.orig/src/config.mk.in	2010-07-17 11:28:51.000000000 -0400
+++ vim73/src/config.mk.in	2011-01-08 21:01:19.118661627 -0500
@@ -30,6 +30,7 @@
 CPP		= @CPP@
 CPP_MM		= @CPP_MM@
 DEPEND_CFLAGS_FILTER = @DEPEND_CFLAGS_FILTER@
+LINK_AS_NEEDED	= @LINK_AS_NEEDED@
 X_CFLAGS	= @X_CFLAGS@
 X_LIBS_DIR	= @X_LIBS@
 X_PRE_LIBS	= @X_PRE_LIBS@
diff -Naur vim73.orig/src/configure.in vim73/src/configure.in
--- vim73.orig/src/configure.in	2010-08-13 10:15:17.000000000 -0400
+++ vim73/src/configure.in	2011-01-08 21:01:19.186662333 -0500
@@ -568,13 +568,27 @@
 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
       else
 	AC_MSG_RESULT(no)
-	AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
-	if test -f /usr/include/plt/scheme.h; then
+	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
+	if test -f $vi_cv_path_mzscheme_pfx/include/racket/scheme.h; then
 	  AC_MSG_RESULT(yes)
-	  SCHEME_INC=/usr/include/plt
+	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
 	else
 	  AC_MSG_RESULT(no)
-	  vi_cv_path_mzscheme_pfx=
+	  AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+	  if test -f /usr/include/plt/scheme.h; then
+	    AC_MSG_RESULT(yes)
+	    SCHEME_INC=/usr/include/plt
+	  else
+	    AC_MSG_RESULT(no)
+	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
+	    if test -f /usr/include/racket/scheme.h; then
+	      AC_MSG_RESULT(yes)
+	      SCHEME_INC=/usr/include/racket
+	    else
+	      AC_MSG_RESULT(no)
+	      vi_cv_path_mzscheme_pfx=
+	    fi
+	  fi
 	fi
       fi
     fi
@@ -586,13 +600,23 @@
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
-    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
       dnl Using shared objects
       if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket -lmzgc"
       else
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
       fi
@@ -607,10 +631,20 @@
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
+    else
+      if test -d $vi_cv_path_mzscheme_pfx/lib/racket/collects; then
+	SCHEME_COLLECTS=lib/racket/
+      fi
     fi
     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
-      dnl need to generate bytecode for MzScheme base
       MZSCHEME_EXTRA="mzscheme_base.c"
+    else
+      if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+	MZSCHEME_EXTRA="mzscheme_base.c"
+      fi
+    fi
+    if test "X$MZSCHEME_EXTRA" != "X" ; then
+      dnl need to generate bytecode for MzScheme base
       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
     fi
@@ -857,9 +891,9 @@
 
 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	else
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	fi
 	PYTHON_SRC="if_python.c"
 	dnl For Mac OSX 10.2 config.o is included in the Python library.
@@ -871,7 +905,7 @@
 	if test "${vi_cv_var_python_version}" = "1.4"; then
 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
 	fi
-	PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+    PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
 
 	dnl On FreeBSD linking with "-pthread" is required to use threads.
 	dnl _THREAD_SAFE must be used for compiling then.
@@ -1029,9 +1063,9 @@
 
       PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
       if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       else
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       fi
       PYTHON3_SRC="if_python3.c"
       dnl For Mac OSX 10.2 config.o is included in the Python library.
@@ -1109,9 +1143,9 @@
 if test "$python_ok" = yes && test "$python3_ok" = yes; then
   AC_DEFINE(DYNAMIC_PYTHON)
   AC_DEFINE(DYNAMIC_PYTHON3)
-  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL)
+  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
   cflags_save=$CFLAGS
-  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS"
   ldflags_save=$LDFLAGS
   LDFLAGS="$LDFLAGS -ldl"
   AC_RUN_IFELSE([
@@ -1122,15 +1156,17 @@
      * Only the first pyhton version used will be switched on.
      */
 
-    int no_rtl_global_needed_for(char *python_instsoname)
+    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
     {
       int needed = 0;
       void* pylib = dlopen(python_instsoname, RTLD_LAZY);
       if (pylib != 0)
       {
+          void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
           void (*init)(void) = dlsym(pylib, "Py_Initialize");
           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
           (*init)();
           needed = (*simple)("import termios") == -1;
           (*final)();
@@ -1142,13 +1178,60 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("libpython2.7.so.1.0") && no_rtl_global_needed_for("libpython3.1.so.1.0"))
+      if (no_rtl_global_needed_for("${python_INSTSONAME}", "${vi_cv_path_python_pfx}"))
             not_needed = 1;
       return !not_needed;
     }],
     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+
+  CFLAGS=$cflags_save
+  LDFLAGS=$ldflags_save
+
+  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  ldflags_save=$LDFLAGS
+  LDFLAGS="$LDFLAGS -ldl"
+  AC_RUN_IFELSE([
+    #include <dlfcn.h>
+    #include <wchar.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first pyhton version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY);
+      if (pylib != 0)
+      {
+          void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${python3_INSTSONAME}", L"${vi_cv_path_python3_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }],
+    [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+
   CFLAGS=$cflags_save
   LDFLAGS=$ldflags_save
+
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
@@ -1299,10 +1382,10 @@
 
 AC_MSG_CHECKING(--enable-rubyinterp argument)
 AC_ARG_ENABLE(rubyinterp,
-	[  --enable-rubyinterp     Include Ruby interpreter.], ,
+	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
 	[enable_rubyinterp="no"])
 AC_MSG_RESULT($enable_rubyinterp)
-if test "$enable_rubyinterp" = "yes"; then
+if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
   AC_MSG_CHECKING(--with-ruby-command argument)
   AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
 	RUBY_CMD="$withval"; AC_MSG_RESULT($RUBY_CMD),
@@ -1360,6 +1443,12 @@
 	RUBY_OBJ="objects/if_ruby.o"
 	RUBY_PRO="if_ruby.pro"
 	AC_DEFINE(FEAT_RUBY)
+	if test "$enable_rubyinterp" = "dynamic"; then
+	  libruby=`$vi_cv_path_ruby -r rbconfig -e 'printf "lib%s.%s\n", Config::CONFIG[["RUBY_SO_NAME"]], Config::CONFIG[["DLEXT"]]'`
+	  AC_DEFINE(DYNAMIC_RUBY)
+	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+	  RUBY_LIBS=
+	fi
       else
 	AC_MSG_RESULT(not found; disabling Ruby)
       fi
@@ -3487,6 +3576,23 @@
 fi
 AC_SUBST(DEPEND_CFLAGS_FILTER)
 
+dnl link.sh tries to avoid overlinking in a hackish way.
+dnl At least GNU ld supports --as-needed which provides the same functionality
+dnl at linker level. Let's use it.
+AC_MSG_CHECKING(linker --as-needed support)
+LINK_AS_NEEDED=
+# Check if linker supports --as-needed and --no-as-needed options
+if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+  LDFLAGS="$LDFLAGS -Wl,--as-needed"
+  LINK_AS_NEEDED=yes
+fi
+if test "$LINK_AS_NEEDED" = yes; then
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST(LINK_AS_NEEDED)
+
 dnl write output files
 AC_OUTPUT(auto/config.mk:config.mk.in)
 
diff -Naur vim73.orig/src/diff.c vim73/src/diff.c
--- vim73.orig/src/diff.c	2010-07-31 09:35:21.000000000 -0400
+++ vim73/src/diff.c	2011-01-08 20:59:40.994788713 -0500
@@ -1127,11 +1127,13 @@
 # endif
 
     wp->w_p_diff = TRUE;
+    /* Use 'scrollbind' and 'cursorbind' when available */
+#ifdef FEAT_SCROLLBIND
+    wp->w_p_scb = TRUE;
+#endif
 #ifdef FEAT_CURSORBIND
-    /* Use cursorbind if it's available */
     wp->w_p_crb = TRUE;
 #endif
-    wp->w_p_scb = TRUE;
     wp->w_p_wrap = FALSE;
 # ifdef FEAT_FOLDING
     curwin = wp;
@@ -1177,10 +1179,7 @@
 	{
 	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
 	    wp->w_p_diff = FALSE;
-#ifdef FEAT_CURSORBIND
-	    wp->w_p_crb = FALSE;
-#endif
-	    wp->w_p_scb = FALSE;
+	    RESET_BINDING(wp);
 	    wp->w_p_wrap = TRUE;
 #ifdef FEAT_FOLDING
 	    curwin = wp;
diff -Naur vim73.orig/src/edit.c vim73/src/edit.c
--- vim73.orig/src/edit.c	2010-08-08 08:55:05.000000000 -0400
+++ vim73/src/edit.c	2011-01-08 21:01:19.146656810 -0500
@@ -58,6 +58,10 @@
 };
 
 static char e_hitend[] = N_("Hit end of paragraph");
+#ifdef FEAT_COMPL_FUNC
+static char e_complwin[] = N_("E839: Completion function changed window");
+static char e_compldel[] = N_("E840: Completion function deleted text");
+#endif
 
 /*
  * Structure used to store one match for insert completion.
@@ -2658,6 +2662,7 @@
     if (stop_arrow() == FAIL)
 	return;
 
+    compl_direction = FORWARD;
     if (startcol > curwin->w_cursor.col)
 	startcol = curwin->w_cursor.col;
     compl_col = startcol;
@@ -3833,6 +3838,8 @@
     char_u	*args[2];
     char_u	*funcname;
     pos_T	pos;
+    win_T	*curwin_save;
+    buf_T	*curbuf_save;
 
     funcname = (type == CTRL_X_FUNCTION) ? curbuf->b_p_cfu : curbuf->b_p_ofu;
     if (*funcname == NUL)
@@ -3843,13 +3850,27 @@
     args[1] = base;
 
     pos = curwin->w_cursor;
+    curwin_save = curwin;
+    curbuf_save = curbuf;
     matchlist = call_func_retlist(funcname, 2, args, FALSE);
+    if (curwin_save != curwin || curbuf_save != curbuf)
+    {
+	EMSG(_(e_complwin));
+	goto theend;
+    }
     curwin->w_cursor = pos;	/* restore the cursor position */
-    if (matchlist == NULL)
-	return;
+    check_cursor();
+    if (!equalpos(curwin->w_cursor, pos))
+    {
+	EMSG(_(e_compldel));
+	goto theend;
+    }
+    if (matchlist != NULL)
+	ins_compl_add_list(matchlist);
 
-    ins_compl_add_list(matchlist);
-    list_unref(matchlist);
+theend:
+    if (matchlist != NULL)
+	list_unref(matchlist);
 }
 #endif /* FEAT_COMPL_FUNC */
 
@@ -3889,6 +3910,7 @@
     char_u	*word;
     int		icase = FALSE;
     int		adup = FALSE;
+    int		aempty = FALSE;
     char_u	*(cptext[CPT_COUNT]);
 
     if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
@@ -3906,13 +3928,15 @@
 	    icase = get_dict_number(tv->vval.v_dict, (char_u *)"icase");
 	if (get_dict_string(tv->vval.v_dict, (char_u *)"dup", FALSE) != NULL)
 	    adup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
+	if (get_dict_string(tv->vval.v_dict, (char_u *)"empty", FALSE) != NULL)
+	    aempty = get_dict_number(tv->vval.v_dict, (char_u *)"empty");
     }
     else
     {
 	word = get_tv_string_chk(tv);
 	vim_memset(cptext, 0, sizeof(cptext));
     }
-    if (word == NULL || *word == NUL)
+    if (word == NULL || (!aempty && *word == NUL))
 	return FAIL;
     return ins_compl_add(word, -1, icase, NULL, cptext, dir, 0, adup);
 }
@@ -4994,6 +5018,8 @@
 	    int		col;
 	    char_u	*funcname;
 	    pos_T	pos;
+	    win_T	*curwin_save;
+	    buf_T	*curbuf_save;
 
 	    /* Call 'completefunc' or 'omnifunc' and get pattern length as a
 	     * string */
@@ -5009,8 +5035,21 @@
 	    args[0] = (char_u *)"1";
 	    args[1] = NULL;
 	    pos = curwin->w_cursor;
+	    curwin_save = curwin;
+	    curbuf_save = curbuf;
 	    col = call_func_retnr(funcname, 2, args, FALSE);
+	    if (curwin_save != curwin || curbuf_save != curbuf)
+	    {
+		EMSG(_(e_complwin));
+		return FAIL;
+	    }
 	    curwin->w_cursor = pos;	/* restore the cursor position */
+	    check_cursor();
+	    if (!equalpos(curwin->w_cursor, pos))
+	    {
+		EMSG(_(e_compldel));
+		return FAIL;
+	    }
 
 	    if (col < 0)
 		col = curs_col;
diff -Naur vim73.orig/src/eval.c vim73/src/eval.c
--- vim73.orig/src/eval.c	2010-08-09 16:12:14.000000000 -0400
+++ vim73/src/eval.c	2011-01-08 21:01:19.506657797 -0500
@@ -10,9 +10,6 @@
 /*
  * eval.c: Expression evaluation.
  */
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
 
 #include "vim.h"
 
@@ -362,6 +359,7 @@
     {VV_NAME("operator",	 VAR_STRING), VV_RO},
     {VV_NAME("searchforward",	 VAR_NUMBER), 0},
     {VV_NAME("oldfiles",	 VAR_LIST), 0},
+    {VV_NAME("windowid",	 VAR_NUMBER), VV_RO},
 };
 
 /* shorthand */
@@ -433,9 +431,9 @@
 static void listitem_free __ARGS((listitem_T *item));
 static void listitem_remove __ARGS((list_T *l, listitem_T *item));
 static long list_len __ARGS((list_T *l));
-static int list_equal __ARGS((list_T *l1, list_T *l2, int ic));
-static int dict_equal __ARGS((dict_T *d1, dict_T *d2, int ic));
-static int tv_equal __ARGS((typval_T *tv1, typval_T *tv2, int ic));
+static int list_equal __ARGS((list_T *l1, list_T *l2, int ic, int recursive));
+static int dict_equal __ARGS((dict_T *d1, dict_T *d2, int ic, int recursive));
+static int tv_equal __ARGS((typval_T *tv1, typval_T *tv2, int ic, int recursive));
 static listitem_T *list_find __ARGS((list_T *l, long n));
 static long list_find_nr __ARGS((list_T *l, long idx, int *errorp));
 static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
@@ -2325,7 +2323,7 @@
 	    else if (endchars != NULL
 			     && vim_strchr(endchars, *skipwhite(arg)) == NULL)
 		EMSG(_(e_letunexp));
-	    else
+	    else if (!check_secure())
 	    {
 		c1 = name[len];
 		name[len] = NUL;
@@ -3337,6 +3335,15 @@
     int		failed = FALSE;
     funcdict_T	fudi;
 
+    if (eap->skip)
+    {
+	/* trans_function_name() doesn't work well when skipping, use eval0()
+	 * instead to skip to any following command, e.g. for:
+	 *   :if 0 | call dict.foo().bar() | endif  */
+	eval0(eap->arg, &rettv, &eap->nextcmd, FALSE);
+	return;
+    }
+
     tofree = trans_function_name(&arg, eap->skip, TFN_INT, &fudi);
     if (fudi.fd_newkey != NULL)
     {
@@ -4349,7 +4356,8 @@
 		else
 		{
 		    /* Compare two Lists for being equal or unequal. */
-		    n1 = list_equal(rettv->vval.v_list, var2.vval.v_list, ic);
+		    n1 = list_equal(rettv->vval.v_list, var2.vval.v_list,
+								   ic, FALSE);
 		    if (type == TYPE_NEQUAL)
 			n1 = !n1;
 		}
@@ -4378,7 +4386,8 @@
 		else
 		{
 		    /* Compare two Dictionaries for being equal or unequal. */
-		    n1 = dict_equal(rettv->vval.v_dict, var2.vval.v_dict, ic);
+		    n1 = dict_equal(rettv->vval.v_dict, var2.vval.v_dict,
+								   ic, FALSE);
 		    if (type == TYPE_NEQUAL)
 			n1 = !n1;
 		}
@@ -5913,10 +5922,11 @@
  * Return TRUE when two lists have exactly the same values.
  */
     static int
-list_equal(l1, l2, ic)
+list_equal(l1, l2, ic, recursive)
     list_T	*l1;
     list_T	*l2;
     int		ic;	/* ignore case for strings */
+    int		recursive;  /* TRUE when used recursively */
 {
     listitem_T	*item1, *item2;
 
@@ -5930,7 +5940,7 @@
     for (item1 = l1->lv_first, item2 = l2->lv_first;
 	    item1 != NULL && item2 != NULL;
 			       item1 = item1->li_next, item2 = item2->li_next)
-	if (!tv_equal(&item1->li_tv, &item2->li_tv, ic))
+	if (!tv_equal(&item1->li_tv, &item2->li_tv, ic, recursive))
 	    return FALSE;
     return item1 == NULL && item2 == NULL;
 }
@@ -5952,10 +5962,11 @@
  * Return TRUE when two dictionaries have exactly the same key/values.
  */
     static int
-dict_equal(d1, d2, ic)
+dict_equal(d1, d2, ic, recursive)
     dict_T	*d1;
     dict_T	*d2;
     int		ic;	/* ignore case for strings */
+    int		recursive; /* TRUE when used recursively */
 {
     hashitem_T	*hi;
     dictitem_T	*item2;
@@ -5976,7 +5987,7 @@
 	    item2 = dict_find(d2, hi->hi_key, -1);
 	    if (item2 == NULL)
 		return FALSE;
-	    if (!tv_equal(&HI2DI(hi)->di_tv, &item2->di_tv, ic))
+	    if (!tv_equal(&HI2DI(hi)->di_tv, &item2->di_tv, ic, recursive))
 		return FALSE;
 	    --todo;
 	}
@@ -5984,41 +5995,54 @@
     return TRUE;
 }
 
+static int tv_equal_recurse_limit;
+
 /*
  * Return TRUE if "tv1" and "tv2" have the same value.
  * Compares the items just like "==" would compare them, but strings and
  * numbers are different.  Floats and numbers are also different.
  */
     static int
-tv_equal(tv1, tv2, ic)
+tv_equal(tv1, tv2, ic, recursive)
     typval_T *tv1;
     typval_T *tv2;
-    int	    ic;	    /* ignore case */
+    int	     ic;	    /* ignore case */
+    int	     recursive;	    /* TRUE when used recursively */
 {
     char_u	buf1[NUMBUFLEN], buf2[NUMBUFLEN];
     char_u	*s1, *s2;
-    static int  recursive = 0;	    /* cach recursive loops */
+    static int  recursive_cnt = 0;	    /* catch recursive loops */
     int		r;
 
     if (tv1->v_type != tv2->v_type)
 	return FALSE;
+
     /* Catch lists and dicts that have an endless loop by limiting
-     * recursiveness to 1000.  We guess they are equal then. */
-    if (recursive >= 1000)
+     * recursiveness to a limit.  We guess they are equal then.
+     * A fixed limit has the problem of still taking an awful long time.
+     * Reduce the limit every time running into it. That should work fine for
+     * deeply linked structures that are not recursively linked and catch
+     * recursiveness quickly. */
+    if (!recursive)
+	tv_equal_recurse_limit = 1000;
+    if (recursive_cnt >= tv_equal_recurse_limit)
+    {
+	--tv_equal_recurse_limit;
 	return TRUE;
+    }
 
     switch (tv1->v_type)
     {
 	case VAR_LIST:
-	    ++recursive;
-	    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic);
-	    --recursive;
+	    ++recursive_cnt;
+	    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic, TRUE);
+	    --recursive_cnt;
 	    return r;
 
 	case VAR_DICT:
-	    ++recursive;
-	    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic);
-	    --recursive;
+	    ++recursive_cnt;
+	    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, TRUE);
+	    --recursive_cnt;
 	    return r;
 
 	case VAR_FUNC:
@@ -7075,7 +7099,7 @@
 }
 
 /*
- * Add a list  entry to dictionary "d".
+ * Add a list entry to dictionary "d".
  * Returns FAIL when out of memory and when key already exists.
  */
     int
@@ -7097,6 +7121,7 @@
 	dictitem_free(item);
 	return FAIL;
     }
+    ++list->lv_refcount;
     return OK;
 }
 
@@ -7802,7 +7827,7 @@
     {"log10",		1, 1, f_log10},
 #endif
     {"map",		2, 2, f_map},
-    {"maparg",		1, 3, f_maparg},
+    {"maparg",		1, 4, f_maparg},
     {"mapcheck",	1, 3, f_mapcheck},
     {"match",		2, 4, f_match},
     {"matchadd",	2, 4, f_matchadd},
@@ -9389,7 +9414,7 @@
 	    }
 
 	    for ( ; li != NULL; li = li->li_next)
-		if (tv_equal(&li->li_tv, &argvars[1], ic))
+		if (tv_equal(&li->li_tv, &argvars[1], ic, FALSE))
 		    ++n;
 	}
     }
@@ -9416,7 +9441,7 @@
 		if (!HASHITEM_EMPTY(hi))
 		{
 		    --todo;
-		    if (tv_equal(&HI2DI(hi)->di_tv, &argvars[1], ic))
+		    if (tv_equal(&HI2DI(hi)->di_tv, &argvars[1], ic, FALSE))
 			++n;
 		}
 	    }
@@ -9857,7 +9882,7 @@
     char_u	*s;
     int		len;
     char_u	*errormsg;
-    int		flags = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
+    int		options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
     expand_T	xpc;
     int		error = FALSE;
 
@@ -9875,12 +9900,14 @@
 	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
 	if (argvars[1].v_type != VAR_UNKNOWN
 				    && get_tv_number_chk(&argvars[1], &error))
-	    flags |= WILD_KEEP_ALL;
+	    options |= WILD_KEEP_ALL;
 	if (!error)
 	{
 	    ExpandInit(&xpc);
 	    xpc.xp_context = EXPAND_FILES;
-	    rettv->vval.v_string = ExpandOne(&xpc, s, NULL, flags, WILD_ALL);
+	    if (p_wic)
+		options += WILD_ICASE;
+	    rettv->vval.v_string = ExpandOne(&xpc, s, NULL, options, WILD_ALL);
 	}
 	else
 	    rettv->vval.v_string = NULL;
@@ -11653,7 +11680,7 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    int		flags = WILD_SILENT|WILD_USE_NL;
+    int		options = WILD_SILENT|WILD_USE_NL;
     expand_T	xpc;
     int		error = FALSE;
 
@@ -11661,14 +11688,16 @@
     * for 'wildignore' and don't put matches for 'suffixes' at the end. */
     if (argvars[1].v_type != VAR_UNKNOWN
 				&& get_tv_number_chk(&argvars[1], &error))
-	flags |= WILD_KEEP_ALL;
+	options |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
     if (!error)
     {
 	ExpandInit(&xpc);
 	xpc.xp_context = EXPAND_FILES;
+	if (p_wic)
+	    options += WILD_ICASE;
 	rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
-						       NULL, flags, WILD_ALL);
+						     NULL, options, WILD_ALL);
     }
     else
 	rettv->vval.v_string = NULL;
@@ -12116,6 +12145,9 @@
 #ifdef FEAT_TOOLBAR
 	"toolbar",
 #endif
+#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+	"unnamedplus",
+#endif
 #ifdef FEAT_USR_CMDS
 	"user-commands",    /* was accidentally included in 5.4 */
 	"user_commands",
@@ -12572,7 +12604,7 @@
 	}
 
 	for ( ; item != NULL; item = item->li_next, ++idx)
-	    if (tv_equal(&item->li_tv, &argvars[1], ic))
+	    if (tv_equal(&item->li_tv, &argvars[1], ic, FALSE))
 	    {
 		rettv->vval.v_number = idx;
 		break;
@@ -13290,8 +13322,10 @@
     char_u	*keys_buf = NULL;
     char_u	*rhs;
     int		mode;
-    garray_T	ga;
     int		abbr = FALSE;
+    int         get_dict = FALSE;
+    mapblock_T	*mp;
+    int		buffer_local;
 
     /* return empty string for failure */
     rettv->v_type = VAR_STRING;
@@ -13305,7 +13339,11 @@
     {
 	which = get_tv_string_buf_chk(&argvars[1], buf);
 	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
 	    abbr = get_tv_number(&argvars[2]);
+	    if (argvars[3].v_type != VAR_UNKNOWN)
+		get_dict = get_tv_number(&argvars[3]);
+	}
     }
     else
 	which = (char_u *)"";
@@ -13315,19 +13353,34 @@
     mode = get_map_mode(&which, 0);
 
     keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, FALSE);
-    rhs = check_map(keys, mode, exact, FALSE, abbr);
+    rhs = check_map(keys, mode, exact, FALSE, abbr, &mp, &buffer_local);
     vim_free(keys_buf);
-    if (rhs != NULL)
-    {
-	ga_init(&ga);
-	ga.ga_itemsize = 1;
-	ga.ga_growsize = 40;
 
-	while (*rhs != NUL)
-	    ga_concat(&ga, str2special(&rhs, FALSE));
+    if (!get_dict)
+    {
+	/* Return a string. */
+	if (rhs != NULL)
+	    rettv->vval.v_string = str2special_save(rhs, FALSE);
+
+    }
+    else if (rettv_dict_alloc(rettv) != FAIL && rhs != NULL)
+    {
+	/* Return a dictionary. */
+	char_u	    *lhs = str2special_save(mp->m_keys, TRUE);
+	char_u	    *mapmode = map_mode_to_chars(mp->m_mode);
+	dict_T	    *dict = rettv->vval.v_dict;
+
+	dict_add_nr_str(dict, "lhs",	 0L, lhs);
+	dict_add_nr_str(dict, "rhs",     0L, mp->m_orig_str);
+	dict_add_nr_str(dict, "noremap", mp->m_noremap ? 1L : 0L , NULL);
+	dict_add_nr_str(dict, "expr",    mp->m_expr    ? 1L : 0L, NULL);
+	dict_add_nr_str(dict, "silent",  mp->m_silent  ? 1L : 0L, NULL);
+	dict_add_nr_str(dict, "sid",     (long)mp->m_script_ID, NULL);
+	dict_add_nr_str(dict, "buffer",  (long)buffer_local, NULL);
+	dict_add_nr_str(dict, "mode",    0L, mapmode);
 
-	ga_append(&ga, NUL);
-	rettv->vval.v_string = (char_u *)ga.ga_data;
+	vim_free(lhs);
+	vim_free(mapmode);
     }
 }
 
@@ -22519,18 +22572,21 @@
 	if (tab != NULL)
 	{
 	    *tab++ = '\0';	/* isolate the variable name */
-	    if (*tab == 'S')	/* string var */
-		type = VAR_STRING;
+	    switch (*tab)
+	    {
+		case 'S': type = VAR_STRING; break;
 #ifdef FEAT_FLOAT
-	    else if (*tab == 'F')
-		type = VAR_FLOAT;
+		case 'F': type = VAR_FLOAT; break;
 #endif
+		case 'D': type = VAR_DICT; break;
+		case 'L': type = VAR_LIST; break;
+	    }
 
 	    tab = vim_strchr(tab, '\t');
 	    if (tab != NULL)
 	    {
 		tv.v_type = type;
-		if (type == VAR_STRING)
+		if (type == VAR_STRING || type == VAR_DICT || type == VAR_LIST)
 		    tv.vval.v_string = viminfo_readstring(virp,
 				       (int)(tab - virp->vir_line + 1), TRUE);
 #ifdef FEAT_FLOAT
@@ -22539,9 +22595,27 @@
 #endif
 		else
 		    tv.vval.v_number = atol((char *)tab + 1);
+		if (type == VAR_DICT || type == VAR_LIST)
+		{
+		    typval_T *etv = eval_expr(tv.vval.v_string, NULL);
+
+		    if (etv == NULL)
+			/* Failed to parse back the dict or list, use it as a
+			 * string. */
+			tv.v_type = VAR_STRING;
+		    else
+		    {
+			vim_free(tv.vval.v_string);
+			tv = *etv;
+		    }
+		}
+
 		set_var(virp->vir_line + 1, &tv, FALSE);
-		if (type == VAR_STRING)
+
+		if (tv.v_type == VAR_STRING)
 		    vim_free(tv.vval.v_string);
+		else if (tv.v_type == VAR_DICT || tv.v_type == VAR_LIST)
+		    clear_tv(&tv);
 	    }
 	}
     }
@@ -22583,8 +22657,10 @@
 		    case VAR_STRING: s = "STR"; break;
 		    case VAR_NUMBER: s = "NUM"; break;
 #ifdef FEAT_FLOAT
-		    case VAR_FLOAT: s = "FLO"; break;
+		    case VAR_FLOAT:  s = "FLO"; break;
 #endif
+		    case VAR_DICT:   s = "DIC"; break;
+		    case VAR_LIST:   s = "LIS"; break;
 		    default: continue;
 		}
 		fprintf(fp, "!%s\t%s\t", this_var->di_key, s);
diff -Naur vim73.orig/src/ex_cmds.c vim73/src/ex_cmds.c
--- vim73.orig/src/ex_cmds.c	2010-08-13 05:14:35.000000000 -0400
+++ vim73/src/ex_cmds.c	2011-01-08 21:01:19.370657515 -0500
@@ -11,10 +11,6 @@
  * ex_cmds.c: some functions for command line commands
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 #include "version.h"
 
@@ -323,7 +319,8 @@
     /* When sorting numbers "start_col_nr" is the number, not the column
      * number. */
     if (sort_nr)
-	result = l1.start_col_nr - l2.start_col_nr;
+	result = l1.start_col_nr == l2.start_col_nr ? 0
+				 : l1.start_col_nr > l2.start_col_nr ? 1 : -1;
     else
     {
 	/* We need to copy one line into "sortbuf1", because there is no
@@ -482,7 +479,7 @@
 	     * of the match, by temporarily terminating the string there */
 	    s2 = s + end_col;
 	    c = *s2;
-	    (*s2) = 0;
+	    *s2 = NUL;
 	    /* Sorting on number: Store the number itself. */
 	    p = s + start_col;
 	    if (sort_hex)
@@ -491,9 +488,13 @@
 		s = skiptodigit(p);
 	    if (s > p && s[-1] == '-')
 		--s;  /* include preceding negative sign */
-	    vim_str2nr(s, NULL, NULL, sort_oct, sort_hex,
-					&nrs[lnum - eap->line1].start_col_nr, NULL);
-	    (*s2) = c;
+	    if (*s == NUL)
+		/* empty line should sort before any number */
+		nrs[lnum - eap->line1].start_col_nr = -MAXLNUM;
+	    else
+		vim_str2nr(s, NULL, NULL, sort_oct, sort_hex,
+				  &nrs[lnum - eap->line1].start_col_nr, NULL);
+	    *s2 = c;
 	}
 	else
 	{
@@ -2700,6 +2701,10 @@
 									TRUE);
 		do_modelines(0);
 	    }
+
+	    /* Autocommands may have changed buffer names, esp. when
+	     * 'autochdir' is set. */
+	    fname = curbuf->b_sfname;
 #endif
 	}
 
@@ -3498,9 +3503,7 @@
 	curbuf->b_p_bin = FALSE;	/* reset 'bin' before reading file */
 	curwin->w_p_nu = 0;		/* no line numbers */
 	curwin->w_p_rnu = 0;		/* no relative line numbers */
-#ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;	/* no scroll binding */
-#endif
+	RESET_BINDING(curwin);		/* no scroll or cursor binding */
 #ifdef FEAT_ARABIC
 	curwin->w_p_arab = FALSE;	/* no arabic mode */
 #endif
@@ -5471,9 +5474,8 @@
 		return FALSE;
 	    curwin->w_p_pvw = TRUE;
 	    curwin->w_p_wfh = TRUE;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;	    /* don't take over 'scrollbind' */
-# endif
+	    RESET_BINDING(curwin);	    /* don't take over 'scrollbind'
+					       and 'cursorbind' */
 # ifdef FEAT_DIFF
 	    curwin->w_p_diff = FALSE;	    /* no 'diff' */
 # endif
@@ -6559,8 +6561,7 @@
 struct sign
 {
     sign_T	*sn_next;	/* next sign in list */
-    int		sn_typenr;	/* type number of sign (negative if not equal
-				   to name) */
+    int		sn_typenr;	/* type number of sign */
     char_u	*sn_name;	/* name of sign */
     char_u	*sn_icon;	/* name of pixmap */
 #ifdef FEAT_SIGN_ICONS
@@ -6572,7 +6573,7 @@
 };
 
 static sign_T	*first_sign = NULL;
-static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
+static int	next_sign_typenr = 1;
 
 static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
 static void sign_list_defined __ARGS((sign_T *sp));
@@ -6654,9 +6655,14 @@
 	    EMSG(_("E156: Missing sign name"));
 	else
 	{
+	    /* Isolate the sign name.  If it's a number skip leading zeroes,
+	     * so that "099" and "99" are the same sign.  But keep "0". */
 	    p = skiptowhite(arg);
 	    if (*p != NUL)
 		*p++ = NUL;
+	    while (arg[0] == '0' && arg[1] != NUL)
+		++arg;
+
 	    sp_prev = NULL;
 	    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
 	    {
@@ -6669,46 +6675,52 @@
 		/* ":sign define {name} ...": define a sign */
 		if (sp == NULL)
 		{
+		    sign_T	*lp;
+		    int		start = next_sign_typenr;
+
 		    /* Allocate a new sign. */
 		    sp = (sign_T *)alloc_clear((unsigned)sizeof(sign_T));
 		    if (sp == NULL)
 			return;
-		    if (sp_prev == NULL)
-			first_sign = sp;
-		    else
-			sp_prev->sn_next = sp;
-		    sp->sn_name = vim_strnsave(arg, (int)(p - arg));
 
-		    /* If the name is a number use that for the typenr,
-		     * otherwise use a negative number. */
-		    if (VIM_ISDIGIT(*arg))
-			sp->sn_typenr = atoi((char *)arg);
-		    else
+		    /* Check that next_sign_typenr is not already being used.
+		     * This only happens after wrapping around.  Hopefully
+		     * another one got deleted and we can use its number. */
+		    for (lp = first_sign; lp != NULL; )
 		    {
-			sign_T	*lp;
-			int	start = last_sign_typenr;
-
-			for (lp = first_sign; lp != NULL; lp = lp->sn_next)
+			if (lp->sn_typenr == next_sign_typenr)
 			{
-			    if (lp->sn_typenr == last_sign_typenr)
+			    ++next_sign_typenr;
+			    if (next_sign_typenr == MAX_TYPENR)
+				next_sign_typenr = 1;
+			    if (next_sign_typenr == start)
 			    {
-				--last_sign_typenr;
-				if (last_sign_typenr == 0)
-				    last_sign_typenr = MAX_TYPENR;
-				if (last_sign_typenr == start)
-				{
-				    EMSG(_("E612: Too many signs defined"));
-				    return;
-				}
-				lp = first_sign;
-				continue;
+				vim_free(sp);
+				EMSG(_("E612: Too many signs defined"));
+				return;
 			    }
+			    lp = first_sign;  /* start all over */
+			    continue;
 			}
+			lp = lp->sn_next;
+		    }
+
+		    sp->sn_typenr = next_sign_typenr;
+		    if (++next_sign_typenr == MAX_TYPENR)
+			next_sign_typenr = 1; /* wrap around */
 
-			sp->sn_typenr = last_sign_typenr--;
-			if (last_sign_typenr == 0)
-			    last_sign_typenr = MAX_TYPENR; /* wrap around */
+		    sp->sn_name = vim_strsave(arg);
+		    if (sp->sn_name == NULL)  /* out of memory */
+		    {
+			vim_free(sp);
+			return;
 		    }
+
+		    /* add the new sign to the list of signs */
+		    if (sp_prev == NULL)
+			first_sign = sp;
+		    else
+			sp_prev->sn_next = sp;
 		}
 
 		/* set values for a defined sign. */
@@ -6886,6 +6898,8 @@
 		arg = skiptowhite(arg);
 		if (*arg != NUL)
 		    *arg++ = NUL;
+		while (sign_name[0] == '0' && sign_name[1] != NUL)
+		    ++sign_name;
 	    }
 	    else if (STRNCMP(arg, "file=", 5) == 0)
 	    {
diff -Naur vim73.orig/src/ex_cmds2.c vim73/src/ex_cmds2.c
--- vim73.orig/src/ex_cmds2.c	2010-07-27 15:43:38.000000000 -0400
+++ vim73/src/ex_cmds2.c	2011-01-08 21:01:19.374658068 -0500
@@ -11,10 +11,6 @@
  * ex_cmds2.c: some more functions for command line commands
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 #include "version.h"
 
@@ -2165,9 +2161,7 @@
 	{
 	    if (win_split(0, 0) == FAIL)
 		return;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;
-# endif
+	    RESET_BINDING(curwin);
 	}
 	else
 #endif
diff -Naur vim73.orig/src/ex_docmd.c vim73/src/ex_docmd.c
--- vim73.orig/src/ex_docmd.c	2010-08-07 10:59:47.000000000 -0400
+++ vim73/src/ex_docmd.c	2011-01-08 21:01:19.234657608 -0500
@@ -733,7 +733,7 @@
  * do_cmdline(): execute one Ex command line
  *
  * 1. Execute "cmdline" when it is not NULL.
- *    If "cmdline" is NULL, or more lines are needed, getline() is used.
+ *    If "cmdline" is NULL, or more lines are needed, fgetline() is used.
  * 2. Split up in parts separated with '|'.
  *
  * This function can be called recursively!
@@ -741,7 +741,7 @@
  * flags:
  * DOCMD_VERBOSE  - The command will be included in the error message.
  * DOCMD_NOWAIT   - Don't call wait_return() and friends.
- * DOCMD_REPEAT   - Repeat execution until getline() returns NULL.
+ * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.
  * DOCMD_KEYTYPED - Don't reset KeyTyped.
  * DOCMD_EXCRESET - Reset the exception environment (used for debugging).
  * DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
@@ -749,15 +749,15 @@
  * return FAIL if cmdline could not be executed, OK otherwise
  */
     int
-do_cmdline(cmdline, getline, cookie, flags)
+do_cmdline(cmdline, fgetline, cookie, flags)
     char_u	*cmdline;
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
+    char_u	*(*fgetline) __ARGS((int, void *, int));
+    void	*cookie;		/* argument for fgetline() */
     int		flags;
 {
     char_u	*next_cmdline;		/* next cmd to execute */
     char_u	*cmdline_copy = NULL;	/* copy of cmd line */
-    int		used_getline = FALSE;	/* used "getline" to obtain command */
+    int		used_getline = FALSE;	/* used "fgetline" to obtain command */
     static int	recursive = 0;		/* recursive depth */
     int		msg_didout_before_start = 0;
     int		count = 0;		/* line number count */
@@ -775,14 +775,14 @@
     struct msglist	**saved_msg_list = NULL;
     struct msglist	*private_msg_list;
 
-    /* "getline" and "cookie" passed to do_one_cmd() */
+    /* "fgetline" and "cookie" passed to do_one_cmd() */
     char_u	*(*cmd_getline) __ARGS((int, void *, int));
     void	*cmd_cookie;
     struct loop_cookie cmd_loop_cookie;
     void	*real_cookie;
     int		getline_is_func;
 #else
-# define cmd_getline getline
+# define cmd_getline fgetline
 # define cmd_cookie cookie
 #endif
     static int	call_depth = 0;		/* recursiveness */
@@ -822,10 +822,10 @@
     cstack.cs_lflags = 0;
     ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);
 
-    real_cookie = getline_cookie(getline, cookie);
+    real_cookie = getline_cookie(fgetline, cookie);
 
     /* Inside a function use a higher nesting level. */
-    getline_is_func = getline_equal(getline, cookie, get_func_line);
+    getline_is_func = getline_equal(fgetline, cookie, get_func_line);
     if (getline_is_func && ex_nesting_level == func_level(real_cookie))
 	++ex_nesting_level;
 
@@ -837,7 +837,7 @@
 	breakpoint = func_breakpoint(real_cookie);
 	dbg_tick = func_dbg_tick(real_cookie);
     }
-    else if (getline_equal(getline, cookie, getsourceline))
+    else if (getline_equal(fgetline, cookie, getsourceline))
     {
 	fname = sourcing_name;
 	breakpoint = source_breakpoint(real_cookie);
@@ -881,7 +881,8 @@
      * KeyTyped is only set when calling vgetc().  Reset it here when not
      * calling vgetc() (sourced command lines).
      */
-    if (!(flags & DOCMD_KEYTYPED) && !getline_equal(getline, cookie, getexline))
+    if (!(flags & DOCMD_KEYTYPED)
+			       && !getline_equal(fgetline, cookie, getexline))
 	KeyTyped = FALSE;
 
     /*
@@ -894,7 +895,7 @@
     do
     {
 #ifdef FEAT_EVAL
-	getline_is_func = getline_equal(getline, cookie, get_func_line);
+	getline_is_func = getline_equal(fgetline, cookie, get_func_line);
 #endif
 
 	/* stop skipping cmds for an error msg after all endif/while/for */
@@ -909,7 +910,7 @@
 
 	/*
 	 * 1. If repeating a line in a loop, get a line from lines_ga.
-	 * 2. If no line given: Get an allocated line with getline().
+	 * 2. If no line given: Get an allocated line with fgetline().
 	 * 3. If a line is given: Make a copy, so we can mess with it.
 	 */
 
@@ -938,12 +939,12 @@
 	    }
 #ifdef FEAT_PROFILE
 	    else if (do_profiling == PROF_YES
-			     && getline_equal(getline, cookie, getsourceline))
+			    && getline_equal(fgetline, cookie, getsourceline))
 		script_line_end();
 #endif
 
 	    /* Check if a sourced file hit a ":finish" command. */
-	    if (source_finished(getline, cookie))
+	    if (source_finished(fgetline, cookie))
 	    {
 		retval = FAIL;
 		break;
@@ -954,7 +955,7 @@
 						   && *dbg_tick != debug_tick)
 	    {
 		*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
+				getline_equal(fgetline, cookie, getsourceline),
 							fname, sourcing_lnum);
 		*dbg_tick = debug_tick;
 	    }
@@ -969,7 +970,7 @@
 		dbg_breakpoint(fname, sourcing_lnum);
 		/* Find next breakpoint. */
 		*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
+			       getline_equal(fgetline, cookie, getsourceline),
 							fname, sourcing_lnum);
 		*dbg_tick = debug_tick;
 	    }
@@ -978,7 +979,7 @@
 	    {
 		if (getline_is_func)
 		    func_line_start(real_cookie);
-		else if (getline_equal(getline, cookie, getsourceline))
+		else if (getline_equal(fgetline, cookie, getsourceline))
 		    script_line_start();
 	    }
 # endif
@@ -987,7 +988,7 @@
 	if (cstack.cs_looplevel > 0)
 	{
 	    /* Inside a while/for loop we need to store the lines and use them
-	     * again.  Pass a different "getline" function to do_one_cmd()
+	     * again.  Pass a different "fgetline" function to do_one_cmd()
 	     * below, so that it stores lines in or reads them from
 	     * "lines_ga".  Makes it possible to define a function inside a
 	     * while/for loop. */
@@ -995,27 +996,27 @@
 	    cmd_cookie = (void *)&cmd_loop_cookie;
 	    cmd_loop_cookie.lines_gap = &lines_ga;
 	    cmd_loop_cookie.current_line = current_line;
-	    cmd_loop_cookie.getline = getline;
+	    cmd_loop_cookie.getline = fgetline;
 	    cmd_loop_cookie.cookie = cookie;
 	    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);
 	}
 	else
 	{
-	    cmd_getline = getline;
+	    cmd_getline = fgetline;
 	    cmd_cookie = cookie;
 	}
 #endif
 
-	/* 2. If no line given, get an allocated line with getline(). */
+	/* 2. If no line given, get an allocated line with fgetline(). */
 	if (next_cmdline == NULL)
 	{
 	    /*
 	     * Need to set msg_didout for the first line after an ":if",
 	     * otherwise the ":if" will be overwritten.
 	     */
-	    if (count == 1 && getline_equal(getline, cookie, getexline))
+	    if (count == 1 && getline_equal(fgetline, cookie, getexline))
 		msg_didout = TRUE;
-	    if (getline == NULL || (next_cmdline = getline(':', cookie,
+	    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,
 #ifdef FEAT_EVAL
 		    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2
 #else
@@ -1142,7 +1143,7 @@
 	     * If the command was typed, remember it for the ':' register.
 	     * Do this AFTER executing the command to make :@: work.
 	     */
-	    if (getline_equal(getline, cookie, getexline)
+	    if (getline_equal(fgetline, cookie, getexline)
 						  && new_last_cmdline != NULL)
 	    {
 		vim_free(last_cmdline);
@@ -1163,7 +1164,7 @@
 #ifdef FEAT_EVAL
 	/* reset did_emsg for a function that is not aborted by an error */
 	if (did_emsg && !force_abort
-		&& getline_equal(getline, cookie, get_func_line)
+		&& getline_equal(fgetline, cookie, get_func_line)
 					      && !func_has_abort(real_cookie))
 	    did_emsg = FALSE;
 
@@ -1202,7 +1203,7 @@
 		    if (breakpoint != NULL)
 		    {
 			*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
+			       getline_equal(fgetline, cookie, getsourceline),
 									fname,
 			   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);
 			*dbg_tick = debug_tick;
@@ -1296,8 +1297,8 @@
 #endif
 	    )
 	    && !(did_emsg && used_getline
-			  && (getline_equal(getline, cookie, getexmodeline)
-				|| getline_equal(getline, cookie, getexline)))
+			    && (getline_equal(fgetline, cookie, getexmodeline)
+			       || getline_equal(fgetline, cookie, getexline)))
 	    && (next_cmdline != NULL
 #ifdef FEAT_EVAL
 			|| cstack.cs_idx >= 0
@@ -1316,9 +1317,9 @@
 	 * unclosed conditional.
 	 */
 	if (!got_int && !did_throw
-		&& ((getline_equal(getline, cookie, getsourceline)
-			&& !source_finished(getline, cookie))
-		    || (getline_equal(getline, cookie, get_func_line)
+		&& ((getline_equal(fgetline, cookie, getsourceline)
+			&& !source_finished(fgetline, cookie))
+		    || (getline_equal(fgetline, cookie, get_func_line)
 					    && !func_has_ended(real_cookie))))
 	{
 	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
@@ -1354,7 +1355,7 @@
     /* If a missing ":endtry", ":endwhile", ":endfor", or ":endif" or a memory
      * lack was reported above and the error message is to be converted to an
      * exception, do this now after rewinding the cstack. */
-    do_errthrow(&cstack, getline_equal(getline, cookie, get_func_line)
+    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)
 				  ? (char_u *)"endfunction" : (char_u *)NULL);
 
     if (trylevel == 0)
@@ -1449,9 +1450,9 @@
      */
     if (did_throw)
 	need_rethrow = TRUE;
-    if ((getline_equal(getline, cookie, getsourceline)
+    if ((getline_equal(fgetline, cookie, getsourceline)
 		&& ex_nesting_level > source_level(real_cookie))
-	    || (getline_equal(getline, cookie, get_func_line)
+	    || (getline_equal(fgetline, cookie, get_func_line)
 		&& ex_nesting_level > func_level(real_cookie) + 1))
     {
 	if (!did_throw)
@@ -1460,16 +1461,16 @@
     else
     {
 	/* When leaving a function, reduce nesting level. */
-	if (getline_equal(getline, cookie, get_func_line))
+	if (getline_equal(fgetline, cookie, get_func_line))
 	    --ex_nesting_level;
 	/*
 	 * Go to debug mode when returning from a function in which we are
 	 * single-stepping.
 	 */
-	if ((getline_equal(getline, cookie, getsourceline)
-		    || getline_equal(getline, cookie, get_func_line))
+	if ((getline_equal(fgetline, cookie, getsourceline)
+		    || getline_equal(fgetline, cookie, get_func_line))
 		&& ex_nesting_level + 1 <= debug_break_level)
-	    do_debug(getline_equal(getline, cookie, getsourceline)
+	    do_debug(getline_equal(fgetline, cookie, getsourceline)
 		    ? (char_u *)_("End of sourced file")
 		    : (char_u *)_("End of function"));
     }
@@ -2871,8 +2872,10 @@
 	    }
 
 #ifdef FEAT_USR_CMDS
-	/* Look for a user defined command as a last resort */
-	if (eap->cmdidx == CMD_SIZE && *eap->cmd >= 'A' && *eap->cmd <= 'Z')
+	/* Look for a user defined command as a last resort.  Let ":Print" be
+	 * overruled by a user defined command. */
+	if ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)
+		&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')
 	{
 	    /* User defined commands may contain digits. */
 	    while (ASCII_ISALNUM(*p))
@@ -3465,7 +3468,8 @@
 	case CMD_find:
 	case CMD_sfind:
 	case CMD_tabfind:
-	    xp->xp_context = EXPAND_FILES_IN_PATH;
+	    if (xp->xp_context == EXPAND_FILES)
+		xp->xp_context = EXPAND_FILES_IN_PATH;
 	    break;
 	case CMD_cd:
 	case CMD_chdir:
@@ -4520,12 +4524,14 @@
 		else /* n == 2 */
 		{
 		    expand_T	xpc;
+		    int		options = WILD_LIST_NOTFOUND|WILD_ADD_SLASH;
 
 		    ExpandInit(&xpc);
 		    xpc.xp_context = EXPAND_FILES;
+		    if (p_wic)
+			options += WILD_ICASE;
 		    p = ExpandOne(&xpc, eap->arg, NULL,
-					    WILD_LIST_NOTFOUND|WILD_ADD_SLASH,
-						   WILD_EXPAND_FREE);
+						   options, WILD_EXPAND_FREE);
 		    if (p == NULL)
 			return FAIL;
 		}
@@ -5587,6 +5593,7 @@
     int	    compl = EXPAND_NOTHING;
     char_u  *compl_arg = NULL;
     int	    has_attr = (eap->arg[0] == '-');
+    int	    name_len;
 
     p = eap->arg;
 
@@ -5612,6 +5619,7 @@
 	return;
     }
     end = p;
+    name_len = (int)(end - name);
 
     /* If there is nothing after the name, and no attributes were specified,
      * we are listing commands
@@ -5626,6 +5634,13 @@
 	EMSG(_("E183: User defined commands must start with an uppercase letter"));
 	return;
     }
+    else if ((name_len == 1 && *name == 'X')
+	  || (name_len <= 4
+		  && STRNCMP(name, "Next", name_len > 4 ? 4 : name_len) == 0))
+    {
+	EMSG(_("E841: Reserved name, cannot be used for user defined command"));
+	return;
+    }
     else
 	uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,
 								eap->forceit);
@@ -6897,9 +6912,7 @@
 # ifdef FEAT_WINDOWS
 	if (win_split(0, 0) == FAIL)
 	    return;
-#  ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-#  endif
+	RESET_BINDING(curwin);
 
 	/* When splitting the window, create a new alist.  Otherwise the
 	 * existing one is overwritten. */
@@ -7299,7 +7312,9 @@
 		|| cmdmod.browse
 #  endif
 	   )
-	    curwin->w_p_scb = FALSE;
+	{
+	    RESET_BINDING(curwin);
+	}
 	else
 	    do_check_scrollbind(FALSE);
 # endif
@@ -9393,7 +9408,7 @@
 ex_ptag(eap)
     exarg_T	*eap;
 {
-    g_do_tagpreview = p_pvh;
+    g_do_tagpreview = p_pvh;  /* will be reset to 0 in ex_tag_cmd() */
     ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);
 }
 
@@ -9525,17 +9540,23 @@
 #define SPEC_CFILE  4
 		    "<sfile>",		/* ":so" file name */
 #define SPEC_SFILE  5
+		    "<slnum>",		/* ":so" file line number */
+#define SPEC_SLNUM  6
 #ifdef FEAT_AUTOCMD
 		    "<afile>",		/* autocommand file name */
-# define SPEC_AFILE 6
+# define SPEC_AFILE 7
 		    "<abuf>",		/* autocommand buffer number */
-# define SPEC_ABUF  7
+# define SPEC_ABUF  8
 		    "<amatch>",		/* autocommand match name */
-# define SPEC_AMATCH 8
+# define SPEC_AMATCH 9
 #endif
 #ifdef FEAT_CLIENTSERVER
 		    "<client>"
-# define SPEC_CLIENT 9
+# ifdef FEAT_AUTOCMD
+#  define SPEC_CLIENT 10
+# else
+#  define SPEC_CLIENT 7
+# endif
 #endif
     };
 
@@ -9560,6 +9581,7 @@
  *	  '<cWORD>' to WORD under the cursor
  *	  '<cfile>' to path name under the cursor
  *	  '<sfile>' to sourced file name
+ *	  '<slnum>' to sourced file line number
  *	  '<afile>' to file name for autocommand
  *	  '<abuf>'  to buffer number for autocommand
  *	  '<amatch>' to matching name for autocommand
@@ -9591,10 +9613,7 @@
 #ifdef FEAT_MODIFY_FNAME
     int		skip_mod = FALSE;
 #endif
-
-#if defined(FEAT_AUTOCMD) || defined(FEAT_CLIENTSERVER)
     char_u	strbuf[30];
-#endif
 
     *errormsg = NULL;
     if (escaped != NULL)
@@ -9783,6 +9802,15 @@
 		    return NULL;
 		}
 		break;
+	case SPEC_SLNUM:	/* line in file for ":so" command */
+		if (sourcing_name == NULL || sourcing_lnum == 0)
+		{
+		    *errormsg = (char_u *)_("E842: no line number to use for \"<slnum>\"");
+		    return NULL;
+		}
+		sprintf((char *)strbuf, "%ld", (long)sourcing_lnum);
+		result = strbuf;
+		break;
 #if defined(FEAT_CLIENTSERVER)
 	case SPEC_CLIENT:	/* Source of last submitted input */
 		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
@@ -10707,7 +10735,7 @@
  * Write a file name to the session file.
  * Takes care of the "slash" option in 'sessionoptions' and escapes special
  * characters.
- * Returns FAIL if writing fails.
+ * Returns FAIL if writing fails or out of memory.
  */
     static int
 ses_put_fname(fd, name, flagp)
@@ -10716,49 +10744,32 @@
     unsigned	*flagp;
 {
     char_u	*sname;
+    char_u	*p;
     int		retval = OK;
-    int		c;
 
     sname = home_replace_save(NULL, name);
-    if (sname != NULL)
-	name = sname;
-    while (*name != NUL)
-    {
-#ifdef FEAT_MBYTE
-	{
-	    int l;
+    if (sname == NULL)
+	return FAIL;
 
-	    if (has_mbyte && (l = (*mb_ptr2len)(name)) > 1)
-	    {
-		/* copy a multibyte char */
-		while (--l >= 0)
-		{
-		    if (putc(*name, fd) != *name)
-			retval = FAIL;
-		    ++name;
-		}
-		continue;
-	    }
-	}
-#endif
-	c = *name++;
-	if (c == '\\' && (*flagp & SSOP_SLASH))
-	    /* change a backslash to a forward slash */
-	    c = '/';
-	else if ((vim_strchr(escape_chars, c) != NULL
-#ifdef BACKSLASH_IN_FILENAME
-		    && c != '\\'
-#endif
-		 ) || c == '#' || c == '%')
-	{
-	    /* escape a special character with a backslash */
-	    if (putc('\\', fd) != '\\')
-		retval = FAIL;
-	}
-	if (putc(c, fd) != c)
-	    retval = FAIL;
+    if (*flagp & SSOP_SLASH)
+    {
+	/* change all backslashes to forward slashes */
+	for (p = sname; *p != NUL; mb_ptr_adv(p))
+	    if (*p == '\\')
+		*p = '/';
     }
+
+    /* escapse special characters */
+    p = vim_strsave_fnameescape(sname, FALSE);
     vim_free(sname);
+    if (p == NULL)
+	return FAIL;
+
+    /* write the result */
+    if (fputs((char *)p, fd) < 0)
+	retval = FAIL;
+
+    vim_free(p);
     return retval;
 }
 
diff -Naur vim73.orig/src/ex_getln.c vim73/src/ex_getln.c
--- vim73.orig/src/ex_getln.c	2010-08-14 11:25:45.000000000 -0400
+++ vim73/src/ex_getln.c	2011-01-08 21:01:19.238657508 -0500
@@ -688,28 +688,35 @@
 		    p = get_expr_line();
 		    --textlock;
 		    restore_cmdline(&save_ccline);
-		    len = (int)STRLEN(p);
 
-		    if (p != NULL && realloc_cmdbuff(len + 1) == OK)
+		    if (p != NULL)
 		    {
-			ccline.cmdlen = len;
-			STRCPY(ccline.cmdbuff, p);
-			vim_free(p);
-
-			/* Restore the cursor or use the position set with
-			 * set_cmdline_pos(). */
-			if (new_cmdpos > ccline.cmdlen)
-			    ccline.cmdpos = ccline.cmdlen;
-			else
-			    ccline.cmdpos = new_cmdpos;
-
-			KeyTyped = FALSE;	/* Don't do p_wc completion. */
-			redrawcmd();
-			goto cmdline_changed;
+			len = (int)STRLEN(p);
+			if (realloc_cmdbuff(len + 1) == OK)
+			{
+			    ccline.cmdlen = len;
+			    STRCPY(ccline.cmdbuff, p);
+			    vim_free(p);
+
+			    /* Restore the cursor or use the position set with
+			     * set_cmdline_pos(). */
+			    if (new_cmdpos > ccline.cmdlen)
+				ccline.cmdpos = ccline.cmdlen;
+			    else
+				ccline.cmdpos = new_cmdpos;
+
+			    KeyTyped = FALSE;	/* Don't do p_wc completion. */
+			    redrawcmd();
+			    goto cmdline_changed;
+			}
 		    }
 		}
 		beep_flush();
-		c = ESC;
+		got_int = FALSE;	/* don't abandon the command line */
+		did_emsg = FALSE;
+		emsg_on_display = FALSE;
+		redrawcmd();
+		goto cmdline_not_changed;
 	    }
 #endif
 	    else
@@ -2342,15 +2349,31 @@
 	windgoto(msg_row, msg_col);
 	pend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;
 
-	/* we are done when a NL is entered, but not when it comes after a
-	 * backslash */
-	if (line_ga.ga_len > 0 && pend[-1] == '\n'
-		&& (line_ga.ga_len <= 1 || pend[-2] != '\\'))
-	{
-	    --line_ga.ga_len;
-	    --pend;
-	    *pend = NUL;
-	    break;
+	/* We are done when a NL is entered, but not when it comes after an
+	 * odd number of backslashes, that results in a NUL. */
+	if (line_ga.ga_len > 0 && pend[-1] == '\n')
+	{
+	    int bcount = 0;
+
+	    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\')
+		++bcount;
+
+	    if (bcount > 0)
+	    {
+		/* Halve the number of backslashes: "\NL" -> "NUL", "\\NL" ->
+		 * "\NL", etc. */
+		line_ga.ga_len -= (bcount + 1) / 2;
+		pend -= (bcount + 1) / 2;
+		pend[-1] = '\n';
+	    }
+
+	    if ((bcount & 1) == 0)
+	    {
+		--line_ga.ga_len;
+		--pend;
+		*pend = NUL;
+		break;
+	    }
 	}
     }
 
@@ -3316,10 +3339,14 @@
 	    p2 = NULL;
 	else
 	{
+	    int use_options = options |
+		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE;
+
+	    if (p_wic)
+		use_options += WILD_ICASE;
 	    p2 = ExpandOne(xp, p1,
 			 vim_strnsave(&ccline.cmdbuff[i], xp->xp_pattern_len),
-		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE
-							      |options, type);
+							   use_options, type);
 	    vim_free(p1);
 	    /* longest match: make sure it is not shorter, happens with :help */
 	    if (p2 != NULL && type == WILD_LONGEST)
@@ -3405,6 +3432,7 @@
  * options = WILD_KEEP_ALL:	    don't remove 'wildignore' entries
  * options = WILD_SILENT:	    don't print warning messages
  * options = WILD_ESCAPE:	    put backslash before special chars
+ * options = WILD_ICASE:	    ignore case for files
  *
  * The variables xp->xp_context and xp->xp_backslash must have been set!
  */
@@ -4338,6 +4366,7 @@
     char_u	***matches;	/* return: array of pointers to matches */
 {
     char_u	*file_str = NULL;
+    int		options = WILD_ADD_SLASH|WILD_SILENT;
 
     if (xp->xp_context == EXPAND_UNSUCCESSFUL)
     {
@@ -4356,9 +4385,11 @@
     if (file_str == NULL)
 	return EXPAND_UNSUCCESSFUL;
 
+    if (p_wic)
+	options += WILD_ICASE;
+
     /* find all files that match the description */
-    if (ExpandFromContext(xp, file_str, matchcount, matches,
-					  WILD_ADD_SLASH|WILD_SILENT) == FAIL)
+    if (ExpandFromContext(xp, file_str, matchcount, matches, options) == FAIL)
     {
 	*matchcount = 0;
 	*matches = NULL;
@@ -4410,7 +4441,7 @@
     char_u	*pat;
     int		*num_file;
     char_u	***file;
-    int		options;
+    int		options;  /* EW_ flags */
 {
 #ifdef FEAT_CMDL_COMPL
     regmatch_T	regmatch;
@@ -4464,6 +4495,9 @@
 	    flags |= (EW_FILE | EW_PATH);
 	else
 	    flags = (flags | EW_DIR) & ~EW_FILE;
+	if (options & WILD_ICASE)
+	    flags |= EW_ICASE;
+
 	/* Expand wildcards, supporting %:h and the like. */
 	ret = expand_wildcards_eval(&pat, num_file, file, flags);
 	if (free_pat)
@@ -4728,7 +4762,11 @@
 			    || (pat[1] == '.' && vim_ispathsep(pat[2])))))
 	path = (char_u *)".";
     else
+    {
 	path = vim_getenv((char_u *)"PATH", &mustfree);
+	if (path == NULL)
+	    path = (char_u *)"";
+    }
 
     /*
      * Go over all directories in $PATH.  Expand matches in that directory and
@@ -6147,9 +6185,7 @@
     curwin->w_p_rl = cmdmsg_rl;
     cmdmsg_rl = FALSE;
 # endif
-# ifdef FEAT_SCROLLBIND
-    curwin->w_p_scb = FALSE;
-# endif
+    RESET_BINDING(curwin);
 
 # ifdef FEAT_AUTOCMD
     /* Do execute autocommands for setting the filetype (load syntax). */
diff -Naur vim73.orig/src/fileio.c vim73/src/fileio.c
--- vim73.orig/src/fileio.c	2010-08-14 08:20:54.000000000 -0400
+++ vim73/src/fileio.c	2011-01-08 21:01:19.374658068 -0500
@@ -11,14 +11,6 @@
  * fileio.c: read from and write to a file
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
-#if defined __EMX__
-# include "vimio.h"	/* for mktemp(), CJW 1997-12-03 */
-#endif
-
 #include "vim.h"
 
 #if defined(__TANDEM) || defined(__MINT__)
@@ -918,7 +910,7 @@
 	    {
 		/* Read the first line (and a bit more).  Immediately rewind to
 		 * the start of the file.  If the read() fails "len" is -1. */
-		len = vim_read(fd, firstline, 80);
+		len = read_eintr(fd, firstline, 80);
 		lseek(fd, (off_t)0L, SEEK_SET);
 		for (p = firstline; p < firstline + len; ++p)
 		    if (*p >= 0x80)
@@ -1373,7 +1365,7 @@
 		    /*
 		     * Read bytes from the file.
 		     */
-		    size = vim_read(fd, ptr, size);
+		    size = read_eintr(fd, ptr, size);
 		}
 
 		if (size <= 0)
@@ -4000,7 +3992,7 @@
 #ifdef HAS_BW_FLAGS
 			write_info.bw_flags = FIO_NOCONVERT;
 #endif
-			while ((write_info.bw_len = vim_read(fd, copybuf,
+			while ((write_info.bw_len = read_eintr(fd, copybuf,
 								BUFSIZE)) > 0)
 			{
 			    if (buf_write_bytes(&write_info) == FAIL)
@@ -4813,7 +4805,7 @@
 #ifdef HAS_BW_FLAGS
 			write_info.bw_flags = FIO_NOCONVERT;
 #endif
-			while ((write_info.bw_len = vim_read(fd, smallbuf,
+			while ((write_info.bw_len = read_eintr(fd, smallbuf,
 						      SMBUFSIZE)) > 0)
 			    if (buf_write_bytes(&write_info) == FAIL)
 				break;
@@ -5330,7 +5322,7 @@
 
 /*
  * Call write() to write a number of bytes to the file.
- * Also handles encryption and 'encoding' conversion.
+ * Handles encryption and 'encoding' conversion.
  *
  * Return FAIL for failure, OK otherwise.
  */
@@ -5702,16 +5694,8 @@
 	crypt_encode(buf, len, buf);
 #endif
 
-    /* Repeat the write(), it may be interrupted by a signal. */
-    while (len > 0)
-    {
-	wlen = vim_write(ip->bw_fd, buf, len);
-	if (wlen <= 0)		    /* error! */
-	    return FAIL;
-	len -= wlen;
-	buf += wlen;
-    }
-    return OK;
+    wlen = write_eintr(ip->bw_fd, buf, len);
+    return (wlen < len) ? FAIL : OK;
 }
 
 #ifdef FEAT_MBYTE
@@ -6662,8 +6646,8 @@
 	return -1;
     }
 
-    while ((n = vim_read(fd_in, buffer, BUFSIZE)) > 0)
-	if (vim_write(fd_out, buffer, n) != n)
+    while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)
+	if (write_eintr(fd_out, buffer, n) != n)
 	{
 	    errmsg = _("E208: Error writing to \"%s\"");
 	    break;
@@ -10304,3 +10288,55 @@
     }
     return reg_pat;
 }
+
+#if defined(EINTR) || defined(PROTO)
+/*
+ * Version of read() that retries when interrupted by EINTR (possibly
+ * by a SIGWINCH).
+ */
+    long
+read_eintr(fd, buf, bufsize)
+    int	    fd;
+    void    *buf;
+    size_t  bufsize;
+{
+    long ret;
+
+    for (;;)
+    {
+	ret = vim_read(fd, buf, bufsize);
+	if (ret >= 0 || errno != EINTR)
+	    break;
+    }
+    return ret;
+}
+
+/*
+ * Version of write() that retries when interrupted by EINTR (possibly
+ * by a SIGWINCH).
+ */
+    long
+write_eintr(fd, buf, bufsize)
+    int	    fd;
+    void    *buf;
+    size_t  bufsize;
+{
+    long    ret = 0;
+    long    wlen;
+
+    /* Repeat the write() so long it didn't fail, other than being interrupted
+     * by a signal. */
+    while (ret < (long)bufsize)
+    {
+	wlen = vim_write(fd, (char *)buf + ret, bufsize - ret);
+	if (wlen < 0)
+	{
+	    if (errno != EINTR)
+		break;
+	}
+	else
+	    ret += wlen;
+    }
+    return ret;
+}
+#endif
diff -Naur vim73.orig/src/getchar.c vim73/src/getchar.c
--- vim73.orig/src/getchar.c	2010-08-08 09:00:33.000000000 -0400
+++ vim73/src/getchar.c	2011-01-08 21:01:19.462656564 -0500
@@ -1506,9 +1506,6 @@
     }
 }
 
-#define KL_PART_KEY -1		/* keylen value for incomplete key-code */
-#define KL_PART_MAP -2		/* keylen value for incomplete mapping */
-
 /*
  * Get the next input character.
  * Can return a special key or a multi-byte character.
@@ -2171,7 +2168,7 @@
 					if (!timedout)
 					{
 					    /* break at a partly match */
-					    keylen = KL_PART_MAP;
+					    keylen = KEYLEN_PART_MAP;
 					    break;
 					}
 				    }
@@ -2192,7 +2189,7 @@
 
 			/* If no partly match found, use the longest full
 			 * match. */
-			if (keylen != KL_PART_MAP)
+			if (keylen != KEYLEN_PART_MAP)
 			{
 			    mp = mp_match;
 			    keylen = mp_match_len;
@@ -2230,7 +2227,7 @@
 			}
 			/* Need more chars for partly match. */
 			if (mlen == typebuf.tb_len)
-			    keylen = KL_PART_KEY;
+			    keylen = KEYLEN_PART_KEY;
 			else if (max_mlen < mlen)
 			    /* no match, may have to check for termcode at
 			     * next character */
@@ -2238,7 +2235,7 @@
 		    }
 
 		    if ((mp == NULL || max_mlen >= mp_match_len)
-						     && keylen != KL_PART_MAP)
+						 && keylen != KEYLEN_PART_MAP)
 		    {
 			int	save_keylen = keylen;
 
@@ -2264,8 +2261,8 @@
 			    /* If no termcode matched but 'pastetoggle'
 			     * matched partially it's like an incomplete key
 			     * sequence. */
-			    if (keylen == 0 && save_keylen == KL_PART_KEY)
-				keylen = KL_PART_KEY;
+			    if (keylen == 0 && save_keylen == KEYLEN_PART_KEY)
+				keylen = KEYLEN_PART_KEY;
 
 			    /*
 			     * When getting a partial match, but the last
@@ -2302,7 +2299,7 @@
 				    continue;
 				}
 				if (*s == NUL)	    /* need more characters */
-				    keylen = KL_PART_KEY;
+				    keylen = KEYLEN_PART_KEY;
 			    }
 			    if (keylen >= 0)
 #endif
@@ -2339,7 +2336,8 @@
 			if (keylen > 0)	    /* full matching terminal code */
 			{
 #if defined(FEAT_GUI) && defined(FEAT_MENU)
-			    if (typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL
+			    if (typebuf.tb_len >= 2
+				&& typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL
 					 && typebuf.tb_buf[typebuf.tb_off + 1]
 								   == KS_MENU)
 			    {
@@ -2381,7 +2379,7 @@
 			/* Partial match: get some more characters.  When a
 			 * matching mapping was found use that one. */
 			if (mp == NULL || keylen < 0)
-			    keylen = KL_PART_KEY;
+			    keylen = KEYLEN_PART_KEY;
 			else
 			    keylen = mp_match_len;
 		    }
@@ -2553,7 +2551,8 @@
 #endif
 			&& typebuf.tb_maplen == 0
 			&& (State & INSERT)
-			&& (p_timeout || (keylen == KL_PART_KEY && p_ttimeout))
+			&& (p_timeout
+			    || (keylen == KEYLEN_PART_KEY && p_ttimeout))
 			&& (c = inchar(typebuf.tb_buf + typebuf.tb_off
 						     + typebuf.tb_len, 3, 25L,
 						 typebuf.tb_change_cnt)) == 0)
@@ -2783,9 +2782,9 @@
 			    ? 0
 			    : ((typebuf.tb_len == 0
 				    || !(p_timeout || (p_ttimeout
-						   && keylen == KL_PART_KEY)))
+					       && keylen == KEYLEN_PART_KEY)))
 				    ? -1L
-				    : ((keylen == KL_PART_KEY && p_ttm >= 0)
+				    : ((keylen == KEYLEN_PART_KEY && p_ttm >= 0)
 					    ? p_ttm
 					    : p_tm)), typebuf.tb_change_cnt);
 
@@ -3168,6 +3167,7 @@
     int		expr = FALSE;
 #endif
     int		noremap;
+    char_u      *orig_rhs;
 
     keys = arg;
     map_table = maphash;
@@ -3266,6 +3266,7 @@
     }
     if (*p != NUL)
 	*p++ = NUL;
+
     p = skipwhite(p);
     rhs = p;
     hasarg = (*rhs != NUL);
@@ -3288,6 +3289,7 @@
      */
     if (haskey)
 	keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, special);
+    orig_rhs = rhs;
     if (hasarg)
     {
 	if (STRICMP(rhs, "<nop>") == 0)	    /* "<Nop>" means nothing */
@@ -3298,7 +3300,7 @@
 
 #ifdef FEAT_FKMAP
     /*
-     * when in right-to-left mode and alternate keymap option set,
+     * When in right-to-left mode and alternate keymap option set,
      * reverse the character flow in the rhs in Farsi.
      */
     if (p_altkeymap && curwin->w_p_rl)
@@ -3556,6 +3558,8 @@
 				}
 				vim_free(mp->m_str);
 				mp->m_str = newstr;
+				vim_free(mp->m_orig_str);
+				mp->m_orig_str = vim_strsave(orig_rhs);
 				mp->m_noremap = noremap;
 				mp->m_silent = silent;
 				mp->m_mode = mode;
@@ -3633,10 +3637,12 @@
 
     mp->m_keys = vim_strsave(keys);
     mp->m_str = vim_strsave(rhs);
+    mp->m_orig_str = vim_strsave(orig_rhs);
     if (mp->m_keys == NULL || mp->m_str == NULL)
     {
 	vim_free(mp->m_keys);
 	vim_free(mp->m_str);
+	vim_free(mp->m_orig_str);
 	vim_free(mp);
 	retval = 4;	/* no mem */
 	goto theend;
@@ -3682,6 +3688,7 @@
     mp = *mpp;
     vim_free(mp->m_keys);
     vim_free(mp->m_str);
+    vim_free(mp->m_orig_str);
     *mpp = mp->m_next;
     vim_free(mp);
 }
@@ -3851,12 +3858,57 @@
     }
 }
 
+/*
+ * Return characters to represent the map mode in an allocated string.
+ * Returns NULL when out of memory.
+ */
+    char_u *
+map_mode_to_chars(mode)
+    int mode;
+{
+    garray_T    mapmode;
+
+    ga_init2(&mapmode, 1, 7);
+
+    if ((mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
+	ga_append(&mapmode, '!');			/* :map! */
+    else if (mode & INSERT)
+	ga_append(&mapmode, 'i');			/* :imap */
+    else if (mode & LANGMAP)
+	ga_append(&mapmode, 'l');			/* :lmap */
+    else if (mode & CMDLINE)
+	ga_append(&mapmode, 'c');			/* :cmap */
+    else if ((mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING))
+				 == NORMAL + VISUAL + SELECTMODE + OP_PENDING)
+	ga_append(&mapmode, ' ');			/* :map */
+    else
+    {
+	if (mode & NORMAL)
+	    ga_append(&mapmode, 'n');			/* :nmap */
+	if (mode & OP_PENDING)
+	    ga_append(&mapmode, 'o');			/* :omap */
+	if ((mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)
+	    ga_append(&mapmode, 'v');			/* :vmap */
+	else
+	{
+	    if (mode & VISUAL)
+		ga_append(&mapmode, 'x');		/* :xmap */
+	    if (mode & SELECTMODE)
+		ga_append(&mapmode, 's');		/* :smap */
+	}
+    }
+
+    ga_append(&mapmode, NUL);
+    return (char_u *)mapmode.ga_data;
+}
+
     static void
 showmap(mp, local)
     mapblock_T	*mp;
     int		local;	    /* TRUE for buffer-local map */
 {
-    int len = 1;
+    int		len = 1;
+    char_u	*mapchars;
 
     if (msg_didout || msg_silent != 0)
     {
@@ -3864,49 +3916,15 @@
 	if (got_int)	    /* 'q' typed at MORE prompt */
 	    return;
     }
-    if ((mp->m_mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
-	msg_putchar('!');			/* :map! */
-    else if (mp->m_mode & INSERT)
-	msg_putchar('i');			/* :imap */
-    else if (mp->m_mode & LANGMAP)
-	msg_putchar('l');			/* :lmap */
-    else if (mp->m_mode & CMDLINE)
-	msg_putchar('c');			/* :cmap */
-    else if ((mp->m_mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING))
-				 == NORMAL + VISUAL + SELECTMODE + OP_PENDING)
-	msg_putchar(' ');			/* :map */
-    else
+
+    mapchars = map_mode_to_chars(mp->m_mode);
+    if (mapchars != NULL)
     {
-	len = 0;
-	if (mp->m_mode & NORMAL)
-	{
-	    msg_putchar('n');		/* :nmap */
-	    ++len;
-	}
-	if (mp->m_mode & OP_PENDING)
-	{
-	    msg_putchar('o');		/* :omap */
-	    ++len;
-	}
-	if ((mp->m_mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)
-	{
-	    msg_putchar('v');		/* :vmap */
-	    ++len;
-	}
-	else
-	{
-	    if (mp->m_mode & VISUAL)
-	    {
-		msg_putchar('x');		/* :xmap */
-		++len;
-	    }
-	    if (mp->m_mode & SELECTMODE)
-	    {
-		msg_putchar('s');		/* :smap */
-		++len;
-	    }
-	}
+	msg_puts(mapchars);
+	len = (int)STRLEN(mapchars);
+	vim_free(mapchars);
     }
+
     while (++len <= 3)
 	msg_putchar(' ');
 
@@ -3931,8 +3949,7 @@
 	msg_putchar(' ');
 
     /* Use FALSE below if we only want things like <Up> to show up as such on
-     * the rhs, and not M-x etc, TRUE gets both -- webb
-     */
+     * the rhs, and not M-x etc, TRUE gets both -- webb */
     if (*mp->m_str == NUL)
 	msg_puts_attr((char_u *)"<Nop>", hl_attr(HLF_8));
     else
@@ -4995,19 +5012,21 @@
     sourcing_name = save_name;
 }
 
-#ifdef FEAT_EVAL
+#if defined(FEAT_EVAL) || defined(PROTO)
 /*
- * Check the string "keys" against the lhs of all mappings
- * Return pointer to rhs of mapping (mapblock->m_str)
- * NULL otherwise
+ * Check the string "keys" against the lhs of all mappings.
+ * Return pointer to rhs of mapping (mapblock->m_str).
+ * NULL when no mapping found.
  */
     char_u *
-check_map(keys, mode, exact, ign_mod, abbr)
+check_map(keys, mode, exact, ign_mod, abbr, mp_ptr, local_ptr)
     char_u	*keys;
     int		mode;
     int		exact;		/* require exact match */
     int		ign_mod;	/* ignore preceding modifier */
     int		abbr;		/* do abbreviations */
+    mapblock_T	**mp_ptr;	/* return: pointer to mapblock or NULL */
+    int		*local_ptr;	/* return: buffer-local mapping or NULL */
 {
     int		hash;
     int		len, minlen;
@@ -5062,7 +5081,17 @@
 			    minlen = mp->m_keylen - 3;
 		    }
 		    if (STRNCMP(s, keys, minlen) == 0)
+		    {
+			if (mp_ptr != NULL)
+			    *mp_ptr = mp;
+			if (local_ptr != NULL)
+#ifdef FEAT_LOCALMAP
+			    *local_ptr = local;
+#else
+			    *local_ptr = 0;
+#endif
 			return mp->m_str;
+		    }
 		}
 	    }
 	}
diff -Naur vim73.orig/src/globals.h vim73/src/globals.h
--- vim73.orig/src/globals.h	2010-07-23 15:20:45.000000000 -0400
+++ vim73/src/globals.h	2011-01-08 21:01:19.278656842 -0500
@@ -510,8 +510,13 @@
 EXTERN VimClipboard clip_plus;	/* CLIPBOARD selection in X11 */
 # else
 #  define clip_plus clip_star	/* there is only one clipboard */
+#  define ONE_CLIPBOARD
 # endif
-EXTERN int	clip_unnamed INIT(= FALSE);
+
+#define CLIP_UNNAMED      1
+#define CLIP_UNNAMED_PLUS 2
+EXTERN int	clip_unnamed INIT(= 0); /* above two values or'ed */
+
 EXTERN int	clip_autoselect INIT(= FALSE);
 EXTERN int	clip_autoselectml INIT(= FALSE);
 EXTERN int	clip_html INIT(= FALSE);
diff -Naur vim73.orig/src/gui.c vim73/src/gui.c
--- vim73.orig/src/gui.c	2010-08-08 09:01:18.000000000 -0400
+++ vim73/src/gui.c	2011-01-08 21:01:18.886656411 -0500
@@ -105,8 +105,18 @@
 
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
     if (gui.in_use)
+    {
+# ifdef FEAT_EVAL
+	Window	x11_window;
+	Display	*x11_display;
+
+	if (gui_get_x11_windis(&x11_window, &x11_display) == OK)
+	    set_vim_var_nr(VV_WINDOWID, (long)x11_window);
+# endif
+
 	/* Display error messages in a dialog now. */
 	display_errors();
+    }
 #endif
 
 #if defined(MAY_FORK) && !defined(__QNXNTO__)
@@ -2352,7 +2362,7 @@
     if (draw_sign)
 	/* Draw the sign on top of the spaces. */
 	gui_mch_drawsign(gui.row, col, gui.highlight_mask);
-# if defined(FEAT_NETBEANS_INTG) && (defined(FEAT_GUI_MOTIF) \
+# if defined(FEAT_NETBEANS_INTG) && (defined(FEAT_GUI_X11) \
 	|| defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32))
     if (multi_sign)
 	netbeans_draw_multisign_indicator(gui.row);
diff -Naur vim73.orig/src/gui_gtk.c vim73/src/gui_gtk.c
--- vim73.orig/src/gui_gtk.c	2010-07-20 07:15:22.000000000 -0400
+++ vim73/src/gui_gtk.c	2011-01-08 21:01:19.298658878 -0500
@@ -1287,6 +1287,9 @@
 	entry = gtk_entry_new();
 	gtk_widget_show(entry);
 
+	/* Make Enter work like pressing OK. */
+        gtk_entry_set_activates_default(GTK_ENTRY(entry), TRUE);
+
 	text = CONVERT_TO_UTF8(textfield);
 	gtk_entry_set_text(GTK_ENTRY(entry), (const char *)text);
 	CONVERT_TO_UTF8_FREE(text);
@@ -1795,7 +1798,6 @@
     char_u		*repl_text;
     gboolean		direction_down;
     SharedFindReplace	*sfr;
-    int			rc;
 
     flags = (int)(long)data;	    /* avoid a lint warning here */
 
@@ -1821,7 +1823,7 @@
 
     repl_text = CONVERT_FROM_UTF8(repl_text);
     find_text = CONVERT_FROM_UTF8(find_text);
-    rc = gui_do_findrepl(flags, find_text, repl_text, direction_down);
+    gui_do_findrepl(flags, find_text, repl_text, direction_down);
     CONVERT_FROM_UTF8_FREE(repl_text);
     CONVERT_FROM_UTF8_FREE(find_text);
 }
diff -Naur vim73.orig/src/gui_mac.c vim73/src/gui_mac.c
--- vim73.orig/src/gui_mac.c	2010-08-14 15:39:54.000000000 -0400
+++ vim73/src/gui_mac.c	2011-01-08 21:01:18.766656221 -0500
@@ -1480,7 +1480,7 @@
  *
  *  Returns the index inside the menu wher
  */
-    short /* Shoulde we return MenuItemIndex? */
+    short /* Should we return MenuItemIndex? */
 gui_mac_get_menu_item_index(vimmenu_T *pMenu)
 {
     short	index;
@@ -1823,7 +1823,7 @@
 	p.h += gui.scrollbar_width;
     if (gui.which_scrollbars[SBAR_RIGHT])
 	p.h += gui.scrollbar_width;
-    /* ideal height is as heigh as we can get */
+    /* ideal height is as high as we can get */
     p.v = 15 * 1024;
 
     thePart = IsWindowInStandardState(whichWindow, &p, &r)
@@ -4481,7 +4481,7 @@
 	 * event arrives.  No need to check for input_buf_full because we are
 	 * returning as soon as it contains a single char.
 	 */
-	/* TODO: reduce wtime accordinly???  */
+	/* TODO: reduce wtime accordingly???  */
 	if (wtime > -1)
 	    sleeppyTick = 60 * wtime / 1000;
 	else
@@ -5723,13 +5723,13 @@
     iconDITL = GetResource('DITL', 131);
     switch (type)
     {
-	case VIM_GENERIC:  useIcon = kNoteIcon;
-	case VIM_ERROR:    useIcon = kStopIcon;
-	case VIM_WARNING:  useIcon = kCautionIcon;
-	case VIM_INFO:     useIcon = kNoteIcon;
-	case VIM_QUESTION: useIcon = kNoteIcon;
-	default:      useIcon = kStopIcon;
-    };
+	case VIM_GENERIC:
+	case VIM_INFO:
+	case VIM_QUESTION: useIcon = kNoteIcon; break;
+	case VIM_WARNING:  useIcon = kCautionIcon; break;
+	case VIM_ERROR:    useIcon = kStopIcon; break;
+	default:           useIcon = kStopIcon;
+    }
     AppendDITL(theDialog, iconDITL, overlayDITL);
     ReleaseResource(iconDITL);
     GetDialogItem(theDialog, iconItm.idx, &itemType, &itemHandle, &box);
@@ -5892,7 +5892,7 @@
 
     return itemHit;
 /*
- * Usefull thing which could be used
+ * Useful thing which could be used
  * SetDialogTimeout(): Auto click a button after timeout
  * SetDialogTracksCursor() : Get the I-beam cursor over input box
  * MoveDialogItem():	    Probably better than SetDialogItem
@@ -6100,7 +6100,7 @@
 #endif
 
 /*
- * Transfered from os_mac.c for MacOS X using os_unix.c prep work
+ * Transferred from os_mac.c for MacOS X using os_unix.c prep work
  */
 
     int
@@ -6543,7 +6543,7 @@
 static ControlRef dataBrowser = NULL;
 
 // when the tabline is hidden, vim doesn't call update_tabline(). When
-// the tabline is shown again, show_tabline() is called before upate_tabline(),
+// the tabline is shown again, show_tabline() is called before update_tabline(),
 // and because of this, the tab labels and vims internal tabs are out of sync
 // for a very short time. to prevent inconsistent state, we store the labels
 // of the tabs, not pointers to the tabs (which are invalid for a short time).
diff -Naur vim73.orig/src/gui_w32.c vim73/src/gui_w32.c
--- vim73.orig/src/gui_w32.c	2010-08-08 09:05:26.000000000 -0400
+++ vim73/src/gui_w32.c	2011-01-08 21:01:18.990656516 -0500
@@ -289,13 +289,13 @@
 
 #ifdef FEAT_MENU
 static UINT	s_menu_id = 100;
+#endif
 
 /*
  * Use the system font for dialogs and tear-off menus.  Remove this line to
  * use DLG_FONT_NAME.
  */
-# define USE_SYSMENU_FONT
-#endif
+#define USE_SYSMENU_FONT
 
 #define VIM_NAME	"vim"
 #define VIM_CLASS	"Vim"
@@ -1260,7 +1260,7 @@
 
     /* try and load the user32.dll library and get the entry points for
      * multi-monitor-support. */
-    if ((user32_lib = LoadLibrary("User32.dll")) != NULL)
+    if ((user32_lib = vimLoadLib("User32.dll")) != NULL)
     {
 	pMonitorFromWindow = (TMonitorFromWindow)GetProcAddress(user32_lib,
 							 "MonitorFromWindow");
@@ -1573,6 +1573,11 @@
 # endif
 #endif
 
+#ifdef FEAT_EVAL
+    /* set the v:windowid variable */
+    set_vim_var_nr(VV_WINDOWID, (long)s_hwnd);
+#endif
+
 theend:
     /* Display any pending error messages */
     display_errors();
@@ -4188,7 +4193,7 @@
     static void
 dyn_imm_load(void)
 {
-    hLibImm = LoadLibrary("imm32.dll");
+    hLibImm = vimLoadLib("imm32.dll");
     if (hLibImm == NULL)
 	return;
 
diff -Naur vim73.orig/src/gui_w48.c vim73/src/gui_w48.c
--- vim73.orig/src/gui_w48.c	2010-07-27 15:46:04.000000000 -0400
+++ vim73/src/gui_w48.c	2011-01-08 21:01:18.918658776 -0500
@@ -1810,7 +1810,8 @@
 		 * mapped we want to use the mapping instead. */
 		if (vk == VK_F10
 			&& gui.menu_is_active
-			&& check_map(k10, State, FALSE, TRUE, FALSE) == NULL)
+			&& check_map(k10, State, FALSE, TRUE, FALSE,
+							  NULL, NULL) == NULL)
 		    break;
 #endif
 		if (GetKeyState(VK_SHIFT) & 0x8000)
@@ -1924,7 +1925,8 @@
     /* Check for <F10>: Default effect is to select the menu.  When <F10> is
      * mapped we need to stop it here to avoid strange effects (e.g., for the
      * key-up event) */
-    if (vk != VK_F10 || check_map(k10, State, FALSE, TRUE, FALSE) == NULL)
+    if (vk != VK_F10 || check_map(k10, State, FALSE, TRUE, FALSE,
+							  NULL, NULL) == NULL)
 #endif
 	DispatchMessage(&msg);
 }
diff -Naur vim73.orig/src/gui_x11.c vim73/src/gui_x11.c
--- vim73.orig/src/gui_x11.c	2010-08-08 09:05:45.000000000 -0400
+++ vim73/src/gui_x11.c	2011-01-08 21:01:19.178657868 -0500
@@ -2895,6 +2895,11 @@
 	    focus = gui.in_focus;
 	}
 
+#if defined(FEAT_NETBEANS_INTG)
+	/* Process any queued netbeans messages. */
+	netbeans_parse_messages();
+#endif
+
 	/*
 	 * Don't use gui_mch_update() because then we will spin-lock until a
 	 * char arrives, instead we use XtAppProcessEvent() to hang until an
diff -Naur vim73.orig/src/if_cscope.c vim73/src/if_cscope.c
--- vim73.orig/src/if_cscope.c	2010-07-25 10:32:31.000000000 -0400
+++ vim73/src/if_cscope.c	2011-01-08 21:01:19.458660505 -0500
@@ -13,16 +13,11 @@
 
 #if defined(FEAT_CSCOPE) || defined(PROTO)
 
-#include <string.h>
-#include <errno.h>
 #include <assert.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #if defined(UNIX)
 # include <sys/wait.h>
-#else
-    /* not UNIX, must be WIN32 */
-# include "vimio.h"
 #endif
 #include "if_cscope.h"
 
@@ -1274,9 +1269,7 @@
 		{
 		    win_split(postponed_split > 0 ? postponed_split : 0,
 						       postponed_split_flags);
-#  ifdef FEAT_SCROLLBIND
-		    curwin->w_p_scb = FALSE;
-#  endif
+		    RESET_BINDING(curwin);
 		    postponed_split = 0;
 		}
 # endif
@@ -1353,7 +1346,7 @@
 		       "       g: Find this definition\n"
 		       "       i: Find files #including this file\n"
 		       "       s: Find this C symbol\n"
-		       "       t: Find assignments to\n"));
+		       "       t: Find this text string\n"));
 
 	cmdp++;
     }
@@ -1664,7 +1657,7 @@
 /*
  * PRIVATE: cs_make_vim_style_matches
  *
- * convert the cscope output into into a ctags style entry (as might be found
+ * convert the cscope output into a ctags style entry (as might be found
  * in a ctags tags file).  there's one catch though: cscope doesn't tell you
  * the type of the tag you are looking for.  for example, in Darren Hiebert's
  * ctags (the one that comes with vim), #define's use a line number to find the
diff -Naur vim73.orig/src/if_lua.c vim73/src/if_lua.c
--- vim73.orig/src/if_lua.c	2010-08-12 16:12:04.000000000 -0400
+++ vim73/src/if_lua.c	2011-01-08 21:01:18.922656581 -0500
@@ -49,7 +49,7 @@
 # define symbol_from_dll dlsym
 # define close_dll dlclose
 #else
-# define load_dll LoadLibrary
+# define load_dll vimLoadLib
 # define symbol_from_dll GetProcAddress
 # define close_dll FreeLibrary
 #endif
diff -Naur vim73.orig/src/if_mzsch.c vim73/src/if_mzsch.c
--- vim73.orig/src/if_mzsch.c	2010-06-25 23:56:17.000000000 -0400
+++ vim73/src/if_mzsch.c	2011-01-08 21:01:19.114655467 -0500
@@ -556,8 +556,8 @@
 
     if (hMzGC && hMzSch)
 	return OK;
-    hMzSch = LoadLibrary(sch_dll);
-    hMzGC = LoadLibrary(gc_dll);
+    hMzSch = vimLoadLib(sch_dll);
+    hMzGC = vimLoadLib(gc_dll);
 
     if (!hMzSch)
     {
@@ -794,9 +794,16 @@
 #endif
 }
 
+#if MZSCHEME_VERSION_MAJOR >= 500 && defined(WIN32) && defined(USE_THREAD_LOCAL)
+static __declspec(thread) void *tls_space;
+#endif
+
     void
 mzscheme_main(void)
 {
+#if MZSCHEME_VERSION_MAJOR >= 500 && defined(WIN32) && defined(USE_THREAD_LOCAL)
+    scheme_register_tls_space(&tls_space, 0);
+#endif
 #if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR >= 400
     /* use trampoline for precise GC in MzScheme >= 4.x */
     scheme_main_setup(TRUE, mzscheme_env_main, 0, NULL);
diff -Naur vim73.orig/src/if_perl.xs vim73/src/if_perl.xs
--- vim73.orig/src/if_perl.xs	2010-07-22 05:33:37.000000000 -0400
+++ vim73/src/if_perl.xs	2011-01-08 21:01:18.926655661 -0500
@@ -106,7 +106,7 @@
 #define close_dll dlclose
 #else
 #define PERL_PROC FARPROC
-#define load_dll LoadLibrary
+#define load_dll vimLoadLib
 #define symbol_from_dll GetProcAddress
 #define close_dll FreeLibrary
 #endif
diff -Naur vim73.orig/src/if_py_both.h vim73/src/if_py_both.h
--- vim73.orig/src/if_py_both.h	2010-08-08 07:06:29.000000000 -0400
+++ vim73/src/if_py_both.h	2011-01-08 21:01:18.982656784 -0500
@@ -34,6 +34,7 @@
 static PyObject *OutputWrite(PyObject *, PyObject *);
 static PyObject *OutputWritelines(PyObject *, PyObject *);
 
+/* Function to write a line, points to either msg() or emsg(). */
 typedef void (*writefn)(char_u *);
 static void writer(writefn fn, char_u *str, PyInt n);
 
@@ -122,52 +123,19 @@
     return Py_None;
 }
 
-static char_u *buffer = NULL;
-static PyInt buffer_len = 0;
-static PyInt buffer_size = 0;
-
+/* Buffer IO, we write one whole line at a time. */
+static garray_T io_ga = {0, 0, 1, 80, NULL};
 static writefn old_fn = NULL;
 
     static void
-buffer_ensure(PyInt n)
-{
-    PyInt new_size;
-    char_u *new_buffer;
-
-    if (n < buffer_size)
-	return;
-
-    new_size = buffer_size;
-    while (new_size < n)
-	new_size += 80;
-
-    if (new_size != buffer_size)
-    {
-	new_buffer = alloc((unsigned)new_size);
-	if (new_buffer == NULL)
-	    return;
-
-	if (buffer)
-	{
-	    memcpy(new_buffer, buffer, buffer_len);
-	    vim_free(buffer);
-	}
-
-	buffer = new_buffer;
-	buffer_size = new_size;
-    }
-}
-
-    static void
 PythonIO_Flush(void)
 {
-    if (old_fn && buffer_len)
+    if (old_fn != NULL && io_ga.ga_len > 0)
     {
-	buffer[buffer_len] = 0;
-	old_fn(buffer);
+	((char_u *)io_ga.ga_data)[io_ga.ga_len] = NUL;
+	old_fn((char_u *)io_ga.ga_data);
     }
-
-    buffer_len = 0;
+    io_ga.ga_len = 0;
 }
 
     static void
@@ -175,30 +143,34 @@
 {
     char_u *ptr;
 
-    if (fn != old_fn && old_fn != NULL)
+    /* Flush when switching output function. */
+    if (fn != old_fn)
 	PythonIO_Flush();
-
     old_fn = fn;
 
+    /* Write each NL separated line.  Text after the last NL is kept for
+     * writing later. */
     while (n > 0 && (ptr = memchr(str, '\n', n)) != NULL)
     {
 	PyInt len = ptr - str;
 
-	buffer_ensure(buffer_len + len + 1);
+	if (ga_grow(&io_ga, (int)(len + 1)) == FAIL)
+	    break;
 
-	memcpy(buffer + buffer_len, str, len);
-	buffer_len += len;
-	buffer[buffer_len] = 0;
-	fn(buffer);
+	mch_memmove(((char *)io_ga.ga_data) + io_ga.ga_len, str, (size_t)len);
+	((char *)io_ga.ga_data)[io_ga.ga_len + len] = NUL;
+	fn((char_u *)io_ga.ga_data);
 	str = ptr + 1;
 	n -= len + 1;
-	buffer_len = 0;
+	io_ga.ga_len = 0;
     }
 
-    /* Put the remaining text into the buffer for later printing */
-    buffer_ensure(buffer_len + n + 1);
-    memcpy(buffer + buffer_len, str, n);
-    buffer_len += n;
+    /* Put the remaining text into io_ga for later printing. */
+    if (n > 0 && ga_grow(&io_ga, (int)(n + 1)) == OK)
+    {
+	mch_memmove(((char *)io_ga.ga_data) + io_ga.ga_len, str, (size_t)n);
+	io_ga.ga_len += (int)n;
+    }
 }
 
 /***************/
diff -Naur vim73.orig/src/if_python.c vim73/src/if_python.c
--- vim73.orig/src/if_python.c	2010-08-13 09:59:41.000000000 -0400
+++ vim73/src/if_python.c	2011-01-08 21:01:19.190656939 -0500
@@ -102,7 +102,7 @@
 #  include <dlfcn.h>
 #  define FARPROC void*
 #  define HINSTANCE void*
-#  ifdef PY_NO_RTLD_GLOBAL
+#  if defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)
 #   define load_dll(n) dlopen((n), RTLD_LAZY)
 #  else
 #   define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)
@@ -110,7 +110,7 @@
 #  define close_dll dlclose
 #  define symbol_from_dll dlsym
 # else
-#  define load_dll LoadLibrary
+#  define load_dll vimLoadLib
 #  define close_dll FreeLibrary
 #  define symbol_from_dll GetProcAddress
 # endif
@@ -168,6 +168,7 @@
 # define Py_BuildValue dll_Py_BuildValue
 # define Py_FindMethod dll_Py_FindMethod
 # define Py_InitModule4 dll_Py_InitModule4
+# define Py_SetPythonHome dll_Py_SetPythonHome
 # define Py_Initialize dll_Py_Initialize
 # define Py_Finalize dll_Py_Finalize
 # define Py_IsInitialized dll_Py_IsInitialized
@@ -226,6 +227,7 @@
 static PyObject*(*dll_Py_BuildValue)(char *, ...);
 static PyObject*(*dll_Py_FindMethod)(struct PyMethodDef[], PyObject *, char *);
 static PyObject*(*dll_Py_InitModule4)(char *, struct PyMethodDef *, char *, PyObject *, int);
+static void(*dll_Py_SetPythonHome)(char *home);
 static void(*dll_Py_Initialize)(void);
 static void(*dll_Py_Finalize)(void);
 static int(*dll_Py_IsInitialized)(void);
@@ -310,6 +312,7 @@
 # else
     {"Py_InitModule4", (PYTHON_PROC*)&dll_Py_InitModule4},
 # endif
+    {"Py_SetPythonHome", (PYTHON_PROC*)&dll_Py_SetPythonHome},
     {"Py_Initialize", (PYTHON_PROC*)&dll_Py_Initialize},
     {"Py_Finalize", (PYTHON_PROC*)&dll_Py_Finalize},
     {"Py_IsInitialized", (PYTHON_PROC*)&dll_Py_IsInitialized},
@@ -349,7 +352,7 @@
 {
     int i;
 
-#if !defined(PY_NO_RTLD_GLOBAL) && defined(UNIX) && defined(FEAT_PYTHON3)
+#if !(defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)) && defined(UNIX) && defined(FEAT_PYTHON3)
     /* Can't have Python and Python3 loaded at the same time.
      * It cause a crash, because RTLD_GLOBAL is needed for
      * standard C extension libraries of one or both python versions. */
@@ -543,6 +546,10 @@
 	}
 #endif
 
+#ifdef PYTHON_HOME
+	Py_SetPythonHome(PYTHON_HOME);
+#endif
+
 	init_structs();
 
 #if !defined(MACOS) || defined(MACOS_X_UNIX)
diff -Naur vim73.orig/src/if_python3.c vim73/src/if_python3.c
--- vim73.orig/src/if_python3.c	2010-08-13 09:59:40.000000000 -0400
+++ vim73/src/if_python3.c	2011-01-08 21:01:19.190656939 -0500
@@ -80,7 +80,7 @@
 #  include <dlfcn.h>
 #  define FARPROC void*
 #  define HINSTANCE void*
-#  ifdef PY_NO_RTLD_GLOBAL
+#  if defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)
 #   define load_dll(n) dlopen((n), RTLD_LAZY)
 #  else
 #   define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)
@@ -88,7 +88,7 @@
 #  define close_dll dlclose
 #  define symbol_from_dll dlsym
 # else
-#  define load_dll LoadLibrary
+#  define load_dll vimLoadLib
 #  define close_dll FreeLibrary
 #  define symbol_from_dll GetProcAddress
 # endif
@@ -132,6 +132,7 @@
 # define PyType_Ready py3_PyType_Ready
 #undef Py_BuildValue
 # define Py_BuildValue py3_Py_BuildValue
+# define Py_SetPythonHome py3_Py_SetPythonHome
 # define Py_Initialize py3_Py_Initialize
 # define Py_Finalize py3_Py_Finalize
 # define Py_IsInitialized py3_Py_IsInitialized
@@ -170,6 +171,7 @@
  * Pointers for dynamic link
  */
 static int (*py3_PySys_SetArgv)(int, wchar_t **);
+static void (*py3_Py_SetPythonHome)(wchar_t *home);
 static void (*py3_Py_Initialize)(void);
 static PyObject* (*py3_PyList_New)(Py_ssize_t size);
 static PyGILState_STATE (*py3_PyGILState_Ensure)(void);
@@ -254,6 +256,7 @@
 } py3_funcname_table[] =
 {
     {"PySys_SetArgv", (PYTHON_PROC*)&py3_PySys_SetArgv},
+    {"Py_SetPythonHome", (PYTHON_PROC*)&py3_Py_SetPythonHome},
     {"Py_Initialize", (PYTHON_PROC*)&py3_Py_Initialize},
     {"PyArg_ParseTuple", (PYTHON_PROC*)&py3_PyArg_ParseTuple},
     {"PyList_New", (PYTHON_PROC*)&py3_PyList_New},
@@ -336,7 +339,7 @@
     int i;
     void *ucs_from_string, *ucs_from_string_and_size;
 
-# if !defined(PY_NO_RTLD_GLOBAL) && defined(UNIX) && defined(FEAT_PYTHON)
+# if !(defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)) && defined(UNIX) && defined(FEAT_PYTHON)
     /* Can't have Python and Python3 loaded at the same time.
      * It cause a crash, because RTLD_GLOBAL is needed for
      * standard C extension libraries of one or both python versions. */
@@ -539,6 +542,11 @@
 
 	init_structs();
 
+
+#ifdef PYTHON3_HOME
+	Py_SetPythonHome(PYTHON3_HOME);
+#endif
+
 	/* initialise threads */
 	PyEval_InitThreads();
 
diff -Naur vim73.orig/src/if_ruby.c vim73/src/if_ruby.c
--- vim73.orig/src/if_ruby.c	2010-06-30 15:33:12.000000000 -0400
+++ vim73/src/if_ruby.c	2011-01-08 21:01:19.442657935 -0500
@@ -4,6 +4,7 @@
  *
  * Ruby interface by Shugo Maeda
  *   with improvements by SegPhault (Ryan Paul)
+ *   with improvements by Jon Maken
  *
  * Do ":help uganda"  in Vim to read copying and usage conditions.
  * Do ":help credits" in Vim to see a list of people who contributed.
@@ -13,6 +14,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef HAVE_CONFIG_H
+# include "auto/config.h"
+#endif
+
 #ifdef _WIN32
 # if !defined(DYNAMIC_RUBY_VER) || (DYNAMIC_RUBY_VER < 18)
 #   define NT
@@ -26,12 +31,12 @@
 # define RUBYEXTERN extern
 #endif
 
+#ifdef DYNAMIC_RUBY
 /*
  * This is tricky.  In ruby.h there is (inline) function rb_class_of()
  * definition.  This function use these variables.  But we want function to
  * use dll_* variables.
  */
-#ifdef DYNAMIC_RUBY
 # define rb_cFalseClass		(*dll_rb_cFalseClass)
 # define rb_cFixnum		(*dll_rb_cFixnum)
 # define rb_cNilClass		(*dll_rb_cNilClass)
@@ -46,8 +51,23 @@
  */
 #  define RUBY_EXPORT
 # endif
+
+#if !(defined(WIN32) || defined(_WIN64))
+# include <dlfcn.h>
+# define HINSTANCE void*
+# define RUBY_PROC void*
+# define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)
+# define symbol_from_dll dlsym
+# define close_dll dlclose
+#else
+# define RUBY_PROC FARPROC
+# define load_dll vimLoadLib
+# define symbol_from_dll GetProcAddress
+# define close_dll FreeLibrary
 #endif
 
+#endif  /* ifdef DYNAMIC_RUBY */
+
 /* suggested by Ariya Mizutani */
 #if (_MSC_VER == 1200)
 # undef _WIN32_WINNT
@@ -70,6 +90,7 @@
 # include <ruby/encoding.h>
 #endif
 
+#undef off_t	/* ruby defines off_t as _int64, Mingw uses long */
 #undef EXTERN
 #undef _
 
@@ -160,28 +181,35 @@
 #define rb_lastline_get			dll_rb_lastline_get
 #define rb_lastline_set			dll_rb_lastline_set
 #define rb_load_protect			dll_rb_load_protect
+#ifndef RUBY19_OR_LATER
 #define rb_num2long			dll_rb_num2long
+#endif
 #define rb_num2ulong			dll_rb_num2ulong
 #define rb_obj_alloc			dll_rb_obj_alloc
 #define rb_obj_as_string		dll_rb_obj_as_string
 #define rb_obj_id			dll_rb_obj_id
 #define rb_raise			dll_rb_raise
-#define rb_str2cstr			dll_rb_str2cstr
 #define rb_str_cat			dll_rb_str_cat
 #define rb_str_concat			dll_rb_str_concat
 #define rb_str_new			dll_rb_str_new
 #ifdef rb_str_new2
 /* Ruby may #define rb_str_new2 to use rb_str_new_cstr. */
 # define need_rb_str_new_cstr 1
+/* Ruby's headers #define rb_str_new_cstr to make use of GCC's
+ * __builtin_constant_p extension. */
+# undef rb_str_new_cstr
 # define rb_str_new_cstr		dll_rb_str_new_cstr
 #else
 # define rb_str_new2			dll_rb_str_new2
 #endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+# define rb_string_value		dll_rb_string_value
 # define rb_string_value_ptr		dll_rb_string_value_ptr
 # define rb_float_new			dll_rb_float_new
 # define rb_ary_new			dll_rb_ary_new
 # define rb_ary_push			dll_rb_ary_push
+#else
+# define rb_str2cstr			dll_rb_str2cstr
 #endif
 #ifdef RUBY19_OR_LATER
 # define rb_errinfo			dll_rb_errinfo
@@ -190,9 +218,11 @@
 #endif
 #define ruby_init			dll_ruby_init
 #define ruby_init_loadpath		dll_ruby_init_loadpath
-#define NtInitialize			dll_NtInitialize
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
-# define rb_w32_snprintf		dll_rb_w32_snprintf
+#ifdef WIN3264
+# define NtInitialize			dll_NtInitialize
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+#  define rb_w32_snprintf		dll_rb_w32_snprintf
+# endif
 #endif
 
 #ifdef RUBY19_OR_LATER
@@ -201,7 +231,9 @@
 # define rb_enc_find			dll_rb_enc_find
 # define rb_enc_str_new			dll_rb_enc_str_new
 # define rb_sprintf			dll_rb_sprintf
+# define rb_require			dll_rb_require
 # define ruby_init_stack		dll_ruby_init_stack
+# define ruby_process_options		dll_ruby_process_options
 #endif
 
 /*
@@ -246,7 +278,11 @@
 static VALUE (*dll_rb_obj_as_string) (VALUE);
 static VALUE (*dll_rb_obj_id) (VALUE);
 static void (*dll_rb_raise) (VALUE, const char*, ...);
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+static VALUE (*dll_rb_string_value) (volatile VALUE*);
+#else
 static char *(*dll_rb_str2cstr) (VALUE,int*);
+#endif
 static VALUE (*dll_rb_str_cat) (VALUE, const char*, long);
 static VALUE (*dll_rb_str_concat) (VALUE, VALUE);
 static VALUE (*dll_rb_str_new) (const char*, long);
@@ -263,7 +299,12 @@
 #endif
 static void (*dll_ruby_init) (void);
 static void (*dll_ruby_init_loadpath) (void);
+#ifdef WIN3264
 static void (*dll_NtInitialize) (int*, char***);
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);
+# endif
+#endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
 static char * (*dll_rb_string_value_ptr) (volatile VALUE*);
 static VALUE (*dll_rb_float_new) (double);
@@ -273,9 +314,6 @@
 #ifdef RUBY19_OR_LATER
 static VALUE (*dll_rb_int2big)(SIGNED_VALUE);
 #endif
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
-static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);
-#endif
 
 #ifdef RUBY19_OR_LATER
 static void (*dll_ruby_script) (const char*);
@@ -283,7 +321,9 @@
 static rb_encoding* (*dll_rb_enc_find) (const char*);
 static VALUE (*dll_rb_enc_str_new) (const char*, long, rb_encoding*);
 static VALUE (*dll_rb_sprintf) (const char*, ...);
+static VALUE (*dll_rb_require) (const char*);
 static void (*ruby_init_stack)(VALUE*);
+static void* (*ruby_process_options)(int, char**);
 #endif
 
 #ifdef RUBY19_OR_LATER
@@ -297,12 +337,11 @@
 }
 #endif
 
-static HINSTANCE hinstRuby = 0; /* Instance of ruby.dll */
+static HINSTANCE hinstRuby = NULL; /* Instance of ruby.dll */
 
 /*
  * Table of name to function pointer of ruby.
  */
-#define RUBY_PROC FARPROC
 static struct
 {
     char *name;
@@ -347,7 +386,11 @@
     {"rb_obj_as_string", (RUBY_PROC*)&dll_rb_obj_as_string},
     {"rb_obj_id", (RUBY_PROC*)&dll_rb_obj_id},
     {"rb_raise", (RUBY_PROC*)&dll_rb_raise},
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+    {"rb_string_value", (RUBY_PROC*)&dll_rb_string_value},
+#else
     {"rb_str2cstr", (RUBY_PROC*)&dll_rb_str2cstr},
+#endif
     {"rb_str_cat", (RUBY_PROC*)&dll_rb_str_cat},
     {"rb_str_concat", (RUBY_PROC*)&dll_rb_str_concat},
     {"rb_str_new", (RUBY_PROC*)&dll_rb_str_new},
@@ -363,15 +406,17 @@
 #endif
     {"ruby_init", (RUBY_PROC*)&dll_ruby_init},
     {"ruby_init_loadpath", (RUBY_PROC*)&dll_ruby_init_loadpath},
+#ifdef WIN3264
     {
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
     "NtInitialize",
-#else
+# else
     "ruby_sysinit",
-#endif
+# endif
 			(RUBY_PROC*)&dll_NtInitialize},
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
     {"rb_w32_snprintf", (RUBY_PROC*)&dll_rb_w32_snprintf},
+# endif
 #endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
     {"rb_string_value_ptr", (RUBY_PROC*)&dll_rb_string_value_ptr},
@@ -386,7 +431,9 @@
     {"rb_enc_find", (RUBY_PROC*)&dll_rb_enc_find},
     {"rb_enc_str_new", (RUBY_PROC*)&dll_rb_enc_str_new},
     {"rb_sprintf", (RUBY_PROC*)&dll_rb_sprintf},
+    {"rb_require", (RUBY_PROC*)&dll_rb_require},
     {"ruby_init_stack", (RUBY_PROC*)&dll_ruby_init_stack},
+    {"ruby_process_options", (RUBY_PROC*)&dll_ruby_process_options},
 #endif
     {"", NULL},
 };
@@ -399,8 +446,8 @@
 {
     if (hinstRuby)
     {
-	FreeLibrary(hinstRuby);
-	hinstRuby = 0;
+	close_dll(hinstRuby);
+	hinstRuby = NULL;
     }
 }
 
@@ -416,7 +463,7 @@
 
     if (hinstRuby)
 	return OK;
-    hinstRuby = LoadLibrary(libname);
+    hinstRuby = load_dll(libname);
     if (!hinstRuby)
     {
 	if (verbose)
@@ -426,11 +473,11 @@
 
     for (i = 0; ruby_funcname_table[i].ptr; ++i)
     {
-	if (!(*ruby_funcname_table[i].ptr = GetProcAddress(hinstRuby,
+	if (!(*ruby_funcname_table[i].ptr = symbol_from_dll(hinstRuby,
 			ruby_funcname_table[i].name)))
 	{
-	    FreeLibrary(hinstRuby);
-	    hinstRuby = 0;
+	    close_dll(hinstRuby);
+	    hinstRuby = NULL;
 	    if (verbose)
 		EMSG2(_(e_loadfunc), ruby_funcname_table[i].name);
 	    return FAIL;
@@ -539,9 +586,9 @@
 	if (u_save(eap->line1 - 1, eap->line2 + 1) != OK)
 	    return;
 	for (i = eap->line1; i <= eap->line2; i++) {
-	    VALUE line, oldline;
+	    VALUE line;
 
-	    line = oldline = vim_str2rb_enc_str((char *)ml_get(i));
+	    line = vim_str2rb_enc_str((char *)ml_get(i));
 	    rb_lastline_set(line);
 	    eval_enc_string_protect((char *) eap->arg, &state);
 	    if (state) {
@@ -616,13 +663,16 @@
 		ruby_init();
 	    }
 #ifdef RUBY19_OR_LATER
+	    {
+		int dummy_argc = 2;
+		char *dummy_argv[] = {"vim-ruby", "-e0"};
+		ruby_process_options(dummy_argc, dummy_argv);
+	    }
 	    ruby_script("vim-ruby");
-#endif
+#else
 	    ruby_init_loadpath();
-	    ruby_io_init();
-#ifdef RUBY19_OR_LATER
-	    rb_enc_find_index("encdb");
 #endif
+	    ruby_io_init();
 	    ruby_vim_init();
 	    ruby_initialized = 1;
 #ifdef DYNAMIC_RUBY
@@ -906,15 +956,9 @@
 
 static VALUE get_buffer_line(buf_T *buf, linenr_T n)
 {
-    if (n > 0 && n <= buf->b_ml.ml_line_count)
-    {
-	char *line = (char *)ml_get_buf(buf, n, FALSE);
-	return line ? vim_str2rb_enc_str(line) : Qnil;
-    }
-    rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
-#ifndef __GNUC__
-    return Qnil; /* For stop warning */
-#endif
+    if (n <= 0 || n > buf->b_ml.ml_line_count)
+	rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
+    return vim_str2rb_enc_str((char *)ml_get_buf(buf, n, FALSE));
 }
 
 static VALUE buffer_aref(VALUE self, VALUE num)
@@ -953,9 +997,6 @@
     else
     {
 	rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
-#ifndef __GNUC__
-	return Qnil; /* For stop warning */
-#endif
     }
     return str;
 }
@@ -1010,7 +1051,8 @@
     long	n = NUM2LONG(num);
     aco_save_T	aco;
 
-    if (line == NULL) {
+    if (line == NULL)
+    {
 	rb_raise(rb_eIndexError, "NULL line");
     }
     else if (n >= 0 && n <= buf->b_ml.ml_line_count)
@@ -1034,7 +1076,8 @@
 
 	update_curbuf(NOT_VALID);
     }
-    else {
+    else
+    {
 	rb_raise(rb_eIndexError, "line number %ld out of range", n);
     }
     return str;
diff -Naur vim73.orig/src/if_sniff.c vim73/src/if_sniff.c
--- vim73.orig/src/if_sniff.c	2010-05-15 07:04:06.000000000 -0400
+++ vim73/src/if_sniff.c	2011-01-08 21:01:19.378657342 -0500
@@ -9,7 +9,6 @@
 
 #ifdef WIN32
 # include <stdio.h>
-# include "vimio.h"
 # include <process.h>
 # include <string.h>
 # include <assert.h>
diff -Naur vim73.orig/src/if_tcl.c vim73/src/if_tcl.c
--- vim73.orig/src/if_tcl.c	2010-08-08 09:07:25.000000000 -0400
+++ vim73/src/if_tcl.c	2011-01-08 21:01:19.434656677 -0500
@@ -74,7 +74,6 @@
 #endif
 
 #include <tcl.h>
-#include <errno.h>
 #include <string.h>
 
 typedef struct
diff -Naur vim73.orig/src/integration.c vim73/src/integration.c
--- vim73.orig/src/integration.c	2010-08-08 09:09:21.000000000 -0400
+++ vim73/src/integration.c	2011-01-08 21:01:19.434656677 -0500
@@ -33,7 +33,6 @@
 #include <sys/un.h>
 #endif
 
-#include <errno.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/param.h>
diff -Naur vim73.orig/src/link.sh vim73/src/link.sh
--- vim73.orig/src/link.sh	2010-07-21 15:43:29.000000000 -0400
+++ vim73/src/link.sh	2011-01-08 21:01:19.122658259 -0500
@@ -5,7 +5,7 @@
 # libraries when they exist, but this doesn't mean they are needed for Vim.
 #
 #      Author: Bram Moolenaar
-# Last change: 2006 Sep 26
+# Last change: 2010 Nov 03
 #     License: Public domain
 #
 # Warning: This fails miserably if the linker doesn't return an error code!
@@ -16,11 +16,23 @@
 echo "$LINK " >link.cmd
 exit_value=0
 
+if test "$LINK_AS_NEEDED" = yes; then
+  echo "link.sh: \$LINK_AS_NEEDED set to 'yes': invoking linker directly."
+  cat link.cmd
+  if sh link.cmd; then
+    exit_value=0
+    echo "link.sh: Linked fine"
+  else
+    exit_value=$?
+    echo "link.sh: Linking failed"
+  fi
+else
+  if test -f auto/link.sed; then
+
 #
 # If auto/link.sed already exists, use it.  We assume a previous run of
 # link.sh has found the correct set of libraries.
 #
-if test -f auto/link.sed; then
   echo "link.sh: The file 'auto/link.sed' exists, which is going to be used now."
   echo "link.sh: If linking fails, try deleting the auto/link.sed file."
   echo "link.sh: If this fails too, try creating an empty auto/link.sed file."
@@ -124,6 +136,8 @@
   fi
 fi
 
+fi
+
 #
 # cleanup
 #
diff -Naur vim73.orig/src/macros.h vim73/src/macros.h
--- vim73.orig/src/macros.h	2010-07-17 15:41:21.000000000 -0400
+++ vim73/src/macros.h	2011-01-08 20:59:41.002656834 -0500
@@ -285,3 +285,17 @@
 #else
 # define DO_AUTOCHDIR
 #endif
+
+#if defined(FEAT_SCROLLBIND) && defined(FEAT_CURSORBIND)
+# define RESET_BINDING(wp)  (wp)->w_p_scb = FALSE; (wp)->w_p_crb = FALSE
+#else
+# if defined(FEAT_SCROLLBIND)
+#  define RESET_BINDING(wp)  (wp)->w_p_scb = FALSE
+# else
+#  if defined(FEAT_CURSORBIND)
+#   define RESET_BINDING(wp)  (wp)->w_p_crb = FALSE
+#  else
+#   define RESET_BINDING(wp)
+#  endif
+# endif
+#endif
diff -Naur vim73.orig/src/main.c vim73/src/main.c
--- vim73.orig/src/main.c	2010-08-08 09:09:55.000000000 -0400
+++ vim73/src/main.c	2011-01-08 21:01:19.378657342 -0500
@@ -7,10 +7,6 @@
  * See README.txt for an overview of the Vim source code.
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"		/* for close() and dup() */
-#endif
-
 #define EXTERN
 #include "vim.h"
 
@@ -940,7 +936,7 @@
     if (netbeansArg != NULL && strncmp("-nb", netbeansArg, 3) == 0)
     {
 # ifdef FEAT_GUI
-#  if !defined(FEAT_GUI_MOTIF) && !defined(FEAT_GUI_GTK)  \
+#  if !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)  \
 		&& !defined(FEAT_GUI_W32)
 	if (gui.in_use)
 	{
@@ -3817,6 +3813,8 @@
     /* Check if we have at least one argument. */
     if (filec <= 0)
 	mainerr_arg_missing((char_u *)filev[-1]);
+
+    /* Temporarily cd to the current directory to handle relative file names. */
     if (mch_dirname(cwd, MAXPATHL) != OK)
 	return NULL;
     if ((p = vim_strsave_escaped_ext(cwd,
@@ -3858,13 +3856,20 @@
 	ga_concat(&ga, p);
 	vim_free(p);
     }
+    ga_concat(&ga, (char_u *)"|if exists('*inputrestore')|call inputrestore()|endif<CR>");
+
     /* The :drop commands goes to Insert mode when 'insertmode' is set, use
      * CTRL-\ CTRL-N again. */
-    ga_concat(&ga, (char_u *)"|if exists('*inputrestore')|call inputrestore()|endif<CR>");
-    ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd -");
+    ga_concat(&ga, (char_u *)"<C-\\><C-N>");
+
+    /* Switch back to the correct current directory (prior to temporary path
+     * switch) unless 'autochdir' is set, in which case it will already be
+     * correct after the :drop command. */
+    ga_concat(&ga, (char_u *)":if !exists('+acd')||!&acd|cd -|endif<CR>");
+
     if (sendReply)
-	ga_concat(&ga, (char_u *)"<CR>:call SetupRemoteReplies()");
-    ga_concat(&ga, (char_u *)"<CR>:");
+	ga_concat(&ga, (char_u *)":call SetupRemoteReplies()<CR>");
+    ga_concat(&ga, (char_u *)":");
     if (inicmd != NULL)
     {
 	/* Can't use <CR> after "inicmd", because an "startinsert" would cause
diff -Naur vim73.orig/src/mbyte.c vim73/src/mbyte.c
--- vim73.orig/src/mbyte.c	2010-07-18 09:05:44.000000000 -0400
+++ vim73/src/mbyte.c	2011-01-08 21:01:19.006657043 -0500
@@ -3124,6 +3124,9 @@
 		/* If one of the two characters is incomplete return -1. */
 		if (incomplete || i + utf_byte2len(s2[i]) > n)
 		    return -1;
+		/* Don't case-fold illegal bytes or truncated characters. */
+		if (utf_ptr2len(s1 + i) < l || utf_ptr2len(s2 + i) < l)
+		    return -1;
 		cdiff = utf_fold(utf_ptr2char(s1 + i))
 					     - utf_fold(utf_ptr2char(s2 + i));
 		if (cdiff != 0)
@@ -4159,11 +4162,11 @@
 {
     if (hIconvDLL != 0 && hMsvcrtDLL != 0)
 	return TRUE;
-    hIconvDLL = LoadLibrary(DYNAMIC_ICONV_DLL);
+    hIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);
     if (hIconvDLL == 0)		/* sometimes it's called libiconv.dll */
-	hIconvDLL = LoadLibrary(DYNAMIC_ICONV_DLL_ALT);
+	hIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT);
     if (hIconvDLL != 0)
-	hMsvcrtDLL = LoadLibrary(DYNAMIC_MSVCRT_DLL);
+	hMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);
     if (hIconvDLL == 0 || hMsvcrtDLL == 0)
     {
 	/* Only give the message when 'verbose' is set, otherwise it might be
@@ -5167,16 +5170,16 @@
     void
 xim_set_preedit()
 {
-    if (xic == NULL)
-	return;
-
-    xim_set_focus(TRUE);
-
     XVaNestedList attr_list;
     XRectangle spot_area;
     XPoint over_spot;
     int line_space;
 
+    if (xic == NULL)
+	return;
+
+    xim_set_focus(TRUE);
+
     if (!xim_has_focus)
     {
 	/* hide XIM cursor */
@@ -5554,12 +5557,12 @@
     void
 xim_set_status_area()
 {
-    if (xic == NULL)
-	return;
-
     XVaNestedList preedit_list = 0, status_list = 0, list = 0;
     XRectangle pre_area, status_area;
 
+    if (xic == NULL)
+	return;
+
     if (input_style & XIMStatusArea)
     {
 	if (input_style & XIMPreeditArea)
diff -Naur vim73.orig/src/memfile.c vim73/src/memfile.c
--- vim73.orig/src/memfile.c	2010-06-20 22:59:57.000000000 -0400
+++ vim73/src/memfile.c	2011-01-08 21:01:19.378657342 -0500
@@ -32,10 +32,6 @@
  * file is opened.
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 /*
@@ -1049,7 +1045,7 @@
 	PERROR(_("E294: Seek error in swap file read"));
 	return FAIL;
     }
-    if ((unsigned)vim_read(mfp->mf_fd, hp->bh_data, size) != size)
+    if ((unsigned)read_eintr(mfp->mf_fd, hp->bh_data, size) != size)
     {
 	PERROR(_("E295: Read error in swap file"));
 	return FAIL;
@@ -1168,7 +1164,7 @@
     }
 #endif
 
-    if ((unsigned)vim_write(mfp->mf_fd, data, size) != size)
+    if ((unsigned)write_eintr(mfp->mf_fd, data, size) != size)
 	result = FAIL;
 
 #ifdef FEAT_CRYPT
diff -Naur vim73.orig/src/memline.c vim73/src/memline.c
--- vim73.orig/src/memline.c	2010-08-08 09:11:46.000000000 -0400
+++ vim73/src/memline.c	2011-01-08 21:01:19.434656677 -0500
@@ -42,10 +42,6 @@
  *  mf_get().
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 #ifndef UNIX		/* it's in os_unix.h for Unix */
@@ -56,10 +52,6 @@
 # include <proto/dos.h>	    /* for Open() and Close() */
 #endif
 
-#ifdef HAVE_ERRNO_H
-# include <errno.h>
-#endif
-
 typedef struct block0		ZERO_BL;    /* contents of the first block */
 typedef struct pointer_block	PTR_BL;	    /* contents of a pointer block */
 typedef struct data_block	DATA_BL;    /* contents of a data block */
@@ -582,6 +574,9 @@
 	    idx = ip->ip_index + 1;	    /* go to next index */
 	    page_count = 1;
 	}
+
+	if (error > 0)
+	    EMSG(_("E843: Error while updating swap file crypt"));
     }
 
     mfp->mf_old_key = NULL;
@@ -2059,7 +2054,7 @@
     fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);
     if (fd >= 0)
     {
-	if (read(fd, (char *)&b0, sizeof(b0)) == sizeof(b0))
+	if (read_eintr(fd, &b0, sizeof(b0)) == sizeof(b0))
 	{
 	    if (STRNCMP(b0.b0_version, "VIM 3.0", 7) == 0)
 	    {
@@ -2384,7 +2379,7 @@
  * Make a copy of the line if necessary.
  */
 /*
- * get a pointer to a (read-only copy of a) line
+ * Return a pointer to a (read-only copy of a) line.
  *
  * On failure an error message is given and IObuff is returned (to avoid
  * having to check for error everywhere).
@@ -2397,7 +2392,7 @@
 }
 
 /*
- * ml_get_pos: get pointer to position 'pos'
+ * Return pointer to position "pos".
  */
     char_u *
 ml_get_pos(pos)
@@ -2407,7 +2402,7 @@
 }
 
 /*
- * ml_get_curline: get pointer to cursor line.
+ * Return pointer to cursor line.
  */
     char_u *
 ml_get_curline()
@@ -2416,7 +2411,7 @@
 }
 
 /*
- * ml_get_cursor: get pointer to cursor position
+ * Return pointer to cursor position.
  */
     char_u *
 ml_get_cursor()
@@ -2426,7 +2421,7 @@
 }
 
 /*
- * get a pointer to a line in a specific buffer
+ * Return a pointer to a line in a specific buffer
  *
  * "will_change": if TRUE mark the buffer dirty (chars in the line will be
  * changed)
@@ -4389,7 +4384,7 @@
 		fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);
 		if (fd >= 0)
 		{
-		    if (read(fd, (char *)&b0, sizeof(b0)) == sizeof(b0))
+		    if (read_eintr(fd, &b0, sizeof(b0)) == sizeof(b0))
 		    {
 			/*
 			 * If the swapfile has the same directory as the
diff -Naur vim73.orig/src/menu.c vim73/src/menu.c
--- vim73.orig/src/menu.c	2010-07-14 10:49:01.000000000 -0400
+++ vim73/src/menu.c	2011-01-08 21:01:19.494656637 -0500
@@ -1512,8 +1512,8 @@
 {
 #ifdef FEAT_MULTI_LANG
     if (menu->en_name != NULL
-	    && (menu_namecmp(name,menu->en_name)
-		|| menu_namecmp(name,menu->en_dname)))
+	    && (menu_namecmp(name, menu->en_name)
+		|| menu_namecmp(name, menu->en_dname)))
 	return TRUE;
 #endif
     return menu_namecmp(name, menu->name) || menu_namecmp(name, menu->dname);
@@ -2342,7 +2342,7 @@
 
 	while (menu != NULL)
 	{
-	    if (STRCMP(name, menu->name) == 0 || STRCMP(name, menu->dname) == 0)
+	    if (menu_name_equal(name, menu))
 	    {
 		if (menu->children == NULL)
 		{
diff -Naur vim73.orig/src/message.c vim73/src/message.c
--- vim73.orig/src/message.c	2010-08-04 14:10:02.000000000 -0400
+++ vim73/src/message.c	2011-01-08 21:01:19.510657932 -0500
@@ -569,6 +569,10 @@
     int		severe;
 #endif
 
+    /* Skip this if not giving error messages at the moment. */
+    if (emsg_not_now())
+	return TRUE;
+
     called_emsg = TRUE;
     ex_exitval = 1;
 
@@ -581,10 +585,6 @@
     emsg_severe = FALSE;
 #endif
 
-    /* Skip this if not giving error messages at the moment. */
-    if (emsg_not_now())
-	return TRUE;
-
     if (!emsg_off || vim_strchr(p_debug, 't') != NULL)
     {
 #ifdef FEAT_EVAL
@@ -1477,6 +1477,27 @@
     return retval;
 }
 
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Return the lhs or rhs of a mapping, with the key codes turned into printable
+ * strings, in an allocated string.
+ */
+    char_u *
+str2special_save(str, is_lhs)
+    char_u  *str;
+    int	    is_lhs;  /* TRUE for lhs, FALSE for rhs */
+{
+    garray_T	ga;
+    char_u	*p = str;
+
+    ga_init2(&ga, 1, 40);
+    while (*p != NUL)
+	ga_concat(&ga, str2special(&p, is_lhs));
+    ga_append(&ga, NUL);
+    return (char_u *)ga.ga_data;
+}
+#endif
+
 /*
  * Return the printable string for the key codes at "*sp".
  * Used for translating the lhs or rhs of a mapping to printable chars.
diff -Naur vim73.orig/src/misc1.c vim73/src/misc1.c
--- vim73.orig/src/misc1.c	2010-08-15 07:24:05.000000000 -0400
+++ vim73/src/misc1.c	2011-01-08 21:01:19.466658112 -0500
@@ -3114,10 +3114,11 @@
 	       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))
 	    continue;
 
-	/* found a termcode: adjust length */
-	if (n > 0)
+	if (n == KEYLEN_REMOVED)  /* key code removed */
+	    continue;
+	if (n > 0)		/* found a termcode: adjust length */
 	    len = n;
-	if (len == 0)	    /* nothing typed yet */
+	if (len == 0)		/* nothing typed yet */
 	    continue;
 
 	/* Handle modifier and/or special key code. */
@@ -9161,7 +9162,10 @@
 #ifdef CASE_INSENSITIVE_FILENAME
     regmatch.rm_ic = TRUE;		/* Behave like Terminal.app */
 #else
-    regmatch.rm_ic = FALSE;		/* Don't ever ignore case */
+    if (flags & EW_ICASE)
+	regmatch.rm_ic = TRUE;		/* 'wildignorecase' set */
+    else
+	regmatch.rm_ic = FALSE;		/* Don't ignore case */
 #endif
     regmatch.regprog = vim_regcomp(pat, RE_MAGIC);
     vim_free(pat);
@@ -9317,7 +9321,8 @@
 	    continue;  /* it's different when it's shorter */
 
 	rival = other_paths[j] + other_path_len - candidate_len;
-	if (fnamecmp(maybe_unique, rival) == 0)
+	if (fnamecmp(maybe_unique, rival) == 0
+		&& (rival == other_paths[j] || vim_ispathsep(*(rival - 1))))
 	    return FALSE;  /* match */
     }
 
@@ -9642,7 +9647,7 @@
     if (paths == NULL)
 	return 0;
 
-    files = globpath(paths, pattern, 0);
+    files = globpath(paths, pattern, (flags & EW_ICASE) ? WILD_ICASE : 0);
     vim_free(paths);
     if (files == NULL)
 	return 0;
diff -Naur vim73.orig/src/misc2.c vim73/src/misc2.c
--- vim73.orig/src/misc2.c	2010-08-13 05:14:35.000000000 -0400
+++ vim73/src/misc2.c	2011-01-08 21:01:19.302660568 -0500
@@ -200,7 +200,6 @@
 	}
 #endif
 
-	idx = -1;
 	ptr = line;
 	while (col <= wcol && *ptr != NUL)
 	{
@@ -1223,7 +1222,7 @@
 #endif
 
 /*
- * copy a string into newly allocated memory
+ * Copy "string" into newly allocated memory.
  */
     char_u *
 vim_strsave(string)
@@ -1239,6 +1238,12 @@
     return p;
 }
 
+/*
+ * Copy up to "len" bytes of "string" into newly allocated memory and
+ * terminate with a NUL.
+ * The allocated memory always has size "len + 1", also when "string" is
+ * shorter.
+ */
     char_u *
 vim_strnsave(string, len)
     char_u	*string;
diff -Naur vim73.orig/src/netbeans.c vim73/src/netbeans.c
--- vim73.orig/src/netbeans.c	2010-08-09 16:48:09.000000000 -0400
+++ vim73/src/netbeans.c	2011-01-08 21:01:19.498658408 -0500
@@ -16,10 +16,6 @@
  * See ":help netbeans-protocol" for explanation.
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 #if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
@@ -87,7 +83,7 @@
 static void nb_init_graphics __ARGS((void));
 static void coloncmd __ARGS((char *cmd, ...));
 static void nb_set_curbuf __ARGS((buf_T *buf));
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
 static void messageFromNetbeans __ARGS((XtPointer, int *, XtInputId *));
 #endif
 #ifdef FEAT_GUI_GTK
@@ -112,7 +108,7 @@
 static NBSOCK nbsock = -1;		/* socket fd for Netbeans connection */
 #define NETBEANS_OPEN (nbsock != -1)
 
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
 static XtInputId inputHandler = (XtInputId)NULL;  /* Cookie for input */
 #endif
 #ifdef FEAT_GUI_GTK
@@ -135,15 +131,13 @@
 static int needupdate = 0;
 static int inAtomic = 0;
 
+/*
+ * Close the socket and remove the input handlers.
+ */
     static void
-netbeans_close(void)
+nb_close_socket(void)
 {
-    if (!NETBEANS_OPEN)
-	return;
-
-    netbeans_send_disconnect();
-
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
     if (inputHandler != (XtInputId)NULL)
     {
 	XtRemoveInput(inputHandler);
@@ -167,13 +161,27 @@
 # endif
 #endif
 
+    sock_close(nbsock);
+    nbsock = -1;
+}
+
+/*
+ * Close the connection and cleanup.
+ * May be called when nb_close_socket() was called earlier.
+ */
+    static void
+netbeans_close(void)
+{
+    if (NETBEANS_OPEN)
+    {
+	netbeans_send_disconnect();
+	nb_close_socket();
+    }
+
 #ifdef FEAT_BEVAL
     bevalServers &= ~BEVAL_NETBEANS;
 #endif
 
-    sock_close(nbsock);
-    nbsock = -1;
-
     needupdate = 0;
     inAtomic = 0;
     nb_free();
@@ -311,14 +319,9 @@
     server.sin_port = htons(port);
     if ((host = gethostbyname(hostname)) == NULL)
     {
-	if (mch_access(hostname, R_OK) >= 0)
-	{
-	    /* DEBUG: input file */
-	    sd = mch_open(hostname, O_RDONLY, 0);
-	    goto theend;
-	}
 	nbdebug(("error in gethostbyname() in netbeans_connect()\n"));
 	PERROR("gethostbyname() in netbeans_connect()");
+	sock_close(sd);
 	goto theend;
     }
     memcpy((char *)&server.sin_addr, host->h_addr, host->h_length);
@@ -368,15 +371,12 @@
 							 || (errno == EINTR)))
 		{
 		    nbdebug(("retrying...\n"));
-		    sleep(5);
-		    if (!doabort)
+		    mch_delay(3000L, TRUE);
+		    ui_breakcheck();
+		    if (got_int)
 		    {
-			ui_breakcheck();
-			if (got_int)
-			{
-			    errno = EINTR;
-			    break;
-			}
+			errno = EINTR;
+			break;
 		    }
 		    if (connect(sd, (struct sockaddr *)&server,
 							 sizeof(server)) == 0)
@@ -391,6 +391,7 @@
 		    /* Get here when the server can't be found. */
 		    nbdebug(("Cannot connect to Netbeans #2\n"));
 		    PERROR(_("Cannot connect to Netbeans #2"));
+		    sock_close(sd);
 		    if (doabort)
 			getout(1);
 		    goto theend;
@@ -401,6 +402,7 @@
 	{
 	    nbdebug(("Cannot connect to Netbeans\n"));
 	    PERROR(_("Cannot connect to Netbeans"));
+	    sock_close(sd);
 	    if (doabort)
 		getout(1);
 	    goto theend;
@@ -631,9 +633,7 @@
 {
     char_u	*p;
     queue_T	*node;
-
-    if (!NETBEANS_OPEN)
-	return;
+    int		own_node;
 
     while (head.next != NULL && head.next != &head)
     {
@@ -672,20 +672,25 @@
 	    *p++ = NUL;
 	    if (*p == NUL)
 	    {
+		own_node = TRUE;
 		head.next = node->next;
 		node->next->prev = node->prev;
 	    }
+	    else
+		own_node = FALSE;
 
 	    /* now, parse and execute the commands */
 	    nb_parse_cmd(node->buffer);
 
-	    if (*p == NUL)
+	    if (own_node)
 	    {
 		/* buffer finished, dispose of the node and buffer */
 		vim_free(node->buffer);
 		vim_free(node);
 	    }
-	    else
+	    /* Check that "head" wasn't changed under our fingers, e.g. when a
+	     * DETACH command was handled. */
+	    else if (head.next == node)
 	    {
 		/* more follows, move to the start */
 		STRMOVE(node->buffer, p);
@@ -700,7 +705,7 @@
 /*
  * Read a command from netbeans.
  */
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
     static void
 messageFromNetbeans(XtPointer clientData UNUSED,
 		    int *unused1 UNUSED,
@@ -720,15 +725,14 @@
 }
 #endif
 
+#define DETACH_MSG "DETACH\n"
+
     void
 netbeans_read()
 {
     static char_u	*buf = NULL;
     int			len = 0;
     int			readlen = 0;
-#if defined(NB_HAS_GUI) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)
-    static int		level = 0;
-#endif
 #ifdef HAVE_SELECT
     struct timeval	tval;
     fd_set		rfds;
@@ -744,13 +748,6 @@
 	return;
     }
 
-#if defined(NB_HAS_GUI) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)
-    /* recursion guard; this will be called from the X event loop at unknown
-     * moments */
-    if (NB_HAS_GUI)
-	++level;
-#endif
-
     /* Allocate a buffer to read into. */
     if (buf == NULL)
     {
@@ -790,34 +787,32 @@
 	    break;	/* did read everything that's available */
     }
 
+    /* Reading a socket disconnection (readlen == 0), or a socket error. */
     if (readlen <= 0)
     {
-	/* read error or didn't read anything */
-	netbeans_close();
-	nbdebug(("messageFromNetbeans: Error in read() from socket\n"));
+	/* Queue a "DETACH" netbeans message in the command queue in order to
+	 * terminate the netbeans session later. Do not end the session here
+	 * directly as we may be running in the context of a call to
+	 * netbeans_parse_messages():
+	 *	netbeans_parse_messages
+	 *	    -> autocmd triggered while processing the netbeans cmd
+	 *		-> ui_breakcheck
+	 *		    -> gui event loop or select loop
+	 *			-> netbeans_read()
+	 */
+	save((char_u *)DETACH_MSG, (int)strlen(DETACH_MSG));
+	nb_close_socket();
+
 	if (len < 0)
 	{
 	    nbdebug(("read from Netbeans socket\n"));
 	    PERROR(_("read from Netbeans socket"));
 	}
-	return; /* don't try to parse it */
     }
 
-#if defined(NB_HAS_GUI) && !defined(FEAT_GUI_W32)
-    /* Let the main loop handle messages. */
-    if (NB_HAS_GUI)
-    {
-# ifdef FEAT_GUI_GTK
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
-# else
-	/* Parse the messages now, but avoid recursion. */
-	if (level == 1)
-	    netbeans_parse_messages();
-
-	--level;
-# endif
-    }
+#if defined(NB_HAS_GUI) && defined(FEAT_GUI_GTK)
+    if (NB_HAS_GUI && gtk_main_level() > 0)
+	gtk_main_quit();
 #endif
 }
 
@@ -955,7 +950,6 @@
     keyQ_T *key_node = keyHead.next;
     queue_T *cmd_node = head.next;
     nbbuf_T buf;
-    buf_T *bufp;
     int i;
 
     /* free the netbeans buffer list */
@@ -964,7 +958,7 @@
 	buf = buf_list[i];
 	vim_free(buf.displayname);
 	vim_free(buf.signmap);
-	if ((bufp=buf.bufp) != NULL)
+	if (buf.bufp != NULL)
 	{
 	    buf.bufp->b_netbeans_file = FALSE;
 	    buf.bufp->b_was_netbeans_file = FALSE;
@@ -1186,6 +1180,10 @@
 
     nbdebug(("REP %d: <none>\n", cmdno));
 
+    /* Avoid printing an annoying error message. */
+    if (!NETBEANS_OPEN)
+	return;
+
     sprintf(reply, "%d\n", cmdno);
     nb_send(reply, "nb_reply_nil");
 }
@@ -2773,6 +2771,16 @@
 ex_nbstart(eap)
     exarg_T	*eap;
 {
+#ifdef FEAT_GUI
+# if !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)  \
+		&& !defined(FEAT_GUI_W32)
+    if (gui.in_use)
+    {
+	EMSG(_("E838: netbeans is not supported with this GUI"));
+	return;
+    }
+# endif
+#endif
     netbeans_open((char *)eap->arg, FALSE);
 }
 
@@ -2937,7 +2945,7 @@
     if (!NB_HAS_GUI || !NETBEANS_OPEN)
 	return;
 
-# ifdef FEAT_GUI_MOTIF
+# ifdef FEAT_GUI_X11
     /* tell notifier we are interested in being called
      * when there is input on the editor connection socket
      */
@@ -3027,7 +3035,7 @@
     }
 }
 
-#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_W32) || defined(PROTO)
+#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_W32) || defined(PROTO)
 /*
  * Tell netbeans that the window was moved or resized.
  */
@@ -3458,7 +3466,7 @@
     return FALSE;
 }
 
-#if defined(FEAT_GUI_MOTIF) || defined(PROTO)
+#if defined(FEAT_GUI_X11) || defined(PROTO)
 /*
  * We have multiple signs to draw at the same location. Draw the
  * multi-sign indicator instead. This is the Motif version.
@@ -3487,7 +3495,7 @@
     XDrawPoint(gui.dpy, gui.wid, gui.text_gc, x+3, y++);
     XDrawPoint(gui.dpy, gui.wid, gui.text_gc, x+2, y);
 }
-#endif /* FEAT_GUI_MOTIF */
+#endif /* FEAT_GUI_X11 */
 
 #if defined(FEAT_GUI_GTK) && !defined(PROTO)
 /*
diff -Naur vim73.orig/src/normal.c vim73/src/normal.c
--- vim73.orig/src/normal.c	2010-07-31 09:25:19.000000000 -0400
+++ vim73/src/normal.c	2011-01-08 21:01:19.390656741 -0500
@@ -25,6 +25,9 @@
 static int	restart_VIsual_select = 0;
 #endif
 
+#ifdef FEAT_EVAL
+static void	set_vcount_ca __ARGS((cmdarg_T *cap, int *set_prevcount));
+#endif
 static int
 # ifdef __BORLANDC__
 _RTLENTRYF
@@ -648,6 +651,14 @@
     dont_scroll = FALSE;	/* allow scrolling here */
 #endif
 
+#ifdef FEAT_EVAL
+    /* Set v:count here, when called from main() and not a stuffed
+     * command, so that v:count can be used in an expression mapping
+     * when there is no count. */
+    if (toplevel && stuff_empty())
+	set_vcount_ca(&ca, &set_prevcount);
+#endif
+
     /*
      * Get the command character from the user.
      */
@@ -725,15 +736,7 @@
 	     * command, so that v:count can be used in an expression mapping
 	     * right after the count. */
 	    if (toplevel && stuff_empty())
-	    {
-		long count = ca.count0;
-
-		/* multiply with ca.opcount the same way as below */
-		if (ca.opcount != 0)
-		    count = ca.opcount * (count == 0 ? 1 : count);
-		set_vcount(count, count == 0 ? 1 : count, set_prevcount);
-		set_prevcount = FALSE;  /* only set v:prevcount once */
-	    }
+		set_vcount_ca(&ca, &set_prevcount);
 #endif
 	    if (ctrl_w)
 	    {
@@ -1386,6 +1389,26 @@
     opcount = ca.opcount;
 }
 
+#ifdef FEAT_EVAL
+/*
+ * Set v:count and v:count1 according to "cap".
+ * Set v:prevcount only when "set_prevcount" is TRUE.
+ */
+    static void
+set_vcount_ca(cap, set_prevcount)
+    cmdarg_T	*cap;
+    int		*set_prevcount;
+{
+    long count = cap->count0;
+
+    /* multiply with cap->opcount the same way as above */
+    if (cap->opcount != 0)
+	count = cap->opcount * (count == 0 ? 1 : count);
+    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);
+    *set_prevcount = FALSE;  /* only set v:prevcount once */
+}
+#endif
+
 /*
  * Handle an operator after visual mode or when the movement is finished
  */
@@ -5666,8 +5689,13 @@
 	else if (cmdchar == '#')
 	    aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
 	else if (tag_cmd)
-	    /* Don't escape spaces and Tabs in a tag with a backslash */
-	    aux_ptr = (char_u *)"\\|\"\n[";
+	{
+	    if (curbuf->b_help)
+		/* ":help" handles unescaped argument */
+		aux_ptr = (char_u *)"";
+	    else
+		aux_ptr = (char_u *)"\\|\"\n[";
+	}
 	else
 	    aux_ptr = (char_u *)"\\|\"\n*?[";
 
@@ -8524,7 +8552,7 @@
     else
 	curwin->w_curswant = 0;
     /* keep curswant at the column where we wanted to go, not where
-       we ended; differs if line is too short */
+     * we ended; differs if line is too short */
     curwin->w_set_curswant = FALSE;
 }
 
diff -Naur vim73.orig/src/ops.c vim73/src/ops.c
--- vim73.orig/src/ops.c	2010-08-01 08:16:08.000000000 -0400
+++ vim73/src/ops.c	2011-01-08 21:01:19.314657721 -0500
@@ -1584,9 +1584,11 @@
 adjust_clip_reg(rp)
     int		*rp;
 {
-    /* If no reg. specified, and "unnamed" is in 'clipboard', use '*' reg. */
-    if (*rp == 0 && clip_unnamed)
-	*rp = '*';
+    /* If no reg. specified, and "unnamed" or "unnamedplus" is in 'clipboard',
+     * use '*' or '+' reg, respectively. "unnamedplus" prevails. */
+    if (*rp == 0 && clip_unnamed != 0)
+	*rp = ((clip_unnamed & CLIP_UNNAMED_PLUS) && clip_plus.available)
+								  ? '+' : '*';
     if (!clip_star.available && *rp == '*')
 	*rp = 0;
     if (!clip_plus.available && *rp == '+')
@@ -2842,6 +2844,9 @@
     char_u		*p;
     char_u		*pnew;
     struct block_def	bd;
+#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+    int			did_star = FALSE;
+#endif
 
 				    /* check for read-only register */
     if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))
@@ -3115,7 +3120,8 @@
      */
     if (clip_star.available
 	    && (curr == &(y_regs[STAR_REGISTER])
-		|| (!deleting && oap->regname == 0 && clip_unnamed)))
+		|| (!deleting && oap->regname == 0
+					   && (clip_unnamed & CLIP_UNNAMED))))
     {
 	if (curr != &(y_regs[STAR_REGISTER]))
 	    /* Copy the text from register 0 to the clipboard register. */
@@ -3123,6 +3129,9 @@
 
 	clip_own_selection(&clip_star);
 	clip_gen_set_selection(&clip_star);
+# ifdef FEAT_X11
+	did_star = TRUE;
+# endif
     }
 
 # ifdef FEAT_X11
@@ -3130,12 +3139,19 @@
      * If we were yanking to the '+' register, send result to selection.
      * Also copy to the '*' register, in case auto-select is off.
      */
-    else if (clip_plus.available && curr == &(y_regs[PLUS_REGISTER]))
+    if (clip_plus.available
+	    && (curr == &(y_regs[PLUS_REGISTER])
+		|| (!deleting && oap->regname == 0
+				      && (clip_unnamed & CLIP_UNNAMED_PLUS))))
     {
+	if (curr != &(y_regs[PLUS_REGISTER]))
+	    /* Copy the text from register 0 to the clipboard register. */
+	    copy_yank_reg(&(y_regs[PLUS_REGISTER]));
+
 	/* No need to copy to * register upon 'unnamed' now - see below */
 	clip_own_selection(&clip_plus);
 	clip_gen_set_selection(&clip_plus);
-	if (!clip_isautosel())
+	if (!clip_isautosel() && !did_star)
 	{
 	    copy_yank_reg(&(y_regs[STAR_REGISTER]));
 	    clip_own_selection(&clip_star);
@@ -3979,7 +3995,12 @@
     for (i = -1; i < NUM_REGISTERS && !got_int; ++i)
     {
 	name = get_register_name(i);
-	if (arg != NULL && vim_strchr(arg, name) == NULL)
+	if (arg != NULL && vim_strchr(arg, name) == NULL
+#ifdef ONE_CLIPBOARD
+	    /* Star register and plus register contain the same thing. */
+		&& (name != '*' || vim_strchr(arg, '+') == NULL)
+#endif
+		)
 	    continue;	    /* did not ask for this register */
 
 #ifdef FEAT_CLIPBOARD
@@ -4153,9 +4174,10 @@
     int	    save_undo;
 {
     char_u	*curr = NULL;
+    char_u      *curr_start = NULL;
     char_u	*cend;
     char_u	*newp;
-    char_u	*spaces;	/* number of spaces inserte before a line */
+    char_u	*spaces;	/* number of spaces inserted before a line */
     int		endcurr1 = NUL;
     int		endcurr2 = NUL;
     int		currsize = 0;	/* size of the current line */
@@ -4181,7 +4203,7 @@
      */
     for (t = 0; t < count; ++t)
     {
-	curr = ml_get((linenr_T)(curwin->w_cursor.lnum + t));
+	curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));
 	if (insert_space && t > 0)
 	{
 	    curr = skipwhite(curr);
@@ -4265,10 +4287,10 @@
 	    copy_spaces(cend, (size_t)(spaces[t]));
 	}
 	mark_col_adjust(curwin->w_cursor.lnum + t, (colnr_T)0, (linenr_T)-t,
-				 (long)(cend - newp + spaces[t]));
+			 (long)(cend - newp + spaces[t] - (curr - curr_start)));
 	if (t == 0)
 	    break;
-	curr = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));
+	curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));
 	if (insert_space && t > 1)
 	    curr = skipwhite(curr);
 	currsize = (int)STRLEN(curr);
diff -Naur vim73.orig/src/option.c vim73/src/option.c
--- vim73.orig/src/option.c	2010-08-04 14:49:18.000000000 -0400
+++ vim73/src/option.c	2011-01-08 21:01:19.282656400 -0500
@@ -2740,7 +2740,7 @@
 			    (char_u *)&p_wc, PV_NONE,
 			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}
 			    SCRIPTID_INIT},
-    {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
+    {"wildcharm",   "wcm",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_wcm, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
@@ -2750,6 +2750,9 @@
 			    (char_u *)NULL, PV_NONE,
 #endif
 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
+    {"wildignorecase", "wic", P_BOOL|P_VI_DEF,
+			    (char_u *)&p_wic, PV_NONE,
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
 #ifdef FEAT_WILDMENU
 			    (char_u *)&p_wmnu, PV_NONE,
@@ -7304,7 +7307,7 @@
     static char_u *
 check_clipboard_option()
 {
-    int		new_unnamed = FALSE;
+    int		new_unnamed = 0;
     int		new_autoselect = FALSE;
     int		new_autoselectml = FALSE;
     int		new_html = FALSE;
@@ -7316,9 +7319,15 @@
     {
 	if (STRNCMP(p, "unnamed", 7) == 0 && (p[7] == ',' || p[7] == NUL))
 	{
-	    new_unnamed = TRUE;
+	    new_unnamed |= CLIP_UNNAMED;
 	    p += 7;
 	}
+        else if (STRNCMP(p, "unnamedplus", 11) == 0
+					    && (p[11] == ',' || p[11] == NUL))
+	{
+	    new_unnamed |= CLIP_UNNAMED_PLUS;
+	    p += 11;
+	}
 	else if (STRNCMP(p, "autoselect", 10) == 0
 					&& (p[10] == ',' || p[10] == NUL))
 	{
@@ -9756,6 +9765,9 @@
 #ifdef FEAT_SCROLLBIND
     to->wo_scb = from->wo_scb;
 #endif
+#ifdef FEAT_CURSORBIND
+    to->wo_crb = from->wo_crb;
+#endif
 #ifdef FEAT_SPELL
     to->wo_spell = from->wo_spell;
 #endif
@@ -10011,7 +10023,7 @@
 	    buf->b_p_smc = p_smc;
 #endif
 #ifdef FEAT_SPELL
-	    buf->b_s.b_p_spc = vim_strsave(p_spf);
+	    buf->b_s.b_p_spc = vim_strsave(p_spc);
 	    (void)compile_cap_prog(&buf->b_s);
 	    buf->b_s.b_p_spf = vim_strsave(p_spf);
 	    buf->b_s.b_p_spl = vim_strsave(p_spl);
diff -Naur vim73.orig/src/option.h vim73/src/option.h
--- vim73.orig/src/option.h	2010-07-25 10:15:02.000000000 -0400
+++ vim73/src/option.h	2011-01-08 21:01:19.246657477 -0500
@@ -872,6 +872,7 @@
 EXTERN char_u	*p_ww;		/* 'whichwrap' */
 EXTERN long	p_wc;		/* 'wildchar' */
 EXTERN long	p_wcm;		/* 'wildcharm' */
+EXTERN long	p_wic;		/* 'wildignorecase' */
 EXTERN char_u	*p_wim;		/* 'wildmode' */
 #ifdef FEAT_WILDMENU
 EXTERN int	p_wmnu;		/* 'wildmenu' */
diff -Naur vim73.orig/src/os_macosx.m vim73/src/os_macosx.m
--- vim73.orig/src/os_macosx.m	2010-08-15 06:56:50.000000000 -0400
+++ vim73/src/os_macosx.m	2011-01-08 21:01:18.806655841 -0500
@@ -15,6 +15,10 @@
     Error: MACOS 9 is no longer supported in Vim 7
 #endif
 
+/* Avoid a conflict for the definition of Boolean between Mac header files and
+ * X11 header files. */
+#define NO_X11_INCLUDES
+
 #include "vim.h"
 #import <Cocoa/Cocoa.h>
 
diff -Naur vim73.orig/src/os_msdos.c vim73/src/os_msdos.c
--- vim73.orig/src/os_msdos.c	2010-05-15 07:04:07.000000000 -0400
+++ vim73/src/os_msdos.c	2011-01-08 21:01:19.382657751 -0500
@@ -21,7 +21,6 @@
  * Some functions are also used for Win16 (MS-Windows 3.1).
  */
 
-#include "vimio.h"
 #include "vim.h"
 
 #include <conio.h>
diff -Naur vim73.orig/src/os_mswin.c vim73/src/os_mswin.c
--- vim73.orig/src/os_mswin.c	2010-07-27 15:39:05.000000000 -0400
+++ vim73/src/os_mswin.c	2011-01-08 21:01:19.434656677 -0500
@@ -22,7 +22,6 @@
 # endif
 #endif
 
-#include "vimio.h"
 #include "vim.h"
 
 #ifdef WIN16
@@ -31,7 +30,6 @@
 # include <string.h>
 #endif
 #include <sys/types.h>
-#include <errno.h>
 #include <signal.h>
 #include <limits.h>
 #include <process.h>
@@ -817,7 +815,11 @@
     BOOL fRunTimeLinkSuccess = FALSE;
 
     // Get a handle to the DLL module.
+# ifdef WIN16
     hinstLib = LoadLibrary(libname);
+# else
+    hinstLib = vimLoadLib(libname);
+# endif
 
     // If the handle is valid, try to get the function address.
     if (hinstLib != NULL)
diff -Naur vim73.orig/src/os_unix.c vim73/src/os_unix.c
--- vim73.orig/src/os_unix.c	2010-08-08 09:14:04.000000000 -0400
+++ vim73/src/os_unix.c	2011-01-08 21:01:19.358658475 -0500
@@ -1123,6 +1123,30 @@
 }
 #endif
 
+# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+static void loose_clipboard __ARGS((void));
+
+/*
+ * Called when Vim is going to sleep or execute a shell command.
+ * We can't respond to requests for the X selections.  Lose them, otherwise
+ * other applications will hang.  But first copy the text to cut buffer 0.
+ */
+    static void
+loose_clipboard()
+{
+    if (clip_star.owned || clip_plus.owned)
+    {
+	x11_export_final_selection();
+	if (clip_star.owned)
+	    clip_lose_selection(&clip_star);
+	if (clip_plus.owned)
+	    clip_lose_selection(&clip_plus);
+	if (x11_display != NULL)
+	    XFlush(x11_display);
+    }
+}
+#endif
+
 /*
  * If the machine has job control, use it to suspend the program,
  * otherwise fake it by starting a new shell.
@@ -1137,19 +1161,7 @@
     out_flush();	    /* needed to disable mouse on some systems */
 
 # if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
-    /* Since we are going to sleep, we can't respond to requests for the X
-     * selections.  Lose them, otherwise other applications will hang.  But
-     * first copy the text to cut buffer 0. */
-    if (clip_star.owned || clip_plus.owned)
-    {
-	x11_export_final_selection();
-	if (clip_star.owned)
-	    clip_lose_selection(&clip_star);
-	if (clip_plus.owned)
-	    clip_lose_selection(&clip_plus);
-	if (x11_display != NULL)
-	    XFlush(x11_display);
-    }
+    loose_clipboard();
 # endif
 
 # if defined(_REENTRANT) && defined(SIGCONT)
@@ -1726,6 +1738,11 @@
     }
     if (x11_window == 0 || x11_display == NULL)
 	return (result = FAIL);
+
+# ifdef FEAT_EVAL
+    set_vim_var_nr(VV_WINDOWID, (long)x11_window);
+# endif
+
     return (result = OK);
 }
 
@@ -3706,6 +3723,10 @@
     if (options & SHELL_COOKED)
 	settmode(TMODE_COOK);	    /* set to normal mode */
 
+# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+    loose_clipboard();
+# endif
+
 # ifdef __EMX__
     if (cmd == NULL)
 	x = system("");	/* this starts an interactive shell in emx */
@@ -3814,13 +3835,17 @@
 # endif
     int		did_settmode = FALSE;	/* settmode(TMODE_RAW) called */
 
+    newcmd = vim_strsave(p_sh);
+    if (newcmd == NULL)		/* out of memory */
+	goto error;
+
     out_flush();
     if (options & SHELL_COOKED)
 	settmode(TMODE_COOK);		/* set to normal mode */
 
-    newcmd = vim_strsave(p_sh);
-    if (newcmd == NULL)		/* out of memory */
-	goto error;
+# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+    loose_clipboard();
+# endif
 
     /*
      * Do this loop twice:
@@ -4148,7 +4173,6 @@
 # ifdef FEAT_GUI
 		if (pty_master_fd >= 0)
 		{
-		    close(pty_slave_fd);	/* close slave side of pty */
 		    fromshell_fd = pty_master_fd;
 		    toshell_fd = dup(pty_master_fd);
 		}
@@ -4430,7 +4454,7 @@
 		    ++noread_cnt;
 		    while (RealWaitForChar(fromshell_fd, 10L, NULL))
 		    {
-			len = read(fromshell_fd, (char *)buffer
+			len = read_eintr(fromshell_fd, buffer
 # ifdef FEAT_MBYTE
 				+ buffer_off, (size_t)(BUFLEN - buffer_off)
 # else
@@ -4617,6 +4641,14 @@
 		    break;
 	    }
 
+# ifdef FEAT_GUI
+	    /* Close slave side of pty.  Only do this after the child has
+	     * exited, otherwise the child may hang when it tries to write on
+	     * the pty. */
+	    if (pty_master_fd >= 0)
+		close(pty_slave_fd);
+# endif
+
 	    /* Make sure the child that writes to the external program is
 	     * dead. */
 	    if (wpid > 0)
diff -Naur vim73.orig/src/os_win16.c vim73/src/os_win16.c
--- vim73.orig/src/os_win16.c	2010-06-26 00:03:31.000000000 -0400
+++ vim73/src/os_win16.c	2011-01-08 21:01:19.434656677 -0500
@@ -20,13 +20,11 @@
 # pragma warn -obs
 #endif
 
-#include "vimio.h"
 #include "vim.h"
 
 #include <dos.h>
 #include <string.h>
 #include <sys/types.h>
-#include <errno.h>
 #include <signal.h>
 #include <limits.h>
 #include <process.h>
diff -Naur vim73.orig/src/os_win32.c vim73/src/os_win32.c
--- vim73.orig/src/os_win32.c	2010-07-14 10:49:36.000000000 -0400
+++ vim73/src/os_win32.c	2011-01-08 21:01:19.438656953 -0500
@@ -20,7 +20,6 @@
  * Roger Knobbe <rogerk@wonderware.com> did the initial port of Vim 3.0.
  */
 
-#include "vimio.h"
 #include "vim.h"
 
 #ifdef FEAT_MZSCHEME
@@ -28,7 +27,6 @@
 #endif
 
 #include <sys/types.h>
-#include <errno.h>
 #include <signal.h>
 #include <limits.h>
 #include <process.h>
@@ -206,42 +204,73 @@
 static int suppress_winsize = 1;	/* don't fiddle with console */
 #endif
 
+static char_u *exe_path = NULL;
+
     static void
 get_exe_name(void)
 {
-    char	temp[256];
-    static int	did_set_PATH = FALSE;
+    /* Maximum length of $PATH is more than MAXPATHL.  8191 is often mentioned
+     * as the maximum length that works (plus a NUL byte). */
+#define MAX_ENV_PATH_LEN 8192
+    char	temp[MAX_ENV_PATH_LEN];
+    char_u	*p;
 
     if (exe_name == NULL)
     {
 	/* store the name of the executable, may be used for $VIM */
-	GetModuleFileName(NULL, temp, 255);
+	GetModuleFileName(NULL, temp, MAX_ENV_PATH_LEN - 1);
 	if (*temp != NUL)
 	    exe_name = FullName_save((char_u *)temp, FALSE);
     }
 
-    if (!did_set_PATH && exe_name != NULL)
+    if (exe_path == NULL && exe_name != NULL)
     {
-	char_u	    *p;
-	char_u	    *newpath;
-
-	/* Append our starting directory to $PATH, so that when doing "!xxd"
-	 * it's found in our starting directory.  Needed because SearchPath()
-	 * also looks there. */
-	p = mch_getenv("PATH");
-	newpath = alloc((unsigned)(STRLEN(p) + STRLEN(exe_name) + 2));
-	if (newpath != NULL)
-	{
-	    STRCPY(newpath, p);
-	    STRCAT(newpath, ";");
-	    vim_strncpy(newpath + STRLEN(newpath), exe_name,
-					    gettail_sep(exe_name) - exe_name);
-	    vim_setenv((char_u *)"PATH", newpath);
-	    vim_free(newpath);
+	exe_path = vim_strnsave(exe_name,
+				     (int)(gettail_sep(exe_name) - exe_name));
+	if (exe_path != NULL)
+	{
+	    /* Append our starting directory to $PATH, so that when doing
+	     * "!xxd" it's found in our starting directory.  Needed because
+	     * SearchPath() also looks there. */
+	    p = mch_getenv("PATH");
+	    if (p == NULL
+		       || STRLEN(p) + STRLEN(exe_path) + 2 < MAX_ENV_PATH_LEN)
+	    {
+		if (p == NULL || *p == NUL)
+		    temp[0] = NUL;
+		else
+		{
+		    STRCPY(temp, p);
+		    STRCAT(temp, ";");
+		}
+		STRCAT(temp, exe_path);
+		vim_setenv((char_u *)"PATH", temp);
+	    }
 	}
+    }
+}
+
+/*
+ * Load library "name".
+ */
+    HINSTANCE
+vimLoadLib(char *name)
+{
+    HINSTANCE dll = NULL;
+    char old_dir[MAXPATHL];
 
-	did_set_PATH = TRUE;
+    if (exe_path == NULL)
+	get_exe_name();
+    if (exe_path != NULL && mch_dirname(old_dir, MAXPATHL) == OK)
+    {
+	/* Change directory to where the executable is, both to make sure we
+	 * find a .dll there and to avoid looking for a .dll in the current
+	 * directory. */
+	mch_chdir(exe_path);
+	dll = LoadLibrary(name);
+	mch_chdir(old_dir);
     }
+    return dll;
 }
 
 #if defined(DYNAMIC_GETTEXT) || defined(PROTO)
@@ -254,7 +283,7 @@
 static char *null_libintl_bindtextdomain(const char *, const char *);
 static char *null_libintl_bind_textdomain_codeset(const char *, const char *);
 
-static HINSTANCE hLibintlDLL = 0;
+static HINSTANCE hLibintlDLL = NULL;
 char *(*dyn_libintl_gettext)(const char *) = null_libintl_gettext;
 char *(*dyn_libintl_textdomain)(const char *) = null_libintl_textdomain;
 char *(*dyn_libintl_bindtextdomain)(const char *, const char *)
@@ -282,26 +311,16 @@
     if (hLibintlDLL)
 	return 1;
     /* Load gettext library (libintl.dll) */
-    hLibintlDLL = LoadLibrary(libname != NULL ? libname : GETTEXT_DLL);
+    hLibintlDLL = vimLoadLib(libname != NULL ? libname : GETTEXT_DLL);
     if (!hLibintlDLL)
     {
-	char_u	    dirname[_MAX_PATH];
-
-	/* Try using the path from gvim.exe to find the .dll there. */
-	get_exe_name();
-	STRCPY(dirname, exe_name);
-	STRCPY(gettail(dirname), GETTEXT_DLL);
-	hLibintlDLL = LoadLibrary((char *)dirname);
-	if (!hLibintlDLL)
+	if (p_verbose > 0)
 	{
-	    if (p_verbose > 0)
-	    {
-		verbose_enter();
-		EMSG2(_(e_loadlib), GETTEXT_DLL);
-		verbose_leave();
-	    }
-	    return 0;
+	    verbose_enter();
+	    EMSG2(_(e_loadlib), GETTEXT_DLL);
+	    verbose_leave();
 	}
+	return 0;
     }
     for (i = 0; libintl_entry[i].name != NULL
 					 && libintl_entry[i].ptr != NULL; ++i)
@@ -430,7 +449,7 @@
 	     * Seems like a lot of overhead to load/unload ADVAPI32.DLL each
 	     * time we verify security...
 	     */
-	    advapi_lib = LoadLibrary("ADVAPI32.DLL");
+	    advapi_lib = vimLoadLib("ADVAPI32.DLL");
 	    if (advapi_lib != NULL)
 	    {
 		pSetNamedSecurityInfo = (PSNSECINFO)GetProcAddress(advapi_lib,
@@ -1615,6 +1634,35 @@
     return TRUE;
 }
 
+#if ((defined(__MINGW32__) || defined (__CYGWIN32__)) && \
+        __MSVCRT_VERSION__ >= 0x800) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+/*
+ * Bad parameter handler.
+ *
+ * Certain MS CRT functions will intentionally crash when passed invalid
+ * parameters to highlight possible security holes.  Setting this function as
+ * the bad parameter handler will prevent the crash.
+ *
+ * In debug builds the parameters contain CRT information that might help track
+ * down the source of a problem, but in non-debug builds the arguments are all
+ * NULL/0.  Debug builds will also produce assert dialogs from the CRT, it is
+ * worth allowing these to make debugging of issues easier.
+ */
+    static void
+bad_param_handler(const wchar_t *expression,
+    const wchar_t *function,
+    const wchar_t *file,
+    unsigned int line,
+    uintptr_t pReserved)
+{
+}
+
+# define SET_INVALID_PARAM_HANDLER \
+	((void)_set_invalid_parameter_handler(bad_param_handler))
+#else
+# define SET_INVALID_PARAM_HANDLER
+#endif
+
 #ifdef FEAT_GUI_W32
 
 /*
@@ -1627,6 +1675,9 @@
     extern int _fmode;
 #endif
 
+    /* Silently handle invalid parameters to CRT functions */
+    SET_INVALID_PARAM_HANDLER;
+
     /* Let critical errors result in a failure, not in a dialog box.  Required
      * for the timestamp test to work on removed floppies. */
     SetErrorMode(SEM_FAILCRITICALERRORS);
@@ -2103,6 +2154,9 @@
     extern int _fmode;
 #endif
 
+    /* Silently handle invalid parameters to CRT functions */
+    SET_INVALID_PARAM_HANDLER;
+
     /* Let critical errors result in a failure, not in a dialog box.  Required
      * for the timestamp test to work on removed floppies. */
     SetErrorMode(SEM_FAILCRITICALERRORS);
@@ -2273,12 +2327,14 @@
     int		len)
 {
     char		szTrueName[_MAX_PATH + 2];
+    char		szTrueNameTemp[_MAX_PATH + 2];
     char		*ptrue, *ptruePrev;
     char		*porig, *porigPrev;
     int			flen;
     WIN32_FIND_DATA	fb;
     HANDLE		hFind;
     int			c;
+    int			slen;
 
     flen = (int)STRLEN(name);
     if (flen == 0 || flen > _MAX_PATH)
@@ -2323,12 +2379,19 @@
 	}
 	*ptrue = NUL;
 
+	/* To avoid a slow failure append "\*" when searching a directory,
+	 * server or network share. */
+	STRCPY(szTrueNameTemp, szTrueName);
+	slen = (int)strlen(szTrueNameTemp);
+	if (*porig == psepc && slen + 2 < _MAX_PATH)
+	    STRCPY(szTrueNameTemp + slen, "\\*");
+
 	/* Skip "", "." and "..". */
 	if (ptrue > ptruePrev
 		&& (ptruePrev[0] != '.'
 		    || (ptruePrev[1] != NUL
 			&& (ptruePrev[1] != '.' || ptruePrev[2] != NUL)))
-		&& (hFind = FindFirstFile(szTrueName, &fb))
+		&& (hFind = FindFirstFile(szTrueNameTemp, &fb))
 						      != INVALID_HANDLE_VALUE)
 	{
 	    c = *porig;
@@ -3120,9 +3183,10 @@
      * It's nicer to run a filter command in a minimized window, but in
      * Windows 95 this makes the command MUCH slower.  We can't do it under
      * Win32s either as it stops the synchronous spawn workaround working.
+     * Don't activate the window to keep focus on Vim.
      */
     if ((options & SHELL_DOOUT) && !mch_windows95() && !gui_is_win32s())
-	si.wShowWindow = SW_SHOWMINIMIZED;
+	si.wShowWindow = SW_SHOWMINNOACTIVE;
     else
 	si.wShowWindow = SW_SHOWNORMAL;
     si.cbReserved2 = 0;
diff -Naur vim73.orig/src/popupmnu.c vim73/src/popupmnu.c
--- vim73.orig/src/popupmnu.c	2010-08-08 09:14:58.000000000 -0400
+++ vim73/src/popupmnu.c	2011-01-08 21:01:19.046656594 -0500
@@ -558,8 +558,11 @@
 	    win_T	*curwin_save = curwin;
 	    int		res = OK;
 
-	    /* Open a preview window.  3 lines by default. */
+	    /* Open a preview window.  3 lines by default.  Prefer
+	     * 'previewheight' if set and smaller. */
 	    g_do_tagpreview = 3;
+	    if (p_pvh > 0 && p_pvh < g_do_tagpreview)
+		g_do_tagpreview = p_pvh;
 	    resized = prepare_tagpreview(FALSE);
 	    g_do_tagpreview = 0;
 
diff -Naur vim73.orig/src/proto/fileio.pro vim73/src/proto/fileio.pro
--- vim73.orig/src/proto/fileio.pro	2010-08-15 08:30:28.000000000 -0400
+++ vim73/src/proto/fileio.pro	2011-01-08 21:01:19.354659886 -0500
@@ -54,4 +54,6 @@
 int match_file_pat __ARGS((char_u *pattern, regprog_T *prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs));
 int match_file_list __ARGS((char_u *list, char_u *sfname, char_u *ffname));
 char_u *file_pat_to_reg_pat __ARGS((char_u *pat, char_u *pat_end, char *allow_dirs, int no_bslash));
+long read_eintr __ARGS((int fd, void *buf, size_t bufsize));
+long write_eintr __ARGS((int fd, void *buf, size_t bufsize));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/getchar.pro vim73/src/proto/getchar.pro
--- vim73.orig/src/proto/getchar.pro	2010-08-15 08:30:29.000000000 -0400
+++ vim73/src/proto/getchar.pro	2011-01-08 21:01:18.918658776 -0500
@@ -51,6 +51,7 @@
 int get_map_mode __ARGS((char_u **cmdp, int forceit));
 void map_clear __ARGS((char_u *cmdp, char_u *arg, int forceit, int abbr));
 void map_clear_int __ARGS((buf_T *buf, int mode, int local, int abbr));
+char_u *map_mode_to_chars __ARGS((int mode));
 int map_to_exists __ARGS((char_u *str, char_u *modechars, int abbr));
 int map_to_exists_mode __ARGS((char_u *rhs, int mode, int abbr));
 char_u *set_context_in_map_cmd __ARGS((expand_T *xp, char_u *cmd, char_u *arg, int forceit, int isabbrev, int isunmap, cmdidx_T cmdidx));
@@ -61,7 +62,7 @@
 int makemap __ARGS((FILE *fd, buf_T *buf));
 int put_escstr __ARGS((FILE *fd, char_u *strstart, int what));
 void check_map_keycodes __ARGS((void));
-char_u *check_map __ARGS((char_u *keys, int mode, int exact, int ign_mod, int abbr));
+char_u *check_map __ARGS((char_u *keys, int mode, int exact, int ign_mod, int abbr, mapblock_T **mp_ptr, int *local_ptr));
 void init_mappings __ARGS((void));
 void add_map __ARGS((char_u *map, int mode));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/message.pro vim73/src/proto/message.pro
--- vim73.orig/src/proto/message.pro	2010-08-15 08:30:41.000000000 -0400
+++ vim73/src/proto/message.pro	2011-01-08 21:01:18.918658776 -0500
@@ -33,6 +33,7 @@
 int msg_outtrans_len_attr __ARGS((char_u *msgstr, int len, int attr));
 void msg_make __ARGS((char_u *arg));
 int msg_outtrans_special __ARGS((char_u *strstart, int from));
+char_u *str2special_save __ARGS((char_u *str, int is_lhs));
 char_u *str2special __ARGS((char_u **sp, int from));
 void str2specialbuf __ARGS((char_u *sp, char_u *buf, int len));
 void msg_prt_line __ARGS((char_u *s, int list));
diff -Naur vim73.orig/src/proto/os_win32.pro vim73/src/proto/os_win32.pro
--- vim73.orig/src/proto/os_win32.pro	2010-08-15 08:31:14.000000000 -0400
+++ vim73/src/proto/os_win32.pro	2011-01-08 21:01:18.926655661 -0500
@@ -1,4 +1,5 @@
 /* os_win32.c */
+HINSTANCE vimLoadLib __ARGS((char *name));
 int dyn_libintl_init __ARGS((char *libname));
 void dyn_libintl_end __ARGS((void));
 void PlatformId __ARGS((void));
diff -Naur vim73.orig/src/quickfix.c vim73/src/quickfix.c
--- vim73.orig/src/quickfix.c	2010-08-09 16:12:14.000000000 -0400
+++ vim73/src/quickfix.c	2011-01-08 21:01:19.226656888 -0500
@@ -1656,9 +1656,7 @@
 	    opened_window = TRUE;	/* close it when fail */
 	    p_swb = empty_option;	/* don't split again */
 	    swb_flags = 0;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;
-# endif
+	    RESET_BINDING(curwin);
 	    if (ll_ref != NULL)
 	    {
 		/* The new window should use the location list from the
@@ -2125,6 +2123,7 @@
 	--qi->qf_lists[idx].qf_count;
     }
     vim_free(qi->qf_lists[idx].qf_title);
+    qi->qf_lists[idx].qf_title = NULL;
 }
 
 /*
@@ -2333,9 +2332,7 @@
 	    win_goto(lastwin);
 	if (win_split(height, WSP_BELOW | WSP_NEWLOC) == FAIL)
 	    return;		/* not enough room for window */
-#ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-#endif
+	RESET_BINDING(curwin);
 
 	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
 	{
@@ -2362,6 +2359,7 @@
 	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
 								   OPT_LOCAL);
 	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
+	    RESET_BINDING(curwin);
 #ifdef FEAT_DIFF
 	    curwin->w_p_diff = FALSE;
 #endif
@@ -3435,6 +3433,7 @@
     char_u	*fname;
 {
     buf_T	*newbuf;
+    buf_T	*newbuf_to_wipe = NULL;
     int		failed = TRUE;
     aco_save_T	aco;
 
@@ -3471,15 +3470,19 @@
 	    failed = FALSE;
 	    if (curbuf != newbuf)
 	    {
-		/* Bloody autocommands changed the buffer! */
-		if (buf_valid(newbuf))
-		    wipe_buffer(newbuf, FALSE);
+		/* Bloody autocommands changed the buffer!  Can happen when
+		 * using netrw and editing a remote file.  Use the current
+		 * buffer instead, delete the dummy one after restoring the
+		 * window stuff. */
+		newbuf_to_wipe = newbuf;
 		newbuf = curbuf;
 	    }
 	}
 
 	/* restore curwin/curbuf and a few other things */
 	aucmd_restbuf(&aco);
+	if (newbuf_to_wipe != NULL && buf_valid(newbuf_to_wipe))
+	    wipe_buffer(newbuf_to_wipe, FALSE);
     }
 
     if (!buf_valid(newbuf))
diff -Naur vim73.orig/src/regexp.c vim73/src/regexp.c
--- vim73.orig/src/regexp.c	2010-07-12 16:41:48.000000000 -0400
+++ vim73/src/regexp.c	2011-01-08 20:59:37.790766680 -0500
@@ -3538,6 +3538,7 @@
 
     regline = line;
     reglnum = 0;
+    reg_toolong = FALSE;
 
     /* Simplest case: Anchored match need be tried only once. */
     if (prog->reganch)
diff -Naur vim73.orig/src/screen.c vim73/src/screen.c
--- vim73.orig/src/screen.c	2010-08-13 09:21:27.000000000 -0400
+++ vim73/src/screen.c	2011-01-08 21:01:19.494656637 -0500
@@ -2317,7 +2317,7 @@
 		num = (long)lnum;
 	    else
 		/* 'relativenumber', don't use negative numbers */
-		num = (long)abs((int)get_cursor_rel_lnum(wp, lnum));
+		num = labs((long)get_cursor_rel_lnum(wp, lnum));
 
 	    sprintf((char *)buf, "%*ld ", w, num);
 #ifdef FEAT_RIGHTLEFT
@@ -3405,9 +3405,9 @@
 # endif
 		   )
 		{
-		    int_u	text_sign;
+		    int	text_sign;
 # ifdef FEAT_SIGN_ICONS
-		    int_u	icon_sign;
+		    int	icon_sign;
 # endif
 
 		    /* Draw two cells with the sign value or blank. */
@@ -3475,8 +3475,7 @@
 			    num = (long)lnum;
 			else
 			    /* 'relativenumber', don't use negative numbers */
-			    num = (long)abs((int)get_cursor_rel_lnum(wp,
-								    lnum));
+			    num = labs((long)get_cursor_rel_lnum(wp, lnum));
 
 			sprintf((char *)extra, "%*ld ",
 						number_width(wp), num);
@@ -6522,8 +6521,17 @@
 				stl, use_sandbox,
 				fillchar, maxwidth, hltab, tabtab);
     vim_free(stl);
-    len = (int)STRLEN(buf);
 
+    /* Make all characters printable. */
+    p = transstr(buf);
+    if (p != NULL)
+    {
+	vim_strncpy(buf, p, sizeof(buf) - 1);
+	vim_free(p);
+    }
+
+    /* fill up with "fillchar" */
+    len = (int)STRLEN(buf);
     while (width < maxwidth && len < (int)sizeof(buf) - 1)
     {
 #ifdef FEAT_MBYTE
diff -Naur vim73.orig/src/search.c vim73/src/search.c
--- vim73.orig/src/search.c	2010-07-14 10:49:41.000000000 -0400
+++ vim73/src/search.c	2011-01-08 20:59:41.002656834 -0500
@@ -5075,9 +5075,7 @@
 			if (win_split(0, 0) == FAIL)
 #endif
 			    break;
-#ifdef FEAT_SCROLLBIND
-			curwin->w_p_scb = FALSE;
-#endif
+			RESET_BINDING(curwin);
 		    }
 		    if (depth == -1)
 		    {
diff -Naur vim73.orig/src/spell.c vim73/src/spell.c
--- vim73.orig/src/spell.c	2010-08-01 09:43:01.000000000 -0400
+++ vim73/src/spell.c	2011-01-08 21:01:19.386656778 -0500
@@ -303,10 +303,6 @@
  *			    few bytes as possible, see offset2bytes())
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 #if defined(FEAT_SPELL) || defined(PROTO)
@@ -327,6 +323,16 @@
 typedef long idx_T;
 #endif
 
+#ifdef VMS
+# define SPL_FNAME_TMPL  "%s_%s.spl"
+# define SPL_FNAME_ADD   "_add."
+# define SPL_FNAME_ASCII "_ascii."
+#else
+# define SPL_FNAME_TMPL  "%s.%s.spl"
+# define SPL_FNAME_ADD   ".add."
+# define SPL_FNAME_ASCII ".ascii."
+#endif
+
 /* Flags used for a word.  Only the lowest byte can be used, the region byte
  * comes above it. */
 #define WF_REGION   0x01	/* region byte follows */
@@ -2471,14 +2477,24 @@
 	 * Find the first spell file for "lang" in 'runtimepath' and load it.
 	 */
 	vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,
-					"spell/%s.%s.spl", lang, spell_enc());
+#ifdef VMS
+					"spell/%s_%s.spl",
+#else
+					"spell/%s.%s.spl",
+#endif
+							   lang, spell_enc());
 	r = do_in_runtimepath(fname_enc, FALSE, spell_load_cb, &sl);
 
 	if (r == FAIL && *sl.sl_lang != NUL)
 	{
 	    /* Try loading the ASCII version. */
 	    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,
-						  "spell/%s.ascii.spl", lang);
+#ifdef VMS
+						  "spell/%s_ascii.spl",
+#else
+						  "spell/%s.ascii.spl",
+#endif
+									lang);
 	    r = do_in_runtimepath(fname_enc, FALSE, spell_load_cb, &sl);
 
 #ifdef FEAT_AUTOCMD
@@ -2496,7 +2512,12 @@
 
     if (r == FAIL)
     {
-	smsg((char_u *)_("Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""),
+	smsg((char_u *)
+#ifdef VMS
+	_("Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""),
+#else
+	_("Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""),
+#endif
 						     lang, spell_enc(), lang);
     }
     else if (sl.sl_slang != NULL)
@@ -2530,7 +2551,7 @@
 int_wordlist_spl(fname)
     char_u	    *fname;
 {
-    vim_snprintf((char *)fname, MAXPATHL, "%s.%s.spl",
+    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,
 						  int_wordlist, spell_enc());
 }
 
@@ -2785,8 +2806,8 @@
 	if (lp->sl_fname == NULL)
 	    goto endFAIL;
 
-	/* Check for .add.spl. */
-	lp->sl_add = strstr((char *)gettail(fname), ".add.") != NULL;
+	/* Check for .add.spl (_add.spl for VMS). */
+	lp->sl_add = strstr((char *)gettail(fname), SPL_FNAME_ADD) != NULL;
     }
     else
 	lp = old_lp;
@@ -4679,7 +4700,7 @@
     buf_T	*buf;
     char_u	fname[MAXPATHL];
 
-    /* Go through all buffers and handle 'spelllang'. */ //<VN>
+    /* Go through all buffers and handle 'spelllang'. <VN> */
     for (buf = firstbuf; buf != NULL; buf = buf->b_next)
 	ga_clear(&buf->b_s.b_langp);
 
@@ -4951,7 +4972,7 @@
     char_u	*si_info;	/* info text chars or NULL  */
     int		si_region_count; /* number of regions supported (1 when there
 				    are no regions) */
-    char_u	si_region_name[16]; /* region names; used only if
+    char_u	si_region_name[17]; /* region names; used only if
 				     * si_region_count > 1) */
 
     garray_T	si_rep;		/* list of fromto_T entries from REP lines */
@@ -9109,8 +9130,8 @@
 	    /* For ":mkspell path/vim" output file is "path/vim.latin1.spl". */
 	    innames = &fnames[0];
 	    incount = 1;
-	    vim_snprintf((char *)wfname, sizeof(wfname), "%s.%s.spl", fnames[0],
-			     spin.si_ascii ? (char_u *)"ascii" : spell_enc());
+	    vim_snprintf((char *)wfname, sizeof(wfname), SPL_FNAME_TMPL,
+		  fnames[0], spin.si_ascii ? (char_u *)"ascii" : spell_enc());
 	}
 	else if (len > 4 && STRCMP(fnames[0] + len - 4, ".spl") == 0)
 	{
@@ -9119,15 +9140,15 @@
 	}
 	else
 	    /* Name should be language, make the file name from it. */
-	    vim_snprintf((char *)wfname, sizeof(wfname), "%s.%s.spl", fnames[0],
-			     spin.si_ascii ? (char_u *)"ascii" : spell_enc());
+	    vim_snprintf((char *)wfname, sizeof(wfname), SPL_FNAME_TMPL,
+		  fnames[0], spin.si_ascii ? (char_u *)"ascii" : spell_enc());
 
 	/* Check for .ascii.spl. */
-	if (strstr((char *)gettail(wfname), ".ascii.") != NULL)
+	if (strstr((char *)gettail(wfname), SPL_FNAME_ASCII) != NULL)
 	    spin.si_ascii = TRUE;
 
 	/* Check for .add.spl. */
-	if (strstr((char *)gettail(wfname), ".add.") != NULL)
+	if (strstr((char *)gettail(wfname), SPL_FNAME_ADD) != NULL)
 	    spin.si_add = TRUE;
     }
 
@@ -9530,7 +9551,8 @@
 	    if (aspath)
 		/* Use directory of an entry with path, e.g., for
 		 * "/dir/lg.utf-8.spl" use "/dir". */
-		vim_strncpy(buf, curbuf->b_s.b_p_spl, lstart - curbuf->b_s.b_p_spl - 1);
+		vim_strncpy(buf, curbuf->b_s.b_p_spl,
+					    lstart - curbuf->b_s.b_p_spl - 1);
 	    else
 		/* Copy the path from 'runtimepath' to buf[]. */
 		copy_option_part(&rtp, buf, MAXPATHL, ",");
@@ -9539,13 +9561,14 @@
 		/* Use the first language name from 'spelllang' and the
 		 * encoding used in the first loaded .spl file. */
 		if (aspath)
-		    vim_strncpy(buf, curbuf->b_s.b_p_spl, lend - curbuf->b_s.b_p_spl);
+		    vim_strncpy(buf, curbuf->b_s.b_p_spl,
+						  lend - curbuf->b_s.b_p_spl);
 		else
 		{
 		    /* Create the "spell" directory if it doesn't exist yet. */
 		    l = (int)STRLEN(buf);
 		    vim_snprintf((char *)buf + l, MAXPATHL - l, "/spell");
-		    if (!filewritable(buf) != 2)
+		    if (filewritable(buf) != 2)
 			vim_mkdir(buf, 0755);
 
 		    l = (int)STRLEN(buf);
@@ -9837,10 +9860,7 @@
 	{
 	    /* be quick for ASCII */
 	    if (wp->w_s->b_spell_ismw[*p])
-	    {
 		s = p + 1;		/* skip a mid-word character */
-		l = MB_BYTE2LEN(*s);
-	    }
 	}
 	else
 	{
@@ -9848,10 +9868,7 @@
 	    if (c < 256 ? wp->w_s->b_spell_ismw[c]
 		    : (wp->w_s->b_spell_ismw_mb != NULL
 			   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))
-	    {
 		s = p + l;
-		l = MB_BYTE2LEN(*s);
-	    }
 	}
 
 	c = mb_ptr2char(s);
@@ -13811,11 +13828,8 @@
 		    su->su_sfmaxscore = cleanup_suggestions(gap,
 				      su->su_sfmaxscore, SUG_CLEAN_COUNT(su));
 		else
-		{
-		    i = su->su_maxscore;
 		    su->su_maxscore = cleanup_suggestions(gap,
 					su->su_maxscore, SUG_CLEAN_COUNT(su));
-		}
 	    }
 	}
     }
diff -Naur vim73.orig/src/structs.h vim73/src/structs.h
--- vim73.orig/src/structs.h	2010-08-07 10:59:27.000000000 -0400
+++ vim73/src/structs.h	2011-01-08 21:01:18.918658776 -0500
@@ -979,9 +979,10 @@
 struct mapblock
 {
     mapblock_T	*m_next;	/* next mapblock in list */
-    char_u	*m_keys;	/* mapped from */
+    char_u	*m_keys;	/* mapped from, lhs */
     int		m_keylen;	/* strlen(m_keys) */
-    char_u	*m_str;		/* mapped to */
+    char_u	*m_str;		/* mapped to, rhs */
+    char_u	*m_orig_str;	/* rhs as entered by the user */
     int		m_mode;		/* valid mode */
     int		m_noremap;	/* if non-zero no re-mapping for m_str */
     char	m_silent;	/* <silent> used, don't echo commands */
diff -Naur vim73.orig/src/syntax.c vim73/src/syntax.c
--- vim73.orig/src/syntax.c	2010-08-08 09:17:03.000000000 -0400
+++ vim73/src/syntax.c	2011-01-08 21:01:18.790655926 -0500
@@ -7600,10 +7600,10 @@
 		/*
 		 * Copy characters from arg[] to buf[], translating <> codes.
 		 */
-		for (p = arg, off = 0; off < 100 && *p; )
+		for (p = arg, off = 0; off < 100 - 6 && *p; )
 		{
 		    len = trans_special(&p, buf + off, FALSE);
-		    if (len)		    /* recognized special char */
+		    if (len > 0)	    /* recognized special char */
 			off += len;
 		    else		    /* copy as normal char */
 			buf[off++] = *p++;
diff -Naur vim73.orig/src/tag.c vim73/src/tag.c
--- vim73.orig/src/tag.c	2010-08-10 03:25:22.000000000 -0400
+++ vim73/src/tag.c	2011-01-08 21:01:19.386656778 -0500
@@ -11,10 +11,6 @@
  * Code to handle tags and the tag stack
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 /*
@@ -3143,9 +3139,7 @@
     {
 	win_split(postponed_split > 0 ? postponed_split : 0,
 						       postponed_split_flags);
-# ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-# endif
+	RESET_BINDING(curwin);
     }
 #endif
 
diff -Naur vim73.orig/src/term.c vim73/src/term.c
--- vim73.orig/src/term.c	2010-07-25 09:30:31.000000000 -0400
+++ vim73/src/term.c	2011-01-08 21:01:19.486656758 -0500
@@ -3053,10 +3053,13 @@
     int		old_Rows = Rows;
     int		old_Columns = Columns;
 
-    (void)ui_get_shellsize();
-    check_shellsize();
-    if (old_Rows != Rows || old_Columns != Columns)
-	shell_resized();
+    if (!exiting)
+    {
+	(void)ui_get_shellsize();
+	check_shellsize();
+	if (old_Rows != Rows || old_Columns != Columns)
+	    shell_resized();
+    }
 }
 
 /*
@@ -3828,6 +3831,7 @@
  * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off
  * + max_offset].
  * Return 0 for no match, -1 for partial match, > 0 for full match.
+ * Return KEYLEN_REMOVED when a key code was deleted.
  * With a match, the match is removed, the replacement code is inserted in
  * typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is
  * returned.
@@ -3845,6 +3849,7 @@
     int		slen = 0;	/* init for GCC */
     int		modslen;
     int		len;
+    int		retval = 0;
     int		offset;
     char_u	key_name[2];
     int		modifiers;
@@ -4940,6 +4945,13 @@
 #endif
 		string[new_slen++] = key_name[1];
 	}
+	else if (new_slen == 0 && key_name[0] == KS_EXTRA
+						  && key_name[1] == KE_IGNORE)
+	{
+	    /* Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED
+	     * to indicate what happened. */
+	    retval = KEYLEN_REMOVED;
+	}
 	else
 	{
 	    string[new_slen++] = K_SPECIAL;
@@ -4976,7 +4988,7 @@
 						   (size_t)(buflen - offset));
 	    mch_memmove(buf + offset, string, (size_t)new_slen);
 	}
-	return (len + extra + offset);
+	return retval == 0 ? (len + extra + offset) : retval;
     }
 
     return 0;			    /* no match found */
diff -Naur vim73.orig/src/testdir/Make_amiga.mak vim73/src/testdir/Make_amiga.mak
--- vim73.orig/src/testdir/Make_amiga.mak	2010-08-04 10:34:34.000000000 -0400
+++ vim73/src/testdir/Make_amiga.mak	2011-01-08 21:01:19.138657005 -0500
@@ -27,7 +27,8 @@
 		test56.out test57.out test58.out test59.out test60.out \
 		test61.out test62.out test63.out test64.out test65.out \
 		test66.out test67.out test68.out test69.out test70.out \
-		test71.out test72.out test73.out
+		test71.out test72.out test73.out test74.out test75.out \
+		test76.out
 
 .SUFFIXES: .in .out
 
@@ -120,3 +121,6 @@
 test71.out: test71.in
 test72.out: test72.in
 test73.out: test73.in
+test74.out: test74.in
+test75.out: test75.in
+test76.out: test76.in
diff -Naur vim73.orig/src/testdir/Make_dos.mak vim73/src/testdir/Make_dos.mak
--- vim73.orig/src/testdir/Make_dos.mak	2010-08-13 12:27:19.000000000 -0400
+++ vim73/src/testdir/Make_dos.mak	2011-01-08 21:01:19.138657005 -0500
@@ -27,7 +27,8 @@
 		test30.out test31.out test32.out test33.out test34.out \
 		test37.out test38.out test39.out test40.out test41.out \
 		test42.out test52.out test65.out test66.out test67.out \
-		test68.out test69.out test71.out test72.out test73.out
+		test68.out test69.out test71.out test72.out test73.out \
+		test74.out test75.out test76.out
 
 SCRIPTS32 =	test50.out test70.out
 
diff -Naur vim73.orig/src/testdir/Make_ming.mak vim73/src/testdir/Make_ming.mak
--- vim73.orig/src/testdir/Make_ming.mak	2010-08-04 10:34:47.000000000 -0400
+++ vim73/src/testdir/Make_ming.mak	2011-01-08 21:01:19.138657005 -0500
@@ -47,7 +47,8 @@
 		test30.out test31.out test32.out test33.out test34.out \
 		test37.out test38.out test39.out test40.out test41.out \
 		test42.out test52.out test65.out test66.out test67.out \
-		test68.out test69.out test71.out test72.out test72.out
+		test68.out test69.out test71.out test72.out test73.out \
+		test74.out test75.out test76.out
 
 SCRIPTS32 =	test50.out test70.out
 
diff -Naur vim73.orig/src/testdir/Make_os2.mak vim73/src/testdir/Make_os2.mak
--- vim73.orig/src/testdir/Make_os2.mak	2010-08-04 10:34:55.000000000 -0400
+++ vim73/src/testdir/Make_os2.mak	2011-01-08 21:01:19.138657005 -0500
@@ -27,7 +27,8 @@
 		test56.out test57.out test58.out test59.out test60.out \
 		test61.out test62.out test63.out test64.out test65.out \
 		test66.out test67.out test68.out test69.out test70.out \
-		test71.out test72.out test73.out
+		test71.out test72.out test73.out test74.out test75.out \
+		test76.out
 
 .SUFFIXES: .in .out
 
diff -Naur vim73.orig/src/testdir/Make_vms.mms vim73/src/testdir/Make_vms.mms
--- vim73.orig/src/testdir/Make_vms.mms	2010-08-04 10:35:46.000000000 -0400
+++ vim73/src/testdir/Make_vms.mms	2011-01-08 21:01:19.138657005 -0500
@@ -4,7 +4,7 @@
 # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
 #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
 #
-# Last change:  2010 Aug 04
+# Last change:  2010 Nov 10
 #
 # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
 # Edit the lines in the Configuration section below to select.
@@ -74,7 +74,7 @@
 	 test56.out test57.out test60.out \
 	 test61.out test62.out test63.out test64.out test65.out \
 	 test66.out test67.out test68.out test69.out \
-	 test71.out test72.out
+	 test71.out test72.out test74.out test75.out test76.out
 
 # Known problems:
 # Test 30: a problem around mac format - unknown reason
diff -Naur vim73.orig/src/testdir/Makefile vim73/src/testdir/Makefile
--- vim73.orig/src/testdir/Makefile	2010-08-15 08:56:30.000000000 -0400
+++ vim73/src/testdir/Makefile	2011-01-08 21:01:19.138657005 -0500
@@ -10,6 +10,7 @@
 #   This will make testing about 10 times as slow.
 # VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --log-file=valgrind.$*
 
+
 SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
 		test7.out test8.out test9.out test10.out test11.out \
 		test12.out  test13.out test14.out test15.out test17.out \
@@ -23,7 +24,8 @@
 		test54.out test55.out test56.out test57.out test58.out \
 		test59.out test60.out test61.out test62.out test63.out \
 		test64.out test65.out test66.out test67.out test68.out \
-		test69.out test70.out test71.out test72.out test73.out
+		test69.out test70.out test71.out test72.out test73.out \
+		test74.out test75.out test76.out
 
 SCRIPTS_GUI = test16.out
 
@@ -44,7 +46,7 @@
 $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
 
 clean:
-	-rm -rf *.out *.failed *.rej *.orig test.log tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* valgrind.pid* viminfo
+	-rm -rf *.out *.failed *.rej *.orig test.log tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* valgrind.* viminfo
 
 test1.out: test1.in
 	-rm -f $*.failed tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* viminfo
diff -Naur vim73.orig/src/testdir/main.aap vim73/src/testdir/main.aap
--- vim73.orig/src/testdir/main.aap	2010-07-30 16:03:23.000000000 -0400
+++ vim73/src/testdir/main.aap	2011-01-08 21:01:18.878656504 -0500
@@ -13,7 +13,7 @@
 		test33.out test34.out test35.out test36.out test37.out
 		test38.out test39.out test40.out test41.out test42.out
 		test43.out test44.out test45.out test46.out test47.out
-		test48.out test49.out
+		test48.out test49.out test74.out
 
 ScriptsGUI = test16.out
 
diff -Naur vim73.orig/src/testdir/test49.vim vim73/src/testdir/test49.vim
--- vim73.orig/src/testdir/test49.vim	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test49.vim	2011-01-08 21:01:18.782656702 -0500
@@ -1,6 +1,6 @@
 " Vim script language tests
 " Author:	Servatius Brandt <Servatius.Brandt@fujitsu-siemens.com>
-" Last Change:	2006 Apr 28
+" Last Change:	2010 Sep 29
 
 "-------------------------------------------------------------------------------
 " Test environment							    {{{1
@@ -8711,7 +8711,7 @@
 		endif
 	    else
 		if cmd == "let"
-		    let match = MATCH(0, thrmsg, 'E106', "Unknown variable")
+		    let match = MATCH(0, thrmsg, 'E121', "Undefined variable")
 		elseif cmd == "unlet"
 		    let match = MATCH(0, thrmsg, 'E108', "No such variable")
 		endif
diff -Naur vim73.orig/src/testdir/test55.in vim73/src/testdir/test55.in
--- vim73.orig/src/testdir/test55.in	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test55.in	2011-01-08 21:01:19.158657647 -0500
@@ -342,7 +342,18 @@
 :$put =(d == d)
 :$put =(l != deepcopy(l))
 :$put =(d != deepcopy(d))
+:"
+:" compare complex recursively linked list and dict
+:let l = []
+:call add(l, l)
+:let dict4 = {"l": l}
+:call add(dict4.l, dict4)
+:let lcopy = deepcopy(l)
+:let dict4copy = deepcopy(dict4)
+:$put =(l == lcopy)
+:$put =(dict4 == dict4copy)
 :endfun
+:"
 :call Test(1, 2, [3, 4], {5: 6})  " This may take a while
 :"
 :delfunc Test
diff -Naur vim73.orig/src/testdir/test55.ok vim73/src/testdir/test55.ok
--- vim73.orig/src/testdir/test55.ok	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test55.ok	2011-01-08 21:01:19.158657647 -0500
@@ -109,3 +109,5 @@
 1
 0
 0
+1
+1
diff -Naur vim73.orig/src/testdir/test57.in vim73/src/testdir/test57.in
--- vim73.orig/src/testdir/test57.in	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test57.in	2011-01-08 21:01:18.866656341 -0500
@@ -53,15 +53,19 @@
 t02: numeric
 abc
 ab
-a
 a321
 a123
 a122
+a
+x-22
 b321
 b123
+
 c123d
+-24
  123b
 c321d
+0
 b322b
 b321
 b321b
diff -Naur vim73.orig/src/testdir/test57.ok vim73/src/testdir/test57.ok
--- vim73.orig/src/testdir/test57.ok	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test57.ok	2011-01-08 21:01:18.866656341 -0500
@@ -21,6 +21,10 @@
 a
 
 
+
+-24
+x-22
+0
 a122
 a123
 b123
diff -Naur vim73.orig/src/testdir/test61.in vim73/src/testdir/test61.in
--- vim73.orig/src/testdir/test61.in	2010-06-26 23:07:58.000000000 -0400
+++ vim73/src/testdir/test61.in	2011-01-08 20:59:38.610657137 -0500
@@ -4,6 +4,10 @@
 Also tests :earlier and :later.
 
 STARTTEST
+:echo undotree().entries
+ENDTEST
+
+STARTTEST
 :" Delete three characters and undo
 Gx:set ul=100
 x:set ul=100
diff -Naur vim73.orig/src/testdir/test68.in vim73/src/testdir/test68.in
--- vim73.orig/src/testdir/test68.in	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test68.in	2011-01-08 21:01:18.806655841 -0500
@@ -51,6 +51,17 @@
 }
 
 STARTTEST
+/^{/+2
+:set tw& fo=a
+I^^
+ENDTEST
+
+{
+   1aa
+   2bb
+}
+
+STARTTEST
 :g/^STARTTEST/.,/^ENDTEST/d
 :1;/^Results/,$wq! test.out
 ENDTEST
diff -Naur vim73.orig/src/testdir/test68.ok vim73/src/testdir/test68.ok
--- vim73.orig/src/testdir/test68.ok	2010-05-15 07:04:10.000000000 -0400
+++ vim73/src/testdir/test68.ok	2011-01-08 21:01:18.806655841 -0500
@@ -33,3 +33,6 @@
 #a b
 }
 
+
+{ 1aa ^^2bb }
+
diff -Naur vim73.orig/src/testdir/test74.in vim73/src/testdir/test74.in
--- vim73.orig/src/testdir/test74.in	1969-12-31 19:00:00.000000000 -0500
+++ vim73/src/testdir/test74.in	2011-01-08 21:01:18.878656504 -0500
@@ -0,0 +1,36 @@
+" Tests for storing global variables in the .viminfo file vim: set ft=vim:
+
+STARTTEST
+:so small.vim
+:" Do all test in a separate window to avoid E211 when we recursively
+:" delete the Xfind directory during cleanup
+:"
+:" This will cause a few errors, do it silently.
+:set visualbell
+:set nocp viminfo+=!,nviminfo
+:let MY_GLOBAL_DICT={'foo': 1, 'bar': 0, 'longvarible': 1000}
+:" store a really long list, so line wrapping will occur in viminfo file
+:let MY_GLOBAL_LIST=range(1,100)
+:wv! Xviminfo
+:unlet MY_GLOBAL_DICT
+:unlet MY_GLOBAL_LIST
+:rv! Xviminfo
+:call delete('Xviminfo')
+:if exists("MY_GLOBAL_DICT")
+:redir >> test.out
+:echo MY_GLOBAL_DICT
+:redir end
+:endif
+:if exists("MY_GLOBAL_LIST")
+:redir >> test.out
+:echo MY_GLOBAL_LIST
+:redir end
+:endif
+:redir >> test.out
+:echo "foobar"
+:redir end
+:endif
+:qa!
+ENDTEST
+
+eof
diff -Naur vim73.orig/src/testdir/test74.ok vim73/src/testdir/test74.ok
--- vim73.orig/src/testdir/test74.ok	1969-12-31 19:00:00.000000000 -0500
+++ vim73/src/testdir/test74.ok	2011-01-08 21:01:18.878656504 -0500
@@ -0,0 +1,5 @@
+
+{'foo': 1, 'longvarible': 1000, 'bar': 0}
+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
+
+foobar
diff -Naur vim73.orig/src/testdir/test75.in vim73/src/testdir/test75.in
--- vim73.orig/src/testdir/test75.in	1969-12-31 19:00:00.000000000 -0500
+++ vim73/src/testdir/test75.in	2011-01-08 21:01:18.918658776 -0500
@@ -0,0 +1,16 @@
+" Tests for functions.
+
+STARTTEST
+:so small.vim
+:" Test maparg() with a string result
+:map foo<C-V> is<F4>foo
+:vnoremap <script> <buffer> <expr> <silent> bar isbar
+:call append('$', maparg('foo<C-V>'))
+:call append('$', string(maparg('foo<C-V>', '', 0, 1)))
+:call append('$', string(maparg('bar', '', 0, 1)))
+:"
+:/^eof/+1,$w! test.out
+:qa!
+ENDTEST
+
+eof
diff -Naur vim73.orig/src/testdir/test75.ok vim73/src/testdir/test75.ok
--- vim73.orig/src/testdir/test75.ok	1969-12-31 19:00:00.000000000 -0500
+++ vim73/src/testdir/test75.ok	2011-01-08 21:01:18.918658776 -0500
@@ -0,0 +1,3 @@
+is<F4>foo
+{'silent': 0, 'noremap': 0, 'lhs': 'foo<C-V>', 'mode': ' ', 'expr': 0, 'sid': 0, 'rhs': 'is<F4>foo', 'buffer': 0}
+{'silent': 1, 'noremap': 1, 'lhs': 'bar', 'mode': 'v', 'expr': 1, 'sid': 0, 'rhs': 'isbar', 'buffer': 1}
diff -Naur vim73.orig/src/testdir/test76.in vim73/src/testdir/test76.in
--- vim73.orig/src/testdir/test76.in	1969-12-31 19:00:00.000000000 -0500
+++ vim73/src/testdir/test76.in	2011-01-08 21:01:19.138657005 -0500
@@ -0,0 +1,46 @@
+Tests for completefunc/omnifunc. vim: set ft=vim :
+
+STARTTEST
+:"Test that nothing happens if the 'completefunc' opens
+:"a new window (no completion, no crash)
+:so small.vim
+:function! DummyCompleteOne(findstart, base)
+:  if a:findstart
+:    return 0
+:  else
+:    wincmd n
+:    return ['onedef', 'oneDEF']
+:  endif
+:endfunction
+:setlocal completefunc=DummyCompleteOne
+/^one
+A:q!
+:function! DummyCompleteTwo(findstart, base)
+:  if a:findstart
+:    wincmd n
+:    return 0
+:  else
+:    return ['twodef', 'twoDEF']
+:  endif
+:endfunction
+:setlocal completefunc=DummyCompleteTwo
+/^two
+A:q!
+:"Test that 'completefunc' works when it's OK.
+:function! DummyCompleteThree(findstart, base)
+:  if a:findstart
+:    return 0
+:  else
+:    return ['threedef', 'threeDEF']
+:  endif
+:endfunction
+:setlocal completefunc=DummyCompleteThree
+/^three
+A:/^+++/,/^three/w! test.out
+:qa!
+ENDTEST
+
++++
+one
+two
+three
diff -Naur vim73.orig/src/testdir/test76.ok vim73/src/testdir/test76.ok
--- vim73.orig/src/testdir/test76.ok	1969-12-31 19:00:00.000000000 -0500
+++ vim73/src/testdir/test76.ok	2011-01-08 21:01:19.142655736 -0500
@@ -0,0 +1,4 @@
++++
+
+two
+threeDEF
diff -Naur vim73.orig/src/ui.c vim73/src/ui.c
--- vim73.orig/src/ui.c	2010-08-08 09:17:30.000000000 -0400
+++ vim73/src/ui.c	2011-01-08 21:01:18.766656221 -0500
@@ -469,7 +469,7 @@
      */
 #ifdef FEAT_X11
     /* Always own the selection, we might have lost it without being
-     * notified. */
+     * notified, e.g. during a ":sh" command. */
     if (cbd->available)
     {
 	int was_owned = cbd->owned;
@@ -1944,10 +1944,9 @@
  */
 
 static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
-
 static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
-
 static void clip_x11_timestamp_cb __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
+static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
 
 /*
  * Property callback to get a timestamp for XtOwnSelection.
@@ -1985,8 +1984,17 @@
 	return;
 
     /* Get the selection, using the event timestamp. */
-    XtOwnSelection(w, xproperty->atom, xproperty->time,
-	    clip_x11_convert_selection_cb, clip_x11_lose_ownership_cb, NULL);
+    if (XtOwnSelection(w, xproperty->atom, xproperty->time,
+	    clip_x11_convert_selection_cb, clip_x11_lose_ownership_cb,
+	    NULL) == OK)
+    {
+	/* Set the "owned" flag now, there may have been a call to
+	 * lose_ownership_cb in between. */
+	if (xproperty->atom == clip_plus.sel_atom)
+	    clip_plus.owned = TRUE;
+	else
+	    clip_star.owned = TRUE;
+    }
 }
 
     void
@@ -1997,8 +2005,6 @@
 	    /*(XtEventHandler)*/clip_x11_timestamp_cb, (XtPointer)NULL);
 }
 
-static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
-
     static void
 clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
 			      format)
@@ -2336,7 +2342,7 @@
 
     void
 clip_x11_lose_selection(myShell, cbd)
-    Widget	myShell;
+    Widget		myShell;
     VimClipboard	*cbd;
 {
     XtDisownSelection(myShell, cbd->sel_atom, CurrentTime);
@@ -2344,14 +2350,29 @@
 
     int
 clip_x11_own_selection(myShell, cbd)
-    Widget	myShell;
+    Widget		myShell;
     VimClipboard	*cbd;
 {
-    /* Get the time by a zero-length append, clip_x11_timestamp_cb will be
-     * called with the current timestamp.  */
-    if (!XChangeProperty(XtDisplay(myShell), XtWindow(myShell), cbd->sel_atom,
-	    timestamp_atom, 32, PropModeAppend, NULL, 0))
+    /* When using the GUI we have proper timestamps, use the one of the last
+     * event.  When in the console we don't get events (the terminal gets
+     * them), Get the time by a zero-length append, clip_x11_timestamp_cb will
+     * be called with the current timestamp.  */
+#ifdef FEAT_GUI
+    if (gui.in_use)
+    {
+	if (XtOwnSelection(myShell, cbd->sel_atom,
+	       XtLastTimestampProcessed(XtDisplay(myShell)),
+	       clip_x11_convert_selection_cb, clip_x11_lose_ownership_cb,
+	       NULL) == False)
 	return FAIL;
+    }
+    else
+#endif
+    {
+	if (!XChangeProperty(XtDisplay(myShell), XtWindow(myShell),
+		  cbd->sel_atom, timestamp_atom, 32, PropModeAppend, NULL, 0))
+	return FAIL;
+    }
     /* Flush is required in a terminal as nothing else is doing it. */
     XFlush(XtDisplay(myShell));
     return OK;
diff -Naur vim73.orig/src/undo.c vim73/src/undo.c
--- vim73.orig/src/undo.c	2010-08-07 06:48:15.000000000 -0400
+++ vim73/src/undo.c	2011-01-08 21:01:19.386656778 -0500
@@ -81,10 +81,6 @@
 #define UH_MAGIC 0x18dade	/* value for uh_magic when in use */
 #define UE_MAGIC 0xabc123	/* value for ue_magic when in use */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for vim_read(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 static void u_unch_branch __ARGS((u_header_T *uhp));
@@ -1386,7 +1382,7 @@
 		char_u	mbuf[UF_START_MAGIC_LEN];
 		int	len;
 
-		len = vim_read(fd, mbuf, UF_START_MAGIC_LEN);
+		len = read_eintr(fd, mbuf, UF_START_MAGIC_LEN);
 		close(fd);
 		if (len < UF_START_MAGIC_LEN
 		      || memcmp(mbuf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)
@@ -1861,6 +1857,7 @@
     curbuf->b_u_seq_cur = seq_cur;
     curbuf->b_u_time_cur = seq_time;
     curbuf->b_u_save_nr_last = last_save_nr;
+    curbuf->b_u_save_nr_cur = last_save_nr;
 
     curbuf->b_u_synced = TRUE;
     vim_free(uhp_table);
@@ -2794,7 +2791,7 @@
 								uhp->uh_time);
 	    if (uhp->uh_save_nr > 0)
 	    {
-		while (STRLEN(IObuff) < 32)
+		while (STRLEN(IObuff) < 33)
 		    STRCAT(IObuff, " ");
 		vim_snprintf_add((char *)IObuff, IOSIZE,
 						   "  %3ld", uhp->uh_save_nr);
@@ -2849,7 +2846,7 @@
 	sort_strings((char_u **)ga.ga_data, ga.ga_len);
 
 	msg_start();
-	msg_puts_attr((char_u *)_("number changes  time            saved"),
+	msg_puts_attr((char_u *)_("number changes  when               saved"),
 							      hl_attr(HLF_T));
 	for (i = 0; i < ga.ga_len && !got_int; ++i)
 	{
@@ -2879,7 +2876,15 @@
     if (time(NULL) - tt >= 100)
     {
 	curtime = localtime(&tt);
-	(void)strftime((char *)buf, buflen, "%H:%M:%S", curtime);
+	if (time(NULL) - tt < (60L * 60L * 12L))
+	    /* within 12 hours */
+	    (void)strftime((char *)buf, buflen, "%H:%M:%S", curtime);
+	else if (time(NULL) - tt < (60L * 60L * 24L * 180L))
+	    /* within 6 months */
+	    (void)strftime((char *)buf, buflen, "%m/%d %H:%M:%S", curtime);
+	else
+	    /* long ago */
+	    (void)strftime((char *)buf, buflen, "%y/%m/%d %H:%M:%S", curtime);
     }
     else
 #endif
diff -Naur vim73.orig/src/version.c vim73/src/version.c
--- vim73.orig/src/version.c	2010-08-01 09:45:48.000000000 -0400
+++ vim73/src/version.c	2011-01-08 21:01:19.514657428 -0500
@@ -715,6 +715,204 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    74,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
@@ -1262,9 +1460,9 @@
 	if (highest_patch())
 	{
 	    /* Check for 9.9x or 9.9xx, alpha/beta version */
-	    if (isalpha((int)mediumVersion[3]))
+	    if (isalpha((int)vers[3]))
 	    {
-		if (isalpha((int)mediumVersion[4]))
+		if (isalpha((int)vers[4]))
 		    sprintf((char *)vers + 5, ".%d%s", highest_patch(),
 							   mediumVersion + 5);
 		else
diff -Naur vim73.orig/src/vim.h vim73/src/vim.h
--- vim73.orig/src/vim.h	2010-07-29 14:46:39.000000000 -0400
+++ vim73/src/vim.h	2011-01-08 21:01:19.466658112 -0500
@@ -27,6 +27,11 @@
 # endif
 #endif
 
+#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64) \
+	|| defined(__EMX__)
+# include "vimio.h"
+#endif
+
 /* ============ the header file puzzle (ca. 50-100 pieces) ========= */
 
 #ifdef HAVE_CONFIG_H	/* GNU autoconf (or something else) was here */
@@ -192,8 +197,8 @@
 #endif
 
 #ifdef NO_X11_INCLUDES
-    /* In os_mac_conv.c NO_X11_INCLUDES is defined to avoid X11 headers.
-     * Disable all X11 related things to avoid conflicts. */
+    /* In os_mac_conv.c and os_macosx.m NO_X11_INCLUDES is defined to avoid
+     * X11 headers.  Disable all X11 related things to avoid conflicts. */
 # ifdef FEAT_X11
 #  undef FEAT_X11
 # endif
@@ -475,6 +480,11 @@
 # include <sys/stat.h>
 #endif
 
+#if defined(HAVE_ERRNO_H) || defined(DJGPP) || defined(WIN16) \
+	|| defined(WIN32) || defined(_WIN64) || defined(__EMX__)
+# include <errno.h>
+#endif
+
 /*
  * Allow other (non-unix) systems to configure themselves now
  * These are also in os_unix.h, because osdef.sh needs them there.
@@ -798,6 +808,7 @@
 #define WILD_KEEP_ALL		32
 #define WILD_SILENT		64
 #define WILD_ESCAPE		128
+#define WILD_ICASE		256
 
 /* Flags for expand_wildcards() */
 #define EW_DIR		0x01	/* include directory names */
@@ -808,6 +819,7 @@
 #define EW_SILENT	0x20	/* don't print "1 returned" from shell */
 #define EW_EXEC		0x40	/* executable files */
 #define EW_PATH		0x80	/* search in 'path' too */
+#define EW_ICASE	0x100	/* ignore case */
 /* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
  * is used when executing commands and EW_SILENT for interactive expanding. */
 
@@ -1640,6 +1652,11 @@
 # define USE_INPUT_BUF
 #endif
 
+#ifndef EINTR
+# define read_eintr(fd, buf, count) vim_read((fd), (buf), (count))
+# define write_eintr(fd, buf, count) vim_write((fd), (buf), (count))
+#endif
+
 #ifdef MSWIN
 /* On MS-Windows the third argument isn't size_t.  This matters for Win64,
  * where sizeof(size_t)==8, not 4 */
@@ -1842,7 +1859,8 @@
 #define VV_OP		52
 #define VV_SEARCHFORWARD 53
 #define VV_OLDFILES	54
-#define VV_LEN		55	/* number of v: vars */
+#define VV_WINDOWID	55
+#define VV_LEN		56	/* number of v: vars */
 
 #ifdef FEAT_CLIPBOARD
 
@@ -2193,4 +2211,8 @@
 #define MSCR_LEFT	-1
 #define MSCR_RIGHT	-2
 
+#define KEYLEN_PART_KEY -1	/* keylen value for incomplete key-code */
+#define KEYLEN_PART_MAP -2	/* keylen value for incomplete mapping */
+#define KEYLEN_REMOVED  9999	/* keylen value for removed sequence */
+
 #endif /* VIM__H */
diff -Naur vim73.orig/src/window.c vim73/src/window.c
--- vim73.orig/src/window.c	2010-07-20 16:23:49.000000000 -0400
+++ vim73/src/window.c	2011-01-08 21:01:19.514657428 -0500
@@ -70,7 +70,8 @@
 #endif /* FEAT_WINDOWS */
 
 static win_T *win_alloc __ARGS((win_T *after, int hidden));
-static void win_new_height __ARGS((win_T *, int));
+static void set_fraction __ARGS((win_T *wp));
+static void win_new_height __ARGS((win_T *wp, int height));
 
 #define URL_SLASH	1		/* path_is_url() has found "://" */
 #define URL_BACKSLASH	2		/* path_is_url() has found ":\\" */
@@ -525,9 +526,7 @@
 		    setpcmark();
 		    if (win_split(0, 0) == OK)
 		    {
-# ifdef FEAT_SCROLLBIND
-			curwin->w_p_scb = FALSE;
-# endif
+			RESET_BINDING(curwin);
 			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
 							   ECMD_HIDE, NULL);
 			if (nchar == 'F' && lnum >= 0)
@@ -985,10 +984,17 @@
     else
 	frame_append(curfrp, frp);
 
+    /* Set w_fraction now so that the cursor keeps the same relative
+     * vertical position. */
+    if (oldwin->w_height > 0)
+	set_fraction(oldwin);
+    wp->w_fraction = oldwin->w_fraction;
+
 #ifdef FEAT_VERTSPLIT
     if (flags & WSP_VERT)
     {
 	wp->w_p_scr = curwin->w_p_scr;
+
 	if (need_status)
 	{
 	    win_new_height(oldwin, oldwin->w_height - 1);
@@ -3277,9 +3283,7 @@
     if (aucmd_win != NULL)
     {
 	win_init_some(aucmd_win, curwin);
-# ifdef FEAT_SCROLLBIND
-	aucmd_win->w_p_scb = FALSE;
-# endif
+	RESET_BINDING(aucmd_win);
 	new_frame(aucmd_win);
     }
 }
@@ -3320,10 +3324,8 @@
 	/* First window in new tab page, initialize it from "oldwin". */
 	win_init(curwin, oldwin, 0);
 
-# ifdef FEAT_SCROLLBIND
-	/* We don't want scroll-binding in the first window. */
-	curwin->w_p_scb = FALSE;
-# endif
+	/* We don't want cursor- and scroll-binding in the first window. */
+	RESET_BINDING(curwin);
     }
 #endif
 
@@ -5459,6 +5461,19 @@
 
 #endif /* FEAT_WINDOWS */
 
+#define FRACTION_MULT	16384L
+
+/*
+ * Set wp->w_fraction for the current w_wrow and w_height.
+ */
+    static void
+set_fraction(wp)
+    win_T	*wp;
+{
+    wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
+				    + FRACTION_MULT / 2) / (long)wp->w_height;
+}
+
 /*
  * Set the height of a window.
  * This takes care of the things inside the window, not what happens to the
@@ -5471,7 +5486,6 @@
 {
     linenr_T	lnum;
     int		sline, line_size;
-#define FRACTION_MULT	16384L
 
     /* Don't want a negative height.  Happens when splitting a tiny window.
      * Will equalize heights soon to fix it. */
@@ -5481,8 +5495,7 @@
 	return;	    /* nothing to do */
 
     if (wp->w_wrow != wp->w_prev_fraction_row && wp->w_height > 0)
-	wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
-				    + FRACTION_MULT / 2) / (long)wp->w_height;
+	set_fraction(wp);
 
     wp->w_height = height;
     wp->w_skipcol = 0;
diff -Naur vim73.orig/src/workshop.c vim73/src/workshop.c
--- vim73.orig/src/workshop.c	2010-08-08 09:18:24.000000000 -0400
+++ vim73/src/workshop.c	2011-01-08 21:01:19.438656953 -0500
@@ -16,7 +16,6 @@
 #include <sys/types.h>
 #include <netdb.h>
 #include <netinet/in.h>
-#include <errno.h>
 #include <sys/socket.h>
 #ifdef HAVE_LIBGEN_H
 # include <libgen.h>
