Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 09-12-2009
Initial Package Version: 4.4.1
Origin: Upstream
Upstream Status: Applied
Description: This is a branch update for gcc-4.4.1, and should be
             rechecked periodically.

This patch was made from Revision # 151655.

diff -Naur gcc-4.4.1.orig/contrib/compare-debug gcc-4.4.1/contrib/compare-debug
--- gcc-4.4.1.orig/contrib/compare-debug	2007-11-25 22:40:31.000000000 -0800
+++ gcc-4.4.1/contrib/compare-debug	2009-08-18 12:46:20.000000000 -0700
@@ -2,7 +2,7 @@
 
 # Compare stripped copies of two given object files.
 
-# Copyright (C) 2007 Free Software Foundation
+# Copyright (C) 2007, 2008, 2009 Free Software Foundation
 # Originally by Alexandre Oliva <aoliva@redhat.com>
 
 # This file is part of GCC.
@@ -67,6 +67,74 @@
   status=0
 else
   status=1
+
+  # Assembler-generated CFI will add an .eh_frame section for -g not
+  # present in -g0.  Try to cope with it by checking that an .eh_frame
+  # section is present in either object file, and then stripping it
+  # off before re-comparing.
+
+  cmd=
+  cmp1=
+  cmp2=
+
+  for t in objdump readelf eu-readelf; do
+    if ($t --help) 2>&1 | grep -e '--\[*section-\]*headers' > /dev/null; then
+      cmd=$t
+
+      $cmd --section-headers "$1.$suf1" | grep '\.eh_frame' > /dev/null
+      cmp1=$?
+
+      $cmd --section-headers "$2.$suf2" | grep '\.eh_frame' > /dev/null
+      cmp2=$?
+
+      break
+    fi
+  done
+
+  # If we found .eh_frame in one but not the other, or if we could not
+  # find a command to tell, try to strip off the .eh_frame section
+  # from both.
+  if test "x$cmp1" != "x$cmp2" || test "x$cmd" = "x"; then
+    suf3=$suf1.
+    while test -f "$1.$suf3"; do
+      suf3=$suf3.
+    done
+
+    suf4=$suf2.
+    while test -f "$2.$suf4"; do
+      suf4=$suf4.
+    done
+
+    trap 'rm -f "$1.$suf1" "$2.$suf2" "$1.$suf3" "$2.$suf4"' 0 1 2 15
+
+    echo stripping off .eh_frame, then retrying >&2
+
+    if (objcopy -v) 2>&1 | grep -e "--remove-section" > /dev/null; then
+      objcopy --remove-section .eh_frame --remove-section .rel.eh_frame --remove-section .rela.eh_frame "$1.$suf1" "$1.$suf3"
+      mv "$1.$suf3" "$1.$suf1"
+
+      objcopy --remove-section .eh_frame --remove-section .rel.eh_frame --remove-section .rela.eh_frame "$2.$suf2" "$2.$suf4"
+      mv "$2.$suf4" "$2.$suf2"
+    elif (strip --help) 2>&1 | grep -e --remove-section > /dev/null; then
+      cp "$1.$suf1" "$1.$suf3"
+      strip --remove-section .eh_frame --remove-section .rel.eh_frame --remove-section .rela.eh_frame "$1.$suf3"
+      mv "$1.$suf3" "$1.$suf1"
+
+      cp "$2.$suf2" "$2.$suf4"
+      strip --remove-section .eh_frame --remove-section .rel.eh_frame --remove-section .rela.eh_frame "$2.$suf4"
+      mv "$2.$suf4" "$2.$suf2"
+    else
+      echo failed to strip off .eh_frame >&2
+    fi
+
+    trap 'rm -f "$1.$suf1" "$2.$suf2"' 0 1 2 15
+
+    if cmp "$1.$suf1" "$2.$suf2"; then
+      status=0
+    else
+      status=1
+    fi
+  fi
 fi
 
 $rm "$1.$suf1" "$2.$suf2"
diff -Naur gcc-4.4.1.orig/gcc/alias.c gcc-4.4.1/gcc/alias.c
--- gcc-4.4.1.orig/gcc/alias.c	2009-04-27 04:55:13.000000000 -0700
+++ gcc-4.4.1/gcc/alias.c	2009-08-12 23:28:28.000000000 -0700
@@ -1932,6 +1932,9 @@
 {
   const_tree fieldx, fieldy, typex, typey, orig_y;
 
+  if (!flag_strict_aliasing)
+    return false;
+
   do
     {
       /* The comparison has to be done at a common type, since we don't
diff -Naur gcc-4.4.1.orig/gcc/builtins.c gcc-4.4.1/gcc/builtins.c
--- gcc-4.4.1.orig/gcc/builtins.c	2009-05-29 08:47:31.000000000 -0700
+++ gcc-4.4.1/gcc/builtins.c	2009-08-24 02:52:03.000000000 -0700
@@ -8634,15 +8634,18 @@
 	    }
 	}
 
-      /* Optimize pow(pow(x,y),z) = pow(x,y*z).  */
+      /* Optimize pow(pow(x,y),z) = pow(x,y*z) iff x is nonnegative.  */
       if (fcode == BUILT_IN_POW
 	  || fcode == BUILT_IN_POWF
 	  || fcode == BUILT_IN_POWL)
 	{
 	  tree arg00 = CALL_EXPR_ARG (arg0, 0);
-	  tree arg01 = CALL_EXPR_ARG (arg0, 1);
-	  tree narg1 = fold_build2 (MULT_EXPR, type, arg01, arg1);
-	  return build_call_expr (fndecl, 2, arg00, narg1);
+	  if (tree_expr_nonnegative_p (arg00))
+	    {
+	      tree arg01 = CALL_EXPR_ARG (arg0, 1);
+	      tree narg1 = fold_build2 (MULT_EXPR, type, arg01, arg1);
+	      return build_call_expr (fndecl, 2, arg00, narg1);
+	    }
 	}
     }
 
diff -Naur gcc-4.4.1.orig/gcc/config/alpha/alpha.c gcc-4.4.1/gcc/config/alpha/alpha.c
--- gcc-4.4.1.orig/gcc/config/alpha/alpha.c	2009-03-17 13:18:21.000000000 -0700
+++ gcc-4.4.1/gcc/config/alpha/alpha.c	2009-08-28 02:57:51.000000000 -0700
@@ -2052,11 +2052,22 @@
 
   switch (GET_CODE (x))
     {
-    case CONST:
     case LABEL_REF:
     case HIGH:
       return true;
 
+    case CONST:
+      if (GET_CODE (XEXP (x, 0)) == PLUS
+	  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)
+	x = XEXP (XEXP (x, 0), 0);
+      else
+	return true;
+
+      if (GET_CODE (x) != SYMBOL_REF)
+	return true;
+
+      /* FALLTHRU */
+
     case SYMBOL_REF:
       /* TLS symbols are never valid.  */
       return SYMBOL_REF_TLS_MODEL (x) == 0;
@@ -3542,7 +3553,7 @@
 	      emit_insn (gen_insll_le (insl, gen_lowpart (SImode, src), addr));
 	      break;
 	    case 8:
-	      emit_insn (gen_insql_le (insl, src, addr));
+	      emit_insn (gen_insql_le (insl, gen_lowpart (DImode, src), addr));
 	      break;
 	    }
 	}
@@ -8279,7 +8290,7 @@
   insn = get_last_insn ();
   if (!INSN_P (insn))
     insn = prev_active_insn (insn);
-  if (GET_CODE (insn) == CALL_INSN)
+  if (insn && GET_CODE (insn) == CALL_INSN)
     output_asm_insn (get_insn_template (CODE_FOR_nop, NULL), NULL);
 
 #if TARGET_ABI_OSF
diff -Naur gcc-4.4.1.orig/gcc/config/alpha/alpha.md gcc-4.4.1/gcc/config/alpha/alpha.md
--- gcc-4.4.1.orig/gcc/config/alpha/alpha.md	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/config/alpha/alpha.md	2009-08-28 02:57:51.000000000 -0700
@@ -256,16 +256,7 @@
 	(sign_extend:DI (match_dup 1)))]
   "")
 
-;; Don't say we have addsi3 if optimizing.  This generates better code.  We
-;; have the anonymous addsi3 pattern below in case combine wants to make it.
-(define_expand "addsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (match_operand:SI 1 "reg_or_0_operand" "")
-		 (match_operand:SI 2 "add_operand" "")))]
-  "! optimize"
-  "")
-
-(define_insn "*addsi_internal"
+(define_insn "addsi3"
   [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
 	(plus:SI (match_operand:SI 1 "reg_or_0_operand" "%rJ,rJ,rJ,rJ")
 		 (match_operand:SI 2 "add_operand" "rI,O,K,L")))]
@@ -619,14 +610,7 @@
   ""
   "subqv $31,%1,%0")
 
-(define_expand "subsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(minus:SI (match_operand:SI 1 "reg_or_0_operand" "")
-		  (match_operand:SI 2 "reg_or_8bit_operand" "")))]
-  "! optimize"
-  "")
-
-(define_insn "*subsi_internal"
+(define_insn "subsi3"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(minus:SI (match_operand:SI 1 "reg_or_0_operand" "rJ")
 		  (match_operand:SI 2 "reg_or_8bit_operand" "rI")))]
@@ -3716,19 +3700,7 @@
 	(match_operator:DF 1 "alpha_fp_comparison_operator"
 			   [(match_operand:DF 2 "reg_or_0_operand" "fG")
 			    (match_operand:DF 3 "reg_or_0_operand" "fG")]))]
-  "TARGET_FP && alpha_fptm < ALPHA_FPTM_SU"
-  "cmp%-%C1%/ %R2,%R3,%0"
-  [(set_attr "type" "fadd")
-   (set_attr "trap" "yes")
-   (set_attr "trap_suffix" "su")])
-
-(define_insn "*cmpdf_ieee_ext1"
-  [(set (match_operand:DF 0 "register_operand" "=&f")
-	(match_operator:DF 1 "alpha_fp_comparison_operator"
-			   [(float_extend:DF
-			     (match_operand:SF 2 "reg_or_0_operand" "fG"))
-			    (match_operand:DF 3 "reg_or_0_operand" "fG")]))]
-  "TARGET_FP && alpha_fptm >= ALPHA_FPTM_SU"
+  "TARGET_FP"
   "cmp%-%C1%/ %R2,%R3,%0"
   [(set_attr "type" "fadd")
    (set_attr "trap" "yes")
@@ -3746,18 +3718,6 @@
    (set_attr "trap" "yes")
    (set_attr "trap_suffix" "su")])
 
-(define_insn "*cmpdf_ieee_ext2"
-  [(set (match_operand:DF 0 "register_operand" "=&f")
-	(match_operator:DF 1 "alpha_fp_comparison_operator"
-			   [(match_operand:DF 2 "reg_or_0_operand" "fG")
-			    (float_extend:DF
-			     (match_operand:SF 3 "reg_or_0_operand" "fG"))]))]
-  "TARGET_FP && alpha_fptm >= ALPHA_FPTM_SU"
-  "cmp%-%C1%/ %R2,%R3,%0"
-  [(set_attr "type" "fadd")
-   (set_attr "trap" "yes")
-   (set_attr "trap_suffix" "su")])
-
 (define_insn "*cmpdf_ext2"
   [(set (match_operand:DF 0 "register_operand" "=f")
 	(match_operator:DF 1 "alpha_fp_comparison_operator"
@@ -3770,19 +3730,6 @@
    (set_attr "trap" "yes")
    (set_attr "trap_suffix" "su")])
 
-(define_insn "*cmpdf_ieee_ext3"
-  [(set (match_operand:DF 0 "register_operand" "=&f")
-	(match_operator:DF 1 "alpha_fp_comparison_operator"
-			   [(float_extend:DF
-			     (match_operand:SF 2 "reg_or_0_operand" "fG"))
-			    (float_extend:DF
-			     (match_operand:SF 3 "reg_or_0_operand" "fG"))]))]
-  "TARGET_FP && alpha_fptm >= ALPHA_FPTM_SU"
-  "cmp%-%C1%/ %R2,%R3,%0"
-  [(set_attr "type" "fadd")
-   (set_attr "trap" "yes")
-   (set_attr "trap_suffix" "su")])
-
 (define_insn "*cmpdf_ext3"
   [(set (match_operand:DF 0 "register_operand" "=f")
 	(match_operator:DF 1 "alpha_fp_comparison_operator"
@@ -3832,7 +3779,7 @@
 			  (match_operand:DF 2 "const0_operand" "G,G")])
 	 (float_extend:DF (match_operand:SF 1 "reg_or_0_operand" "fG,0"))
 	 (match_operand:DF 5 "reg_or_0_operand" "0,fG")))]
-  "TARGET_FP"
+  "TARGET_FP && alpha_fptm < ALPHA_FPTM_SU"
   "@
    fcmov%C3 %R4,%R1,%0
    fcmov%D3 %R4,%R5,%0"
@@ -3847,7 +3794,7 @@
 			  (match_operand:DF 2 "const0_operand" "G,G")])
 	 (match_operand:DF 1 "reg_or_0_operand" "fG,0")
 	 (match_operand:DF 5 "reg_or_0_operand" "0,fG")))]
-  "TARGET_FP"
+  "TARGET_FP && alpha_fptm < ALPHA_FPTM_SU"
   "@
    fcmov%C3 %R4,%R1,%0
    fcmov%D3 %R4,%R5,%0"
@@ -3862,7 +3809,7 @@
 			  (match_operand:DF 2 "const0_operand" "G,G")])
 	 (match_operand:SF 1 "reg_or_0_operand" "fG,0")
 	 (match_operand:SF 5 "reg_or_0_operand" "0,fG")))]
-  "TARGET_FP"
+  "TARGET_FP && alpha_fptm < ALPHA_FPTM_SU"
   "@
    fcmov%C3 %R4,%R1,%0
    fcmov%D3 %R4,%R5,%0"
@@ -3877,7 +3824,7 @@
 			  (match_operand:DF 2 "const0_operand" "G,G")])
 	 (float_extend:DF (match_operand:SF 1 "reg_or_0_operand" "fG,0"))
 	 (match_operand:DF 5 "reg_or_0_operand" "0,fG")))]
-  "TARGET_FP"
+  "TARGET_FP && alpha_fptm < ALPHA_FPTM_SU"
   "@
    fcmov%C3 %R4,%R1,%0
    fcmov%D3 %R4,%R5,%0"
diff -Naur gcc-4.4.1.orig/gcc/config/alpha/sync.md gcc-4.4.1/gcc/config/alpha/sync.md
--- gcc-4.4.1.orig/gcc/config/alpha/sync.md	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/config/alpha/sync.md	2009-08-28 02:57:51.000000000 -0700
@@ -62,11 +62,8 @@
   [(set_attr "type" "st_c")])
 
 ;; The Alpha Architecture Handbook says that it is UNPREDICTABLE whether
-;; the lock is cleared by a TAKEN branch.  If we were to honor that, it
-;; would mean that we could not expand a ll/sc sequence until after the
-;; final basic-block reordering pass.  Fortunately, it appears that no
-;; Alpha implementation ever built actually clears the lock on branches,
-;; taken or not.
+;; the lock is cleared by a TAKEN branch.  This means that we can not
+;; expand a ll/sc sequence until after the final basic-block reordering pass.
 
 (define_insn_and_split "sync_<fetchop_name><mode>"
   [(set (match_operand:I48MODE 0 "memory_operand" "+m")
@@ -77,7 +74,7 @@
    (clobber (match_scratch:I48MODE 2 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_atomic_op (<CODE>, operands[0], operands[1],
@@ -96,7 +93,7 @@
    (clobber (match_scratch:I48MODE 2 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_atomic_op (NOT, operands[0], operands[1],
@@ -116,7 +113,7 @@
    (clobber (match_scratch:I48MODE 3 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_atomic_op (<CODE>, operands[1], operands[2],
@@ -137,7 +134,7 @@
    (clobber (match_scratch:I48MODE 3 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_atomic_op (NOT, operands[1], operands[2],
@@ -158,7 +155,7 @@
    (clobber (match_scratch:I48MODE 3 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_atomic_op (<CODE>, operands[1], operands[2],
@@ -179,7 +176,7 @@
    (clobber (match_scratch:I48MODE 3 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_atomic_op (NOT, operands[1], operands[2],
@@ -214,7 +211,7 @@
    (clobber (match_scratch:DI 6 "=X,&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_compare_and_swap_12 (<MODE>mode, operands[0], operands[1],
@@ -251,7 +248,7 @@
    (clobber (match_scratch:I48MODE 4 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_compare_and_swap (operands[0], operands[1], operands[2],
@@ -282,7 +279,7 @@
    (clobber (match_scratch:DI 4 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_lock_test_and_set_12 (<MODE>mode, operands[0], operands[1],
@@ -301,7 +298,7 @@
    (clobber (match_scratch:I48MODE 3 "=&r"))]
   ""
   "#"
-  "reload_completed"
+  "epilogue_completed"
   [(const_int 0)]
 {
   alpha_split_lock_test_and_set (operands[0], operands[1],
diff -Naur gcc-4.4.1.orig/gcc/config/arm/arm.md gcc-4.4.1/gcc/config/arm/arm.md
--- gcc-4.4.1.orig/gcc/config/arm/arm.md	2009-05-16 06:28:27.000000000 -0700
+++ gcc-4.4.1/gcc/config/arm/arm.md	2009-08-05 09:11:25.000000000 -0700
@@ -472,9 +472,9 @@
   if (TARGET_THUMB1)
     {
       if (GET_CODE (operands[1]) != REG)
-        operands[1] = force_reg (SImode, operands[1]);
+        operands[1] = force_reg (DImode, operands[1]);
       if (GET_CODE (operands[2]) != REG)
-        operands[2] = force_reg (SImode, operands[2]);
+        operands[2] = force_reg (DImode, operands[2]);
      }
   "
 )
diff -Naur gcc-4.4.1.orig/gcc/config/avr/avr.c gcc-4.4.1/gcc/config/avr/avr.c
--- gcc-4.4.1.orig/gcc/config/avr/avr.c	2009-04-01 00:18:47.000000000 -0700
+++ gcc-4.4.1/gcc/config/avr/avr.c	2009-08-25 12:03:53.000000000 -0700
@@ -996,7 +996,7 @@
 	      start_sequence ();
 
 	      emit_move_insn (myfp,
-			      gen_rtx_PLUS (HImode, myfp,
+			      gen_rtx_PLUS (GET_MODE (myfp), myfp,
 					    gen_int_mode (size, 
 							  GET_MODE(myfp))));
 
diff -Naur gcc-4.4.1.orig/gcc/config/i386/i386.c gcc-4.4.1/gcc/config/i386/i386.c
--- gcc-4.4.1.orig/gcc/config/i386/i386.c	2009-07-21 00:22:51.000000000 -0700
+++ gcc-4.4.1/gcc/config/i386/i386.c	2009-09-09 12:08:31.000000000 -0700
@@ -7340,7 +7340,8 @@
     return 0;
 
   ix86_compute_frame_layout (&frame);
-  return frame.to_allocate == 0 && (frame.nregs + frame.nsseregs) == 0;
+  return frame.to_allocate == 0 && frame.padding0 == 0
+         && (frame.nregs + frame.nsseregs) == 0;
 }
 
 /* Value should be nonzero if functions must have frame pointers.
@@ -8328,7 +8329,7 @@
          && (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)))
     {
       if (!frame_pointer_needed
-	  || !frame.to_allocate
+	  || !(frame.to_allocate + frame.padding0)
 	  || crtl->stack_realign_needed)
         ix86_emit_save_regs_using_mov (stack_pointer_rtx,
 				       frame.to_allocate
@@ -8338,7 +8339,7 @@
 				       -frame.nregs * UNITS_PER_WORD);
     }
   if (!frame_pointer_needed
-      || !frame.to_allocate
+      || !(frame.to_allocate + frame.padding0)
       || crtl->stack_realign_needed)
     ix86_emit_save_sse_regs_using_mov (stack_pointer_rtx,
 				       frame.to_allocate);
@@ -8524,8 +8525,10 @@
   if ((!sp_valid && (frame.nregs + frame.nsseregs) <= 1)
       || (TARGET_EPILOGUE_USING_MOVE
 	  && cfun->machine->use_fast_prologue_epilogue
-	  && ((frame.nregs + frame.nsseregs) > 1 || frame.to_allocate))
-      || (frame_pointer_needed && !(frame.nregs + frame.nsseregs) && frame.to_allocate)
+	  && ((frame.nregs + frame.nsseregs) > 1
+	      || (frame.to_allocate + frame.padding0) != 0))
+      || (frame_pointer_needed && !(frame.nregs + frame.nsseregs)
+          && (frame.to_allocate + frame.padding0) != 0)
       || (frame_pointer_needed && TARGET_USE_LEAVE
 	  && cfun->machine->use_fast_prologue_epilogue
 	  && (frame.nregs + frame.nsseregs) == 1)
@@ -8535,13 +8538,13 @@
 	 locations.  If both are available, default to ebp, since offsets
 	 are known to be small.  Only exception is esp pointing directly
 	 to the end of block of saved registers, where we may simplify
-	 addressing mode.  
+	 addressing mode.
 
 	 If we are realigning stack with bp and sp, regs restore can't
 	 be addressed by bp. sp must be used instead.  */
 
       if (!frame_pointer_needed
-	  || (sp_valid && !frame.to_allocate) 
+	  || (sp_valid && !(frame.to_allocate + frame.padding0))
 	  || stack_realign_fp)
 	{
 	  ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,
@@ -8630,9 +8633,10 @@
           ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,
 					        frame.to_allocate, style == 2);
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
-				     GEN_INT (frame.nsseregs * 16), style);
+				     GEN_INT (frame.nsseregs * 16 +
+				       frame.padding0), style);
 	}
-      else if (frame.to_allocate || frame.nsseregs)
+      else if (frame.to_allocate || frame.padding0 || frame.nsseregs)
 	{
           ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,
 					        frame.to_allocate,
@@ -12090,16 +12094,18 @@
 output_387_ffreep (rtx *operands ATTRIBUTE_UNUSED, int opno)
 {
   if (TARGET_USE_FFREEP)
-#if HAVE_AS_IX86_FFREEP
+#ifdef HAVE_AS_IX86_FFREEP
     return opno ? "ffreep\t%y1" : "ffreep\t%y0";
 #else
     {
-      static char retval[] = ".word\t0xc_df";
+      static char retval[32];
       int regno = REGNO (operands[opno]);
 
       gcc_assert (FP_REGNO_P (regno));
 
-      retval[9] = '0' + (regno - FIRST_STACK_REG);
+      regno -= FIRST_STACK_REG;
+
+      snprintf (retval, sizeof (retval), ASM_SHORT "0xc%ddf", regno);
       return retval;
     }
 #endif
@@ -16307,10 +16313,20 @@
   /* When emitting push, take care for source operands on the stack.  */
   if (push && MEM_P (operands[1])
       && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))
-    for (i = 0; i < nparts - 1; i++)
-      part[1][i] = change_address (part[1][i],
-				   GET_MODE (part[1][i]),
-				   XEXP (part[1][i + 1], 0));
+    {
+      rtx src_base = XEXP (part[1][nparts - 1], 0);
+
+      /* Compensate for the stack decrement by 4.  */
+      if (!TARGET_64BIT && nparts == 3
+	  && mode == XFmode && TARGET_128BIT_LONG_DOUBLE)
+	src_base = plus_constant (src_base, 4);
+
+      /* src_base refers to the stack pointer and is
+	 automatically decreased by emitted push.  */
+      for (i = 0; i < nparts; i++)
+	part[1][i] = change_address (part[1][i],
+				     GET_MODE (part[1][i]), src_base);
+    }
 
   /* We need to do copy in the right order in case an address register
      of the source overlaps the destination.  */
@@ -16380,7 +16396,8 @@
 	  if (nparts == 3)
 	    {
 	      if (TARGET_128BIT_LONG_DOUBLE && mode == XFmode)
-                emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (-4)));
+                emit_insn (gen_addsi3 (stack_pointer_rtx,
+				       stack_pointer_rtx, GEN_INT (-4)));
 	      emit_move_insn (part[0][2], part[1][2]);
 	    }
 	  else if (nparts == 4)
@@ -25306,7 +25323,7 @@
 static tree
 ix86_vectorize_builtin_conversion (unsigned int code, tree type)
 {
-  if (TREE_CODE (type) != VECTOR_TYPE
+  if (!TARGET_SSE2 || TREE_CODE (type) != VECTOR_TYPE
       /* There are only conversions from/to signed integers.  */
       || TYPE_UNSIGNED (TREE_TYPE (type)))
     return NULL_TREE;
diff -Naur gcc-4.4.1.orig/gcc/config/i386/i386.md gcc-4.4.1/gcc/config/i386/i386.md
--- gcc-4.4.1.orig/gcc/config/i386/i386.md	2009-07-08 09:59:15.000000000 -0700
+++ gcc-4.4.1/gcc/config/i386/i386.md	2009-08-23 05:47:57.000000000 -0700
@@ -14973,22 +14973,25 @@
 	 (match_operand:SI 1 "" ""))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 2 "immediate_operand" "i")))]
-  "!TARGET_64BIT"
+  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
 {
   if (constant_call_address_operand (operands[0], Pmode))
-    {
-      if (SIBLING_CALL_P (insn))
-	return "jmp\t%P0";
-      else
-	return "call\t%P0";
-    }
-  if (SIBLING_CALL_P (insn))
-    return "jmp\t%A0";
-  else
-    return "call\t%A0";
+    return "call\t%P0";
+  return "call\t%A0";
 }
   [(set_attr "type" "call")])
 
+(define_insn "*sibcall_pop_1"
+  [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,U"))
+	 (match_operand:SI 1 "" ""))
+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 2 "immediate_operand" "i,i")))]
+  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "@
+   jmp\t%P0
+   jmp\t%A0"
+  [(set_attr "type" "call")])
+
 (define_expand "call"
   [(call (match_operand:QI 0 "" "")
 	 (match_operand 1 "" ""))
@@ -15920,7 +15923,7 @@
    (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
 	      UNSPEC_TLS_GD)]
   "TARGET_64BIT"
-  ".byte\t0x66\;lea{q}\t{%a1@TLSGD(%%rip), %%rdi|rdi, %a1@TLSGD[rip]}\;.word\t0x6666\;rex64\;call\t%P2"
+  { return ".byte\t0x66\n\tlea{q}\t{%a1@TLSGD(%%rip), %%rdi|rdi, %a1@TLSGD[rip]}\n" ASM_SHORT "0x6666\n\trex64\n\tcall\t%P2"; }
   [(set_attr "type" "multi")
    (set_attr "length" "16")])
 
@@ -21469,22 +21472,26 @@
 	      (match_operand:SI 2 "" "")))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 3 "immediate_operand" "i")))]
-  "!TARGET_64BIT"
+  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
 {
   if (constant_call_address_operand (operands[1], Pmode))
-    {
-      if (SIBLING_CALL_P (insn))
-	return "jmp\t%P1";
-      else
-	return "call\t%P1";
-    }
-  if (SIBLING_CALL_P (insn))
-    return "jmp\t%A1";
-  else
-    return "call\t%A1";
+    return "call\t%P1";
+  return "call\t%A1";
 }
   [(set_attr "type" "callv")])
 
+(define_insn "*sibcall_value_pop_1"
+  [(set (match_operand 0 "" "")
+	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,U"))
+	      (match_operand:SI 2 "" "")))
+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 3 "immediate_operand" "i,i")))]
+  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "@
+   jmp\t%P1
+   jmp\t%A1"
+  [(set_attr "type" "callv")])
+
 (define_insn "*call_value_0"
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:SI 1 "constant_call_address_operand" ""))
diff -Naur gcc-4.4.1.orig/gcc/config/i386/netware.c gcc-4.4.1/gcc/config/i386/netware.c
--- gcc-4.4.1.orig/gcc/config/i386/netware.c	2008-07-01 23:43:45.000000000 -0700
+++ gcc-4.4.1/gcc/config/i386/netware.c	2009-08-28 08:40:31.000000000 -0700
@@ -30,6 +30,7 @@
 #include "flags.h"
 #include "tm_p.h"
 #include "toplev.h"
+#include "langhooks.h"
 #include "ggc.h"
 
 /* Return string which is the function name, identified by ID, modified
@@ -179,16 +180,15 @@
 {
   default_encode_section_info (decl, rtl, first);
 
-  if (first
-      && TREE_CODE (decl) == FUNCTION_DECL
+  if (TREE_CODE (decl) == FUNCTION_DECL
       /* Do not change the identifier if a verbatim asmspec
 	 or if stdcall suffix already added.  */
       && *IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)) != '*'
-      && !strchr (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), '@'))
+      && !strchr (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), '@')
+      /* FIXME:  Imported stdcall names are not modified by the Ada frontend.
+	 Check and decorate the RTL name now.  */
+      && strcmp (lang_hooks.name, "GNU Ada") == 0)
     {
-      /* FIXME: In Ada, and perhaps other language frontends,
-	 imported stdcall names may not yet have been modified.
-	 Check and do it know.  */
       rtx symbol = XEXP (rtl, 0);
       tree new_id;
       tree old_id = DECL_ASSEMBLER_NAME (decl);
@@ -196,14 +196,7 @@
       gcc_assert (GET_CODE (symbol) == SYMBOL_REF);
 
       if ((new_id = i386_nlm_maybe_mangle_decl_assembler_name (decl, old_id)))
-	{
-	  /* These attributes must be present on first declaration,
-	     change_decl_assembler_name will warn if they are added
-	     later and the decl has been referenced, but duplicate_decls
-	     should catch the mismatch first.  */
-	  change_decl_assembler_name (decl, new_id);
-	  XSTR (symbol, 0) = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
-	}
+	XSTR (symbol, 0) = IDENTIFIER_POINTER (new_id);
     }
 }
 
@@ -233,24 +226,3 @@
     }
   return name;
 }
-
-/* Sometimes certain combinations of command options do not make
-   sense on a particular target machine.  You can define a macro
-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
-   defined, is executed once just after all the command options have
-   been parsed.
-
-   Don't use this macro to turn on various extra optimizations for
-   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
-
-void
-netware_override_options (void)
-{
-  override_options ();
-
-  if (flag_pic)
-    {
-      error ("-fPIC and -fpic are not supported for this target");
-      flag_pic = 0;
-    }
-}
diff -Naur gcc-4.4.1.orig/gcc/config/i386/netware.h gcc-4.4.1/gcc/config/i386/netware.h
--- gcc-4.4.1.orig/gcc/config/i386/netware.h	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/config/i386/netware.h	2009-08-28 08:40:31.000000000 -0700
@@ -72,17 +72,16 @@
 #define TARGET_SUBTARGET_DEFAULT (MASK_80387 | MASK_IEEE_FP | \
 	MASK_FLOAT_RETURNS | MASK_ALIGN_DOUBLE | MASK_MS_BITFIELD_LAYOUT)
 
-/* Sometimes certain combinations of command options do not make
-   sense on a particular target machine.  You can define a macro
-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
-   defined, is executed once just after all the command options have
-   been parsed.
-
-   Don't use this macro to turn on various extra optimizations for
-   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
-#undef  OVERRIDE_OPTIONS
-extern void netware_override_options (void);
-#define OVERRIDE_OPTIONS netware_override_options ()
+/* Don't allow flag_pic to propagate since invalid relocations will
+   result otherwise.  */
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if (flag_pic)								\
+    {									\
+      error ("-fPIC and -fpic are not supported for this target");	\
+      flag_pic = 0;							\
+    }									\
+} while (0)
 
 #undef MATH_LIBRARY
 #define MATH_LIBRARY ""
@@ -99,6 +98,9 @@
 #undef KEEP_AGGREGATE_RETURN_POINTER
 #define KEEP_AGGREGATE_RETURN_POINTER 1
 
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
 #undef DBX_REGISTER_NUMBER
 #define DBX_REGISTER_NUMBER(n) (svr4_dbx_register_map[n])
 
diff -Naur gcc-4.4.1.orig/gcc/config/i386/nwld.h gcc-4.4.1/gcc/config/i386/nwld.h
--- gcc-4.4.1.orig/gcc/config/i386/nwld.h	2007-08-02 03:49:31.000000000 -0700
+++ gcc-4.4.1/gcc/config/i386/nwld.h	2009-08-28 08:40:31.000000000 -0700
@@ -55,6 +55,13 @@
 #define TARGET_ASM_CONSTRUCTOR nwld_named_section_asm_out_constructor
 #define TARGET_ASM_DESTRUCTOR  nwld_named_section_asm_out_destructor
 
+#define SUBSUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  /* XXX This can be enabled once gas output meets nwld's needs. */	\
+  /* if (!flag_unwind_tables && !flag_exceptions) */			\
+    flag_dwarf2_cfi_asm = 0;						\
+} while (0)
+
 #undef  EH_FRAME_SECTION_NAME
 #define EH_FRAME_SECTION_NAME ".eh_frame"TARGET_SUB_SECTION_SEPARATOR
 
diff -Naur gcc-4.4.1.orig/gcc/config/i386/sse.md gcc-4.4.1/gcc/config/i386/sse.md
--- gcc-4.4.1.orig/gcc/config/i386/sse.md	2009-05-06 06:20:41.000000000 -0700
+++ gcc-4.4.1/gcc/config/i386/sse.md	2009-08-16 12:34:49.000000000 -0700
@@ -64,6 +64,10 @@
 (define_mode_iterator SSEMODE4S [V4SF V4SI])
 (define_mode_iterator SSEMODE2D [V2DF V2DI])
 
+;; Modes handled by integer vcond pattern
+(define_mode_iterator SSEMODE124C8 [V16QI V8HI V4SI
+				    (V2DI "TARGET_SSE4_2 || TARGET_SSE5")])
+
 ;; Mapping from float mode to required SSE level
 (define_mode_attr sse [(SF "sse") (DF "sse2") (V4SF "sse") (V2DF "sse2")])
 
@@ -1493,10 +1497,9 @@
           (match_operand:SSEMODEF2P 2 "general_operand" "")))]
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
 {
-  if (ix86_expand_fp_vcond (operands))
-    DONE;
-  else
-    FAIL;
+  bool ok = ix86_expand_fp_vcond (operands);
+  gcc_assert (ok);
+  DONE;
 })
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -5837,35 +5840,33 @@
    (set_attr "mode" "TI")])
 
 (define_expand "vcond<mode>"
-  [(set (match_operand:SSEMODEI 0 "register_operand" "")
-        (if_then_else:SSEMODEI
+  [(set (match_operand:SSEMODE124C8 0 "register_operand" "")
+        (if_then_else:SSEMODE124C8
           (match_operator 3 ""
-            [(match_operand:SSEMODEI 4 "nonimmediate_operand" "")
-             (match_operand:SSEMODEI 5 "nonimmediate_operand" "")])
-          (match_operand:SSEMODEI 1 "general_operand" "")
-          (match_operand:SSEMODEI 2 "general_operand" "")))]
+            [(match_operand:SSEMODE124C8 4 "nonimmediate_operand" "")
+             (match_operand:SSEMODE124C8 5 "nonimmediate_operand" "")])
+          (match_operand:SSEMODE124C8 1 "general_operand" "")
+          (match_operand:SSEMODE124C8 2 "general_operand" "")))]
   "TARGET_SSE2"
 {
-  if (ix86_expand_int_vcond (operands))
-    DONE;
-  else
-    FAIL;
+  bool ok = ix86_expand_int_vcond (operands);
+  gcc_assert (ok);
+  DONE;
 })
 
 (define_expand "vcondu<mode>"
-  [(set (match_operand:SSEMODEI 0 "register_operand" "")
-        (if_then_else:SSEMODEI
+  [(set (match_operand:SSEMODE124C8 0 "register_operand" "")
+        (if_then_else:SSEMODE124C8
           (match_operator 3 ""
-            [(match_operand:SSEMODEI 4 "nonimmediate_operand" "")
-             (match_operand:SSEMODEI 5 "nonimmediate_operand" "")])
-          (match_operand:SSEMODEI 1 "general_operand" "")
-          (match_operand:SSEMODEI 2 "general_operand" "")))]
+            [(match_operand:SSEMODE124C8 4 "nonimmediate_operand" "")
+             (match_operand:SSEMODE124C8 5 "nonimmediate_operand" "")])
+          (match_operand:SSEMODE124C8 1 "general_operand" "")
+          (match_operand:SSEMODE124C8 2 "general_operand" "")))]
   "TARGET_SSE2"
 {
-  if (ix86_expand_int_vcond (operands))
-    DONE;
-  else
-    FAIL;
+  bool ok = ix86_expand_int_vcond (operands);
+  gcc_assert (ok);
+  DONE;
 })
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
diff -Naur gcc-4.4.1.orig/gcc/config/pa/pa.c gcc-4.4.1/gcc/config/pa/pa.c
--- gcc-4.4.1.orig/gcc/config/pa/pa.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/config/pa/pa.c	2009-07-27 08:26:05.000000000 -0700
@@ -2217,9 +2217,9 @@
   else
     {
       /* Find the width of the bitstring in IMM.  */
-      for (len = 5; len < 32; len++)
+      for (len = 5; len < 32 - lsb; len++)
 	{
-	  if ((imm & (1 << len)) == 0)
+	  if ((imm & ((unsigned HOST_WIDE_INT) 1 << len)) == 0)
 	    break;
 	}
 
@@ -2238,10 +2238,12 @@
 void
 compute_zdepdi_operands (unsigned HOST_WIDE_INT imm, unsigned *op)
 {
-  HOST_WIDE_INT lsb, len;
+  int lsb, len, maxlen;
+
+  maxlen = MIN (HOST_BITS_PER_WIDE_INT, 64);
 
   /* Find the least significant set bit in IMM.  */
-  for (lsb = 0; lsb < HOST_BITS_PER_WIDE_INT; lsb++)
+  for (lsb = 0; lsb < maxlen; lsb++)
     {
       if ((imm & 1) != 0)
         break;
@@ -2250,17 +2252,20 @@
 
   /* Choose variants based on *sign* of the 5-bit field.  */
   if ((imm & 0x10) == 0)
-    len = ((lsb <= HOST_BITS_PER_WIDE_INT - 4)
-	   ? 4 : HOST_BITS_PER_WIDE_INT - lsb);
+    len = (lsb <= maxlen - 4) ? 4 : maxlen - lsb;
   else
     {
       /* Find the width of the bitstring in IMM.  */
-      for (len = 5; len < HOST_BITS_PER_WIDE_INT; len++)
+      for (len = 5; len < maxlen - lsb; len++)
 	{
 	  if ((imm & ((unsigned HOST_WIDE_INT) 1 << len)) == 0)
 	    break;
 	}
 
+      /* Extend length if host is narrow and IMM is negative.  */
+      if (HOST_BITS_PER_WIDE_INT == 32 && len == maxlen - lsb)
+	len += 32;
+
       /* Sign extend IMM as a 5-bit value.  */
       imm = (imm & 0xf) - 0x10;
     }
diff -Naur gcc-4.4.1.orig/gcc/config/rs6000/freebsd.h gcc-4.4.1/gcc/config/rs6000/freebsd.h
--- gcc-4.4.1.orig/gcc/config/rs6000/freebsd.h	2007-08-02 03:49:31.000000000 -0700
+++ gcc-4.4.1/gcc/config/rs6000/freebsd.h	2009-08-10 11:22:22.000000000 -0700
@@ -1,5 +1,5 @@
 /* Definitions for PowerPC running FreeBSD using the ELF format
-   Copyright (C) 2001, 2003, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2003, 2007, 2009 Free Software Foundation, Inc.
    Contributed by David E. O'Brien <obrien@FreeBSD.org> and BSDi.
 
    This file is part of GCC.
@@ -69,3 +69,6 @@
 /* Override rs6000.h definition.  */
 #undef  ASM_APP_OFF
 #define ASM_APP_OFF "#NO_APP\n"
+/* Define SVR4_ASM_SPEC, we use GAS by default. See svr4.h for details.  */
+#define SVR4_ASM_SPEC \
+  "%{v:-V} %{Wa,*:%*}"
diff -Naur gcc-4.4.1.orig/gcc/config/rs6000/rs6000.c gcc-4.4.1/gcc/config/rs6000/rs6000.c
--- gcc-4.4.1.orig/gcc/config/rs6000/rs6000.c	2009-03-17 13:18:21.000000000 -0700
+++ gcc-4.4.1/gcc/config/rs6000/rs6000.c	2009-08-18 04:43:16.000000000 -0700
@@ -3808,6 +3808,8 @@
 rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
 			   enum machine_mode mode)
 {
+  unsigned int extra = 0;
+
   if (GET_CODE (x) == SYMBOL_REF)
     {
       enum tls_model model = SYMBOL_REF_TLS_MODEL (x);
@@ -3815,10 +3817,32 @@
 	return rs6000_legitimize_tls_address (x, model);
     }
 
+  switch (mode)
+    {
+    case DFmode:
+    case DDmode:
+      extra = 4;
+      break;
+    case DImode:
+      if (!TARGET_POWERPC64)
+	extra = 4;
+      break;
+    case TFmode:
+    case TDmode:
+      extra = 12;
+      break;
+    case TImode:
+      extra = TARGET_POWERPC64 ? 8 : 12;
+      break;
+    default:
+      break;
+    }
+
   if (GET_CODE (x) == PLUS
       && GET_CODE (XEXP (x, 0)) == REG
       && GET_CODE (XEXP (x, 1)) == CONST_INT
-      && (unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000) >= 0x10000
+      && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000)
+	  >= 0x10000 - extra)
       && !((TARGET_POWERPC64
 	    && (mode == DImode || mode == TImode)
 	    && (INTVAL (XEXP (x, 1)) & 3) != 0)
@@ -3831,10 +3855,12 @@
       HOST_WIDE_INT high_int, low_int;
       rtx sum;
       low_int = ((INTVAL (XEXP (x, 1)) & 0xffff) ^ 0x8000) - 0x8000;
+      if (low_int >= 0x8000 - extra)
+	low_int = 0;
       high_int = INTVAL (XEXP (x, 1)) - low_int;
       sum = force_operand (gen_rtx_PLUS (Pmode, XEXP (x, 0),
 					 GEN_INT (high_int)), 0);
-      return gen_rtx_PLUS (Pmode, sum, GEN_INT (low_int));
+      return plus_constant (sum, low_int);
     }
   else if (GET_CODE (x) == PLUS
 	   && GET_CODE (XEXP (x, 0)) == REG
diff -Naur gcc-4.4.1.orig/gcc/config/s390/2084.md gcc-4.4.1/gcc/config/s390/2084.md
--- gcc-4.4.1.orig/gcc/config/s390/2084.md	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/config/s390/2084.md	2009-09-04 03:05:45.000000000 -0700
@@ -163,17 +163,17 @@
 
 (define_insn_reservation "x_fsimptf" 7 
   (and (eq_attr "cpu" "z990,z9_109")
-       (eq_attr "type" "fsimptf"))
+       (eq_attr "type" "fsimptf,fhex"))
   "x_e1_t*2,x-wr-fp") 
 
 (define_insn_reservation "x_fsimpdf" 6 
   (and (eq_attr "cpu" "z990,z9_109")
-       (eq_attr "type" "fsimpdf,fmuldf"))
+       (eq_attr "type" "fsimpdf,fmuldf,fhex"))
   "x_e1_t,x-wr-fp") 
 
 (define_insn_reservation "x_fsimpsf" 6 
   (and (eq_attr "cpu" "z990,z9_109")
-       (eq_attr "type" "fsimpsf,fmulsf"))
+       (eq_attr "type" "fsimpsf,fmulsf,fhex"))
   "x_e1_t,x-wr-fp") 
 
 
diff -Naur gcc-4.4.1.orig/gcc/config/s390/2097.md gcc-4.4.1/gcc/config/s390/2097.md
--- gcc-4.4.1.orig/gcc/config/s390/2097.md	2008-08-15 00:36:40.000000000 -0700
+++ gcc-4.4.1/gcc/config/s390/2097.md	2009-09-04 03:05:45.000000000 -0700
@@ -463,29 +463,34 @@
 
 ; BFP multiplication and general instructions
 
-(define_insn_reservation "z10_fsimpdf" 12
+(define_insn_reservation "z10_fsimpdf" 6
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "fsimpdf,fmuldf"))
   "z10_e1_BOTH, z10_Gate_FP")
-; Wg "z10_e1_T, z10_Gate_FP")
 
-(define_insn_reservation "z10_fsimpsf" 12
+; LOAD ZERO produces a hex value but we need bin. Using the stage 7
+; bypass causes an exception for format conversion which is very
+; expensive. So, make sure subsequent instructions only get the zero
+; in the normal way.
+(define_insn_reservation "z10_fhex" 12
+  (and (eq_attr "cpu" "z10")
+       (eq_attr "type" "fhex"))
+  "z10_e1_BOTH, z10_Gate_FP")
+
+(define_insn_reservation "z10_fsimpsf" 6
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "fsimpsf,fmulsf"))
   "z10_e1_BOTH, z10_Gate_FP")
-; Wg "z10_e1_T, z10_Gate_FP")
 
 (define_insn_reservation "z10_fmultf" 52
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "fmultf"))
   "z10_e1_BOTH*4, z10_Gate_FP")
-; Wg  "z10_e1_T*4, z10_Gate_FP")
 
 (define_insn_reservation "z10_fsimptf" 14
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "fsimptf"))
   "z10_e1_BOTH*2, z10_Gate_FP")
-; Wg  "z10_e1_T*2, z10_Gate_FP")
 
 
 ; BFP division
@@ -531,12 +536,12 @@
        (eq_attr "type" "floadtf"))
   "z10_e1_T, z10_Gate_FP")
 
-(define_insn_reservation "z10_floaddf" 12
+(define_insn_reservation "z10_floaddf" 1
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "floaddf"))
   "z10_e1_T, z10_Gate_FP")
 
-(define_insn_reservation "z10_floadsf" 12
+(define_insn_reservation "z10_floadsf" 1
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "floadsf"))
   "z10_e1_T, z10_Gate_FP")
@@ -553,12 +558,12 @@
 
 
 ; BFP truncate
-(define_insn_reservation "z10_ftrunctf" 12
+(define_insn_reservation "z10_ftrunctf" 16
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "ftrunctf"))
   "z10_e1_T, z10_Gate_FP")
 
-(define_insn_reservation "z10_ftruncdf" 16
+(define_insn_reservation "z10_ftruncdf" 12
   (and (eq_attr "cpu" "z10")
        (eq_attr "type" "ftruncdf"))
   "z10_e1_T, z10_Gate_FP")
@@ -585,8 +590,8 @@
 ; BFP-related bypasses.  There is no bypass for extended mode.
 (define_bypass 1 "z10_fsimpdf" "z10_fstoredf")
 (define_bypass 1 "z10_fsimpsf" "z10_fstoresf")
-(define_bypass 1 "z10_floaddf" "z10_fsimpdf, z10_fstoredf, z10_floaddf")
-(define_bypass 1 "z10_floadsf" "z10_fsimpsf, z10_fstoresf, z10_floadsf")
+(define_bypass 1 "z10_floaddf" "z10_fsimpdf, z10_fstoredf")
+(define_bypass 1 "z10_floadsf" "z10_fsimpsf, z10_fstoresf")
 
 
 ;
diff -Naur gcc-4.4.1.orig/gcc/config/s390/constraints.md gcc-4.4.1/gcc/config/s390/constraints.md
--- gcc-4.4.1.orig/gcc/config/s390/constraints.md	2009-04-24 07:51:17.000000000 -0700
+++ gcc-4.4.1/gcc/config/s390/constraints.md	2009-07-30 05:32:19.000000000 -0700
@@ -66,9 +66,14 @@
 ;;    B -- Multiple letter constraint followed by Q, R, S, or T:
 ;;         Memory reference of the type specified by second letter that
 ;;         does *not* refer to a literal pool entry.
-;;    U -- Pointer with short displacement.
-;;    W -- Pointer with long displacement.
+;;    U -- Pointer with short displacement. (deprecated - use ZQZR)
+;;    W -- Pointer with long displacement. (deprecated - use ZSZT)
 ;;    Y -- Shift count operand.
+;;    ZQ -- Pointer without index register and with short displacement.
+;;    ZR -- Pointer with index register and short displacement.
+;;    ZS -- Pointer without index register but with long displacement.
+;;    ZT -- Pointer with index register and long displacement.
+;;
 ;;
 
 
@@ -462,11 +467,26 @@
 
 
 (define_address_constraint "U"
-  "Pointer with short displacement"
+  "Pointer with short displacement. (deprecated - use ZQZR)"
   (match_test "s390_mem_constraint (\"U\", op)"))
 
-
-
 (define_address_constraint "W"
-  "Pointer with long displacement"
+  "Pointer with long displacement. (deprecated - use ZSZT)"
   (match_test "s390_mem_constraint (\"W\", op)"))
+
+
+(define_address_constraint "ZQ"
+  "Pointer without index register and with short displacement."
+  (match_test "s390_mem_constraint (\"ZQ\", op)"))
+
+(define_address_constraint "ZR"
+  "Pointer with index register and short displacement."
+  (match_test "s390_mem_constraint (\"ZR\", op)"))
+
+(define_address_constraint "ZS"
+  "Pointer without index register but with long displacement."
+  (match_test "s390_mem_constraint (\"ZS\", op)"))
+
+(define_address_constraint "ZT"
+  "Pointer with index register and long displacement."
+  (match_test "s390_mem_constraint (\"ZT\", op)"))
diff -Naur gcc-4.4.1.orig/gcc/config/s390/s390.c gcc-4.4.1/gcc/config/s390/s390.c
--- gcc-4.4.1.orig/gcc/config/s390/s390.c	2009-02-27 06:56:19.000000000 -0800
+++ gcc-4.4.1/gcc/config/s390/s390.c	2009-09-04 03:05:45.000000000 -0700
@@ -52,6 +52,7 @@
 #include "optabs.h"
 #include "gimple.h"
 #include "df.h"
+#include "params.h"
 
 
 /* Define the specific costs for a given cpu.  */
@@ -204,13 +205,13 @@
   COSTS_N_INSNS (10),    /* MSGFR */
   COSTS_N_INSNS (10),    /* MSGR  */
   COSTS_N_INSNS (10),    /* MSR   */
-  COSTS_N_INSNS (10),    /* multiplication in DFmode */
+  COSTS_N_INSNS (1) ,    /* multiplication in DFmode */
   COSTS_N_INSNS (50),    /* MXBR */
   COSTS_N_INSNS (120),   /* SQXBR */
   COSTS_N_INSNS (52),    /* SQDBR */
   COSTS_N_INSNS (38),    /* SQEBR */
-  COSTS_N_INSNS (10),    /* MADBR */
-  COSTS_N_INSNS (10),    /* MAEBR */
+  COSTS_N_INSNS (1),     /* MADBR */
+  COSTS_N_INSNS (1),     /* MAEBR */
   COSTS_N_INSNS (111),   /* DXBR */
   COSTS_N_INSNS (39),    /* DDBR */
   COSTS_N_INSNS (32),    /* DEBR */
@@ -352,6 +353,10 @@
 #define REGNO_PAIR_OK(REGNO, MODE)                               \
   (HARD_REGNO_NREGS ((REGNO), (MODE)) == 1 || !((REGNO) & 1))
 
+/* That's the read ahead of the dynamic branch prediction unit in
+   bytes on a z10 CPU.  */
+#define Z10_PREDICT_DISTANCE 384
+
 static enum machine_mode
 s390_libgcc_cmp_return_mode (void)
 {
@@ -1641,6 +1646,10 @@
   if (!(target_flags_explicit & MASK_LONG_DOUBLE_128))
     target_flags |= MASK_LONG_DOUBLE_128;
 #endif
+
+  if (s390_tune == PROCESSOR_2097_Z10
+      && !PARAM_SET_P (PARAM_MAX_UNROLLED_INSNS))
+    set_param_value ("max-unrolled-insns", 100);
 }
 
 /* Map for smallest class containing reg regno.  */
@@ -1678,6 +1687,11 @@
   if (!disp)
     return true;
 
+  /* Without the long displacement facility we don't need to
+     distingiush between long and short displacement.  */
+  if (!TARGET_LONG_DISPLACEMENT)
+    return true;
+
   /* Integer displacement in range.  */
   if (GET_CODE (disp) == CONST_INT)
     return INTVAL (disp) >= 0 && INTVAL (disp) < 4096;
@@ -2046,79 +2060,93 @@
 }
 
 
-/* Evaluates constraint strings described by the regular expression
-   ([A|B](Q|R|S|T))|U|W and returns 1 if OP is a valid operand for the
-   constraint given in STR, or 0 else.  */
+/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int
+   and return these parts in SYMREF and ADDEND.  You can pass NULL in
+   SYMREF and/or ADDEND if you are not interested in these values.  */
 
-int
-s390_mem_constraint (const char *str, rtx op)
+static bool
+s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)
 {
-  struct s390_address addr;
-  char c = str[0];
+  HOST_WIDE_INT tmpaddend = 0;
 
-  /* Check for offsettable variants of memory constraints.  */
-  if (c == 'A')
+  if (GET_CODE (addr) == CONST)
+    addr = XEXP (addr, 0);
+
+  if (GET_CODE (addr) == PLUS)
     {
-      /* Only accept non-volatile MEMs.  */
-      if (!MEM_P (op) || MEM_VOLATILE_P (op))
-	return 0;
+      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF
+	  && CONST_INT_P (XEXP (addr, 1)))
+	{
+	  tmpaddend = INTVAL (XEXP (addr, 1));
+	  addr = XEXP (addr, 0);
+	}
+      else
+	return false;
+    }
+  else
+    if (GET_CODE (addr) != SYMBOL_REF)
+	return false;
 
-      if ((reload_completed || reload_in_progress)
-	  ? !offsettable_memref_p (op) : !offsettable_nonstrict_memref_p (op))
-	return 0;
+  if (symref)
+    *symref = addr;
+  if (addend)
+    *addend = tmpaddend;
+
+  return true;
+}
 
-      c = str[1];
-    }
 
-  /* Check for non-literal-pool variants of memory constraints.  */
-  else if (c == 'B')
+/* Return true if the address in OP is valid for constraint letter C
+   if wrapped in a MEM rtx.  Set LIT_POOL_OK to true if it literal
+   pool MEMs should be accepted.  Only the Q, R, S, T constraint
+   letters are allowed for C.  */
+
+static int
+s390_check_qrst_address (char c, rtx op, bool lit_pool_ok)
+{
+  struct s390_address addr;
+  bool decomposed = false;
+
+  /* This check makes sure that no symbolic address (except literal
+     pool references) are accepted by the R or T constraints.  */
+  if (s390_symref_operand_p (op, NULL, NULL))
     {
-      if (GET_CODE (op) != MEM)
+      if (!lit_pool_ok)
 	return 0;
-      if (!s390_decompose_address (XEXP (op, 0), &addr))
+      if (!s390_decompose_address (op, &addr))
 	return 0;
-      if (addr.literal_pool)
+      if (!addr.literal_pool)
 	return 0;
-
-      c = str[1];
+      decomposed = true;
     }
 
   switch (c)
     {
-    case 'Q':
-      if (GET_CODE (op) != MEM)
-	return 0;
-      if (!s390_decompose_address (XEXP (op, 0), &addr))
+    case 'Q': /* no index short displacement */
+      if (!decomposed && !s390_decompose_address (op, &addr))
 	return 0;
       if (addr.indx)
 	return 0;
-
-      if (TARGET_LONG_DISPLACEMENT)
-	{
-	  if (!s390_short_displacement (addr.disp))
-	    return 0;
-	}
-      break;
-
-    case 'R':
-      if (GET_CODE (op) != MEM)
+      if (!s390_short_displacement (addr.disp))
 	return 0;
+      break;
 
+    case 'R': /* with index short displacement */
       if (TARGET_LONG_DISPLACEMENT)
 	{
-	  if (!s390_decompose_address (XEXP (op, 0), &addr))
+	  if (!decomposed && !s390_decompose_address (op, &addr))
 	    return 0;
 	  if (!s390_short_displacement (addr.disp))
 	    return 0;
 	}
+      /* Any invalid address here will be fixed up by reload,
+	 so accept it for the most generic constraint.  */
       break;
 
-    case 'S':
+    case 'S': /* no index long displacement */
       if (!TARGET_LONG_DISPLACEMENT)
 	return 0;
-      if (GET_CODE (op) != MEM)
-	return 0;
-      if (!s390_decompose_address (XEXP (op, 0), &addr))
+      if (!decomposed && !s390_decompose_address (op, &addr))
 	return 0;
       if (addr.indx)
 	return 0;
@@ -2126,52 +2154,74 @@
 	return 0;
       break;
 
-    case 'T':
+    case 'T': /* with index long displacement */
       if (!TARGET_LONG_DISPLACEMENT)
 	return 0;
-      if (GET_CODE (op) != MEM)
-	return 0;
-      if (!s390_decompose_address (XEXP (op, 0), &addr))
-	return 0;
-      if (s390_short_displacement (addr.disp))
+      /* Any invalid address here will be fixed up by reload,
+	 so accept it for the most generic constraint.  */
+      if ((decomposed || s390_decompose_address (op, &addr))
+	  && s390_short_displacement (addr.disp))
 	return 0;
       break;
+    default:
+      return 0;
+    }
+  return 1;
+}
 
-    case 'U':
-      if (TARGET_LONG_DISPLACEMENT)
-	{
-	  if (!s390_decompose_address (op, &addr))
-	    return 0;
-	  if (!s390_short_displacement (addr.disp))
-	    return 0;
-	}
-      break;
 
-    case 'W':
-      if (!TARGET_LONG_DISPLACEMENT)
+/* Evaluates constraint strings described by the regular expression
+   ([A|B|Z](Q|R|S|T))|U|W|Y and returns 1 if OP is a valid operand for
+   the constraint given in STR, or 0 else.  */
+
+int
+s390_mem_constraint (const char *str, rtx op)
+{
+  char c = str[0];
+
+  switch (c)
+    {
+    case 'A':
+      /* Check for offsettable variants of memory constraints.  */
+      if (!MEM_P (op) || MEM_VOLATILE_P (op))
 	return 0;
-      if (!s390_decompose_address (op, &addr))
+      if ((reload_completed || reload_in_progress)
+	  ? !offsettable_memref_p (op) : !offsettable_nonstrict_memref_p (op))
 	return 0;
-      if (s390_short_displacement (addr.disp))
+      return s390_check_qrst_address (str[1], XEXP (op, 0), true);
+    case 'B':
+      /* Check for non-literal-pool variants of memory constraints.  */
+      if (!MEM_P (op))
 	return 0;
-      break;
-
+      return s390_check_qrst_address (str[1], XEXP (op, 0), false);
+    case 'Q':
+    case 'R':
+    case 'S':
+    case 'T':
+      if (GET_CODE (op) != MEM)
+	return 0;
+      return s390_check_qrst_address (c, XEXP (op, 0), true);
+    case 'U':
+      return (s390_check_qrst_address ('Q', op, true)
+	      || s390_check_qrst_address ('R', op, true));
+    case 'W':
+      return (s390_check_qrst_address ('S', op, true)
+	      || s390_check_qrst_address ('T', op, true));
     case 'Y':
       /* Simply check for the basic form of a shift count.  Reload will
 	 take care of making sure we have a proper base register.  */
       if (!s390_decompose_shift_count (op, NULL, NULL))
 	return 0;
       break;
-
+    case 'Z':
+      return s390_check_qrst_address (str[1], op, true);
     default:
       return 0;
     }
-
   return 1;
 }
 
 
-
 /* Evaluates constraint strings starting with letter O.  Input
    parameter C is the second letter following the "O" in the constraint
    string. Returns 1 if VALUE meets the respective constraint and 0
@@ -2789,41 +2839,6 @@
   return rclass;
 }
 
-/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int
-   and return these parts in SYMREF and ADDEND.  You can pass NULL in
-   SYMREF and/or ADDEND if you are not interested in these values.  */
-
-static bool
-s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)
-{
-  HOST_WIDE_INT tmpaddend = 0;
-
-  if (GET_CODE (addr) == CONST)
-    addr = XEXP (addr, 0);
-
-  if (GET_CODE (addr) == PLUS)
-    {
-      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF
-	  && CONST_INT_P (XEXP (addr, 1)))
-	{
-	  tmpaddend = INTVAL (XEXP (addr, 1));
-	  addr = XEXP (addr, 0);
-	}
-      else
-	return false;
-    }
-  else
-    if (GET_CODE (addr) != SYMBOL_REF)
-	return false;
-
-  if (symref)
-    *symref = addr;
-  if (addend)
-    *addend = tmpaddend;
-
-  return true;
-}
-
 /* Return true if ADDR is SYMBOL_REF + addend with addend being a
    multiple of ALIGNMENT and the SYMBOL_REF being naturally
    aligned.  */
@@ -5276,6 +5291,7 @@
    A STD instruction should be scheduled earlier,
    in order to use the bypass.  */
 
+
 static int
 s390_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)
 {
@@ -5283,7 +5299,8 @@
     return priority;
 
   if (s390_tune != PROCESSOR_2084_Z990
-      && s390_tune != PROCESSOR_2094_Z9_109)
+      && s390_tune != PROCESSOR_2094_Z9_109
+      && s390_tune != PROCESSOR_2097_Z10)
     return priority;
 
   switch (s390_safe_attr_type (insn))
@@ -5302,6 +5319,7 @@
   return priority;
 }
 
+
 /* The number of instructions that can be issued per cycle.  */
 
 static int
@@ -9589,6 +9607,66 @@
     }
 }
 
+/* On z10 the dynamic branch prediction must see the backward jump in
+   a window of 384 bytes. If not it falls back to the static
+   prediction.  This function rearranges the loop backward branch in a
+   way which makes the static prediction always correct.  The function
+   returns true if it added an instruction.  */
+static bool
+s390_z10_fix_long_loop_prediction (rtx insn)
+{
+  rtx set = single_set (insn);
+  rtx code_label, label_ref, new_label;
+  rtx uncond_jump;
+  rtx cur_insn;
+  rtx tmp;
+  int distance;
+
+  /* This will exclude branch on count and branch on index patterns
+     since these are correctly statically predicted.  */
+  if (!set
+      || SET_DEST (set) != pc_rtx
+      || GET_CODE (SET_SRC(set)) != IF_THEN_ELSE)
+    return false;
+
+  label_ref = (GET_CODE (XEXP (SET_SRC (set), 1)) == LABEL_REF ?
+	       XEXP (SET_SRC (set), 1) : XEXP (SET_SRC (set), 2));
+
+  gcc_assert (GET_CODE (label_ref) == LABEL_REF);
+
+  code_label = XEXP (label_ref, 0);
+
+  if (INSN_ADDRESSES (INSN_UID (code_label)) == -1
+      || INSN_ADDRESSES (INSN_UID (insn)) == -1
+      || (INSN_ADDRESSES (INSN_UID (insn))
+	  - INSN_ADDRESSES (INSN_UID (code_label)) < Z10_PREDICT_DISTANCE))
+    return false;
+
+  for (distance = 0, cur_insn = PREV_INSN (insn);
+       distance < Z10_PREDICT_DISTANCE - 6;
+       distance += get_attr_length (cur_insn), cur_insn = PREV_INSN (cur_insn))
+    if (!cur_insn || JUMP_P (cur_insn) || LABEL_P (cur_insn))
+      return false;
+
+  new_label = gen_label_rtx ();
+  uncond_jump = emit_jump_insn_after (
+		  gen_rtx_SET (VOIDmode, pc_rtx,
+			       gen_rtx_LABEL_REF (VOIDmode, code_label)),
+		  insn);
+  emit_label_after (new_label, uncond_jump);
+
+  tmp = XEXP (SET_SRC (set), 1);
+  XEXP (SET_SRC (set), 1) = XEXP (SET_SRC (set), 2);
+  XEXP (SET_SRC (set), 2) = tmp;
+  INSN_CODE (insn) = -1;
+
+  XEXP (label_ref, 0) = new_label;
+  JUMP_LABEL (insn) = new_label;
+  JUMP_LABEL (uncond_jump) = code_label;
+
+  return true;
+}
+
 /* Returns 1 if INSN reads the value of REG for purposes not related
    to addressing of memory, and 0 otherwise.  */
 static int
@@ -9671,97 +9749,87 @@
    if that register's value is delivered via a bypass, then the
    pipeline recycles, thereby causing significant performance decline.
    This function locates such situations and exchanges the two
-   operands of the compare.  */
-static void
-s390_z10_optimize_cmp (void)
+   operands of the compare.  The function return true whenever it
+   added an insn.  */
+static bool
+s390_z10_optimize_cmp (rtx insn)
 {
-  rtx insn, prev_insn, next_insn;
-  int added_NOPs = 0;
+  rtx prev_insn, next_insn;
+  bool insn_added_p = false;
+  rtx cond, *op0, *op1;
 
-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+  if (GET_CODE (PATTERN (insn)) == PARALLEL)
     {
-      rtx cond, *op0, *op1;
-
-      if (!INSN_P (insn) || INSN_CODE (insn) <= 0)
-	continue;
-
-      if (GET_CODE (PATTERN (insn)) == PARALLEL)
-	{
-	  /* Handle compare and branch and branch on count
-	     instructions.  */
-	  rtx pattern = single_set (insn);
-
-	  if (!pattern
-	      || SET_DEST (pattern) != pc_rtx
-	      || GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)
-	    continue;
+      /* Handle compare and branch and branch on count
+	 instructions.  */
+      rtx pattern = single_set (insn);
+
+      if (!pattern
+	  || SET_DEST (pattern) != pc_rtx
+	  || GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)
+	return false;
 
-	  cond = XEXP (SET_SRC (pattern), 0);
-	  op0 = &XEXP (cond, 0);
-	  op1 = &XEXP (cond, 1);
-	}
-      else if (GET_CODE (PATTERN (insn)) == SET)
-	{
-	  rtx src, dest;
+      cond = XEXP (SET_SRC (pattern), 0);
+      op0 = &XEXP (cond, 0);
+      op1 = &XEXP (cond, 1);
+    }
+  else if (GET_CODE (PATTERN (insn)) == SET)
+    {
+      rtx src, dest;
 
-	  /* Handle normal compare instructions.  */
-	  src = SET_SRC (PATTERN (insn));
-	  dest = SET_DEST (PATTERN (insn));
+      /* Handle normal compare instructions.  */
+      src = SET_SRC (PATTERN (insn));
+      dest = SET_DEST (PATTERN (insn));
 
-	  if (!REG_P (dest)
-	      || !CC_REGNO_P (REGNO (dest))
-	      || GET_CODE (src) != COMPARE)
-	    continue;
+      if (!REG_P (dest)
+	  || !CC_REGNO_P (REGNO (dest))
+	  || GET_CODE (src) != COMPARE)
+	return false;
 
-	  /* s390_swap_cmp will try to find the conditional
-	     jump when passing NULL_RTX as condition.  */
-	  cond = NULL_RTX;
-	  op0 = &XEXP (src, 0);
-	  op1 = &XEXP (src, 1);
-	}
-      else
-	continue;
+      /* s390_swap_cmp will try to find the conditional
+	 jump when passing NULL_RTX as condition.  */
+      cond = NULL_RTX;
+      op0 = &XEXP (src, 0);
+      op1 = &XEXP (src, 1);
+    }
+  else
+    return false;
 
-      if (!REG_P (*op0) || !REG_P (*op1))
-	continue;
+  if (!REG_P (*op0) || !REG_P (*op1))
+    return false;
 
-      /* Swap the COMPARE arguments and its mask if there is a
-	 conflicting access in the previous insn.  */
-      prev_insn = PREV_INSN (insn);
+  /* Swap the COMPARE arguments and its mask if there is a
+     conflicting access in the previous insn.  */
+  prev_insn = PREV_INSN (insn);
+  if (prev_insn != NULL_RTX && INSN_P (prev_insn)
+      && reg_referenced_p (*op1, PATTERN (prev_insn)))
+    s390_swap_cmp (cond, op0, op1, insn);
+
+  /* Check if there is a conflict with the next insn. If there
+     was no conflict with the previous insn, then swap the
+     COMPARE arguments and its mask.  If we already swapped
+     the operands, or if swapping them would cause a conflict
+     with the previous insn, issue a NOP after the COMPARE in
+     order to separate the two instuctions.  */
+  next_insn = NEXT_INSN (insn);
+  if (next_insn != NULL_RTX && INSN_P (next_insn)
+      && s390_non_addr_reg_read_p (*op1, next_insn))
+    {
       if (prev_insn != NULL_RTX && INSN_P (prev_insn)
-	  && reg_referenced_p (*op1, PATTERN (prev_insn)))
-	s390_swap_cmp (cond, op0, op1, insn);
-
-      /* Check if there is a conflict with the next insn. If there
-	 was no conflict with the previous insn, then swap the
-	 COMPARE arguments and its mask.  If we already swapped
-	 the operands, or if swapping them would cause a conflict
-	 with the previous insn, issue a NOP after the COMPARE in
-	 order to separate the two instuctions.  */
-      next_insn = NEXT_INSN (insn);
-      if (next_insn != NULL_RTX && INSN_P (next_insn)
-	  && s390_non_addr_reg_read_p (*op1, next_insn))
+	  && s390_non_addr_reg_read_p (*op0, prev_insn))
 	{
-	  if (prev_insn != NULL_RTX && INSN_P (prev_insn)
-	      && s390_non_addr_reg_read_p (*op0, prev_insn))
-	    {
-	      if (REGNO (*op1) == 0)
-		emit_insn_after (gen_nop1 (), insn);
-	      else
-		emit_insn_after (gen_nop (), insn);
-	      added_NOPs = 1;
-	    }
+	  if (REGNO (*op1) == 0)
+	    emit_insn_after (gen_nop1 (), insn);
 	  else
-	    s390_swap_cmp (cond, op0, op1, insn);
+	    emit_insn_after (gen_nop (), insn);
+	  insn_added_p = true;
 	}
+      else
+	s390_swap_cmp (cond, op0, op1, insn);
     }
-
-  /* Adjust branches if we added new instructions.  */
-  if (added_NOPs)
-    shorten_branches (get_insns ());
+  return insn_added_p;
 }
 
-
 /* Perform machine-dependent processing.  */
 
 static void
@@ -9872,10 +9940,33 @@
   /* Try to optimize prologue and epilogue further.  */
   s390_optimize_prologue ();
 
-  /* Eliminate z10-specific pipeline recycles related to some compare
-     instructions.  */
+  /* Walk over the insns and do some z10 specific changes.  */
   if (s390_tune == PROCESSOR_2097_Z10)
-    s390_z10_optimize_cmp ();
+    {
+      rtx insn;
+      bool insn_added_p = false;
+
+      /* The insn lengths and addresses have to be up to date for the
+	 following manipulations.  */
+      shorten_branches (get_insns ());
+
+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+	{
+	  if (!INSN_P (insn) || INSN_CODE (insn) <= 0)
+	    continue;
+
+	  if (JUMP_P (insn))
+	    insn_added_p |= s390_z10_fix_long_loop_prediction (insn);
+
+	  if (GET_CODE (PATTERN (insn)) == PARALLEL
+	      || GET_CODE (PATTERN (insn)) == SET)
+	    insn_added_p |= s390_z10_optimize_cmp (insn);
+	}
+
+      /* Adjust branches if we added new instructions.  */
+      if (insn_added_p)
+	shorten_branches (get_insns ());
+    }
 }
 
 
diff -Naur gcc-4.4.1.orig/gcc/config/s390/s390.md gcc-4.4.1/gcc/config/s390/s390.md
--- gcc-4.4.1.orig/gcc/config/s390/s390.md	2009-06-15 02:27:22.000000000 -0700
+++ gcc-4.4.1/gcc/config/s390/s390.md	2009-09-04 03:05:45.000000000 -0700
@@ -202,7 +202,7 @@
 (define_attr "type" "none,integer,load,lr,la,larl,lm,stm,
 	             cs,vs,store,sem,idiv,
                      imulhi,imulsi,imuldi,
-		     branch,jsr,fsimptf,fsimpdf,fsimpsf,
+		     branch,jsr,fsimptf,fsimpdf,fsimpsf,fhex,
 		     floadtf,floaddf,floadsf,fstoredf,fstoresf,
 		     fmultf,fmuldf,fmulsf,fdivtf,fdivdf,fdivsf,
 		     ftoi,fsqrttf,fsqrtdf,fsqrtsf,
@@ -1076,6 +1076,64 @@
                       (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg
                                                        ; 10 byte for clgr/jg
 
+; And now the same two patterns as above but with a negated CC mask.
+
+; cij, cgij, crj, cgrj, cfi, cgfi, cr, cgr
+; The following instructions do a complementary access of their second
+; operand (z01 only): crj_c, cgrjc, cr, cgr
+(define_insn "*icmp_and_br_signed_<mode>"
+  [(set (pc)
+	(if_then_else (match_operator 0 "s390_signed_integer_comparison"
+			[(match_operand:GPR 1 "register_operand"  "d,d")
+			 (match_operand:GPR 2 "nonmemory_operand" "d,C")])
+		      (pc)
+		      (label_ref (match_operand 3 "" ""))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10"
+{
+  if (get_attr_length (insn) == 6)
+    return which_alternative ?
+      "c<g>ij%D0\t%1,%c2,%l3" : "c<g>rj%D0\t%1,%2,%l3";
+  else
+    return which_alternative ?
+      "c<g>fi\t%1,%c2\;jg%D0\t%l3" : "c<g>r\t%1,%2\;jg%D0\t%l3";
+}
+  [(set_attr "op_type" "RIE")
+   (set_attr "type"    "branch")
+   (set_attr "z10prop" "z10_super_c,z10_super")
+   (set (attr "length")
+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))
+                      (const_int 6) (const_int 12)))]) ; 8 byte for cr/jg
+                                                       ; 10 byte for cgr/jg
+
+; clij, clgij, clrj, clgrj, clfi, clgfi, clr, clgr
+; The following instructions do a complementary access of their second
+; operand (z10 only): clrj, clgrj, clr, clgr
+(define_insn "*icmp_and_br_unsigned_<mode>"
+  [(set (pc)
+	(if_then_else (match_operator 0 "s390_unsigned_integer_comparison"
+			[(match_operand:GPR 1 "register_operand"  "d,d")
+			 (match_operand:GPR 2 "nonmemory_operand" "d,I")])
+		      (pc)
+		      (label_ref (match_operand 3 "" ""))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_Z10"
+{
+  if (get_attr_length (insn) == 6)
+    return which_alternative ?
+      "cl<g>ij%D0\t%1,%b2,%l3" : "cl<g>rj%D0\t%1,%2,%l3";
+  else
+    return which_alternative ?
+      "cl<g>fi\t%1,%b2\;jg%D0\t%l3" : "cl<g>r\t%1,%2\;jg%D0\t%l3";
+}
+  [(set_attr "op_type" "RIE")
+   (set_attr "type"    "branch")
+   (set_attr "z10prop" "z10_super_c,z10_super")
+   (set (attr "length")
+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))
+                      (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg
+                                                       ; 10 byte for clgr/jg
+
 ;;
 ;;- Move instructions.
 ;;
@@ -1470,7 +1528,7 @@
 
 (define_insn "*la_64"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
-        (match_operand:QI 1 "address_operand" "U,W"))]
+        (match_operand:QI 1 "address_operand" "ZQZR,ZSZT"))]
   "TARGET_64BIT"
   "@
    la\t%0,%a1
@@ -1653,7 +1711,7 @@
 
 (define_insn "*la_31"
   [(set (match_operand:SI 0 "register_operand" "=d,d")
-        (match_operand:QI 1 "address_operand" "U,W"))]
+        (match_operand:QI 1 "address_operand" "ZQZR,ZSZT"))]
   "!TARGET_64BIT && legitimate_la_operand_p (operands[1])"
   "@
    la\t%0,%a1
@@ -1688,7 +1746,7 @@
 
 (define_insn "*la_31_and"
   [(set (match_operand:SI 0 "register_operand" "=d,d")
-        (and:SI (match_operand:QI 1 "address_operand" "U,W")
+        (and:SI (match_operand:QI 1 "address_operand" "ZQZR,ZSZT")
                 (const_int 2147483647)))]
   "!TARGET_64BIT"
   "@
@@ -1714,7 +1772,7 @@
 
 (define_insn "force_la_31"
   [(set (match_operand:SI 0 "register_operand" "=d,d")
-        (match_operand:QI 1 "address_operand" "U,W"))
+        (match_operand:QI 1 "address_operand" "ZQZR,ZSZT"))
    (use (const_int 0))]
   "!TARGET_64BIT"
   "@
@@ -1909,7 +1967,7 @@
    #
    #"
   [(set_attr "op_type" "RRE,RRE,*,*,RSY,RSY,*,*")
-   (set_attr "type"    "fsimptf,fsimptf,*,*,lm,stm,*,*")])
+   (set_attr "type"    "fhex,fsimptf,*,*,lm,stm,*,*")])
 
 (define_insn "*mov<mode>_31"
   [(set (match_operand:TD_TF 0 "nonimmediate_operand" "=f,f,f,o")
@@ -1921,7 +1979,7 @@
    #
    #"
   [(set_attr "op_type" "RRE,RRE,*,*")
-   (set_attr "type"    "fsimptf,fsimptf,*,*")])
+   (set_attr "type"    "fhex,fsimptf,*,*")])
 
 ; TFmode in GPRs splitters
 
@@ -2029,7 +2087,7 @@
    lg\t%0,%1
    stg\t%1,%0"
   [(set_attr "op_type" "RRE,RR,RRE,RRE,RX,RXY,RX,RXY,RRE,RXY,RXY")
-   (set_attr "type" "fsimpdf,floaddf,floaddf,floaddf,floaddf,floaddf,
+   (set_attr "type" "fhex,floaddf,floaddf,floaddf,floaddf,floaddf,
                      fstoredf,fstoredf,lr,load,store")
    (set_attr "z10prop" "*,
                         *,
@@ -2059,7 +2117,7 @@
    lg\t%0,%1
    stg\t%1,%0"
   [(set_attr "op_type" "RRE,RR,RX,RXY,RX,RXY,RRE,RXY,RXY")
-   (set_attr "type" "fsimp<mode>,fload<mode>,fload<mode>,fload<mode>,
+   (set_attr "type" "fhex,fload<mode>,fload<mode>,fload<mode>,
                      fstore<mode>,fstore<mode>,lr,load,store")
    (set_attr "z10prop" "*,
                         *,
@@ -2091,7 +2149,7 @@
    #
    #"
   [(set_attr "op_type" "RRE,RR,RX,RXY,RX,RXY,RS,RSY,RS,RSY,*,*")
-   (set_attr "type" "fsimp<mode>,fload<mode>,fload<mode>,fload<mode>,
+   (set_attr "type" "fhex,fload<mode>,fload<mode>,fload<mode>,
                      fstore<mode>,fstore<mode>,lm,lm,stm,stm,*,*")])
 
 (define_split
@@ -2158,7 +2216,7 @@
    st\t%1,%0
    sty\t%1,%0"
   [(set_attr "op_type" "RRE,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY")
-   (set_attr "type" "fsimp<mode>,fload<mode>,fload<mode>,fload<mode>,
+   (set_attr "type" "fhex,fload<mode>,fload<mode>,fload<mode>,
                      fstore<mode>,fstore<mode>,lr,load,load,store,store")
    (set_attr "z10prop" "*,
                         *,
@@ -7407,7 +7465,7 @@
   [(set (pc)
         (if_then_else
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
-          (match_operand 0 "address_operand" "U")
+          (match_operand 0 "address_operand" "ZQZR")
           (pc)))]
   ""
 {
@@ -7471,7 +7529,7 @@
         (if_then_else
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (pc)
-          (match_operand 0 "address_operand" "U")))]
+          (match_operand 0 "address_operand" "ZQZR")))]
   ""
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
@@ -7660,7 +7718,7 @@
         (if_then_else
           (ne (match_operand:SI 1 "register_operand" "d")
               (const_int 1))
-          (match_operand 0 "address_operand" "U")
+          (match_operand 0 "address_operand" "ZQZR")
           (pc)))
    (set (match_operand:SI 2 "register_operand" "=1")
         (plus:SI (match_dup 1) (const_int -1)))
@@ -7771,7 +7829,7 @@
 ;
 
 (define_insn "indirect_jump"
- [(set (pc) (match_operand 0 "address_operand" "U"))]
+ [(set (pc) (match_operand 0 "address_operand" "ZQZR"))]
   ""
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
@@ -7790,7 +7848,7 @@
 ;
 
 (define_insn "casesi_jump"
- [(set (pc) (match_operand 0 "address_operand" "U"))
+ [(set (pc) (match_operand 0 "address_operand" "ZQZR"))
    (use (label_ref (match_operand 1 "" "")))]
   ""
 {
@@ -8012,7 +8070,7 @@
    (set_attr "type"    "jsr")])
 
 (define_insn "*basr"
-  [(call (mem:QI (match_operand 0 "address_operand" "U"))
+  [(call (mem:QI (match_operand 0 "address_operand" "ZQZR"))
          (match_operand 1 "const_int_operand" "n"))
    (clobber (match_operand 2 "register_operand" "=r"))]
   "!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode"
@@ -8070,7 +8128,7 @@
 
 (define_insn "*basr_r"
   [(set (match_operand 0 "" "")
-        (call (mem:QI (match_operand 1 "address_operand" "U"))
+        (call (mem:QI (match_operand 1 "address_operand" "ZQZR"))
               (match_operand 2 "const_int_operand" "n")))
    (clobber (match_operand 3 "register_operand" "=r"))]
   "!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode"
@@ -8170,7 +8228,7 @@
 
 (define_insn "*basr_tls"
   [(set (match_operand 0 "" "")
-        (call (mem:QI (match_operand 1 "address_operand" "U"))
+        (call (mem:QI (match_operand 1 "address_operand" "ZQZR"))
               (match_operand 2 "const_int_operand" "n")))
    (clobber (match_operand 3 "register_operand" "=r"))
    (use (match_operand 4 "" ""))]
@@ -8720,27 +8778,32 @@
 ;
 
 (define_insn "prefetch"
-  [(prefetch (match_operand 0 "address_operand" "UW,X")
-	     (match_operand:SI 1 "const_int_operand" "n,n")
-	     (match_operand:SI 2 "const_int_operand" "n,n"))]
-  "TARGET_Z10"
+  [(prefetch (match_operand 0    "address_operand"   "ZQZS,ZRZT,X")
+	     (match_operand:SI 1 "const_int_operand" "   n,   n,n")
+	     (match_operand:SI 2 "const_int_operand" "   n,   n,n"))]
+  "TARGET_ZARCH && s390_tune == PROCESSOR_2097_Z10"
 {
-  if (larl_operand (operands[0], Pmode))
-    return INTVAL (operands[1]) == 1 ? "pfdrl\t2,%a0" : "pfdrl\t1,%a0";
+  switch (which_alternative)
+    {
+      case 0:
+        return INTVAL (operands[1]) == 1 ? "stcmh\t2,0,%a0" : "stcmh\t1,0,%a0";
+      case 1:
+        return INTVAL (operands[1]) == 1 ? "pfd\t2,%a0" : "pfd\t1,%a0";
+      case 2:
+        if (larl_operand (operands[0], Pmode))
+	  return INTVAL (operands[1]) == 1 ? "pfdrl\t2,%a0" : "pfdrl\t1,%a0";
+      default:
 
-  if (s390_mem_constraint ("W", operands[0])
-      || s390_mem_constraint ("U", operands[0]))
-    return INTVAL (operands[1]) == 1 ? "pfd\t2,%a0" : "pfd\t1,%a0";
-
-  /* This point might be reached if op0 is a larl operand with an
-     uneven addend.  In this case we simply omit issuing a prefetch
-     instruction.  */
+        /* This might be reached for symbolic operands with an odd
+           addend.  We simply omit the prefetch for such rare cases.  */
 
-  return "";
+        return "";
+     }
 }
-  [(set_attr "type" "load,larl")
-   (set_attr "op_type" "RXY,RIL")
-   (set_attr "z10prop" "z10_super")])
+  [(set_attr "type" "store,load,larl")
+   (set_attr "op_type" "RSY,RXY,RIL")
+   (set_attr "z10prop" "z10_super")
+   (set_attr "cpu_facility" "*,z10,z10")])
 
 
 ;
diff -Naur gcc-4.4.1.orig/gcc/cp/call.c gcc-4.4.1/gcc/cp/call.c
--- gcc-4.4.1.orig/gcc/cp/call.c	2009-07-12 23:06:27.000000000 -0700
+++ gcc-4.4.1/gcc/cp/call.c	2009-07-24 11:06:08.000000000 -0700
@@ -1211,7 +1211,21 @@
       lvalue_p = clk_ordinary;
       from = TREE_TYPE (from);
     }
-  else if (expr)
+
+  if (expr && BRACE_ENCLOSED_INITIALIZER_P (expr))
+    {
+      maybe_warn_cpp0x ("extended initializer lists");
+      conv = implicit_conversion (to, from, expr, c_cast_p,
+				  flags);
+      if (!CLASS_TYPE_P (to)
+	  && CONSTRUCTOR_NELTS (expr) == 1)
+	{
+	  expr = CONSTRUCTOR_ELT (expr, 0)->value;
+	  from = TREE_TYPE (expr);
+	}
+    }
+
+  if (lvalue_p == clk_none && expr)
     lvalue_p = real_lvalue_p (expr);
 
   tfrom = from;
@@ -1347,8 +1361,9 @@
      conversion operator).  */
   flags |= LOOKUP_NO_TEMP_BIND;
 
-  conv = implicit_conversion (to, from, expr, c_cast_p,
-			      flags);
+  if (!conv)
+    conv = implicit_conversion (to, from, expr, c_cast_p,
+				flags);
   if (!conv)
     return NULL;
 
@@ -6242,6 +6257,14 @@
   ref_conv1 = maybe_handle_ref_bind (&ics1);
   ref_conv2 = maybe_handle_ref_bind (&ics2);
 
+  /* List-initialization sequence L1 is a better conversion sequence than
+     list-initialization sequence L2 if L1 converts to
+     std::initializer_list<X> for some X and L2 does not.  */
+  if (ics1->kind == ck_list && ics2->kind != ck_list)
+    return 1;
+  if (ics2->kind == ck_list && ics1->kind != ck_list)
+    return -1;
+
   /* [over.ics.rank]
 
      When  comparing  the  basic forms of implicit conversion sequences (as
@@ -6292,26 +6315,13 @@
       conversion *t1;
       conversion *t2;
 
-      for (t1 = ics1; t1->kind != ck_user && t1->kind != ck_list; t1 = t1->u.next)
+      for (t1 = ics1; t1->kind != ck_user; t1 = t1->u.next)
 	if (t1->kind == ck_ambig || t1->kind == ck_aggr)
 	  return 0;
-      for (t2 = ics2; t2->kind != ck_user && t2->kind != ck_list; t2 = t2->u.next)
+      for (t2 = ics2; t2->kind != ck_user; t2 = t2->u.next)
 	if (t2->kind == ck_ambig || t2->kind == ck_aggr)
 	  return 0;
 
-      /* Conversion to std::initializer_list is better than other
-	 user-defined conversions.  */
-      if (t1->kind == ck_list
-	  || t2->kind == ck_list)
-	{
-	  if (t2->kind != ck_list)
-	    return 1;
-	  else if (t1->kind != ck_list)
-	    return -1;
-	  else
-	    return 0;
-	}
-
       if (t1->cand->fn != t2->cand->fn)
 	return 0;
 
@@ -7288,6 +7298,7 @@
   if (!conv || conv->bad_p)
     {
       if (!(TYPE_QUALS (TREE_TYPE (type)) & TYPE_QUAL_CONST)
+	  && !TYPE_REF_IS_RVALUE (type)
 	  && !real_lvalue_p (expr))
 	error ("invalid initialization of non-const reference of "
 	       "type %qT from a temporary of type %qT",
diff -Naur gcc-4.4.1.orig/gcc/cp/decl.c gcc-4.4.1/gcc/cp/decl.c
--- gcc-4.4.1.orig/gcc/cp/decl.c	2009-07-07 15:08:01.000000000 -0700
+++ gcc-4.4.1/gcc/cp/decl.c	2009-07-26 09:05:22.000000000 -0700
@@ -4345,13 +4345,6 @@
       return NULL_TREE;
     }
 
-  if (TREE_CODE (init) == CONSTRUCTOR)
-    {
-      error ("ISO C++ forbids use of initializer list to "
-	     "initialize reference %qD", decl);
-      return NULL_TREE;
-    }
-
   if (TREE_CODE (init) == TREE_LIST)
     init = build_x_compound_expr_from_list (init, "initializer");
 
@@ -7618,7 +7611,6 @@
   bool unsigned_p, signed_p, short_p, long_p, thread_p;
   bool type_was_error_mark_node = false;
   bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;
-  bool set_no_warning = false;
   bool template_type_arg = false;
 
   signed_p = declspecs->specs[(int)ds_signed];
@@ -8297,7 +8289,6 @@
 		/* We now know that the TYPE_QUALS don't apply to the
 		   decl, but to its return type.  */
 		type_quals = TYPE_UNQUALIFIED;
-		set_no_warning = true;
 	      }
 
 	    /* Error about some types functions can't return.  */
@@ -9499,9 +9490,6 @@
     if (!processing_template_decl)
       cp_apply_type_quals_to_decl (type_quals, decl);
 
-    if (set_no_warning)
-        TREE_NO_WARNING (decl) = 1;
-
     return decl;
   }
 }
diff -Naur gcc-4.4.1.orig/gcc/cp/error.c gcc-4.4.1/gcc/cp/error.c
--- gcc-4.4.1.orig/gcc/cp/error.c	2009-07-10 15:31:34.000000000 -0700
+++ gcc-4.4.1/gcc/cp/error.c	2009-08-04 05:28:27.000000000 -0700
@@ -2181,7 +2181,10 @@
     return decl_as_string (decl, TFF_DECL_SPECIFIERS);
 
   reinit_cxx_pp ();
-  if (v == 1 && DECL_CLASS_SCOPE_P (decl))
+  if (v == 1
+      && (DECL_CLASS_SCOPE_P (decl)
+	  || (DECL_NAMESPACE_SCOPE_P (decl)
+	      && CP_DECL_CONTEXT (decl) != global_namespace)))
     {
       dump_type (CP_DECL_CONTEXT (decl), TFF_PLAIN_IDENTIFIER);
       pp_cxx_colon_colon (cxx_pp);
diff -Naur gcc-4.4.1.orig/gcc/cp/init.c gcc-4.4.1/gcc/cp/init.c
--- gcc-4.4.1.orig/gcc/cp/init.c	2009-07-12 23:06:27.000000000 -0700
+++ gcc-4.4.1/gcc/cp/init.c	2009-08-06 10:22:19.000000000 -0700
@@ -2695,6 +2695,13 @@
     gcc_assert (!init);
 
   inner_elt_type = strip_array_types (type);
+
+  /* Look through the TARGET_EXPR around a compound literal.  */
+  if (init && TREE_CODE (init) == TARGET_EXPR
+      && TREE_CODE (TARGET_EXPR_INITIAL (init)) == CONSTRUCTOR
+      && from_array != 2)
+    init = TARGET_EXPR_INITIAL (init);
+
   if (init
       && TREE_CODE (atype) == ARRAY_TYPE
       && (from_array == 2
@@ -2763,6 +2770,17 @@
   base = get_temp_regvar (ptype, rval);
   iterator = get_temp_regvar (ptrdiff_type_node, maxindex);
 
+  /* If initializing one array from another, initialize element by
+     element.  We rely upon the below calls to do the argument
+     checking.  Evaluate the initializer before entering the try block.  */
+  if (from_array && init && TREE_CODE (init) != CONSTRUCTOR)
+    {
+      base2 = decay_conversion (init);
+      itype = TREE_TYPE (base2);
+      base2 = get_temp_regvar (itype, base2);
+      itype = TREE_TYPE (itype);
+    }
+
   /* Protect the entire array initialization so that we can destroy
      the partially constructed array if an exception is thrown.
      But don't do this if we're assigning.  */
@@ -2805,16 +2823,8 @@
     }
   else if (from_array)
     {
-      /* If initializing one array from another, initialize element by
-	 element.  We rely upon the below calls the do argument
-	 checking.  */
       if (init)
-	{
-	  base2 = decay_conversion (init);
-	  itype = TREE_TYPE (base2);
-	  base2 = get_temp_regvar (itype, base2);
-	  itype = TREE_TYPE (itype);
-	}
+	/* OK, we set base2 above.  */;
       else if (TYPE_LANG_SPECIFIC (type)
 	       && TYPE_NEEDS_CONSTRUCTING (type)
 	       && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))
diff -Naur gcc-4.4.1.orig/gcc/cp/Make-lang.in gcc-4.4.1/gcc/cp/Make-lang.in
--- gcc-4.4.1.orig/gcc/cp/Make-lang.in	2008-12-05 00:01:58.000000000 -0800
+++ gcc-4.4.1/gcc/cp/Make-lang.in	2009-09-09 01:46:32.000000000 -0700
@@ -72,8 +72,8 @@
 # Shared with C front end:
 CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \
 	c-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \
-	incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
-	c-gimplify.o c-omp.o tree-inline.o
+	incpath.o c-ppoutput.o c-cppbuiltin.o prefix.o \
+	c-gimplify.o c-omp.o
 
 # Language-specific object files for C++ and Objective C++.
 CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \
diff -Naur gcc-4.4.1.orig/gcc/cp/parser.c gcc-4.4.1/gcc/cp/parser.c
--- gcc-4.4.1.orig/gcc/cp/parser.c	2009-06-08 21:23:00.000000000 -0700
+++ gcc-4.4.1/gcc/cp/parser.c	2009-08-31 14:20:07.000000000 -0700
@@ -11871,11 +11871,19 @@
   else
     identifier = make_anon_name ();
 
-  /* Check for the `:' that denotes a specified underlying type in C++0x.  */
+  /* Check for the `:' that denotes a specified underlying type in C++0x.
+     Note that a ':' could also indicate a bitfield width, however.  */
   if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))
     {
       cp_decl_specifier_seq type_specifiers;
 
+      /* Consume the `:'.  */
+      cp_lexer_consume_token (parser->lexer);
+
+      /* Parse the type-specifier-seq.  */
+      cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+                                    &type_specifiers);
+
       /* At this point this is surely not elaborated type specifier.  */
       if (!cp_parser_parse_definitely (parser))
 	return NULL_TREE;
@@ -11883,15 +11891,8 @@
       if (cxx_dialect == cxx98)
         maybe_warn_cpp0x ("scoped enums");
 
-      /* Consume the `:'.  */
-      cp_lexer_consume_token (parser->lexer);
-
       has_underlying_type = true;
 
-      /* Parse the type-specifier-seq.  */
-      cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
-                                    &type_specifiers);
-
       /* If that didn't work, stop.  */
       if (type_specifiers.type != error_mark_node)
         {
diff -Naur gcc-4.4.1.orig/gcc/cp/pt.c gcc-4.4.1/gcc/cp/pt.c
--- gcc-4.4.1.orig/gcc/cp/pt.c	2009-07-09 11:00:58.000000000 -0700
+++ gcc-4.4.1/gcc/cp/pt.c	2009-08-04 12:59:48.000000000 -0700
@@ -8007,11 +8007,11 @@
       cp_function_chain->x_current_class_ref = saved_class_ref;
     }
 
-  pop_access_scope (fn);
-
   /* Make sure the default argument is reasonable.  */
   arg = check_default_argument (type, arg);
 
+  pop_access_scope (fn);
+
   return arg;
 }
 
diff -Naur gcc-4.4.1.orig/gcc/cp/tree.c gcc-4.4.1/gcc/cp/tree.c
--- gcc-4.4.1.orig/gcc/cp/tree.c	2009-07-12 23:06:27.000000000 -0700
+++ gcc-4.4.1/gcc/cp/tree.c	2009-08-21 00:10:36.000000000 -0700
@@ -132,6 +132,12 @@
       return clk_ordinary;
 
     case CONST_DECL:
+      /* CONST_DECL without TREE_STATIC are enumeration values and
+	 thus not lvalues.  With TREE_STATIC they are used by ObjC++
+	 in objc_build_string_object and need to be considered as
+	 lvalues.  */
+      if (! TREE_STATIC (ref))
+	return clk_none;
     case VAR_DECL:
       if (TREE_READONLY (ref) && ! TREE_STATIC (ref)
 	  && DECL_LANG_SPECIFIC (ref)
diff -Naur gcc-4.4.1.orig/gcc/DATESTAMP gcc-4.4.1/gcc/DATESTAMP
--- gcc-4.4.1.orig/gcc/DATESTAMP	2009-07-21 17:16:36.000000000 -0700
+++ gcc-4.4.1/gcc/DATESTAMP	2009-09-11 17:16:45.000000000 -0700
@@ -1 +1 @@
-20090722
+20090912
diff -Naur gcc-4.4.1.orig/gcc/doc/install.texi gcc-4.4.1/gcc/doc/install.texi
--- gcc-4.4.1.orig/gcc/doc/install.texi	2009-03-16 06:23:13.000000000 -0700
+++ gcc-4.4.1/gcc/doc/install.texi	2009-08-31 02:09:29.000000000 -0700
@@ -2463,7 +2463,7 @@
 @samp{make pdf} in place of @samp{make dvi}, you can create documentation
 in the form of @file{.pdf} files; this requires @command{texi2pdf}, which
 is included with Texinfo version 4.8 and later.  You can also
-@uref{http://www.gnu.org/order/order.html,,buy printed manuals from the
+@uref{http://shop.fsf.org/,,buy printed manuals from the
 Free Software Foundation}, though such manuals may not be for the most
 recent version of GCC@.
 
diff -Naur gcc-4.4.1.orig/gcc/doc/invoke.texi gcc-4.4.1/gcc/doc/invoke.texi
--- gcc-4.4.1.orig/gcc/doc/invoke.texi	2009-04-01 00:18:47.000000000 -0700
+++ gcc-4.4.1/gcc/doc/invoke.texi	2009-09-12 08:46:57.000000000 -0700
@@ -456,7 +456,7 @@
 -mfix-cortex-m3-ldrd}
 
 @emph{AVR Options}
-@gccoptlist{-mmcu=@var{mcu}  -msize  -minit-stack=@var{n}  -mno-interrupts @gol
+@gccoptlist{-mmcu=@var{mcu}  -msize  -mno-interrupts @gol
 -mcall-prologues  -mno-tablejump  -mtiny-stack  -mint8}
 
 @emph{Blackfin Options}
@@ -6513,7 +6513,7 @@
 
 @item -fstrict-aliasing
 @opindex fstrict-aliasing
-Allows the compiler to assume the strictest aliasing rules applicable to
+Allow the compiler to assume the strictest aliasing rules applicable to
 the language being compiled.  For C (and C++), this activates
 optimizations based on the type of expressions.  In particular, an
 object of one type is assumed never to reside at the same address as an
@@ -6530,7 +6530,7 @@
 @};
 
 int f() @{
-  a_union t;
+  union a_union t;
   t.d = 3.0;
   return t.i;
 @}
@@ -6543,7 +6543,7 @@
 implementation}.  However, this code might not:
 @smallexample
 int f() @{
-  a_union t;
+  union a_union t;
   int* ip;
   t.d = 3.0;
   ip = &t.i;
@@ -9277,11 +9277,6 @@
 @opindex msize
 Output instruction sizes to the asm file.
 
-@item -minit-stack=@var{N}
-@opindex minit-stack
-Specify the initial stack address, which may be a symbol or numeric value,
-@samp{__stack} is the default.
-
 @item -mno-interrupts
 @opindex mno-interrupts
 Generated code is not compatible with hardware interrupts.
diff -Naur gcc-4.4.1.orig/gcc/doc/service.texi gcc-4.4.1/gcc/doc/service.texi
--- gcc-4.4.1.orig/gcc/doc/service.texi	2002-12-30 13:07:17.000000000 -0800
+++ gcc-4.4.1/gcc/doc/service.texi	2009-08-27 17:01:08.000000000 -0700
@@ -21,7 +21,7 @@
 @item
 Look in the service directory for someone who might help you for a fee.
 The service directory is found at
-@uref{http://www.gnu.org/prep/service.html}.
+@uref{http://www.fsf.org/resources/service}.
 @end itemize
 
 For further information, see
diff -Naur gcc-4.4.1.orig/gcc/dse.c gcc-4.4.1/gcc/dse.c
--- gcc-4.4.1.orig/gcc/dse.c	2009-05-13 14:42:03.000000000 -0700
+++ gcc-4.4.1/gcc/dse.c	2009-08-05 05:54:21.000000000 -0700
@@ -1070,6 +1070,8 @@
 {
   rtx mem_address = XEXP (mem, 0);
   rtx expanded_address, address;
+  int expanded;
+
   /* Make sure that cselib is has initialized all of the operands of
      the address before asking it to do the subst.  */
 
@@ -1114,72 +1116,88 @@
       fprintf (dump_file, "\n");
     }
 
-  /* Use cselib to replace all of the reg references with the full
-     expression.  This will take care of the case where we have 
+  /* First see if just canon_rtx (mem_address) is const or frame,
+     if not, try cselib_expand_value_rtx and call canon_rtx on that.  */
+  address = NULL_RTX;
+  for (expanded = 0; expanded < 2; expanded++)
+    {
+      if (expanded)
+	{
+	  /* Use cselib to replace all of the reg references with the full
+	     expression.  This will take care of the case where we have 
 
-     r_x = base + offset;
-     val = *r_x;
+	     r_x = base + offset;
+	     val = *r_x;
    
-     by making it into 
-
-     val = *(base + offset);  
-  */
-
-  expanded_address = cselib_expand_value_rtx (mem_address, scratch, 5);
+	     by making it into 
 
-  /* If this fails, just go with the mem_address.  */
-  if (!expanded_address)
-    expanded_address = mem_address;
+	     val = *(base + offset);  */
 
-  /* Split the address into canonical BASE + OFFSET terms.  */
-  address = canon_rtx (expanded_address);
+	  expanded_address = cselib_expand_value_rtx (mem_address,
+						      scratch, 5);
 
-  *offset = 0;
+	  /* If this fails, just go with the address from first
+	     iteration.  */
+	  if (!expanded_address)
+	    break;
+	}
+      else
+	expanded_address = mem_address;
 
-  if (dump_file)
-    {
-      fprintf (dump_file, "\n   after cselib_expand address: ");
-      print_inline_rtx (dump_file, expanded_address, 0);
-      fprintf (dump_file, "\n");
+      /* Split the address into canonical BASE + OFFSET terms.  */
+      address = canon_rtx (expanded_address);
 
-      fprintf (dump_file, "\n   after canon_rtx address: ");
-      print_inline_rtx (dump_file, address, 0);
-      fprintf (dump_file, "\n");
-    }
+      *offset = 0;
 
-  if (GET_CODE (address) == CONST)
-    address = XEXP (address, 0);
+      if (dump_file)
+	{
+	  if (expanded)
+	    {
+	      fprintf (dump_file, "\n   after cselib_expand address: ");
+	      print_inline_rtx (dump_file, expanded_address, 0);
+	      fprintf (dump_file, "\n");
+	    }
 
-  if (GET_CODE (address) == PLUS && GET_CODE (XEXP (address, 1)) == CONST_INT)
-    {
-      *offset = INTVAL (XEXP (address, 1));
-      address = XEXP (address, 0);
-    }
+	  fprintf (dump_file, "\n   after canon_rtx address: ");
+	  print_inline_rtx (dump_file, address, 0);
+	  fprintf (dump_file, "\n");
+	}
 
-  if (const_or_frame_p (address))
-    {
-      group_info_t group = get_group_info (address);
+      if (GET_CODE (address) == CONST)
+	address = XEXP (address, 0);
 
-      if (dump_file)
-	fprintf (dump_file, "  gid=%d offset=%d \n", group->id, (int)*offset);
-      *base = NULL;
-      *group_id = group->id;
-    }
-  else
-    {
-      *base = cselib_lookup (address, Pmode, true);
-      *group_id = -1;
+      if (GET_CODE (address) == PLUS
+	  && GET_CODE (XEXP (address, 1)) == CONST_INT)
+	{
+	  *offset = INTVAL (XEXP (address, 1));
+	  address = XEXP (address, 0);
+	}
 
-      if (*base == NULL)
+      if (const_or_frame_p (address))
 	{
+	  group_info_t group = get_group_info (address);
+
 	  if (dump_file)
-	    fprintf (dump_file, " no cselib val - should be a wild read.\n");
-	  return false;
+	    fprintf (dump_file, "  gid=%d offset=%d \n",
+		     group->id, (int)*offset);
+	  *base = NULL;
+	  *group_id = group->id;
+	  return true;
 	}
+    }
+
+  *base = cselib_lookup (address, Pmode, true);
+  *group_id = -1;
+
+  if (*base == NULL)
+    {
       if (dump_file)
-	fprintf (dump_file, "  varying cselib base=%d offset = %d\n", 
-		 (*base)->value, (int)*offset);
+	fprintf (dump_file, " no cselib val - should be a wild read.\n");
+      return false;
     }
+  if (dump_file)
+    fprintf (dump_file, "  varying cselib base=%d offset = %d\n", 
+	     (*base)->value, (int)*offset);
   return true;
 }
 
diff -Naur gcc-4.4.1.orig/gcc/dwarf2out.c gcc-4.4.1/gcc/dwarf2out.c
--- gcc-4.4.1.orig/gcc/dwarf2out.c	2009-06-03 10:32:45.000000000 -0700
+++ gcc-4.4.1/gcc/dwarf2out.c	2009-08-16 02:07:40.000000000 -0700
@@ -14260,7 +14260,13 @@
 static void
 gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)
 {
-  tree decl = block_ultimate_origin (stmt);
+  tree decl;
+
+  /* The instance of function that is effectively being inlined shall not
+     be abstract.  */
+  gcc_assert (! BLOCK_ABSTRACT (stmt));
+
+  decl = block_ultimate_origin (stmt);
 
   /* Emit info for the abstract instance first, if we haven't yet.  We
      must emit this even if the block is abstract, otherwise when we
@@ -14281,20 +14287,6 @@
       decls_for_scope (stmt, subr_die, depth);
       current_function_has_inlines = 1;
     }
-  else
-    /* We may get here if we're the outer block of function A that was
-       inlined into function B that was inlined into function C.  When
-       generating debugging info for C, dwarf2out_abstract_function(B)
-       would mark all inlined blocks as abstract, including this one.
-       So, we wouldn't (and shouldn't) expect labels to be generated
-       for this one.  Instead, just emit debugging info for
-       declarations within the block.  This is particularly important
-       in the case of initializers of arguments passed from B to us:
-       if they're statement expressions containing declarations, we
-       wouldn't generate dies for their abstract variables, and then,
-       when generating dies for the real variables, we'd die (pun
-       intended :-)  */
-    gen_lexical_block_die (stmt, context_die, depth);
 }
 
 /* Generate a DIE for a field in a record, or structure.  */
@@ -14921,7 +14913,23 @@
   if (must_output_die)
     {
       if (inlined_func)
-	gen_inlined_subroutine_die (stmt, context_die, depth);
+	{
+	  /* If STMT block is abstract, that means we have been called
+	     indirectly from dwarf2out_abstract_function.
+	     That function rightfully marks the descendent blocks (of
+	     the abstract function it is dealing with) as being abstract,
+	     precisely to prevent us from emitting any
+	     DW_TAG_inlined_subroutine DIE as a descendent
+	     of an abstract function instance. So in that case, we should
+	     not call gen_inlined_subroutine_die.
+
+	     Later though, when cgraph asks dwarf2out to emit info
+	     for the concrete instance of the function decl into which
+	     the concrete instance of STMT got inlined, the later will lead
+	     to the generation of a DW_TAG_inlined_subroutine DIE.  */
+	  if (! BLOCK_ABSTRACT (stmt))
+	    gen_inlined_subroutine_die (stmt, context_die, depth);
+	}
       else
 	gen_lexical_block_die (stmt, context_die, depth);
     }
diff -Naur gcc-4.4.1.orig/gcc/expr.c gcc-4.4.1/gcc/expr.c
--- gcc-4.4.1.orig/gcc/expr.c	2009-06-16 07:28:47.000000000 -0700
+++ gcc-4.4.1/gcc/expr.c	2009-08-19 15:52:11.000000000 -0700
@@ -7806,6 +7806,33 @@
 			  || mode1 == BLKmode
 			  || bitpos + bitsize > GET_MODE_BITSIZE (mode2));
 
+	/* Handle CONCAT first.  */
+	if (GET_CODE (op0) == CONCAT && !must_force_mem)
+	  {
+	    if (bitpos == 0
+		&& bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))
+	      return op0;
+	    if (bitpos == 0
+		&& bitsize == GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0)))
+		&& bitsize)
+	      {
+		op0 = XEXP (op0, 0);
+		mode2 = GET_MODE (op0);
+	      }
+	    else if (bitpos == GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0)))
+		     && bitsize == GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 1)))
+		     && bitpos
+		     && bitsize)
+	      {
+		op0 = XEXP (op0, 1);
+		bitpos = 0;
+		mode2 = GET_MODE (op0);
+	      }
+	    else
+	      /* Otherwise force into memory.  */
+	      must_force_mem = 1;
+	  }
+
 	/* If this is a constant, put it in a register if it is a legitimate
 	   constant and we don't need a memory reference.  */
 	if (CONSTANT_P (op0)
@@ -7879,16 +7906,6 @@
 	    MEM_VOLATILE_P (op0) = 1;
 	  }
 
-	/* The following code doesn't handle CONCAT.
-	   Assume only bitpos == 0 can be used for CONCAT, due to
-	   one element arrays having the same mode as its element.  */
-	if (GET_CODE (op0) == CONCAT)
-	  {
-	    gcc_assert (bitpos == 0
-			&& bitsize == GET_MODE_BITSIZE (GET_MODE (op0)));
-	    return op0;
-	  }
-
 	/* In cases where an aligned union has an unaligned object
 	   as a field, we might be extracting a BLKmode value from
 	   an integer-mode (e.g., SImode) object.  Handle this case
diff -Naur gcc-4.4.1.orig/gcc/fortran/check.c gcc-4.4.1/gcc/fortran/check.c
--- gcc-4.4.1.orig/gcc/fortran/check.c	2009-01-09 15:47:55.000000000 -0800
+++ gcc-4.4.1/gcc/fortran/check.c	2009-07-23 17:28:43.000000000 -0700
@@ -813,6 +813,15 @@
 		     gfc_current_intrinsic, &y->where);
 	  return FAILURE;
 	}
+
+      if (y->ts.type == BT_COMPLEX)
+	{
+	  gfc_error ("'%s' argument of '%s' intrinsic at %L must have a type "
+		     "of either REAL or INTEGER", gfc_current_intrinsic_arg[1],
+		     gfc_current_intrinsic, &y->where);
+	  return FAILURE;
+	}
+
     }
 
   if (kind_check (kind, 2, BT_COMPLEX) == FAILURE)
@@ -937,6 +946,14 @@
 		     gfc_current_intrinsic, &y->where);
 	  return FAILURE;
 	}
+
+      if (y->ts.type == BT_COMPLEX)
+	{
+	  gfc_error ("'%s' argument of '%s' intrinsic at %L must have a type "
+		     "of either REAL or INTEGER", gfc_current_intrinsic_arg[1],
+		     gfc_current_intrinsic, &y->where);
+	  return FAILURE;
+	}
     }
 
   return SUCCESS;
diff -Naur gcc-4.4.1.orig/gcc/fortran/intrinsic.c gcc-4.4.1/gcc/fortran/intrinsic.c
--- gcc-4.4.1.orig/gcc/fortran/intrinsic.c	2009-01-09 15:47:55.000000000 -0800
+++ gcc-4.4.1/gcc/fortran/intrinsic.c	2009-09-11 15:11:06.000000000 -0700
@@ -836,13 +836,17 @@
   /* See if this intrinsic is allowed in the current standard.  */
   if (gfc_check_intrinsic_standard (isym, &symstd, false, loc) == FAILURE)
     {
-      if (gfc_option.warn_intrinsics_std)
-	gfc_warning_now ("The intrinsic '%s' at %L is not included in the"
-			 " selected standard but %s and '%s' will be treated as"
-			 " if declared EXTERNAL.  Use an appropriate -std=*"
-			 " option or define -fall-intrinsics to allow this"
-			 " intrinsic.", sym->name, &loc, symstd, sym->name);
-      sym->attr.external = 1;
+      if (sym->attr.proc == PROC_UNKNOWN)
+	{
+	  if (gfc_option.warn_intrinsics_std)
+	    gfc_warning_now ("The intrinsic '%s' at %L is not included in the"
+			     " selected standard but %s and '%s' will be"
+			     " treated as if declared EXTERNAL.  Use an"
+			     " appropriate -std=* option or define"
+			     " -fall-intrinsics to allow this intrinsic.",
+			     sym->name, &loc, symstd, sym->name);
+	  gfc_add_external (&sym->attr, &loc);
+	}
 
       return false;
     }
diff -Naur gcc-4.4.1.orig/gcc/fortran/iresolve.c gcc-4.4.1/gcc/fortran/iresolve.c
--- gcc-4.4.1.orig/gcc/fortran/iresolve.c	2008-11-01 06:26:19.000000000 -0700
+++ gcc-4.4.1/gcc/fortran/iresolve.c	2009-08-16 13:04:40.000000000 -0700
@@ -2346,9 +2346,19 @@
   /* TODO: Make this do something meaningful.  */
   static char transfer0[] = "__transfer0", transfer1[] = "__transfer1";
 
-  if (mold->ts.type == BT_CHARACTER && !mold->ts.cl->length
-	&& !(mold->expr_type == EXPR_VARIABLE && mold->symtree->n.sym->attr.dummy))
-    mold->ts.cl->length = gfc_int_expr (mold->value.character.length);
+  if (mold->ts.type == BT_CHARACTER
+	&& !mold->ts.cl->length
+	&& gfc_is_constant_expr (mold))
+    {
+      int len;
+      if (mold->expr_type == EXPR_CONSTANT)
+	mold->ts.cl->length = gfc_int_expr (mold->value.character.length);
+      else
+	{
+	  len = mold->value.constructor->expr->value.character.length;
+	  mold->ts.cl->length = gfc_int_expr (len);
+	}
+    }
 
   f->ts = mold->ts;
 
diff -Naur gcc-4.4.1.orig/gcc/fortran/openmp.c gcc-4.4.1/gcc/fortran/openmp.c
--- gcc-4.4.1.orig/gcc/fortran/openmp.c	2008-07-19 09:22:12.000000000 -0700
+++ gcc-4.4.1/gcc/fortran/openmp.c	2009-07-28 09:33:08.000000000 -0700
@@ -396,12 +396,13 @@
 	      const char *p = gfc_extract_int (cexpr, &collapse);
 	      if (p)
 		{
-		  gfc_error (p);
+		  gfc_error_now (p);
 		  collapse = 1;
 		}
 	      else if (collapse <= 0)
 		{
-		  gfc_error ("COLLAPSE clause argument not constant positive integer at %C");
+		  gfc_error_now ("COLLAPSE clause argument not"
+				 " constant positive integer at %C");
 		  collapse = 1;
 		}
 	      c->collapse = collapse;
diff -Naur gcc-4.4.1.orig/gcc/fortran/primary.c gcc-4.4.1/gcc/fortran/primary.c
--- gcc-4.4.1.orig/gcc/fortran/primary.c	2009-04-03 13:56:54.000000000 -0700
+++ gcc-4.4.1/gcc/fortran/primary.c	2009-09-05 07:25:39.000000000 -0700
@@ -1773,7 +1773,11 @@
       if (m != MATCH_YES)
 	return MATCH_ERROR;
 
-      tbp = gfc_find_typebound_proc (sym, &t, name, false);
+      if (sym->f2k_derived)
+	tbp = gfc_find_typebound_proc (sym, &t, name, false);
+      else
+	tbp = NULL;
+
       if (tbp)
 	{
 	  gfc_symbol* tbp_sym;
diff -Naur gcc-4.4.1.orig/gcc/fortran/resolve.c gcc-4.4.1/gcc/fortran/resolve.c
--- gcc-4.4.1.orig/gcc/fortran/resolve.c	2009-06-20 02:21:06.000000000 -0700
+++ gcc-4.4.1/gcc/fortran/resolve.c	2009-07-29 02:35:15.000000000 -0700
@@ -9414,7 +9414,7 @@
       if ((!a->save && !a->dummy && !a->pointer
 	   && !a->in_common && !a->use_assoc
 	   && !(a->function && sym != sym->result))
-	  || (a->dummy && a->intent == INTENT_OUT))
+	  || (a->dummy && a->intent == INTENT_OUT && !a->pointer))
 	apply_default_init (sym);
     }
 
diff -Naur gcc-4.4.1.orig/gcc/fortran/trans-decl.c gcc-4.4.1/gcc/fortran/trans-decl.c
--- gcc-4.4.1.orig/gcc/fortran/trans-decl.c	2009-06-03 12:39:09.000000000 -0700
+++ gcc-4.4.1/gcc/fortran/trans-decl.c	2009-08-25 11:54:58.000000000 -0700
@@ -2826,7 +2826,8 @@
   gfc_init_block (&fnblock);
   for (f = proc_sym->formal; f; f = f->next)
     if (f->sym && f->sym->attr.intent == INTENT_OUT
-	  && f->sym->ts.type == BT_DERIVED)
+	&& !f->sym->attr.pointer
+	&& f->sym->ts.type == BT_DERIVED)
       {
 	if (f->sym->ts.derived->attr.alloc_comp)
 	  {
@@ -3253,7 +3254,13 @@
 	      st = gfc_find_symtree (ns->sym_root,
 				     rent->local_name[0]
 				     ? rent->local_name : rent->use_name);
-	      gcc_assert (st && st->n.sym->attr.use_assoc);
+	      gcc_assert (st);
+
+	      /* Fixing-up doubly contained symbols, sometimes results in
+		 ambiguity, which is caught here.  */
+	      if (!st->n.sym->attr.use_assoc)
+		continue;
+
 	      if (st->n.sym->backend_decl
 		  && DECL_P (st->n.sym->backend_decl)
 		  && st->n.sym->module
@@ -3573,6 +3580,7 @@
 	 automatic lengths.  */
       if (sym->attr.dummy && !sym->attr.referenced
 	    && sym->ts.type == BT_DERIVED
+	    && !sym->attr.pointer
 	    && sym->ts.derived->attr.alloc_comp
 	    && sym->attr.intent == INTENT_OUT)
 	{
diff -Naur gcc-4.4.1.orig/gcc/java/lang.c gcc-4.4.1/gcc/java/lang.c
--- gcc-4.4.1.orig/gcc/java/lang.c	2008-09-17 14:39:13.000000000 -0700
+++ gcc-4.4.1/gcc/java/lang.c	2009-08-12 02:02:17.000000000 -0700
@@ -53,7 +53,7 @@
 
 static int java_handle_option (size_t scode, const char *arg, int value);
 static void put_decl_string (const char *, int);
-static void put_decl_node (tree);
+static void put_decl_node (tree, int);
 static void java_print_error_function (diagnostic_context *, const char *,
 				       diagnostic_info *);
 static int merge_init_test_initialization (void * *, void *);
@@ -355,10 +355,13 @@
   decl_bufpos += len;
 }
 
-/* Append to decl_buf a printable name for NODE. */
+/* Append to decl_buf a printable name for NODE.
+   Depending on VERBOSITY, more information about NODE
+   is printed. Read the comments of decl_printable_name in
+   langhooks.h for more.  */
 
 static void
-put_decl_node (tree node)
+put_decl_node (tree node, int verbosity)
 {
   int was_pointer = 0;
   if (TREE_CODE (node) == POINTER_TYPE)
@@ -370,17 +373,32 @@
     {
       if (TREE_CODE (node) == FUNCTION_DECL)
 	{
+	  if (verbosity == 0 && DECL_NAME (node))
+	  /* We have been instructed to just print the bare name
+	     of the function.  */
+	    {
+	      put_decl_node (DECL_NAME (node), 0);
+	      return;
+	    }
+
 	  /* We want to print the type the DECL belongs to. We don't do
 	     that when we handle constructors. */
 	  if (! DECL_CONSTRUCTOR_P (node)
-	      && ! DECL_ARTIFICIAL (node) && DECL_CONTEXT (node))
+	      && ! DECL_ARTIFICIAL (node) && DECL_CONTEXT (node)
+              /* We want to print qualified DECL names only
+                 if verbosity is higher than 1.  */
+              && verbosity >= 1)
 	    {
-	      put_decl_node (TYPE_NAME (DECL_CONTEXT (node)));
+	      put_decl_node (TYPE_NAME (DECL_CONTEXT (node)),
+                               verbosity);
 	      put_decl_string (".", 1);
 	    }
 	  if (! DECL_CONSTRUCTOR_P (node))
-	    put_decl_node (DECL_NAME (node));
-	  if (TREE_TYPE (node) != NULL_TREE)
+	    put_decl_node (DECL_NAME (node), verbosity);
+	  if (TREE_TYPE (node) != NULL_TREE
+              /* We want to print function parameters only if verbosity
+                 is higher than 2.  */
+              && verbosity >= 2)
 	    {
 	      int i = 0;
 	      tree args = TYPE_ARG_TYPES (TREE_TYPE (node));
@@ -391,19 +409,22 @@
 		{
 		  if (i > 0)
 		    put_decl_string (",", 1);
-		  put_decl_node (TREE_VALUE (args));
+		  put_decl_node (TREE_VALUE (args), verbosity);
 		}
 	      put_decl_string (")", 1);
 	    }
 	}
       else
-	put_decl_node (DECL_NAME (node));
+	put_decl_node (DECL_NAME (node), verbosity);
     }
   else if (TYPE_P (node) && TYPE_NAME (node) != NULL_TREE)
     {
-      if (TREE_CODE (node) == RECORD_TYPE && TYPE_ARRAY_P (node))
+      if (TREE_CODE (node) == RECORD_TYPE && TYPE_ARRAY_P (node)
+          /* Print detailed array information only if verbosity is higher
+            than 2.  */
+          && verbosity >= 2)
 	{
-	  put_decl_node (TYPE_ARRAY_ELEMENT (node));
+	  put_decl_node (TYPE_ARRAY_ELEMENT (node), verbosity);
 	  put_decl_string("[]", 2);
 	}
       else if (node == promoted_byte_type_node)
@@ -417,7 +438,7 @@
       else if (node == void_type_node && was_pointer)
 	put_decl_string ("null", 4);
       else
-	put_decl_node (TYPE_NAME (node));
+	put_decl_node (TYPE_NAME (node), verbosity);
     }
   else if (TREE_CODE (node) == IDENTIFIER_NODE)
     put_decl_string (IDENTIFIER_POINTER (node), IDENTIFIER_LENGTH (node));
@@ -434,10 +455,7 @@
 lang_printable_name (tree decl, int v)
 {
   decl_bufpos = 0;
-  if (v == 0 && TREE_CODE (decl) == FUNCTION_DECL)
-    put_decl_node (DECL_NAME (decl));
-  else
-    put_decl_node (decl);
+  put_decl_node (decl, v);
   put_decl_string ("", 1);
   return decl_buf;
 }
diff -Naur gcc-4.4.1.orig/gcc/longlong.h gcc-4.4.1/gcc/longlong.h
--- gcc-4.4.1.orig/gcc/longlong.h	2009-02-12 08:30:53.000000000 -0800
+++ gcc-4.4.1/gcc/longlong.h	2009-08-11 15:36:56.000000000 -0700
@@ -982,7 +982,7 @@
 "	or r1,%0"							\
 	: "=r" (q), "=&z" (r)						\
 	: "1" (n1), "r" (n0), "rm" (d), "r" (&__udiv_qrnnd_16)		\
-	: "r1", "r2", "r4", "r5", "r6", "pr");				\
+	: "r1", "r2", "r4", "r5", "r6", "pr", "t");			\
   } while (0)
 
 #define UDIV_TIME 80
@@ -990,7 +990,7 @@
 #define sub_ddmmss(sh, sl, ah, al, bh, bl)				\
   __asm__ ("clrt;subc %5,%1; subc %4,%0"				\
 	   : "=r" (sh), "=r" (sl)					\
-	   : "0" (ah), "1" (al), "r" (bh), "r" (bl))
+	   : "0" (ah), "1" (al), "r" (bh), "r" (bl) : "t")
 
 #endif /* __sh__ */
 
diff -Naur gcc-4.4.1.orig/gcc/Makefile.in gcc-4.4.1/gcc/Makefile.in
--- gcc-4.4.1.orig/gcc/Makefile.in	2009-05-21 16:17:37.000000000 -0700
+++ gcc-4.4.1/gcc/Makefile.in	2009-07-25 10:53:35.000000000 -0700
@@ -3975,7 +3975,7 @@
 # These next rules exist because the output name is not the same as
 # the input name, so our implicit %.pod rule will not work.
 
-gcc.pod: invoke.texi cppenv.texi cppopts.texi
+gcc.pod: invoke.texi cppenv.texi cppopts.texi gcc-vers.texi
 	$(STAMP) $@
 	-$(TEXI2POD) $< > $@
 gfdl.pod: fdl.texi
diff -Naur gcc-4.4.1.orig/gcc/resource.c gcc-4.4.1/gcc/resource.c
--- gcc-4.4.1.orig/gcc/resource.c	2009-05-21 16:17:37.000000000 -0700
+++ gcc-4.4.1/gcc/resource.c	2009-07-22 16:22:24.000000000 -0700
@@ -945,10 +945,11 @@
 
   /* If we found a basic block, get the live registers from it and update
      them with anything set or killed between its start and the insn before
-     TARGET.  Otherwise, we must assume everything is live.  */
+     TARGET; this custom life analysis is really about registers so we need
+     to use the LR problem.  Otherwise, we must assume everything is live.  */
   if (b != -1)
     {
-      regset regs_live = df_get_live_in (BASIC_BLOCK (b));
+      regset regs_live = DF_LR_IN (BASIC_BLOCK (b));
       rtx start_insn, stop_insn;
 
       /* Compute hard regs live at start of block.  */
@@ -1052,7 +1053,7 @@
 		{
 		  HARD_REG_SET extra_live;
 
-		  REG_SET_TO_HARD_REG_SET (extra_live, df_get_live_in (bb));
+		  REG_SET_TO_HARD_REG_SET (extra_live, DF_LR_IN (bb));
 		  IOR_HARD_REG_SET (current_live_regs, extra_live);
 		}
 	    }
diff -Naur gcc-4.4.1.orig/gcc/simplify-rtx.c gcc-4.4.1/gcc/simplify-rtx.c
--- gcc-4.4.1.orig/gcc/simplify-rtx.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/simplify-rtx.c	2009-09-07 13:25:52.000000000 -0700
@@ -2009,6 +2009,7 @@
       /* x*2 is x+x and x*(-1) is -x */
       if (GET_CODE (trueop1) == CONST_DOUBLE
 	  && SCALAR_FLOAT_MODE_P (GET_MODE (trueop1))
+	  && !DECIMAL_FLOAT_MODE_P (GET_MODE (trueop1))
 	  && GET_MODE (op0) == mode)
 	{
 	  REAL_VALUE_TYPE d;
@@ -5243,6 +5244,7 @@
       && GET_MODE_BITSIZE (innermode) >= (2 * GET_MODE_BITSIZE (outermode))
       && GET_CODE (XEXP (op, 1)) == CONST_INT
       && (INTVAL (XEXP (op, 1)) & (GET_MODE_BITSIZE (outermode) - 1)) == 0
+      && INTVAL (XEXP (op, 1)) >= 0
       && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (innermode)      
       && byte == subreg_lowpart_offset (outermode, innermode))
     {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/support/impdef.a gcc-4.4.1/gcc/testsuite/ada/acats/support/impdef.a
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/support/impdef.a	2006-01-26 12:39:16.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/support/impdef.a	2009-08-08 11:30:24.000000000 -0700
@@ -105,6 +105,8 @@
    Minimum_Task_Switch : constant Duration := 0.001;
    --                                         ^^^ --- MODIFY HERE AS NEEDED
 
+   Long_Minimum_Task_Switch : constant Duration := 0.1;
+
 --=====-=====-=====-=====-=====-=====-=====-=====-=====-=====-=====-=====--
 
    -- This is the time required to activate another task and allow it
@@ -117,13 +119,15 @@
    Switch_To_New_Task : constant Duration := 0.001;
    --                                        ^^^ -- MODIFY HERE AS NEEDED
 
+   Long_Switch_To_New_Task : constant Duration := 0.1;
+
 --=====-=====-=====-=====-=====-=====-=====-=====-=====-=====-=====-=====--
 
    -- This is the time which will clear the queues of other tasks
    -- waiting to run.  It is expected that this will be about five
    -- times greater than Switch_To_New_Task.
 
-   Clear_Ready_Queue : constant Duration := 1.1;
+   Clear_Ready_Queue : constant Duration := 0.1;
    --                                       ^^^ --- MODIFY HERE AS NEEDED
 
 --=====-=====-=====-=====-=====-=====-=====-=====-=====-=====-=====-=====--
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c940005.a gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c940005.a
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c940005.a	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c940005.a	2009-08-08 11:30:24.000000000 -0700
@@ -85,7 +85,7 @@
       -- In reality one would expect a time of 5 to 10 seconds.  In
       -- the interests of speeding up the test suite a shorter time
       -- is used
-      Pulse_Time_Delta : constant duration := ImpDef.Switch_To_New_Task;
+      Pulse_Time_Delta : constant duration := ImpDef.Long_Switch_To_New_Task;
 
       -- control over stopping tasks
       protected Control is
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c940007.a gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c940007.a
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c940007.a	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c940007.a	2009-08-08 11:30:24.000000000 -0700
@@ -90,7 +90,7 @@
       -- In reality one would expect a time of 5 to 10 seconds.  In
       -- the interests of speeding up the test suite a shorter time
       -- is used
-      Pulse_Time_Delta : constant duration := ImpDef.Switch_To_New_Task;
+      Pulse_Time_Delta : constant duration := ImpDef.Long_Switch_To_New_Task;
 
 
       -- control over stopping tasks
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c94001c.ada gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c94001c.ada
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c94001c.ada	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c94001c.ada	2009-08-08 11:30:24.000000000 -0700
@@ -209,7 +209,7 @@
 
      BEGIN -- (E)
           WHILE NOT(OUT_TSK'TERMINATED) AND DELAY_COUNT < 60 LOOP
-               DELAY 1.0 * Impdef.One_Second;
+               DELAY 1.0 * Impdef.One_Long_Second;
                DELAY_COUNT := DELAY_COUNT + 1;
           END LOOP;
           IF DELAY_COUNT = 60 THEN
@@ -252,7 +252,7 @@
 
      BEGIN
           WHILE NOT(OUT_TSK'TERMINATED) AND DELAY_COUNT < 60 LOOP
-               DELAY 1.0 * Impdef.One_Second;
+               DELAY 1.0 * Impdef.One_Long_Second;
                DELAY_COUNT := DELAY_COUNT + 1;
           END LOOP;
           IF DELAY_COUNT = 60 THEN
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c94006a.ada gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c94006a.ada
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c94006a.ada	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c94006a.ada	2009-08-08 11:30:24.000000000 -0700
@@ -42,7 +42,7 @@
           SELECT
                ACCEPT E;
           OR
-               DELAY 30.0 * Impdef.One_Second;
+               DELAY 30.0 * Impdef.One_Long_Second;
           END SELECT;
      END TT;
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c94008c.ada gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c94008c.ada
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c94008c.ada	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c94008c.ada	2009-08-08 11:30:24.000000000 -0700
@@ -202,7 +202,7 @@
                     DELAY 10.0 * Impdef.One_Second;
 
                     IF TERMINATE_COUNT.GET /= 1 THEN
-                         DELAY 20.0 * Impdef.One_Second;
+                         DELAY 20.0 * Impdef.One_Long_Second;
                     END IF;
 
                     IF TERMINATE_COUNT.GET /= 1 THEN
@@ -243,7 +243,7 @@
           DELAY 10.0 * Impdef.One_Second; -- WAIT FOR T1, T2, AND T3 TO GET TO SELECT STMTS.
 
            IF TERMINATE_COUNT.GET /= 3 THEN
-                DELAY 20.0 * Impdef.One_Second;
+                DELAY 20.0 * Impdef.One_Long_Second;
            END IF;
 
            IF TERMINATE_COUNT.GET /= 3 THEN
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c951002.a gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c951002.a
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c951002.a	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c951002.a	2009-08-08 11:30:24.000000000 -0700
@@ -278,14 +278,14 @@
       -- Wait until the message is queued on the entry before starting
       -- the Credit_Task
       while not Hold.TC_Message_is_Queued loop
-         delay ImpDef.Minimum_Task_Switch;   
+         delay ImpDef.Long_Minimum_Task_Switch;   
       end loop;
       --
       Credit_Task.TC_Start;
 
       -- Ensure the first part of the test is complete before continuing
       while not (Credit_Message'terminated and Credit_Task'terminated) loop
-         delay ImpDef.Minimum_Task_Switch;   
+         delay ImpDef.Long_Minimum_Task_Switch;   
       end loop;
 
       --======================================================
@@ -298,12 +298,12 @@
       -- for it to reach the accept statement and call Hold.Set_DB_Overload
       -- before starting Debit_Message
       --
-      delay ImpDef.Switch_To_New_Task;
+      delay ImpDef.Long_Switch_To_New_Task;
 
       Debit_Message.TC_Start;
 
       while not Debit_Task'terminated loop
-         delay ImpDef.Minimum_Task_Switch;   
+         delay ImpDef.Long_Minimum_Task_Switch;   
       end loop;    
   
       Hold.Clear_DB_Overload;  -- Allow completion 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c954a01.a gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c954a01.a
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c954a01.a	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c954a01.a	2009-08-08 11:30:24.000000000 -0700
@@ -148,7 +148,7 @@
          end select;
 
          -- Allow other tasks to get control
-         delay ImpDef.Minimum_Task_Switch;
+         delay ImpDef.Long_Minimum_Task_Switch;
 
       end loop;
 
@@ -175,7 +175,7 @@
 
 procedure C954A01 is
 
-   Long_Enough : constant Duration := ImpDef.Switch_To_New_Task;
+   Long_Enough : constant Duration := ImpDef.Long_Switch_To_New_Task;
 
                --==============================================--
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c96001a.ada gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c96001a.ada
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c96001a.ada	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c96001a.ada	2009-08-08 11:30:24.000000000 -0700
@@ -51,7 +51,7 @@
      ---------------------------------------------
 
      DECLARE   -- (A)
-          X : DURATION := 5.0;
+          X : DURATION := 5.0 * Impdef.One_Second;
           OLD_TIME : TIME;
           LAPSE : DURATION;
      BEGIN     -- (A)
diff -Naur gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c97307a.ada gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c97307a.ada
--- gcc-4.4.1.orig/gcc/testsuite/ada/acats/tests/c9/c97307a.ada	2003-10-27 03:29:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/ada/acats/tests/c9/c97307a.ada	2009-08-08 11:30:24.000000000 -0700
@@ -160,7 +160,7 @@
                          EXPIRED.READ (EXPIRED_CALLS);
                     EXIT WHEN E'COUNT >= DESIRED_QUEUE_LENGTH -
                                          EXPIRED_CALLS;
-                         DELAY 2.0 * Impdef.One_Second;
+                         DELAY 2.0 * Impdef.One_Long_Second;
                     END LOOP;
                EXIT WHEN DESIRED_QUEUE_LENGTH = 5;
                     DISPATCH.READY;
@@ -171,7 +171,7 @@
                -- LET THE TIMED ENTRY CALLS ISSUED BY CALLER1,
                -- CALLER3, AND CALLER5 EXPIRE:
 
-               DELAY DELAY_TIME + 10.0 * Impdef.One_Second;
+               DELAY DELAY_TIME + 10.0 * Impdef.One_Long_Second;
 
                -- AT THIS POINT, ALL THE TIMED ENTRY CALLS MUST HAVE
                -- EXPIRED AND BEEN REMOVED FROM THE ENTRY QUEUE FOR E,
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/limits-fndefn.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/limits-fndefn.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/limits-fndefn.c	2008-12-29 02:31:14.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/limits-fndefn.c	2009-08-28 02:57:51.000000000 -0700
@@ -1,4 +1,5 @@
 /* { dg-skip-if "too complex for avr and picochip" { picochip-*-* avr-*-* } { "*" } { "" } } */
+/* { dg-timeout-factor 4.0 } */
 #define LIM1(x) x##0, x##1, x##2, x##3, x##4, x##5, x##6, x##7, x##8, x##9,
 #define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
 		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40321.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40321.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40321.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40321.c	2009-07-22 07:45:21.000000000 -0700
@@ -0,0 +1,12 @@
+struct X { int flag; int pos; };
+int foo(struct X *a, struct X *b)
+{
+  while (1)
+    {
+      if (a->flag)
+	break;
+      ({ struct X *tmp = a; a = b; b = tmp; });
+    }
+
+  return a->pos + b->pos;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40570.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40570.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40570.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40570.c	2009-08-05 07:45:15.000000000 -0700
@@ -0,0 +1,22 @@
+extern void anything(int);
+
+static int foo(int i);
+
+static int bar(int i) { foo(i); }
+
+extern int j;
+
+static int foo(int i)
+{
+  if (j)
+    anything(j);
+  return bar(i);
+}
+
+int baz()
+{
+  foo(0);
+  if (baz())
+    return 1;
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40676.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40676.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40676.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40676.c	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,33 @@
+extern int f1();
+extern int f2(void*);
+extern void* f3(int);
+int xmsih;
+typedef unsigned short XWCHAR;
+
+inline unsigned int xstrlenW( const XWCHAR *str )
+{
+    const XWCHAR *s = str;
+    while (*s) s++;
+    return s - str;
+}
+
+
+static int msi_dialog_register_class( void )
+{
+    int cls;
+
+    if( !f2( &cls ) )
+        return 0;
+    if( !f2( &cls ) )
+        return 0;
+    xmsih = f1();
+    if( !xmsih )
+        return 0;
+    return 1;
+}
+
+void *xmsi_dialog_create(const XWCHAR* szDialogName)
+{
+    msi_dialog_register_class();
+    return f3(xstrlenW(szDialogName));
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40692.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40692.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40692.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40692.c	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,15 @@
+/* PR middle-end/40692 */
+
+#define M1(x) (((x) & 0x00000002) ? 0x2 : ((x) & 0x1))
+#define M2(x) (((x) & 0x0000000c) ? M1 ((x) >> 2) << 2 : M1 (x))
+#define M3(x) (((x) & 0x000000f0) ? M2 ((x) >> 4) << 4 : M2 (x))
+#define M4(x) (((x) & 0x0000ff00) ? M3 ((x) >> 8) << 8 : M3 (x))
+#define M5(x) (((x) & 0xffff0000) ? M4 ((x) >> 16) << 16 : M4 (x))
+
+struct A { char e; char f; };
+
+long
+foo (void)
+{
+  return M5 (4096UL - (long) &((struct A *) 0)->f);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40753.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40753.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40753.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40753.c	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,20 @@
+typedef struct {
+    unsigned nargs;
+} ffi_cif;
+typedef struct {
+    char tramp[24];
+    ffi_cif *cif;
+} ffi_closure;
+extern void *memcpy (void *, const void *, __SIZE_TYPE__);
+extern void ffi_closure_LINUX64 (void);
+
+int
+ffi_prep_closure_loc (ffi_closure *closure, ffi_cif *cif)
+{
+  void **tramp = (void **) &closure->tramp[0];
+
+  memcpy (tramp, (char *) ffi_closure_LINUX64, 16);
+  closure->cif = cif;
+
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40964.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40964.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr40964.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr40964.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,10 @@
+struct alloc2 {
+    int bla;
+    char * __restrict data;
+    char * __restrict data2;
+};
+struct alloc2 b;
+void * f (void)
+{
+  return b.data;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41006-1.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41006-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41006-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41006-1.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,17 @@
+typedef int (*FARPROC)();
+
+typedef int (*LPFN_ACCEPTEX)(void*);
+static LPFN_ACCEPTEX acceptex_fn;
+
+int xWSAIoctl(void*);
+static void get_fn(FARPROC* fn)
+{
+    FARPROC func;
+    if (!xWSAIoctl( &func))
+        *fn = func;
+}
+
+void get_fn_pointers()
+{
+    get_fn((FARPROC*)&acceptex_fn);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41006-2.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41006-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41006-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41006-2.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,15 @@
+typedef int *FARPROC;
+static int * __restrict__ acceptex_fn;
+
+int xWSAIoctl(void*);
+static void get_fn(FARPROC* fn)
+{
+  FARPROC func;
+  if (!xWSAIoctl( &func))
+    *fn = func;
+}
+
+void get_fn_pointers()
+{
+  get_fn((FARPROC*)&acceptex_fn);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41016.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41016.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41016.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41016.c	2009-08-09 14:39:19.000000000 -0700
@@ -0,0 +1,17 @@
+typedef struct _IO_FILE FILE;
+void
+CompareRNAStructures (FILE * ofp, int start, int L, char *ss_true, char *ss)
+{
+  int i;
+  float agree = 0.;
+  float pairs = 0.;
+  float pairs_true = 0.;
+  for (i = 0; i < L; i++)
+    {
+      pairs_true += 1.;
+      agree += 1.;
+    }
+  if (((int) pairs % 2 != 0) || ((int) pairs_true % 2 != 0)
+      || ((int) agree % 2 != 0))
+    Die ("Error in CompareRNAStrutures(); odd number of paired nucleotides\n");
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41163.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41163.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41163.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41163.c	2009-08-29 19:06:32.000000000 -0700
@@ -0,0 +1,10 @@
+struct option {
+    void *value;
+};
+void parse_options (struct option *);
+void cmd_grep(void)
+{
+  struct option options[] = { { &options } };
+  parse_options(options);
+}
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41181.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41181.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41181.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41181.c	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,10 @@
+char paths[1024];
+static void x264_slicetype_path(char (*best_paths)[250], int n, int length)
+{
+    __builtin_memcpy (best_paths[n], paths, length);
+}
+void x264_slicetype_analyse(int n, int length)
+{
+    char best_paths[250][250];
+    x264_slicetype_path (best_paths, n, length);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41282.c gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41282.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.c-torture/compile/pr41282.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.c-torture/compile/pr41282.c	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,20 @@
+struct S
+{
+  unsigned int iu;
+};
+
+union U
+{
+  struct S s;
+  signed int is;
+};
+
+extern signed int bar ();
+
+struct S foo (void)
+{
+  union U u;
+
+  u.is = bar ();
+  return u.s;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20010912-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/20010912-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20010912-1.c	2005-10-15 18:14:19.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20010912-1.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,6 +1,5 @@
 /* { dg-do run { target fpic } } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))" "PIC unsupported" { xfail *-*-netware* } 0 } */
 
 extern void abort (void);
 extern void exit (int);
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20021018-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/20021018-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20021018-1.c	2005-10-15 18:14:19.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20021018-1.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,6 +1,5 @@
 /* { dg-do run { target fpic } } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))" "PIC unsupported" { xfail *-*-netware* } 0 } */
 
 extern void abort (void);
 extern void exit (int);
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20030213-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/20030213-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20030213-1.c	2005-10-15 18:14:19.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20030213-1.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,7 +1,6 @@
 /* Testcase for http://gcc.gnu.org/ml/gcc-patches/2003-02/msg01017.html */
 /* { dg-do link { target fpic } } */
 /* { dg-options "-O -fpic" } */
-/* { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))" "PIC unsupported" { xfail *-*-netware* } 0 } */
 
 int *g;
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20030225-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/20030225-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20030225-1.c	2005-10-15 18:14:19.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20030225-1.c	2009-07-27 23:56:49.000000000 -0700
@@ -5,7 +5,6 @@
    and Benjamin Herrenschmidt <benh@kernel.crashing.org>.  */
 /* { dg-do run { target fpic } } */
 /* { dg-options "-O2 -fPIC" } */
-/* { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))" "PIC unsupported" { xfail *-*-netware* } 0 } */
 
 extern void exit (int);
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20030708-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/20030708-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20030708-1.c	2005-10-15 18:14:19.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20030708-1.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,7 +1,6 @@
 /* PR c/11420 */
 /* { dg-do link { target fpic } } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))" "PIC unsupported" { xfail *-*-netware* } 0 } */
 
 void (* volatile fn) (void);
 static void foo (void)
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20050321-2.c gcc-4.4.1/gcc/testsuite/gcc.dg/20050321-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20050321-2.c	2006-04-13 16:14:25.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20050321-2.c	2009-07-27 23:56:49.000000000 -0700
@@ -5,7 +5,6 @@
    figure out branch to lab is too far.  */
 /* { dg-do link { target fpic } } */
 /* { dg-options "-g1 -fpic" } */
-/* { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))" "PIC unsupported" { xfail *-*-netware* } 0 } */
 /* { dg-require-effective-target int32plus } */
 
 #define A(n) \
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20090902-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/20090902-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/20090902-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/20090902-1.c	2009-09-02 11:47:29.000000000 -0700
@@ -0,0 +1,3 @@
+/* { dg-do compile } */
+#define STRING(x) #x
+char buf[] = STRING(L'\x123');
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-15.c gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-15.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-15.c	2009-01-25 12:15:44.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-15.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* Remove pedantic.  Allow the GCC extension to use char for bitfields.  */
 /* { dg-options "" } */
+/* { dg-options "-mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-16.c gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-16.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-16.c	2009-01-22 22:29:54.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-16.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-Wno-packed-bitfield-compat" } */
+/* { dg-options "-Wno-packed-bitfield-compat -mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-17.c gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-17.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-17.c	2009-01-25 12:15:44.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-17.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "" } */
+/* { dg-options "-mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-18.c gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-18.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/bitfld-18.c	2009-01-22 22:29:54.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/bitfld-18.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-Wno-packed-bitfield-compat" } */
+/* { dg-options "-Wno-packed-bitfield-compat -mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/builtins-10.c gcc-4.4.1/gcc/testsuite/gcc.dg/builtins-10.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/builtins-10.c	2005-03-09 12:11:48.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/builtins-10.c	2009-08-24 02:52:03.000000000 -0700
@@ -25,7 +25,7 @@
     link_error ();
 
   if (pow(pow(x,4.0),0.25) != x)
-    link_error ();
+    /* XFAIL.  PR41098.  */;
 }
 
 void test2(double x, double y, double z)
@@ -42,7 +42,7 @@
   if (pow(sqrt(x),y) != pow(x,y*0.5))
     link_error ();
 
-  if (pow(pow(x,y),z) != pow(x,y*z))
+  if (pow(pow(fabs(x),y),z) != pow(fabs(x),y*z))
     link_error ();
 }
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/builtins-config.h gcc-4.4.1/gcc/testsuite/gcc.dg/builtins-config.h
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/builtins-config.h	2008-06-18 14:41:13.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/builtins-config.h	2009-08-30 15:45:18.000000000 -0700
@@ -1,4 +1,4 @@
-/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation.
+/* Copyright (C) 2003, 2004, 2005, 2006, 2009 Free Software Foundation.
 
    Define macros useful in tests for bulitin functions.  */
 
@@ -15,8 +15,8 @@
 /* Irix6 doesn't have the entire C99 runtime.  */
 #elif defined(__AVR__)
 /* AVR doesn't have the entire C99 runtime.  */
-#elif defined(__FreeBSD__) && (__FreeBSD__ < 5)
-/* FreeBSD before version 5 doesn't have the entire C99 runtime. */
+#elif defined(__FreeBSD__)
+/* FreeBSD up to at least version 8 lacks support for cexp and friends.  */
 #elif defined(__netware__)
 /* NetWare doesn't have the entire C99 runtime.  */
 #elif defined(__vxworks)
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/c90-const-expr-2.c gcc-4.4.1/gcc/testsuite/gcc.dg/c90-const-expr-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/c90-const-expr-2.c	2008-04-25 01:40:10.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/c90-const-expr-2.c	2009-09-08 12:10:43.000000000 -0700
@@ -14,8 +14,10 @@
 int b;
 long *c;
 
-#if defined(_LP64) || defined(_WIN64)
+#if defined(_LP64)
 #define ZERO 0L
+#elif defined(_WIN64)
+#define ZERO 0LL
 #else
 #define ZERO 0
 #endif
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/c99-const-expr-2.c gcc-4.4.1/gcc/testsuite/gcc.dg/c99-const-expr-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/c99-const-expr-2.c	2008-04-25 01:40:10.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/c99-const-expr-2.c	2009-09-08 12:10:43.000000000 -0700
@@ -14,8 +14,10 @@
 int b;
 long *c;
 
-#if defined(_LP64) || defined(_WIN64)
+#if defined(_LP64)
 #define ZERO 0L
+#elif defined(_WIN64)
+#define ZERO 0LL
 #else
 #define ZERO 0
 #endif
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/cdce1.c gcc-4.4.1/gcc/testsuite/gcc.dg/cdce1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/cdce1.c	2009-02-05 03:59:20.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/cdce1.c	2009-07-28 09:11:21.000000000 -0700
@@ -1,7 +1,8 @@
 /* { dg-do  run  } */
 /* { dg-skip-if "doubles are floats" { "avr-*-*" "m32c-*-*" } { "*" } { "" } } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details  -lm" } */
-/* { dg-final { scan-tree-dump  "cdce1.c:16: note: function call is shrink-wrapped into error conditions\."  "cdce" } } */
+/* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details" { target *-*-netware* } } */
+/* { dg-final { scan-tree-dump  "cdce1.c:17: note: function call is shrink-wrapped into error conditions\."  "cdce" } } */
 /* { dg-final { cleanup-tree-dump "cdce" } } */
 
 #include <stdlib.h>
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/cdce2.c gcc-4.4.1/gcc/testsuite/gcc.dg/cdce2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/cdce2.c	2008-06-18 14:41:13.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/cdce2.c	2009-07-28 09:11:21.000000000 -0700
@@ -1,7 +1,8 @@
 /* { dg-do  run  } */
 /* { dg-skip-if "doubles are floats" { "avr-*-*" } { "*" } { "" } } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details  -lm" } */
-/* { dg-final { scan-tree-dump  "cdce2.c:16: note: function call is shrink-wrapped into error conditions\." "cdce" } }*/
+/* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details" { target *-*-netware* } } */
+/* { dg-final { scan-tree-dump  "cdce2.c:17: note: function call is shrink-wrapped into error conditions\." "cdce" } }*/
 /* { dg-final { cleanup-tree-dump "cdce" } } */
  
 #include <stdlib.h>
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/debug/20020224-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/debug/20020224-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/debug/20020224-1.c	2002-02-26 11:05:26.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/debug/20020224-1.c	2009-08-16 02:07:40.000000000 -0700
@@ -1,9 +1,13 @@
+/* { dg-options "-g3 -O" } */
 /* { dg-do compile } */
 
-/* Here's the deal: f3 is not inlined because it's too big, but f2 and
-   f1 are inlined into it.  We used to fail to emit debugging info for
-   t1, because it was moved inside the (inlined) block of f1, marked
-   as abstract, then we'd crash.  */
+/* Here's the deal: f4 is inlined into main, f3 is inlined into f4, f2 is
+   inlined into f1. The DIE of main should contain DW_TAG_inlined_subroutines
+   children for f4, f3, f2 and f1. Also, there should be a DIE representing
+   and out of line instance of f4, aside the DIE representing its abstract
+   instance.
+   We used to fail to emit debugging info for t1, because it was moved
+   inside the (inlined) block of f1, marked as abstract, then we'd crash.  */
 
 #define UNUSED __attribute__((unused))
 #define EXT __extension__
@@ -58,3 +62,10 @@
 
   return;
 }
+
+int
+main ()
+{
+    int foo = 1;
+    f4 ();
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c gcc-4.4.1/gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c	2009-08-17 03:04:21.000000000 -0700
@@ -0,0 +1,70 @@
+/* Contributed by Dodji Seketeli <dodji@redhat.com>
+   Origin: PR debug/37801
+
+  Abstract instances (DW_TAG_subroutines having the DW_AT_inline attribute)
+  of second and first were having a DW_TAG_lexical_block DIE wrongly
+  representing the inlined calls to third (in second) and to
+  second (in first). At the same time, main didn't have children
+  DW_TAG_inlined_subroutine DIEs representing the inlined calls to
+  first, second and third.
+
+  The ideal goal here is to test that we have no superfluous
+  DW_TAG_lexical_block DIE anymore, that abstract instances DIEs have
+  no descendant DIE with a DW_AT_abstract_origin attribute, and that main has
+  properly nested DW_TAG_inlined_subroutine DIEs for third, second and first.
+*/
+
+/* { dg-options "-O -g3 -dA" } */
+/* { dg-do compile } */
+
+/* There are 6 inlined subroutines:
+   - One for each subroutine inlined into main, that's 3.
+   - One for earch subroutine inline into the out of line instances
+     of third, second and first.  */
+/* { dg-final { scan-assembler-times "\\(DIE \\(.*?\\) DW_TAG_inlined_subroutine" 6 } } */
+
+/* Likewise we should have 6 DW_TAG_lexical_block DIEs:
+   - One for each subroutine inlined into main, so that's 3.
+   - One for each subroutine inlined in the out of line instances
+     of third, second and first, that's 3.
+*/
+/* { dg-final { scan-assembler-times "\\(DIE \\(.*?\\) DW_TAG_lexical_block" 6 } } */
+
+
+/* There are 3 DW_AT_inline attributes: one per abstract inline instance.
+   The value of the attribute must be 0x3, meaning the function was
+   actually inlined.  */
+/* { dg-final { scan-assembler-times "byte.*?0x3.*? DW_AT_inline" 3 } } */
+
+
+inline void
+third (int arg3)
+{
+  int var3 = arg3;
+  int* a = 0;
+  a[0] = var3;
+}
+
+inline void
+second (int arg2)
+{
+  int var2 = arg2;
+  third (var2+1);
+}
+
+inline void
+first (int arg1)
+{
+  int var1 = arg1;
+  second (var1+1);
+}
+
+int
+main ()
+{
+  int some_int = 1;
+  first (some_int);
+  return 0;
+}
+
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/dfp/pr39902.c gcc-4.4.1/gcc/testsuite/gcc.dg/dfp/pr39902.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/dfp/pr39902.c	2009-06-29 10:13:33.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/dfp/pr39902.c	2009-07-30 10:08:09.000000000 -0700
@@ -189,7 +189,7 @@
   if (COMPARE128 (a128, p128_2_0))
     FAILURE
 
-  a128.d = p128_2_0.d * 1.0DD;
+  a128.d = p128_2_0.d * 1.0DL;
   if (COMPARE128 (a128, p128_2_0))
     FAILURE
 
@@ -197,7 +197,7 @@
   if (COMPARE128 (a128, m128_2_0))
     FAILURE
 
-  a128.d = p128_2_0.d * -1.0DD;
+  a128.d = p128_2_0.d * -1.0DL;
   if (COMPARE128 (a128, m128_2_0))
     FAILURE
 
@@ -208,7 +208,7 @@
   if (! (COMPARE128 (a128, p128_2_0)))
     FAILURE
 
-  a128.d = p128_2_0.d * 1.DD;
+  a128.d = p128_2_0.d * 1.DL;
   if (! (COMPARE128 (a128, p128_2_0)))
     FAILURE
 
@@ -216,7 +216,7 @@
   if (! (COMPARE128 (a128, m128_2_0)))
     FAILURE
 
-  a128.d = p128_2_0.d * -1.DD;
+  a128.d = p128_2_0.d * -1.DL;
   if (! (COMPARE128 (a128, m128_2_0)))
     FAILURE
 }
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/large-size-array-2.c gcc-4.4.1/gcc/testsuite/gcc.dg/large-size-array-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/large-size-array-2.c	2008-04-26 12:14:46.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/large-size-array-2.c	2009-09-08 12:10:43.000000000 -0700
@@ -4,4 +4,4 @@
 static char * name[] = {
     [0x80000000]  = "bar"
   };
-/* { dg-error "too large" "" { target { { ! lp64 } || x86_64-*-mingw* } }  6 } */
+/* { dg-error "too large" "" { target { { ! lp64 } && { ! llp64 } } }  6 } */
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/large-size-array-4.c gcc-4.4.1/gcc/testsuite/gcc.dg/large-size-array-4.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/large-size-array-4.c	2008-04-26 12:14:46.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/large-size-array-4.c	2009-09-08 12:10:43.000000000 -0700
@@ -4,4 +4,4 @@
 static char * name[] = {
     [0x80000000]  = "bar"
   };
-/* { dg-error "too large" "" { target { { ! lp64 } || x86_64-*-mingw* } }  6 } */
+/* { dg-error "too large" "" { target { { ! lp64 } && { ! llp64 } } }  6 } */
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr40861.c gcc-4.4.1/gcc/testsuite/gcc.dg/pr40861.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr40861.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/pr40861.c	2009-09-07 13:25:52.000000000 -0700
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+int foo(int i)
+{
+  return (1LL >> 128 * i) && i;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr40971.c gcc-4.4.1/gcc/testsuite/gcc.dg/pr40971.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr40971.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/pr40971.c	2009-08-18 04:43:16.000000000 -0700
@@ -0,0 +1,23 @@
+/* PR target/40971 */
+/* { dg-do compile } */
+/* { dg-options "-O -fstack-protector -fno-strict-aliasing" } */
+/* { dg-require-effective-target fstack_protector } */
+
+extern void bar (char *);
+
+void
+foo (int f, long a)
+{
+  {
+    char d[32768];
+    bar (d);
+  }
+  double b = f;
+  while (a)
+    {
+      char c[sizeof (double)];
+      __builtin_memcpy (c, &b, sizeof (c));
+      if (*(double *) c != 2.0)
+	break;
+    }
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr41033.c gcc-4.4.1/gcc/testsuite/gcc.dg/pr41033.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr41033.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/pr41033.c	2009-08-12 23:28:28.000000000 -0700
@@ -0,0 +1,24 @@
+/* { dg-options "-O1 -fno-strict-aliasing" } */
+/* PR rtl-optimization/41033 */
+
+struct X {
+  int i;
+  int j;
+};
+
+int foo(struct X *p, struct X *q)
+{
+  p->j = 1;
+  q->i = 0;
+  return p->j;
+}
+
+extern void abort (void);
+
+int main()
+{
+  struct X x;
+  if (foo (&x, (struct X *)&x.j) != 0)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr41123.c gcc-4.4.1/gcc/testsuite/gcc.dg/pr41123.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr41123.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/pr41123.c	2009-08-19 15:52:11.000000000 -0700
@@ -0,0 +1,46 @@
+/* PR middle-end/41123 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-strict-aliasing" } */
+
+struct S { char a, b, c, d, e, f, g, h; };
+struct T { int a, b; };
+
+struct S
+f1 (float _Complex x)
+{
+  return *(struct S *) & x;
+}
+
+int
+f2 (float _Complex x)
+{
+  struct S f = f1 (x);
+  return f.b;
+}
+
+struct T
+f3 (float _Complex x)
+{
+  return *(struct T *) & x;
+}
+
+int
+f4 (float _Complex x)
+{
+  struct T f = f3 (x);
+  return f.a;
+}
+
+int
+f5 (float _Complex x)
+{
+  struct T f = f3 (x);
+  return f.b;
+}
+
+struct T
+f6 (float _Complex x)
+{
+  struct T f = f3 (x);
+  return f;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr41232.c gcc-4.4.1/gcc/testsuite/gcc.dg/pr41232.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/pr41232.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/pr41232.c	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -g" } */
+extern int atoi (const char *);
+extern int sprintf (char *, const char *, ...);
+void malloc_init() {
+  char *cptr;
+  char buf[1];
+  int tmbd = atoi(cptr);
+  if (tmbd > 0)
+    tmbd = (tmbd <= 124) ? tmbd : 124;
+   else
+    tmbd = 0;
+   sprintf(buf, "%d\n", tmbd);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/special/gcsec-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/special/gcsec-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/special/gcsec-1.c	2007-05-07 11:28:41.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/special/gcsec-1.c	2009-07-25 06:54:21.000000000 -0700
@@ -3,10 +3,8 @@
 /* { dg-do run { xfail rs6000-*-aix* powerpc*-*-aix* } } */
 /* { dg-require-gc-sections "" } */
 
-/* { dg-options "-ffunction-sections -fdata-sections -Wl,--gc-sections -static" } */
-/* { dg-options "-ffunction-sections -fdata-sections -Wl,--gc-sections -static" { target native } } */
-/* Solaris 10 does not support static linking; there is no libc.a.  */
-/* { dg-options "-ffunction-sections -fdata-sections -Wl,--gc-sections" { target *-*-netware* i?86-*-solaris2.1[0-9] } } */
+/* { dg-options "-ffunction-sections -fdata-sections -Wl,--gc-sections" } */
+/* { dg-options "-ffunction-sections -fdata-sections -Wl,--gc-sections -static" { target static } } */
 
 #include <stdlib.h>
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/ssp-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/ssp-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/ssp-1.c	2007-03-28 16:08:26.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/ssp-1.c	2009-08-10 10:35:05.000000000 -0700
@@ -4,7 +4,7 @@
 
 #include <stdlib.h>
 
-static void
+void
 __stack_chk_fail (void)
 {
   exit (0); /* pass */
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/builtin-power-1.c gcc-4.4.1/gcc/testsuite/gcc.dg/torture/builtin-power-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/builtin-power-1.c	2007-09-22 01:25:43.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/torture/builtin-power-1.c	2009-08-24 02:52:03.000000000 -0700
@@ -77,9 +77,9 @@
   /* Test pow(pow(x,y),z) -> pow(x,y*z).  */
 #define POW_POW \
  extern void link_failure_pow_pow(void); \
- if (pow(pow(d1, d2), d3) != pow(d1,d2*d3) \
-     || powf(powf(f1,f2),f3) != powf(f1,f2*f3) \
-     || powl(powl(ld1,ld2),ld3) != powl(ld1,ld2*ld3)) \
+ if (pow(pow(fabs(d1), d2), d3) != pow(fabs(d1),d2*d3) \
+     || powf(powf(fabs(f1),f2),f3) != powf(fabs(f1),f2*f3) \
+     || powl(powl(fabs(ld1),ld2),ld3) != powl(fabs(ld1),ld2*ld3)) \
     link_failure_pow_pow()
 
   POW_POW;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/pr39074.c gcc-4.4.1/gcc/testsuite/gcc.dg/torture/pr39074.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/pr39074.c	2009-02-19 02:12:25.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/torture/pr39074.c	2009-09-08 12:10:43.000000000 -0700
@@ -2,9 +2,11 @@
 /* { dg-options "-fdump-tree-alias" } */
 /* { dg-skip-if "" { *-*-* } { "-O0" } { "" } } */
 
+typedef __PTRDIFF_TYPE__ intptr_t;
+
 int i;
 void __attribute__((noinline))
-foo(long b, long q)
+foo(long b, intptr_t q)
 {
   int *y;
   int **a = &y, **x;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/pr41094.c gcc-4.4.1/gcc/testsuite/gcc.dg/torture/pr41094.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/pr41094.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/torture/pr41094.c	2009-08-24 02:52:03.000000000 -0700
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-ffast-math" } */
+
+#include <math.h>
+
+extern void abort (void);
+
+double foo(void)
+{
+  double x = -4.0;
+  return pow (x * x, 0.25);
+}
+
+int main()
+{
+  if (foo() != 2.0)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/pr41261.c gcc-4.4.1/gcc/testsuite/gcc.dg/torture/pr41261.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/torture/pr41261.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/torture/pr41261.c	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-fprofile-arcs" } */
+
+extern void relocate_kernel();
+void machine_kexec(void *control_page)
+{ 
+  __builtin_memcpy(control_page, relocate_kernel, 2048);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/tree-ssa/pr33920.c gcc-4.4.1/gcc/testsuite/gcc.dg/tree-ssa/pr33920.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/tree-ssa/pr33920.c	2009-02-05 03:59:20.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/tree-ssa/pr33920.c	2009-09-08 12:10:43.000000000 -0700
@@ -2,6 +2,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O3" } */
 
+typedef __PTRDIFF_TYPE__ intptr_t;
 typedef union lispunion *object;
 struct character
 {
@@ -22,14 +23,14 @@
   object V659;
   object _x, _y;
   object V643;
-  long V648;
+  intptr_t V648;
   unsigned char V653;
   object V651;
   object V654;
   object V658;
 
 T1240:
-if (V648 >= (long)V651) /* { dg-warning "cast from pointer to integer of different size" "" { target { ! int32plus } } } */
+if (V648 >= (intptr_t)V651) /* { dg-warning "cast from pointer to integer of different size" "" { target { ! int32plus } } } */
     goto T1243;
   V653 = ((char *) V654->v.v_self)[V648];
   V659 = (object) V654 + V653;
@@ -41,7 +42,7 @@
     goto T1249;
   goto T1224;
 T1249:
- V648 = (long) V648 + 1;
+  V648 = (intptr_t) V648 + 1;
   goto T1240;
 T1243:
   V643 = (object) & Cnil_body;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c gcc-4.4.1/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ccp1" } */
+
+#include <string.h>
+
+char c[10];
+
+void
+f1 ()
+{
+  const char *p = "123456";
+  memcpy (c, p, 6);
+}
+
+void
+f2 ()
+{
+  const char *p = "12345678";
+  p += 2;
+  memcpy (c, p, 6);
+}
+
+/* { dg-final { scan-tree-dump-times "memcpy\[^\n\]*123456" 2 "ccp1" } } */
+/* { dg-final { cleanup-tree-dump "ccp1" } } */
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/uninit-6.c gcc-4.4.1/gcc/testsuite/gcc.dg/uninit-6.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/uninit-6.c	2008-08-20 15:23:45.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/uninit-6.c	2009-08-03 12:27:32.000000000 -0700
@@ -39,7 +39,7 @@
     rv = malloc (sizeof (struct tree));
     rv->car = 0;
 
-    APPEND(rv, field, INTEGER_T, a);  /* { dg-bogus "field" "uninitialized variable warning" } */
+    APPEND(rv, field, INTEGER_T, a);  /* { dg-bogus "field" "uninitialized variable warning" { xfail *-*-* } } */
     APPEND(rv, field, PTR_T, b);
     APPEND(rv, field, INTEGER_T, c);
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/uninit-6-O0.c gcc-4.4.1/gcc/testsuite/gcc.dg/uninit-6-O0.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/uninit-6-O0.c	2008-08-20 15:23:45.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/uninit-6-O0.c	2009-08-03 12:27:32.000000000 -0700
@@ -39,7 +39,7 @@
     rv = malloc (sizeof (struct tree));
     rv->car = 0;
 
-    APPEND(rv, field, INTEGER_T, a);  /* { dg-bogus "field" "uninitialized variable warning" } */
+    APPEND(rv, field, INTEGER_T, a);  /* { dg-bogus "field" "uninitialized variable warning" { xfail *-*-* } } */
     APPEND(rv, field, PTR_T, b);
     APPEND(rv, field, INTEGER_T, c);
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/uninit-pr40943.c gcc-4.4.1/gcc/testsuite/gcc.dg/uninit-pr40943.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/uninit-pr40943.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/uninit-pr40943.c	2009-08-03 12:27:32.000000000 -0700
@@ -0,0 +1,10 @@
+/* PR middle-end/40943 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+void
+foo (void)
+{
+  int *p;
+  *p = 3;	/* { dg-warning "is used uninitialized" } */
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c gcc-4.4.1/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c	2007-09-04 06:05:19.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c	2009-07-28 09:51:19.000000000 -0700
@@ -4,7 +4,7 @@
 #include "tree-vect.h"
 
 #define N 40
-int a[200*N];
+int a[200*N+N];
 
 __attribute__ ((noinline)) void
 foo (){
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/O1-pr33854.c gcc-4.4.1/gcc/testsuite/gcc.dg/vect/O1-pr33854.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/O1-pr33854.c	2007-10-22 05:05:36.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/vect/O1-pr33854.c	2009-09-08 12:10:43.000000000 -0700
@@ -1,7 +1,7 @@
 /* Testcase by Martin Michlmayr <tbm@cyrius.com> */
 /* { dg-do compile } */
 
-extern void *malloc (long unsigned int __size);
+extern void *malloc (__SIZE_TYPE__ __size);
 typedef struct VMatrix_ VMatrix;
 struct VMatrix_
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/O1-pr41008.c gcc-4.4.1/gcc/testsuite/gcc.dg/vect/O1-pr41008.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/O1-pr41008.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/vect/O1-pr41008.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+
+double heating[2][2];
+
+void foo (int, int);
+
+void map_do()
+{
+  int jsav, ksav, k, j;
+
+  for(k = 0; k < 2; k++)
+    for(j = 0; j < 2; j++)
+      if (heating[k][j] > 0.)
+        {
+          jsav = j;
+          ksav = k;
+        }
+
+  foo (jsav, ksav);
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/pr33833.c gcc-4.4.1/gcc/testsuite/gcc.dg/vect/pr33833.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/pr33833.c	2007-10-25 09:41:45.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/vect/pr33833.c	2009-09-08 12:10:43.000000000 -0700
@@ -1,6 +1,10 @@
 /* Testcase by Martin Michlmayr <tbm@cyrius.com> */
 /* { dg-do compile } */
 
+#define signed
+typedef unsigned __PTRDIFF_TYPE__ uintptr_t;
+#undef signed
+
 struct list_head
 {
   struct list_head *prev;
@@ -14,7 +18,7 @@
   struct prio_array *active, arrays[2];
 } per_cpu__runqueues;
 
-void sched_init (unsigned long __ptr)
+void sched_init (uintptr_t __ptr)
 {
   int j, k;
   struct prio_array *array;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/pr33846.c gcc-4.4.1/gcc/testsuite/gcc.dg/vect/pr33846.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.dg/vect/pr33846.c	2007-10-23 13:15:04.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.dg/vect/pr33846.c	2009-09-08 12:10:43.000000000 -0700
@@ -7,7 +7,9 @@
   return ~i >> 31;
 }
 
-void _mix_some_samples (long buf, int *mix_buffer, int mix_size)
+typedef __PTRDIFF_TYPE__ intptr_t;
+
+void _mix_some_samples (intptr_t buf, int *mix_buffer, int mix_size)
 {
   int i;
   signed int *p = mix_buffer;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-1.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-1.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-1.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_DOUBLE" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 164 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-1.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-1.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-1.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_DOUBLE" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 164 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-2.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-2.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-2.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_DOUBLE" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 164 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-3.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-3.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-3.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-256-3.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_DOUBLE" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 164 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-2.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-2.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-2.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_DOUBLE" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 164 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-3.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-3.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestpd-3.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestpd-3.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_DOUBLE" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 164 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-1.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-1.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-1.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_FLOAT" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 150 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-256-1.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-256-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-256-1.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-256-1.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_FLOAT" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 150 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-256-2.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-256-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-256-2.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-256-2.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_FLOAT" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 150 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-256-3.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-256-3.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-256-3.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-256-3.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_FLOAT" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 150 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-2.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-2.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-2.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_FLOAT" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 150 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-3.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-3.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/avx-vtestps-3.c	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/avx-vtestps-3.c	2009-07-28 00:01:40.000000000 -0700
@@ -1,6 +1,8 @@
 /* { dg-do run } */
 /* { dg-require-effective-target avx } */
-/* { dg-options "-O2 -mavx" } */
+/* { dg-options "-O2 -mavx -DNEED_IEEE754_FLOAT" } */
+/* { dg-warning "attribute ignored" "" { target default_packed } 150 } */
+/* { dg-message " from " "include chain" { target default_packed } 0 } */
 
 #include "avx-check.h"
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/m128-check.h gcc-4.4.1/gcc/testsuite/gcc.target/i386/m128-check.h
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/m128-check.h	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/m128-check.h	2009-07-28 00:01:40.000000000 -0700
@@ -138,6 +138,7 @@
 CHECK_FP_ARRAY (d, double, ESP_DOUBLE, "%f")
 CHECK_FP_ARRAY (f, float, ESP_FLOAT, "%f")
 
+#ifdef NEED_IEEE754_FLOAT
 union ieee754_float
 {
    float d;
@@ -148,7 +149,9 @@
       unsigned sign : 1;
    } bits __attribute__((packed));
 };
+#endif
 
+#ifdef NEED_IEEE754_DOUBLE
 union ieee754_double
 {
    double d;
@@ -160,3 +163,4 @@
       unsigned sign : 1;
    } bits __attribute__((packed));
 };
+#endif
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr37248-2.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr37248-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr37248-2.c	2008-12-09 09:38:09.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr37248-2.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,5 @@
 /* PR middle-end/37248 */
-/* { dg-do compile } */
+/* { dg-do compile { target { ! default_packed } } } */
 /* { dg-options "-O2 -fdump-tree-optimized" } */
 
 struct S
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr37248-3.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr37248-3.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr37248-3.c	2008-12-09 09:38:09.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr37248-3.c	2009-07-27 23:56:49.000000000 -0700
@@ -1,6 +1,6 @@
 /* PR middle-end/37248 */
-/* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-do compile { target { ! default_packed } } } */
+/* { dg-options "-O2 -fdump-tree-optimized -mno-ms-bitfields" } */
 
 struct S
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40718.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40718.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40718.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40718.c	2009-08-23 05:37:53.000000000 -0700
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O1 -foptimize-sibling-calls" } */
+
+void abort (void);
+
+struct S
+{
+  void (__attribute__((__stdcall__)) *f) (struct S *);
+  int i;
+};
+
+void __attribute__((__stdcall__))
+foo (struct S *s)
+{
+  s->i++;
+}
+
+void __attribute__((__stdcall__))
+bar (struct S *s)
+{
+  foo(s);
+  s->f(s);
+}
+
+int main (void)
+{
+  struct S s = { foo, 0 };
+
+  bar (&s);
+  if (s.i != 2)
+    abort ();
+
+  return 0;
+}
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40906-1.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40906-1.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40906-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40906-1.c	2009-08-05 11:04:42.000000000 -0700
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O2 -fomit-frame-pointer -mpush-args -mno-accumulate-outgoing-args" } */
+
+void abort (void);
+
+void __attribute__((noinline))
+f (long double a)
+{
+  if (a != 1.23L)
+    abort ();
+}
+
+int __attribute__((noinline))
+g (long double b)
+{
+  f (b);
+  return 0;
+}
+
+int
+main (void)
+{
+  g (1.23L);
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40906-2.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40906-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40906-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40906-2.c	2009-08-05 11:04:42.000000000 -0700
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O2 -fomit-frame-pointer -mpush-args -mno-accumulate-outgoing-args -m128bit-long-double" } */
+
+void abort (void);
+
+void __attribute__((noinline))
+f (long double a)
+{
+  if (a != 1.23L)
+    abort ();
+}
+
+int __attribute__((noinline))
+g (long double b)
+{
+  f (b);
+  return 0;
+}
+
+int
+main (void)
+{
+  g (1.23L);
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40906-3.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40906-3.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40906-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40906-3.c	2009-08-05 11:04:42.000000000 -0700
@@ -0,0 +1,25 @@
+/* { dg-do run { target *-*-linux* } } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O2 -fomit-frame-pointer -msse2 -mpush-args -mno-accumulate-outgoing-args" } */
+
+#include "sse2-check.h"
+
+void __attribute__((noinline))
+f (__float128 a)
+{
+  if (a != 1.23Q)
+    abort ();
+}
+
+int __attribute__((noinline))
+g (__float128 b)
+{
+  f (b);
+  return 0;
+}
+
+static void
+sse2_test (void)
+{
+  g (1.23Q);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40934.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40934.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40934.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40934.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O2 -march=i586 -ffast-math" } */
+
+extern double host_frametime;
+extern float pitchvel;
+V_DriftPitch (float delta, float move)
+{
+  if (!delta)
+    move = host_frametime;
+  if (delta > 0)
+    ;
+  else if (delta < 0 && move > -delta)
+    pitchvel = 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40957.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40957.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr40957.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr40957.c	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+typedef int __v8si __attribute__((__vector_size__(32)));
+typedef long long __m256i __attribute__((__vector_size__(32), __may_alias__));
+
+static __m256i
+_mm256_set1_epi32 (int __A)
+{
+  return __extension__ (__m256i)(__v8si){ __A, __A, __A, __A,
+					  __A, __A, __A, __A };
+}
+__m256i
+foo ()
+{
+  return _mm256_set1_epi32 (-1);
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr41019.c gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr41019.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/i386/pr41019.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/i386/pr41019.c	2009-08-16 12:34:49.000000000 -0700
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -msse2 -ftree-vectorize" } */
+
+#include "sse2-check.h"
+
+long long int a[64];
+
+void
+sse2_test (void)
+{
+  int k;
+
+  for (k = 0; k < 64; k++)
+    a[k] = a[k] != 5 ? 12 : 10;
+
+  for (k = 0; k < 64; k++)
+    if (a[k] != 12)
+      abort ();
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gcc.target/powerpc/pr39902-2.c gcc-4.4.1/gcc/testsuite/gcc.target/powerpc/pr39902-2.c
--- gcc-4.4.1.orig/gcc/testsuite/gcc.target/powerpc/pr39902-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gcc.target/powerpc/pr39902-2.c	2009-08-03 14:43:32.000000000 -0700
@@ -0,0 +1,28 @@
+/* Check that simplification "x*(-1)" -> "-x" is not performed for decimal
+   float types.  */
+
+/* { dg-do compile { target { powerpc*-*-linux* && powerpc_fprs } } } */
+/* { dg-options "-std=gnu99 -O -mcpu=power6" } */
+/* { dg-final { scan-assembler-not "fneg" } } */
+
+extern _Decimal32 a32, b32;
+extern _Decimal64 a64, b64;
+extern _Decimal128 a128, b128;
+
+void
+foo32 (void)
+{
+  b32 = a32 * -1.0DF;
+}
+
+void
+foo64 (void)
+{
+  b64 = a64 * -1.0DD;
+}
+
+void
+foo128 (void)
+{
+  b128 = a128 * -1.0DL;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/cdce3.C gcc-4.4.1/gcc/testsuite/g++.dg/cdce3.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/cdce3.C	2008-09-23 14:27:17.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/g++.dg/cdce3.C	2009-08-28 02:57:51.000000000 -0700
@@ -2,14 +2,14 @@
 /* { dg-require-effective-target c99_runtime } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details  -DGNU_EXTENSION -DLARGE_LONG_DOUBLE -lm" { target { pow10 && large_long_double } } } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details -DLARGE_LONG_DOUBLE -lm" { target { {! pow10 } && large_long_double } } } */
-/* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details -DGNU_EXTENSION -lm" { target {pow10 && {! large_long_double } } } } */
+/* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details -DGNU_EXTENSION -lm" { target { pow10 && {! large_long_double } } } } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details -lm" { target { {! pow10 } && {! large_long_double } } } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:91: note: function call is shrink-wrapped into error conditions\." "cdce" { target { pow10 } } } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:92: note: function call is shrink-wrapped into error conditions\." "cdce" { target { pow10 } } } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:94: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:95: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:96: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:97: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
+/* { dg-options "-mieee -O2 -fmath-errno -fdump-tree-cdce-details  -DGNU_EXTENSION -DLARGE_LONG_DOUBLE -lm" { target { alpha*-*-* && { pow10 && large_long_double } } } } */
+/* { dg-options "-mieee -O2 -fmath-errno -fdump-tree-cdce-details -DLARGE_LONG_DOUBLE -lm" { target { alpha*-*-* && { {! pow10 } && large_long_double } } } } */
+/* { dg-options "-mieee -O2 -fmath-errno -fdump-tree-cdce-details -DGNU_EXTENSION -lm" { target { alpha*-*-* && { pow10 && {! large_long_double } } } } } */
+/* { dg-options "-mieee -O2 -fmath-errno -fdump-tree-cdce-details -lm" { target { alpha*-*-* && { {! pow10 } && {! large_long_double } } } } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:95: note: function call is shrink-wrapped into error conditions\." "cdce" { target { pow10 } } } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:96: note: function call is shrink-wrapped into error conditions\." "cdce" { target { pow10 } } } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:98: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:99: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:100: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
@@ -20,6 +20,10 @@
 /* { dg-final { scan-tree-dump  "cdce3.C:105: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:106: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:107: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:108: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:109: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:110: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:111: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { cleanup-tree-dump "cdce" } } */
 #include <stdlib.h>
 #include <math.h>
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/cpp0x/enum1.C gcc-4.4.1/gcc/testsuite/g++.dg/cpp0x/enum1.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/cpp0x/enum1.C	2008-11-10 05:41:37.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/cpp0x/enum1.C	2009-08-31 14:20:07.000000000 -0700
@@ -2,5 +2,5 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 
-enum : { };	// { dg-error "expected type-specifier" }
+enum : { };	// { dg-error "expected" }
 enum : 3 { };	// { dg-error "expected" }
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/cpp0x/initlist22.C gcc-4.4.1/gcc/testsuite/g++.dg/cpp0x/initlist22.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/cpp0x/initlist22.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/cpp0x/initlist22.C	2009-07-24 11:06:08.000000000 -0700
@@ -0,0 +1,24 @@
+// Core issue 934
+// { dg-options "-std=c++0x" }
+
+int i;
+
+int& r1{ i };			// OK, direct binding
+int&& r2{ i };			// OK, direct binding
+
+int& r3{ };			// { dg-error "" } reference to temporary
+int&& r4{ };			// OK, reference to temporary
+
+struct A { int i; } a;
+
+A& r5 { i };			// { dg-error "" } reference to temporary
+A&& r6 { i };			// OK, aggregate initialization of temporary
+A& r7 { a };			// { dg-error "" } invalid aggregate initializer for A
+A&& r8 { a };			// { dg-error "" } invalid aggregate initializer for A
+
+struct B { B(int); int i; } b(0);
+
+B& r9 { i };			// { dg-error "" } reference to temporary
+B&& r10 { i };			// OK, make temporary with B(int) constructor
+B& r11 { b };			// { dg-error "" } reference to temporary
+B&& r12 { b };			// OK, make temporary with copy constructor
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/cpp0x/initlist23.C gcc-4.4.1/gcc/testsuite/g++.dg/cpp0x/initlist23.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/cpp0x/initlist23.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/cpp0x/initlist23.C	2009-07-24 11:06:08.000000000 -0700
@@ -0,0 +1,15 @@
+// { dg-options "-std=c++0x" }
+
+#include <initializer_list>
+
+struct A
+{
+  A& operator=(int i);
+  A& operator=(std::initializer_list<int> l) { return *this; }
+};
+
+int main()
+{
+  A a;
+  a = { };
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C gcc-4.4.1/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C	2009-08-04 05:28:27.000000000 -0700
@@ -0,0 +1,14 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR debug/39706
+// { dg-options "-g -dA" }
+// { dg-do compile }
+// { dg-final { scan-assembler-times ".debug_pubnames" 1 } }
+// { dg-final { scan-assembler-times "\"main\".*external name" 1 } }
+// { dg-final { scan-assembler-times "\"ns::ns_x.*external name" 1 } }
+// { dg-final { scan-assembler-times "\"y::y_x.*external name" 1 } }
+
+namespace ns { int ns_x; }
+class y { public: static int y_x; };
+int y::y_x;
+int main() { return ns::ns_x; }
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C gcc-4.4.1/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,33 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/40705
+// { dg-options "-g -dA" }
+// { dg-do compile }
+// { dg-final { scan-assembler-times "DW_TAG_structure_type" 2 } }
+// { dg-final { scan-assembler-times "DW_AT_name: \"foo<1u>\"" 1 } }
+// { dg-final { scan-assembler-times "DW_TAG_enumeration_type" 2 } }
+// { dg-final { scan-assembler-times "DW_AT_name: \"typedef foo<1u>::type type\"" 1 } }
+// { dg-final { scan-assembler-times "DIE (.*) DW_TAG_enumeration_type" 2 } }
+// { dg-final { scan-assembler-times "\"e0..\".*DW_AT_name" 1 } }
+// { dg-final { scan-assembler-times "\"e1..\".*DW_AT_name" 1 } }
+
+template <unsigned int n>
+struct foo
+{
+public:
+    typedef
+ unsigned char type;
+};
+
+template<>
+struct foo<1>
+{
+    typedef enum { e0, e1 } type;
+};
+
+int
+main()
+{
+    foo<1> f;
+    foo<1>::type t = foo<1>::e1;
+    return t;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/expr/stmt-expr-1.C gcc-4.4.1/gcc/testsuite/g++.dg/expr/stmt-expr-1.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/expr/stmt-expr-1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/expr/stmt-expr-1.C	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,36 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/40866
+// { dg-options "-std=gnu++98" }
+// { dg-do "compile" }
+
+template <typename T> class QForeachContainer {
+public:
+    QForeachContainer();
+    int brk;
+    typename T::const_iterator i;
+};
+
+template <typename T> class QList {
+public:
+    class const_iterator {
+    public:
+        const_iterator(const const_iterator &o);
+        const_iterator &operator++();
+    };
+};
+
+class QAction;
+class QWidget {
+public:
+    QList<QAction*> actions() const;
+};
+class myDialog : public QWidget {
+    myDialog();
+};
+
+myDialog::myDialog()
+{
+    QForeachContainer<__typeof__(actions())> _container_;
+    ({++_container_.brk; ++_container_.i;});
+}
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/expr/unary3.C gcc-4.4.1/gcc/testsuite/g++.dg/expr/unary3.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/expr/unary3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/expr/unary3.C	2009-08-21 00:10:36.000000000 -0700
@@ -0,0 +1,11 @@
+// PR c++/41131
+// { dg-do compile }
+
+struct X { enum E { a = 100 }; };
+
+int
+main ()
+{
+  X x;
+  (void) &x.a;    // { dg-error "lvalue required" }
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield2.C gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield2.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield2.C	2009-01-25 12:15:44.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield2.C	2009-07-27 23:56:49.000000000 -0700
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* Remove pedantic.  Allow the GCC extension to use char for bitfields.  */
 /* { dg-options "" } */
+/* { dg-options "-mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 { /* { dg-message "note: Offset of packed bit-field 't::b' has changed in GCC 4.4" "" { target pcc_bitfield_type_matters } } */
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield3.C gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield3.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield3.C	2009-01-22 22:29:54.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield3.C	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-Wno-packed-bitfield-compat" } */
+/* { dg-options "-Wno-packed-bitfield-compat -mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield4.C gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield4.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield4.C	2009-01-25 12:15:44.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield4.C	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "" } */
+/* { dg-options "-mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 { /* { dg-message "note: Offset of packed bit-field 't::b' has changed in GCC 4.4" "" { target pcc_bitfield_type_matters } } */
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield5.C gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield5.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/bitfield5.C	2009-01-22 22:29:54.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/ext/bitfield5.C	2009-07-27 23:56:49.000000000 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-Wno-packed-bitfield-compat" } */
+/* { dg-options "-Wno-packed-bitfield-compat -mno-ms-bitfields" { target i?86-*-netware } } */
 
 struct t
 {
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/complit12.C gcc-4.4.1/gcc/testsuite/g++.dg/ext/complit12.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/ext/complit12.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/ext/complit12.C	2009-08-06 10:22:19.000000000 -0700
@@ -0,0 +1,65 @@
+// PR c++/40948
+// { dg-do run }
+// { dg-options "" }
+
+int c;
+struct M
+{
+  M () { ++c; }
+  M (const M&) { ++c; }
+  ~M () { --c; }
+};
+
+struct S
+{
+  S ();
+  M m[1];
+};
+
+S::S () : m ((M[1]) { M () })
+{
+}
+
+struct T
+{
+  T ();
+  M m[4];
+};
+
+T::T () : m ((M[4]) { M (), M (), M (), M () })
+{
+}
+
+typedef M MA[1];
+MA &bar (MA, MA& r) { return r; }
+
+M f(M m) { return m; }
+
+int main ()
+{
+  {
+    M m[1] = (M[1]) { M () };
+    if (c != 1)
+      return 1;
+    M n = (M) { M () };
+    if (c != 2)
+      return 2;
+    M o[4] = (M[4]) { M (), M (), M (), M () };
+    if (c != 6)
+      return 3;
+    S s;
+    if (c != 7)
+      return 4;
+    T t;
+    if (c != 11)
+      return 5;
+    MA ma = bar ((M[2]) { M(), M() }, m);
+    if (c != 12)
+      return 7;
+    M mm[2] = ((M[2]) { f(M()), f(M()) });
+    if (c != 14)
+      return 8;
+  }
+  if (c != 0)
+    return 6;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/lookup/using21.C gcc-4.4.1/gcc/testsuite/g++.dg/lookup/using21.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/lookup/using21.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/lookup/using21.C	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,13 @@
+// PR c++/40799
+
+namespace Bar {
+  typedef int A;
+}
+class CollectionDeleteGuard {
+public:
+  CollectionDeleteGuard(int);
+};
+CollectionDeleteGuard::CollectionDeleteGuard(int)
+{
+  using Bar::A;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/opt/pr40496.C gcc-4.4.1/gcc/testsuite/g++.dg/opt/pr40496.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/opt/pr40496.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/opt/pr40496.C	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,18 @@
+// { dg-do compile }
+// { dg-options "-O2 -fprefetch-loop-arrays -msse2" { target i?86-*-* x86_64-*-* } }
+
+struct DOMStringHandle
+{
+  unsigned int fLength;
+  int fRefCount;
+};
+static void *freeListPtr;
+void foo(DOMStringHandle *dsg)
+{
+  int i;
+  for (i = 1; i < 1023; i++)
+    {
+      *(void **) &dsg[i] = freeListPtr;
+      freeListPtr = &dsg[i];
+    }
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/other/gc4.C gcc-4.4.1/gcc/testsuite/g++.dg/other/gc4.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/other/gc4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/other/gc4.C	2009-08-29 19:06:32.000000000 -0700
@@ -0,0 +1,14 @@
+// PR c++/41120
+// { dg-options "--param ggc-min-heapsize=0 --param ggc-min-expand=0" }
+
+struct A
+{
+  A();
+};
+
+struct B
+{
+  A a;
+};
+
+B b;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/other/typedef3.C gcc-4.4.1/gcc/testsuite/g++.dg/other/typedef3.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/other/typedef3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/other/typedef3.C	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,12 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/40357
+// { dg-do compile }
+
+struct XalanCProcessor
+{
+      typedef enum {eInvalid, eXalanSourceTree, eXercesDOM} ParseOptionType;
+          ParseOptionType getParseOption(void);
+};
+typedef XalanCProcessor::ParseOptionType ParseOptionType;
+ParseOptionType XalanCProcessor::getParseOption(void) {}
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/overload/defarg4.C gcc-4.4.1/gcc/testsuite/g++.dg/overload/defarg4.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/overload/defarg4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/overload/defarg4.C	2009-08-07 06:15:43.000000000 -0700
@@ -0,0 +1,26 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39987
+// { dg-do "compile" }
+
+class foo
+{
+ template<typename U>
+ static bool func(const U& x)
+ {}
+public:
+ template<typename U>
+ unsigned int Find(const U& x, bool (*pFunc) (const U&) = func) const
+ {}
+};
+
+class bar {
+ bool Initialize();
+protected:
+ foo b;
+};
+
+bool bar::Initialize()
+{
+        b.Find(b);
+}
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/parse/enum5.C gcc-4.4.1/gcc/testsuite/g++.dg/parse/enum5.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/parse/enum5.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/parse/enum5.C	2009-08-31 14:20:07.000000000 -0700
@@ -0,0 +1,17 @@
+// PR c++/41127
+
+#define CHAR_BIT 8
+enum EE {ee};
+typedef unsigned int T;
+
+struct D {
+        T : sizeof(unsigned int) * CHAR_BIT; // OK
+        EE : sizeof(EE) * CHAR_BIT; // OK
+        enum EE : sizeof(EE) * CHAR_BIT; // not OK
+        enum EE xxxx : sizeof(EE) * CHAR_BIT; // OK
+        T x : sizeof(unsigned int) * CHAR_BIT; // OK
+        enum FF {ff} : sizeof(int) * CHAR_BIT; // OK
+} element;
+
+enum EE xx;
+EE yy;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40321.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40321.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40321.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40321.C	2009-07-22 07:45:21.000000000 -0700
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+
+struct VectorD2
+{
+  VectorD2() : x(0), y(0) { }
+  VectorD2(int _x, int _y) : x(_x), y(_y) { }
+  int x, y;
+  int GetLength2() const { return x*x + y*y; };
+  VectorD2 operator+(const VectorD2 vec) const {
+      return VectorD2(x+vec.x,y+vec.y);
+  }
+};
+struct Shape
+{
+  enum Type { ST_RECT, ST_CIRCLE } type;
+  VectorD2 pos;
+  VectorD2 radius;
+  bool CollisionWith(const Shape& s) const;
+};
+bool Shape::CollisionWith(const Shape& s) const
+{
+  if(type == ST_CIRCLE && s.type == ST_RECT)
+    return s.CollisionWith(*this);
+  return (pos + s.pos).GetLength2() < (radius + s.radius).GetLength2();
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40834.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40834.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40834.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40834.C	2009-08-05 07:45:15.000000000 -0700
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+
+extern "C" void abort (void);
+class XalanDOMString
+{
+public:
+  int y;
+};
+
+class XObject
+{
+public:
+  const XalanDOMString& str() const { return x; }
+  XalanDOMString x;
+};
+
+class XObjectPtr
+{
+public:
+  XObjectPtr(const XObjectPtr& theSource)
+    {
+      m_xobjectPtr = theSource.m_xobjectPtr;
+    }
+  const XObject* operator->() const
+    {
+      return m_xobjectPtr;
+    };
+  XObjectPtr(XObject *p) { m_xobjectPtr = p; }
+  XObject* m_xobjectPtr;
+};
+
+class FunctionSubstringBefore
+{
+public:
+  int execute( const XObjectPtr arg1) const
+    {
+      const XalanDOMString& theFirstString = arg1->str();
+      return theFirstString.y;
+    }
+};
+
+int
+main ()
+{
+  XObject x; 
+  XObjectPtr y (&x);
+  x.x.y = -1;
+  FunctionSubstringBefore z;
+  if (z.execute (y) != -1)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40924.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40924.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40924.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40924.C	2009-08-05 05:54:21.000000000 -0700
@@ -0,0 +1,111 @@
+// PR rtl-optimization/40924
+// { dg-do run }
+
+extern "C" void abort (void);
+
+#define MAY_ALIAS __attribute__((__may_alias__))
+
+typedef struct { float v[2]; } floata;
+typedef struct { int v[2]; } inta;
+
+typedef unsigned int uint MAY_ALIAS;
+typedef signed int sint MAY_ALIAS;
+typedef float flt MAY_ALIAS;
+
+static inline unsigned short
+less_than (inta a, inta b)
+{
+  unsigned short r = 0;
+  const uint *p1 = (const uint *) &a;
+  const uint *p2 = (const uint *) &b;
+  for (int i=0; i < 2; i++)
+    if (p1[i] < p2[i]) r |= (1 << i);
+  return r;
+}
+
+static inline inta
+multiply (inta b, inta c)
+{
+  inta r;
+  sint *p3 = (sint *) &c;
+  for (int i=0; i < 2; i++)
+    r.v[i] = (int) (b.v[i] * p3[i] & 0xFFFFFFFF);
+  return r;
+}
+
+static inline floata
+gather (inta indexes, const void *baseAddr)
+{
+  floata r;
+
+  sint *idx = (sint *) &indexes;
+  flt *src = (flt *) baseAddr;
+  for (int i=0; i < 2; i++)
+    r.v[i] = *(src + idx[i]);
+  return r;
+}
+
+static inline inta
+add (const inta &b, const inta &c)
+{
+  inta result;
+  sint *r = (sint *) &result;
+
+  for (int i=0; i < 2; i++)
+    r[i] = b.v[i] + c.v[i];
+  return result;
+}
+
+struct uintv
+{
+  inta data;
+  inline uintv () { data.v[0] = 0; data.v[1] = 1; }
+  inline uintv (unsigned int a)
+  {
+    for (int i=0; i < 2; i++)
+      *(uint *) &data.v[i] = a;
+  }
+  inline uintv (inta x) : data (x) {}
+  inline uintv operator* (const uintv &x) const
+  { return multiply (data, x.data); }
+  inline uintv operator+ (const uintv &x) const
+  { return uintv (add (data, x.data)); }
+  inline unsigned short operator< (const uintv &x) const
+  { return less_than (data, x.data); }
+};
+
+struct floatv
+{
+  floata data;
+  explicit inline floatv (const uintv &x)
+  {
+    uint *p2 = (uint *) &x.data;
+    for (int i=0; i < 2; i++)
+      data.v[i] = p2[i];
+  }
+  inline floatv (const float *array, const uintv &indexes)
+  {
+    const uintv &offsets = indexes * uintv (1);
+    data = gather (offsets.data, array);
+  }
+  unsigned short operator== (const floatv &x) const
+  {
+    unsigned short r = 0;
+    for (int i=0; i < 2; i++)
+      if (data.v[i] == x.data.v[i]) r |= (1 << i);
+    return r;
+  }
+};
+
+int
+main ()
+{
+  const float array[2] = { 2, 3 };
+  for (uintv i; (i < 2) == 3; i = i + 2)
+    {
+      const floatv ii (i + 2);
+      floatv a (array, i);
+      if ((a == ii) != 3)
+	abort ();
+    }
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40991.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40991.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr40991.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr40991.C	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,113 @@
+/* { dg-options "-std=gnu++0x" } */
+
+typedef __SIZE_TYPE__ size_t;
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    using ::size_t;
+    void __throw_bad_function_call() __attribute__((__noreturn__));
+}
+inline void* operator new(std::size_t, void* __p) throw() {
+    return __p;
+}
+namespace std {
+    class type_info {
+    public:
+	bool operator==(const type_info& __arg) const { }
+    };
+    namespace tr1 {
+	template<typename _Tp, _Tp __v> struct integral_constant { };
+	typedef integral_constant<bool, true> true_type;
+	template<typename _Res, typename... _ArgTypes>
+	struct _Maybe_unary_or_binary_function { };
+	class _Undefined_class;
+	union _Nocopy_types {
+	    void (_Undefined_class::*_M_member_pointer)();
+	};
+	union _Any_data {
+	    void* _M_access() {
+		return &_M_pod_data[0];
+	    }
+	    char _M_pod_data[sizeof(_Nocopy_types)];
+	};
+	enum _Manager_operation { __get_type_info, __get_functor_ptr, __clone_functor, __destroy_functor };
+	template<typename _Tp> struct _Simple_type_wrapper {
+	    _Simple_type_wrapper(_Tp __value) : __value(__value) { }
+	    _Tp __value;
+	};
+	template<typename _Signature> class function;
+	class _Function_base {
+	public:
+	    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
+	    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);
+	    template<typename _Functor> class _Base_manager {
+		static const bool __stored_locally = (sizeof(_Functor) <= _M_max_size && __alignof__(_Functor) <= _M_max_align && (_M_max_align % __alignof__(_Functor) == 0));
+		typedef integral_constant<bool, __stored_locally> _Local_storage;
+	    public:
+		static bool _M_manager(_Any_data& __dest, const _Any_data& __source, _Manager_operation __op) { }
+		static void _M_init_functor(_Any_data& __functor, const _Functor& __f) {
+		    _M_init_functor(__functor, __f, _Local_storage());
+		}
+		template<typename _Class, typename _Tp> static bool _M_not_empty_function(_Tp _Class::* const& __mp) {
+		    return __mp;
+		}
+		static void _M_init_functor(_Any_data& __functor, const _Functor& __f, true_type) {
+		    new (__functor._M_access()) _Functor(__f);
+		}
+	    };
+	    ~_Function_base() {
+		if (_M_manager) _M_manager(_M_functor, _M_functor, __destroy_functor);
+	    }
+	    bool _M_empty() const {
+		return !_M_manager;
+	    }
+	    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&, _Manager_operation);
+	    _Any_data _M_functor;
+	    _Manager_type _M_manager;
+	};
+	template<typename _Signature, typename _Functor> class _Function_handler;
+	template<typename _Class, typename _Member, typename _Res, typename... _ArgTypes> class _Function_handler<_Res(_ArgTypes...), _Member _Class::*> : public _Function_handler<void(_ArgTypes...), _Member _Class::*> {
+	public:
+	    static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args) { }
+	};
+	template<typename _Class, typename _Member, typename... _ArgTypes> class _Function_handler<void(_ArgTypes...), _Member _Class::*> : public _Function_base::_Base_manager< _Simple_type_wrapper< _Member _Class::* > > { };
+	template<typename _Res, typename... _ArgTypes> class function<_Res(_ArgTypes...)> : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>, private _Function_base {
+	    typedef _Res _Signature_type(_ArgTypes...);
+	    struct _Useless { };
+	public:
+	    template<typename _Functor> function(_Functor __f, _Useless = _Useless());
+	    _Res operator()(_ArgTypes... __args) const;
+	    const type_info& target_type() const;
+	    typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
+	    _Invoker_type _M_invoker;
+	};
+	template<typename _Res, typename... _ArgTypes> template<typename _Functor> function<_Res(_ArgTypes...)>:: function(_Functor __f, _Useless) : _Function_base() {
+	    typedef _Function_handler<_Signature_type, _Functor> _My_handler;
+	    if (_My_handler::_M_not_empty_function(__f)) {
+		_M_invoker = &_My_handler::_M_invoke;
+		_M_manager = &_My_handler::_M_manager;
+		_My_handler::_M_init_functor(_M_functor, __f);
+	    }
+	}
+	template<typename _Res, typename... _ArgTypes> _Res function<_Res(_ArgTypes...)>:: operator()(_ArgTypes... __args) const {
+	    if (_M_empty()) {
+		__throw_bad_function_call();
+	    }
+	    return _M_invoker(_M_functor, __args...);
+	}
+	template<typename _Res, typename... _ArgTypes> const type_info& function<_Res(_ArgTypes...)>:: target_type() const {
+	    if (_M_manager) {
+		_Any_data __typeinfo_result;
+		_M_manager(__typeinfo_result, _M_functor, __get_type_info);
+	    }
+	}
+    }
+}
+struct X {
+    int bar;
+};
+void test05() {
+    using std::tr1::function;
+    X x;
+    function<int(X&)> frm(&X::bar);
+    frm(x) == 17;
+    typeid(int X::*) == frm.target_type();
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41144.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41144.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41144.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41144.C	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+
+struct rgba8;
+template<class ColorT> class span_gouraud     {
+public:
+    struct coord_type { };
+    coord_type m_coord[3];
+};
+template<class ColorT> class span_gouraud_rgba : public span_gouraud<ColorT>   
+{
+  typedef ColorT color_type;
+  typedef span_gouraud<color_type> base_type;
+  typedef typename base_type::coord_type coord_type;
+public:
+  void prepare()         {
+      coord_type coord[3];
+  }
+};
+void the_application() {
+    typedef span_gouraud_rgba<rgba8> gouraud_span_gen_type;
+    gouraud_span_gen_type span_gouraud;
+    span_gouraud.prepare();
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41257-2.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41257-2.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41257-2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41257-2.C	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,16 @@
+/* { dg-do link } */
+
+struct A
+{
+  virtual ~A();
+};
+
+struct B : virtual A
+{
+  virtual ~B() {}
+};
+
+int main()
+{
+  return 0;
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41257.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41257.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41257.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41257.C	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+
+struct A
+{
+  virtual void foo();
+  virtual ~A();
+  int i;
+};
+
+struct B : virtual A {};
+
+struct C : B
+{
+  virtual void foo();
+};
+
+void bar()
+{
+  C().foo();
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41273.C gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41273.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/torture/pr41273.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/torture/pr41273.C	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-g" } */
+
+long *H2_ipX_ener_sort;
+double H2_old_populations[2];
+double H2_total;
+
+void H2_LevelPops()
+{
+  double sum_pop = 0.;
+  long nEner = 0;
+  while( nEner < 3 && sum_pop/H2_total < 0.99999 )
+    {
+      long ip = H2_ipX_ener_sort[nEner];
+      sum_pop += H2_old_populations[ip];
+      ++nEner;
+    }
+}
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.dg/warn/Wreturn-type-6.C gcc-4.4.1/gcc/testsuite/g++.dg/warn/Wreturn-type-6.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.dg/warn/Wreturn-type-6.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.dg/warn/Wreturn-type-6.C	2009-07-26 09:05:22.000000000 -0700
@@ -0,0 +1,13 @@
+/* PR c++/40749 */
+/* { dg-do "compile" } */
+/* { dg-options "-Wreturn-type" } */
+
+struct A {};
+const A a() {} /* { dg-warning "no return statement" } */
+const A& b() {} /* { dg-warning "no return statement" } */
+
+const int c() {} /* { dg-warning "no return statement" } */
+
+template<class T>
+const int foo(T t) {} /* { dg-warning "no return statement" } */
+int d = foo<int>(0), e = foo<int>(1);
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/altreturn_7.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/altreturn_7.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/altreturn_7.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/altreturn_7.f90	2009-07-28 09:51:19.000000000 -0700
@@ -0,0 +1,34 @@
+! { dg-do compile }
+!
+! PR 40848: [4.5 Regression] ICE with alternate returns
+!
+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>
+
+MODULE TT
+
+INTERFACE M
+ MODULE PROCEDURE M1,M2
+END INTERFACE
+
+CONTAINS
+
+ SUBROUTINE M1(I,*)
+   INTEGER :: I
+   RETURN 1
+ END SUBROUTINE
+
+ SUBROUTINE M2(I,J)
+   INTEGER :: I,J
+ END SUBROUTINE
+
+END MODULE
+
+
+  USE TT
+  CALL M(1,*2)
+  CALL ABORT()
+2 CONTINUE
+END
+
+! { dg-final { cleanup-modules "tt" } }
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/c_f_pointer_tests_4.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/c_f_pointer_tests_4.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/c_f_pointer_tests_4.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/c_f_pointer_tests_4.f90	2009-08-20 13:42:38.000000000 -0700
@@ -0,0 +1,15 @@
+! { dg-do run }
+program main
+   use iso_c_binding, only: c_ptr, c_loc, c_f_pointer
+   implicit none
+   integer, dimension(2,1,2), target :: table
+   table = reshape ( (/ 1,2,-1,-2/), (/2,1,2/))
+   call set_table (c_loc (table))
+contains
+   subroutine set_table (cptr)
+     type(c_ptr), intent(in) :: cptr
+     integer, dimension(:,:,:), pointer :: table_tmp
+     call c_f_pointer (cptr, table_tmp, (/2,1,2/))
+     if (any(table_tmp /= table)) call abort
+   end subroutine set_table
+end program main
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/char_length_16.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/char_length_16.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/char_length_16.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/char_length_16.f90	2009-07-28 09:51:19.000000000 -0700
@@ -0,0 +1,12 @@
+! { dg-do compile }
+!
+! PR 40822: [4.5 Regression] Internal compiler error when Fortran intrinsic LEN referenced before explicit declaration
+!
+! Contributed by Mat Cross <mathewc@nag.co.uk>
+
+SUBROUTINE SEARCH(ITEMVAL)
+  CHARACTER (*) :: ITEMVAL
+  CHARACTER (LEN(ITEMVAL)) :: ITEM
+  INTRINSIC LEN
+END
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/derived_init_3.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/derived_init_3.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/derived_init_3.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/derived_init_3.f90	2009-07-29 02:35:15.000000000 -0700
@@ -0,0 +1,34 @@
+! { dg-do run }
+!
+! PR fortran/40851
+!
+! Make sure the an INTENT(OUT) dummy is not initialized
+! when it is a pointer.
+!
+! Contributed by Juergen Reuter <juergen.reuter@desy.de>.
+!
+program main
+
+  type :: string
+     character,dimension(:),allocatable :: chars
+  end type string
+
+  type :: string_container
+     type(string) :: string
+  end type string_container
+
+  type(string_container), target :: tgt
+  type(string_container), pointer :: ptr
+
+  ptr => tgt
+  call set_ptr (ptr)
+  if (associated(ptr)) call abort()
+
+contains
+
+  subroutine set_ptr (ptr)
+    type(string_container), pointer, intent(out) :: ptr
+    ptr => null ()
+  end subroutine set_ptr
+
+end program main
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/fmt_cache_1.f gcc-4.4.1/gcc/testsuite/gfortran.dg/fmt_cache_1.f
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/fmt_cache_1.f	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/fmt_cache_1.f	2009-07-23 10:50:56.000000000 -0700
@@ -0,0 +1,33 @@
+! { dg-do run { target fd_truncate } }
+! pr40662 segfaults when specific format is invoked twice.
+! pr40330  incorrect io.
+! test case derived from pr40662, <jvdelisle@gcc.gnu.org>
+      program astap
+      character(40) teststring
+      arlxca = 0.0
+      open(10)
+      write(10,40) arlxca
+      write(10,40) arlxca
+40    format(t4,"arlxca = ",1pg13.6,t27,"arlxcc = ",g13.6,t53,
+     .            "atmpca = ",g13.6,t79,"atmpcc = ",g13.6,t105,
+     .            "backup = ",g13.6,/,
+     .         t4,"csgfac = ",g13.6,t27,"csgmax = ",g13.6,t53,
+     .            "csgmin = ",g13.6,t79,"drlxca = ",g13.6,t105,
+     .            "drlxcc = ",g13.6,/,
+     .         t4,"dtimeh = ",g13.6,t27,"dtimei = ",g13.6,t53,
+     .            "dtimel = ",g13.6,t79,"dtimeu = ",g13.6,t105,
+     .            "dtmpca = ",g13.6,/,
+     .         t4,"dtmpcc = ",g13.6,t27,"ebalna = ",g13.6,t53,
+     .            "ebalnc = ",g13.6,t79,"ebalsa = ",g13.6,t105,
+     .            "ebalsc = ",g13.6)
+      rewind 10
+      rewind 10
+      teststring = ""
+      read(10,'(a)') teststring
+      if (teststring.ne."   arlxca =   0.00000     arlxcc = ")call abort
+      teststring = ""
+      read(10,'(a)') teststring
+      if (teststring.ne."   arlxca =   0.00000     arlxcc = ")call abort
+      end program astap
+
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/gomp/pr40878-1.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/gomp/pr40878-1.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/gomp/pr40878-1.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/gomp/pr40878-1.f90	2009-07-28 09:33:08.000000000 -0700
@@ -0,0 +1,63 @@
+! PR fortran/40878
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+subroutine test1
+  integer :: j, k
+  integer :: m = 2
+!$omp parallel do collapse(m) schedule (static,1) ! { dg-error "Constant expression required" }
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
+subroutine test2
+  integer :: j, k
+  integer :: m
+  m = 2
+!$omp parallel do collapse(m) schedule (static,1) ! { dg-error "Constant expression required" }
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
+subroutine test3
+  integer :: j, k
+  integer, parameter :: m = 0
+!$omp parallel do collapse(m) schedule (static,1) ! { dg-error "not constant positive integer" }
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
+subroutine test4
+  integer :: j, k
+  integer, parameter :: m = -2
+!$omp parallel do collapse(m) schedule (static,1) ! { dg-error "not constant positive integer" }
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
+subroutine test5
+  integer :: j, k
+!$omp parallel do collapse(0) schedule (static,1) ! { dg-error "not constant positive integer" }
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
+subroutine test6
+  integer :: j, k
+!$omp parallel do collapse(-1) schedule (static,1) ! { dg-error "not constant positive integer" }
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/gomp/pr40878-2.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/gomp/pr40878-2.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/gomp/pr40878-2.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/gomp/pr40878-2.f90	2009-07-28 09:33:08.000000000 -0700
@@ -0,0 +1,23 @@
+! PR fortran/40878
+! { dg-do compile }
+! { dg-options "-fopenmp" } 
+
+subroutine test1
+  integer :: j, k
+  integer, parameter :: m = 2
+!$omp parallel do collapse(m) schedule (static,1)
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
+subroutine test2
+  integer :: j, k
+!$omp parallel do collapse(2) schedule (static,1)
+  do k = 1, 2
+    do j = 1, 6
+    enddo
+  enddo
+!$omp end parallel do
+end
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_3.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_3.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_3.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_3.f90	2009-09-11 15:11:06.000000000 -0700
@@ -0,0 +1,40 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+!
+! PR 39876: module procedure name that collides with the GNU intrinsic
+!
+! Contributed by Alexei Matveev <alexei.matveev+gcc@gmail.com>
+
+module p                           
+  implicit none                                                                 
+
+  contains
+
+    subroutine test()
+      implicit none
+      print *, avg(erfc)
+    end subroutine test
+
+    function avg(f)
+      implicit none
+      double precision :: avg
+      interface
+        double precision function f(x)
+          implicit none
+          double precision, intent(in) :: x
+        end function f
+      end interface
+      avg = ( f(1.0D0) + f(2.0D0) ) / 2
+    end function avg
+
+    function erfc(x)
+      implicit none
+      double precision, intent(in) :: x
+      double precision             :: erfc
+      erfc = x
+    end function erfc
+
+end module p
+
+! { dg-final { cleanup-modules "p" } }
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_4.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_4.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_4.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_4.f90	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-Wsurprising" }
+!
+! PR 40995: [4.5 Regression] Spurious "Type specified for intrinsic function...ignored" message
+!
+! Contributed by Mat Cross <mathewc@nag.co.uk>
+
+subroutine sub(n,x)
+  intrinsic abs
+  integer n, x(abs(n))
+end
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_5.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_5.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_5.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_5.f90	2009-08-29 19:06:32.000000000 -0700
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-fimplicit-none" }
+!
+! PR 41121: [4.5 Regression] compile-time error when building BLAS with -fimplicit-none
+!
+! Original test case: http://www.netlib.org/blas/dgbmv.f
+! Reduced by Joost VandeVondele <jv244@cam.ac.uk>
+
+  INTRINSIC MIN
+  INTEGER :: I,J
+  print *,MIN(I,J)
+END
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_cmplx.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_cmplx.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/intrinsic_cmplx.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/intrinsic_cmplx.f90	2009-07-23 17:28:43.000000000 -0700
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/40727
+program test
+  integer, parameter :: sp = kind(1.e0), dp = kind(1.d0)
+  complex(sp) :: s
+  complex(dp) :: d
+  s =  cmplx(0.e0, cmplx(0.e0,0.e0)) ! { dg-error "either REAL or INTEGER" }
+  d = dcmplx(0.d0, cmplx(0.d0,0.d0)) ! { dg-error "either REAL or INTEGER" }
+end program test
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/namelist_40.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/namelist_40.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/namelist_40.f90	2008-03-04 16:59:34.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/namelist_40.f90	2009-08-04 20:17:52.000000000 -0700
@@ -1,4 +1,4 @@
-! { dg-do run { target fd_truncate } }
+! { dg-do run }
 ! PR33672 Additional runtime checks needed for namelist reads
 ! Submitted by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 
@@ -47,7 +47,7 @@
 end subroutine writenml
 
 end program namelist_40
-! { dg-output "Multiple sub-objects with non-zero rank in namelist object x(\n|\r\n|\r)" }
+! { dg-output "Multiple sub-objects with non-zero rank in namelist object x%m%ch(\n|\r\n|\r)" }
 ! { dg-output "Missing colon in substring qualifier for namelist variable x%m%ch(\n|\r\n|\r)" }
 ! { dg-output "Substring out of range for namelist variable x%m%ch(\n|\r\n|\r)" }
 ! { dg-output "Bad character in substring qualifier for namelist variable x%m%ch(\n|\r\n|\r)" }
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/namelist_47.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/namelist_47.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/namelist_47.f90	2008-05-16 07:07:37.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/namelist_47.f90	2009-08-04 20:17:52.000000000 -0700
@@ -1,4 +1,4 @@
-! { dg-do run { target fd_truncate } }
+! { dg-do run }
 
 module nml_47
   type             ::  mt
@@ -45,7 +45,7 @@
 end subroutine writenml
 
 end program namelist_47
-! { dg-output "Multiple sub-objects with non-zero rank in namelist object x(\n|\r\n|\r)" }
+! { dg-output "Multiple sub-objects with non-zero rank in namelist object x%m%c012345678901234567890123456789012345678901234567890123456789h(\n|\r\n|\r)" }
 ! { dg-output "Missing colon in substring qualifier for namelist variable x%m%c012345678901234567890123456789012345678901234567890123456789h(\n|\r\n|\r)" }
 ! { dg-output "Substring out of range for namelist variable x%m%c012345678901234567890123456789012345678901234567890123456789h(\n|\r\n|\r)" }
 ! { dg-output "Bad character in substring qualifier for namelist variable x%m%c012345678901234567890123456789012345678901234567890123456789h(\n|\r\n|\r)" }
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/namelist_58.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/namelist_58.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/namelist_58.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/namelist_58.f90	2009-08-04 20:17:52.000000000 -0700
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR40853 Error in namelist IO.
+! Test case derived from example given in PR. < jvdelisle@gcc.gnu.org >
+program test
+  implicit none
+  type tao_title_struct
+    character(2) justify   
+  end type
+  type tao_plot_page_struct
+    real shape_height_max 
+    type (tao_title_struct) title ! Comment this line out and the bug goes away.
+    real size(2)
+  end type
+  type (tao_plot_page_struct) plot_page
+  namelist / params / plot_page
+  open (10, status="scratch")
+  write(10,'(a)')"  &params"
+  write(10,'(a)')"  plot_page%size=5 , 2,"
+  write(10,'(a)')"/"
+  rewind(10)
+  read (10, nml = params)
+  if (any(plot_page%size .ne. (/ 5, 2 /))) call abort
+  close (10)
+end program
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41126.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41126.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41126.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41126.f90	2009-08-29 19:06:32.000000000 -0700
@@ -0,0 +1,6 @@
+! { dg-do compile }
+SUBROUTINE write_cputime( checkpoint  )
+  CHARACTER(LEN=*), INTENT(IN)             :: checkpoint
+  CHARACTER(LEN=LEN_TRIM(checkpoint)+7)    :: string1
+    string1 = ADJUSTL(string1)
+END SUBROUTINE write_cputime
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41162.f gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41162.f
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41162.f	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41162.f	2009-08-29 19:06:32.000000000 -0700
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! PRs 41154/41162
+      write (*,'(1PD24.15,F4.2,0P)') 1.0d0
+      write (*,'(1PD24.15,F4.2,0P/)') 1.0d0
+      end
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41225.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41225.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41225.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41225.f90	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-options "-O2 -ffast-math -funroll-loops -ftree-vectorize -g" }
+  SUBROUTINE block_15_1_1_1(kbd,kbc,kad,kac,pbd,pbc,pad,pac,prim,scale)
+    INTEGER, PARAMETER :: dp=8
+    REAL(KIND=dp) :: kbd(1*1), kbc(1*1), kad(15*1), kac(15*1), pbd(1*1), &
+      pbc(1*1), pad(15*1), pac(15*1), prim(15*1*1*1), scale
+    INTEGER                                  :: ma, mb, mc, md, p_index
+      DO md = 1,1
+        DO mc = 1,1
+          DO mb = 1,1
+            DO ma = 1,15
+              p_index=p_index+1
+              tmp = scale*prim(p_index)
+              ks_bd = ks_bd + tmp* pac((mc-1)*15+ma)
+            END DO
+            kbd((md-1)*1+mb) = kbd((md-1)*1+mb) - ks_bd
+          END DO
+        END DO
+      END DO
+  END SUBROUTINE block_15_1_1_1
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41229.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41229.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/pr41229.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/pr41229.f90	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-O2 -g" }
+SUBROUTINE cp_fm_triangular_multiply()
+    INTEGER, PARAMETER :: dp=KIND(0.0D0)
+    REAL(dp), ALLOCATABLE, DIMENSION(:)      :: tau, work
+    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: a
+    ndim = SIZE(a,2)
+    ALLOCATE(tau(ndim),STAT=istat)
+    ALLOCATE(work(2*ndim),STAT=istat)
+END SUBROUTINE
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/proc_ptr_25.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/proc_ptr_25.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/proc_ptr_25.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/proc_ptr_25.f90	2009-08-29 19:06:32.000000000 -0700
@@ -0,0 +1,36 @@
+! { dg-do run }
+!
+! PR 41139: [4.5 Regression] a procedure pointer call as actual argument
+!
+! Original test case by Barron Bichon <barron.bichon@swri.org>
+! Modified by Janus Weil <janus@gcc.gnu.org>
+
+PROGRAM test
+
+ PROCEDURE(add), POINTER :: f
+ logical :: g
+
+ ! Passing the function works
+ g=greater(4.,add(1.,2.))
+ if (.not. g) call abort()
+
+ ! Passing the procedure pointer fails
+ f => add
+ g=greater(4.,f(1.,2.))
+ if (.not. g) call abort()
+
+CONTAINS
+
+ REAL FUNCTION add(x,y)
+   REAL, INTENT(in) :: x,y
+   print *,"add:",x,y
+   add = x+y
+ END FUNCTION add
+
+ LOGICAL FUNCTION greater(x,y)
+   REAL, INTENT(in) :: x, y
+   greater = (x > y)
+ END FUNCTION greater
+
+END PROGRAM test
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/structure_constructor_10.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/structure_constructor_10.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/structure_constructor_10.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/structure_constructor_10.f90	2009-08-16 13:23:57.000000000 -0700
@@ -0,0 +1,28 @@
+! { dg-do compile }
+!
+! PR 41070: [4.5 Regression] Error: Components of structure constructor '' at (1) are PRIVATE
+!
+! Contributed by Michael Richmond <michael.a.richmond@nasa.gov>
+
+MODULE cdf_aux_mod
+IMPLICIT NONE
+
+TYPE :: one_parameter
+  CHARACTER (8) :: name
+END TYPE one_parameter
+
+TYPE :: the_distribution
+  CHARACTER (8) :: name
+END TYPE the_distribution
+
+TYPE (the_distribution), PARAMETER :: the_beta = the_distribution('cdf_beta')
+END MODULE cdf_aux_mod
+
+SUBROUTINE cdf_beta()
+  USE cdf_aux_mod
+  IMPLICIT NONE
+  CALL check_complements(the_beta%name)
+END SUBROUTINE cdf_beta
+
+! { dg-final { cleanup-modules "cdf_aux_mod" } }
+
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/transfer_resolve_1.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/transfer_resolve_1.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/transfer_resolve_1.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/transfer_resolve_1.f90	2009-08-16 13:04:40.000000000 -0700
@@ -0,0 +1,21 @@
+! { dg-do run }
+! PR40847 - an error in gfc_resolve_transfer caused the character length
+! of 'mold' to be set incorrectly.
+!
+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>
+!
+program test_elemental
+
+if (any (transfer_size((/0.,0./),(/'a','b'/)) .ne. [4 ,4])) call abort
+
+contains
+
+   elemental function transfer_size (source, mold)
+     real, intent(in)         :: source
+     character(*), intent(in) :: mold
+     integer                  :: transfer_size
+     transfer_size = SIZE(TRANSFER(source, (/mold/)))
+     return
+   end function transfer_size
+
+end program test_elemental
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/typebound_proc_12.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/typebound_proc_12.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/typebound_proc_12.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/typebound_proc_12.f90	2009-09-05 07:25:39.000000000 -0700
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! Test the fix for PR41258, where an ICE was caused by a search
+! for a typebound procedure to resolve d%c%e
+!
+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>
+!
+  TYPE a
+    TYPE(b), DIMENSION(:), POINTER :: c  ! { dg-error "type that has not been declared" }
+  END TYPE
+  TYPE(a), POINTER :: d
+  CALL X(d%c%e)         ! { dg-error "before it is defined" }
+end
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/use_only_4.f90 gcc-4.4.1/gcc/testsuite/gfortran.dg/use_only_4.f90
--- gcc-4.4.1.orig/gcc/testsuite/gfortran.dg/use_only_4.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gfortran.dg/use_only_4.f90	2009-08-25 11:54:58.000000000 -0700
@@ -0,0 +1,34 @@
+! { dg-do compile }
+! Test the fix for PR41062, in which an ICE would ensue because
+! of confusion between the two 'one's in the creation of module
+! debug info.
+!
+! Reported by Norman S. Clerman <clerman@fuse.net>
+! Reduced testcase by Tobias Burnus <burnus@gcc.gnu.org>
+!
+module m1
+   interface one  ! GENERIC "one"
+     module procedure one1
+   end interface
+contains
+  subroutine one1()
+    call abort
+  end subroutine one1
+end module m1
+
+module m2
+use m1, only : one  ! USE generic "one"
+contains
+  subroutine two()
+    call one()  ! Call internal "one"
+  contains
+    subroutine one() ! Internal "one"
+      print *, "m2"
+    end subroutine one
+  end subroutine two
+end module m2
+
+  use m2
+  call two
+end
+! { dg-final { cleanup-modules "m1 m2" } }
diff -Naur gcc-4.4.1.orig/gcc/testsuite/gnat.dg/array8.adb gcc-4.4.1/gcc/testsuite/gnat.dg/array8.adb
--- gcc-4.4.1.orig/gcc/testsuite/gnat.dg/array8.adb	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/gnat.dg/array8.adb	2009-09-10 11:57:46.000000000 -0700
@@ -0,0 +1,34 @@
+-- { dg-do compile }
+-- { dg-options "-O2" }
+
+PROCEDURE Array8 IS
+
+  function ID (I : Integer) return Integer is
+  begin
+    return I;
+  end;
+
+  SUBTYPE STB IS INTEGER RANGE ID(-8) .. -5;
+
+  TYPE TB IS ARRAY (STB RANGE <>) OF INTEGER;
+
+  GENERIC
+    B1 : TB;
+  PROCEDURE PROC1;
+
+  PROCEDURE PROC1 IS
+  BEGIN
+    IF B1'FIRST /= -8 THEN
+      raise Program_Error;
+    ELSIF B1'LAST /= ID(-5) THEN
+      raise Program_Error;
+    ELSIF B1 /= (7, 6, 5, 4) THEN
+      raise Program_Error;
+    END IF;
+  END;
+
+  PROCEDURE PROC2 IS NEW PROC1 ((7, 6, ID(5), 4));
+
+BEGIN
+  PROC2;
+END;
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.old-deja/g++.brendan/init4.C gcc-4.4.1/gcc/testsuite/g++.old-deja/g++.brendan/init4.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.old-deja/g++.brendan/init4.C	2003-04-30 19:02:59.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/g++.old-deja/g++.brendan/init4.C	2009-07-24 11:06:08.000000000 -0700
@@ -2,4 +2,4 @@
 // GROUPS passed initialization
 struct CharList { int i; };
 
-const CharList& terminals = { 1 };// { dg-error "" } .*
+const CharList& terminals = { 1 }; // { dg-error "initializer lists" } c++0x
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C gcc-4.4.1/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C	2009-03-11 10:52:06.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C	2009-07-27 23:56:49.000000000 -0700
@@ -1,6 +1,5 @@
 // { dg-do run { target fpic } }
 // { dg-options "-fPIC" }
-// { dg-bogus "\[Uu\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\[_.A-Za-z\]\[_.0-9A-Za-z\]*@(PLT|GOT|GOTOFF))|\[Bb\]ad fixup at .DATA.:" "PIC unsupported" { xfail *-*-netware* } 0 }
 // { dg-skip-if "requires unsupported run-time relocation" { spu-*-* } { "*" } { "" } }
 // Test that non-variadic function calls using thunks and PIC work right.
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/g++.old-deja/g++.law/weak.C gcc-4.4.1/gcc/testsuite/g++.old-deja/g++.law/weak.C
--- gcc-4.4.1.orig/gcc/testsuite/g++.old-deja/g++.law/weak.C	2005-12-09 15:34:09.000000000 -0800
+++ gcc-4.4.1/gcc/testsuite/g++.old-deja/g++.law/weak.C	2009-07-25 06:54:21.000000000 -0700
@@ -1,4 +1,5 @@
 // { dg-do link { target i?86-*-linux* x86_64-*-linux* } }
+// { dg-require-effective-target static }
 // { dg-options "-static" }
 // Bug: g++ fails to instantiate operator<<.
 
diff -Naur gcc-4.4.1.orig/gcc/testsuite/lib/target-supports.exp gcc-4.4.1/gcc/testsuite/lib/target-supports.exp
--- gcc-4.4.1.orig/gcc/testsuite/lib/target-supports.exp	2009-07-21 00:22:51.000000000 -0700
+++ gcc-4.4.1/gcc/testsuite/lib/target-supports.exp	2009-08-28 02:57:51.000000000 -0700
@@ -611,6 +611,13 @@
     } "-pthread"]
 }
 
+# Return 1 if the target supports -static
+proc check_effective_target_static {} {
+    return [check_no_compiler_messages static executable {
+	int main (void) { return 0; }
+    } "-static"]
+}
+
 # Return 1 if the target supports -fstack-protector
 proc check_effective_target_fstack_protector {} {
     return [check_runtime fstack_protector {
@@ -1269,7 +1276,8 @@
 	verbose "check_effective_target_vect_cmdline_needed: using cached result" 2
     } else {
 	set et_vect_cmdline_needed_saved 1
-	if { [istarget ia64-*-*]
+	if { [istarget alpha*-*-*]
+	     || [istarget ia64-*-*]
 	     || (([istarget x86_64-*-*] || [istarget i?86-*-*])
 		 && [check_effective_target_lp64])
 	     || ([istarget powerpc*-*-*]
diff -Naur gcc-4.4.1.orig/gcc/tree-ssa.c gcc-4.4.1/gcc/tree-ssa.c
--- gcc-4.4.1.orig/gcc/tree-ssa.c	2009-03-27 10:20:51.000000000 -0700
+++ gcc-4.4.1/gcc/tree-ssa.c	2009-08-03 12:27:32.000000000 -0700
@@ -1472,7 +1472,12 @@
 
   /* We do not care about LHS.  */
   if (wi->is_lhs)
-    return NULL_TREE;
+    {
+      /* Except for operands of INDIRECT_REF.  */
+      if (!INDIRECT_REF_P (t))
+	return NULL_TREE;
+      t = TREE_OPERAND (t, 0);
+    }
 
   switch (TREE_CODE (t))
     {
diff -Naur gcc-4.4.1.orig/gcc/tree-ssa-ifcombine.c gcc-4.4.1/gcc/tree-ssa-ifcombine.c
--- gcc-4.4.1.orig/gcc/tree-ssa-ifcombine.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/tree-ssa-ifcombine.c	2009-08-09 14:39:19.000000000 -0700
@@ -151,7 +151,7 @@
     {
       gimple def_stmt = SSA_NAME_DEF_STMT (candidate);
       if (is_gimple_assign (def_stmt)
-	  && gimple_assign_cast_p (def_stmt))
+	  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt)))
 	{
 	  if (TYPE_PRECISION (TREE_TYPE (candidate))
 	      <= TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))
@@ -162,21 +162,6 @@
   return candidate;
 }
 
-/* Helpers for recognize_single_bit_test defined mainly for source code
-   formating.  */
-
-static int
-operand_precision (tree t)
-{
-  return TYPE_PRECISION (TREE_TYPE (t));
-}
-
-static bool
-integral_operand_p (tree t)
-{
-  return INTEGRAL_TYPE_P (TREE_TYPE (t));
-}
-
 /* Recognize a single bit test pattern in GIMPLE_COND and its defining
    statements.  Store the name being tested in *NAME and the bit
    in *BIT.  The GIMPLE_COND computes *NAME & (1 << *BIT).
@@ -212,15 +197,11 @@
       stmt = SSA_NAME_DEF_STMT (orig_name);
 
       while (is_gimple_assign (stmt)
-	     && (gimple_assign_ssa_name_copy_p (stmt)
-		 || (gimple_assign_cast_p (stmt)
-		     && integral_operand_p (gimple_assign_lhs (stmt))
-		     && integral_operand_p (gimple_assign_rhs1 (stmt))
-		     && (operand_precision (gimple_assign_lhs (stmt))
-			 <= operand_precision (gimple_assign_rhs1 (stmt))))))
-	{
-	  stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));
-	}
+	     && ((CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))
+		  && (TYPE_PRECISION (TREE_TYPE (gimple_assign_lhs (stmt)))
+		      <= TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (stmt)))))
+		 || gimple_assign_ssa_name_copy_p (stmt)))
+	stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));
 
       /* If we found such, decompose it.  */
       if (is_gimple_assign (stmt)
diff -Naur gcc-4.4.1.orig/gcc/tree-ssa-pre.c gcc-4.4.1/gcc/tree-ssa-pre.c
--- gcc-4.4.1.orig/gcc/tree-ssa-pre.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.1/gcc/tree-ssa-pre.c	2009-07-22 07:45:21.000000000 -0700
@@ -3507,11 +3507,7 @@
 }
 
 
-/* Add OP to EXP_GEN (block), and possibly to the maximal set if it is
-   not defined by a phi node.
-   PHI nodes can't go in the maximal sets because they are not in
-   TMP_GEN, so it is possible to get into non-monotonic situations
-   during ANTIC calculation, because it will *add* bits.  */
+/* Add OP to EXP_GEN (block), and possibly to the maximal set.  */
 
 static void
 add_to_exp_gen (basic_block block, tree op)
@@ -3523,9 +3519,7 @@
 	return;
       result = get_or_alloc_expr_for_name (op);
       bitmap_value_insert_into_set (EXP_GEN (block), result);
-      if (TREE_CODE (op) != SSA_NAME
-	  || gimple_code (SSA_NAME_DEF_STMT (op)) != GIMPLE_PHI)
-	bitmap_value_insert_into_set (maximal_set, result);
+      bitmap_value_insert_into_set (maximal_set, result);
     }
 }
 
@@ -3544,6 +3538,20 @@
       add_to_value (get_expr_value_id (e), e);
       bitmap_insert_into_set (PHI_GEN (block), e);
       bitmap_value_insert_into_set (AVAIL_OUT (block), e);
+      if (!in_fre)
+	{
+	  unsigned i;
+	  for (i = 0; i < gimple_phi_num_args (phi); ++i)
+	    {
+	      tree arg = gimple_phi_arg_def (phi, i);
+	      if (TREE_CODE (arg) == SSA_NAME)
+		{
+		  e = get_or_alloc_expr_for_name (arg);
+		  add_to_value (get_expr_value_id (e), e);
+		  bitmap_value_insert_into_set (maximal_set, e);
+		}
+	    }
+	}
     }
 }
 
@@ -4254,11 +4262,12 @@
       FOR_ALL_BB (bb)
 	{
 	  print_bitmap_set (dump_file, EXP_GEN (bb), "exp_gen", bb->index);
-	  print_bitmap_set (dump_file, TMP_GEN (bb), "tmp_gen",
-				  bb->index);
-	  print_bitmap_set (dump_file, AVAIL_OUT (bb), "avail_out",
-				  bb->index);
+	  print_bitmap_set (dump_file, PHI_GEN (bb), "phi_gen", bb->index);
+	  print_bitmap_set (dump_file, TMP_GEN (bb), "tmp_gen", bb->index);
+	  print_bitmap_set (dump_file, AVAIL_OUT (bb), "avail_out", bb->index);
 	}
+
+      print_bitmap_set (dump_file, maximal_set, "maximal", 0);
     }
 
   /* Insert can get quite slow on an incredibly large number of basic
diff -Naur gcc-4.4.1.orig/gcc/version.c gcc-4.4.1/gcc/version.c
--- gcc-4.4.1.orig/gcc/version.c	2007-08-21 08:35:30.000000000 -0700
+++ gcc-4.4.1/gcc/version.c	2009-09-12 09:16:46.000000000 -0700
@@ -14,4 +14,4 @@
    Makefile.  */
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
-const char pkgversion_string[] = PKGVERSION;
+const char pkgversion_string[] = "(GCC for Cross-LFS 4.4.1.20090912) ";
diff -Naur gcc-4.4.1.orig/libcpp/macro.c gcc-4.4.1/libcpp/macro.c
--- gcc-4.4.1.orig/libcpp/macro.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libcpp/macro.c	2009-09-02 11:47:29.000000000 -0700
@@ -375,7 +375,7 @@
 	}
 
       escape_it = (token->type == CPP_STRING || token->type == CPP_CHAR
-		   || token->type == CPP_WSTRING || token->type == CPP_STRING
+		   || token->type == CPP_WSTRING || token->type == CPP_WCHAR
 		   || token->type == CPP_STRING32 || token->type == CPP_CHAR32
 		   || token->type == CPP_STRING16 || token->type == CPP_CHAR16);
 
diff -Naur gcc-4.4.1.orig/libdecnumber/decCommon.c gcc-4.4.1/libdecnumber/decCommon.c
--- gcc-4.4.1.orig/libdecnumber/decCommon.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libdecnumber/decCommon.c	2009-08-13 09:58:06.000000000 -0700
@@ -1089,6 +1089,7 @@
   return 10;
   } /* decFloatRadix */
 
+#if (DECCHECK || DECTRACE)
 /* ------------------------------------------------------------------ */
 /* decFloatShow -- printf a decFloat in hexadecimal and decimal	      */
 /*   df	 is the decFloat to show				      */
@@ -1115,6 +1116,7 @@
   printf(">%s> %s [big-endian]	%s\n", tag, hexbuf, buff);
   return;
   } /* decFloatShow */
+#endif
 
 /* ------------------------------------------------------------------ */
 /* decFloatToBCD -- get sign, exponent, and BCD8 from a decFloat      */
diff -Naur gcc-4.4.1.orig/libgfortran/intrinsics/dtime.c gcc-4.4.1/libgfortran/intrinsics/dtime.c
--- gcc-4.4.1.orig/libgfortran/intrinsics/dtime.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libgfortran/intrinsics/dtime.c	2009-08-24 20:30:25.000000000 -0700
@@ -38,9 +38,10 @@
 void
 dtime_sub (gfc_array_r4 *t, GFC_REAL_4 *result)
 {
-  static GFC_REAL_4 tu = 0.0, ts = 0.0, tt = 0.0;
   GFC_REAL_4 *tp;
   long user_sec, user_usec, system_sec, system_usec;
+  static long us = 0, uu = 0, ss = 0 , su = 0;
+  GFC_REAL_4 tu, ts, tt;
 
   if (((t->dim[0].ubound + 1 - t->dim[0].lbound)) < 2)
     runtime_error ("Insufficient number of elements in TARRAY.");
@@ -48,15 +49,19 @@
   __gthread_mutex_lock (&dtime_update_lock);
   if (__time_1 (&user_sec, &user_usec, &system_sec, &system_usec) == 0)
     {
-      tu = (GFC_REAL_4)(user_sec + 1.e-6 * user_usec) - tu;
-      ts = (GFC_REAL_4)(system_sec + 1.e-6 * system_usec) - ts;
+      tu = (GFC_REAL_4) ((user_sec - us) + 1.e-6 * (user_usec - uu));
+      ts = (GFC_REAL_4) ((system_sec - ss) + 1.e-6 * (system_usec - su));
       tt = tu + ts;
+      us = user_sec;
+      uu = user_usec;
+      ss = system_sec;
+      su = system_usec;
     }
   else
     {
-      tu = (GFC_REAL_4)-1.0;
-      ts = (GFC_REAL_4)-1.0;
-      tt = (GFC_REAL_4)-1.0;
+      tu = -1;
+      ts = -1;
+      tt = -1;
     }
 
   tp = t->data;
diff -Naur gcc-4.4.1.orig/libgfortran/intrinsics/iso_c_binding.c gcc-4.4.1/libgfortran/intrinsics/iso_c_binding.c
--- gcc-4.4.1.orig/libgfortran/intrinsics/iso_c_binding.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libgfortran/intrinsics/iso_c_binding.c	2009-08-20 13:42:38.000000000 -0700
@@ -137,8 +137,8 @@
       f_ptr_out->offset = f_ptr_out->dim[0].lbound * f_ptr_out->dim[0].stride;
       for (i = 1; i < shapeSize; i++)
         {
-          f_ptr_out->dim[i].stride = (f_ptr_out->dim[i-1].ubound + 1)
-            - f_ptr_out->dim[i-1].lbound;
+          f_ptr_out->dim[i].stride = ((f_ptr_out->dim[i-1].ubound + 1)
+            - f_ptr_out->dim[i-1].lbound) * f_ptr_out->dim[i-1].stride;
           f_ptr_out->offset += f_ptr_out->dim[i].lbound
             * f_ptr_out->dim[i].stride;
         }
diff -Naur gcc-4.4.1.orig/libgfortran/intrinsics/time_1.h gcc-4.4.1/libgfortran/intrinsics/time_1.h
--- gcc-4.4.1.orig/libgfortran/intrinsics/time_1.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libgfortran/intrinsics/time_1.h	2009-08-24 20:30:25.000000000 -0700
@@ -51,6 +51,10 @@
 #  endif
 #endif
 
+#ifdef HAVE_SYS_TYPES_H
+     #include <sys/types.h>
+#endif
+
 /* The most accurate way to get the CPU time is getrusage (). */
 #if defined (HAVE_GETRUSAGE) && defined (HAVE_SYS_RESOURCE_H)
 #  include <sys/resource.h>
@@ -112,7 +116,7 @@
 {
 #if defined (HAVE_GETRUSAGE) && defined (HAVE_SYS_RESOURCE_H)
   struct rusage usage;
-  getrusage (0, &usage);
+  getrusage (RUSAGE_SELF, &usage);
 
   *user_sec = usage.ru_utime.tv_sec;
   *user_usec = usage.ru_utime.tv_usec;
diff -Naur gcc-4.4.1.orig/libgfortran/io/list_read.c gcc-4.4.1/libgfortran/io/list_read.c
--- gcc-4.4.1.orig/libgfortran/io/list_read.c	2009-06-08 20:15:04.000000000 -0700
+++ gcc-4.4.1/libgfortran/io/list_read.c	2009-08-04 20:15:18.000000000 -0700
@@ -2772,7 +2772,7 @@
 
   if (nl->type == GFC_DTYPE_DERIVED)
     nml_touch_nodes (nl);
-  if (component_flag && nl->var_rank > 0)
+  if (component_flag && nl->var_rank > 0 && nl->next)
     nl = first_nl;
 
   /* Make sure no extraneous qualifiers are there.  */
diff -Naur gcc-4.4.1.orig/libgomp/omp_lib.h.in gcc-4.4.1/libgomp/omp_lib.h.in
--- gcc-4.4.1.orig/libgomp/omp_lib.h.in	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libgomp/omp_lib.h.in	2009-08-19 00:11:43.000000000 -0700
@@ -42,16 +42,16 @@
       external omp_set_num_threads
 
       external omp_get_dynamic, omp_get_nested
-      logical*4 omp_get_dynamic, omp_get_nested
+      logical(4) omp_get_dynamic, omp_get_nested
       external omp_test_lock, omp_in_parallel
-      logical*4 omp_test_lock, omp_in_parallel
+      logical(4) omp_test_lock, omp_in_parallel
 
       external omp_get_max_threads, omp_get_num_procs
-      integer*4 omp_get_max_threads, omp_get_num_procs
+      integer(4) omp_get_max_threads, omp_get_num_procs
       external omp_get_num_threads, omp_get_thread_num
-      integer*4 omp_get_num_threads, omp_get_thread_num
+      integer(4) omp_get_num_threads, omp_get_thread_num
       external omp_test_nest_lock
-      integer*4 omp_test_nest_lock
+      integer(4) omp_test_nest_lock
 
       external omp_get_wtick, omp_get_wtime
       double precision omp_get_wtick, omp_get_wtime
@@ -61,6 +61,6 @@
       external omp_get_max_active_levels, omp_get_level
       external omp_get_ancestor_thread_num, omp_get_team_size
       external omp_get_active_level
-      integer*4 omp_get_thread_limit, omp_get_max_active_levels
-      integer*4 omp_get_level, omp_get_ancestor_thread_num
-      integer*4 omp_get_team_size, omp_get_active_level
+      integer(4) omp_get_thread_limit, omp_get_max_active_levels
+      integer(4) omp_get_level, omp_get_ancestor_thread_num
+      integer(4) omp_get_team_size, omp_get_active_level
diff -Naur gcc-4.4.1.orig/libjava/contrib/aotcompile.py.in gcc-4.4.1/libjava/contrib/aotcompile.py.in
--- gcc-4.4.1.orig/libjava/contrib/aotcompile.py.in	2009-04-26 07:24:38.000000000 -0700
+++ gcc-4.4.1/libjava/contrib/aotcompile.py.in	2009-07-23 07:27:31.000000000 -0700
@@ -15,7 +15,11 @@
 
 import classfile
 import copy
-import md5
+# The md5 module is deprecated in Python 2.5
+try: 
+    from hashlib import md5 
+except ImportError: 
+    from md5 import md5
 import operator
 import os
 import sys
@@ -182,7 +186,7 @@
     def addClass(self, bytes, name):
         """Subclasses call this from their __init__ method for
         every class they find."""
-        digest = md5.new(bytes).digest()
+        digest = md5(bytes).digest()
         self.classes[digest] = bytes
         self.classnames[digest] = name
 
diff -Naur gcc-4.4.1.orig/libstdc++-v3/config/abi/pre/gnu.ver gcc-4.4.1/libstdc++-v3/config/abi/pre/gnu.ver
--- gcc-4.4.1.orig/libstdc++-v3/config/abi/pre/gnu.ver	2009-05-05 14:44:27.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/config/abi/pre/gnu.ver	2009-08-26 12:04:11.000000000 -0700
@@ -32,7 +32,9 @@
       std::a[e-z]*;
 #     std::ba[a-r]*;
       std::basic_[a-e]*;
-      std::basic_f[a-r]*;
+      std::basic_f[a-h]*;
+#     std::basic_filebuf;
+      std::basic_f[j-r]*;
 #     std::basic_fstream;
       std::basic_f[t-z]*;
       std::basic_[g-h]*;
@@ -273,28 +275,40 @@
     _ZNSdC*;
     _ZNSdD*;
 
+    # std::basic_filebuf
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EEC*;
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EED*;
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EE[0-3]*;
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EE4openEPKc*;
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EE4sync*;
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EE[5-9]*;
+    _ZNKSt13basic_filebufI[cw]St11char_traitsI[cw]EE7is_openEv;
+
     # std::basic_fstream
-    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EEC*;
+    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EEC[12]Ev;
+    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EEC[12]EPKc*;
     _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EED*;
     _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EE5closeEv;
     _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EE7is_openEv;
-    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EE4open*;
+    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EE4openEPKc*;
     _ZNKSt13basic_fstreamI[cw]St11char_traitsI[cw]EE5rdbufEv;
 
     # std::basic_ifstream
-    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EEC*;
+    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EEC[12]Ev;
+    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EEC[12]EPKc*;
     _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EED*;
     _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EE5closeEv;
     _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EE7is_openEv;
-    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EE4open*;
+    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EE4openEPKc*;
     _ZNKSt14basic_ifstreamI[cw]St11char_traitsI[cw]EE5rdbufEv;
 
     # std::basic_ofstream
-    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EEC*;
+    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EEC[12]Ev;
+    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EEC[12]EPKc*;
     _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EED*;
     _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EE5closeEv;
     _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EE7is_openEv;
-    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EE4open*;
+    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EE4openEPKc*;
     _ZNKSt14basic_ofstreamI[cw]St11char_traitsI[cw]EE5rdbufEv;
 
     # std::basic_istream<char>
@@ -966,6 +980,19 @@
 
 } GLIBCXX_3.4.11;
 
+GLIBCXX_3.4.13 {
+
+    # new fstream members
+    _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EE4openERKSsSt13_Ios_Openmode;
+    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EEC[12]ERKSsSt13_Ios_Openmode;
+    _ZNSt13basic_fstreamI[cw]St11char_traitsI[cw]EE4openERKSsSt13_Ios_Openmode;
+    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EEC[12]ERKSsSt13_Ios_Openmode;
+    _ZNSt14basic_ifstreamI[cw]St11char_traitsI[cw]EE4openERKSsSt13_Ios_Openmode;
+    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EEC[12]ERKSsSt13_Ios_Openmode;
+    _ZNSt14basic_ofstreamI[cw]St11char_traitsI[cw]EE4openERKSsSt13_Ios_Openmode;
+
+} GLIBCXX_3.4.12;
+
 # Symbols in the support library (libsupc++) have their own tag.
 CXXABI_1.3 {
 
diff -Naur gcc-4.4.1.orig/libstdc++-v3/configure gcc-4.4.1/libstdc++-v3/configure
--- gcc-4.4.1.orig/libstdc++-v3/configure	2009-05-07 03:23:06.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/configure	2009-08-26 12:04:11.000000000 -0700
@@ -1567,7 +1567,7 @@
 ### am handles this now?  ORIGINAL_LD_FOR_MULTILIBS=$LD
 
 # For libtool versioning info, format is CURRENT:REVISION:AGE
-libtool_VERSION=6:12:0
+libtool_VERSION=6:13:0
 
 
 # Find the rest of the source tree framework.
diff -Naur gcc-4.4.1.orig/libstdc++-v3/configure.ac gcc-4.4.1/libstdc++-v3/configure.ac
--- gcc-4.4.1.orig/libstdc++-v3/configure.ac	2009-05-07 03:23:06.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/configure.ac	2009-08-26 12:04:11.000000000 -0700
@@ -12,7 +12,7 @@
 ### am handles this now?  ORIGINAL_LD_FOR_MULTILIBS=$LD
 
 # For libtool versioning info, format is CURRENT:REVISION:AGE
-libtool_VERSION=6:12:0
+libtool_VERSION=6:13:0
 AC_SUBST(libtool_VERSION)
 
 # Find the rest of the source tree framework.
diff -Naur gcc-4.4.1.orig/libstdc++-v3/include/parallel/multiway_merge.h gcc-4.4.1/libstdc++-v3/include/parallel/multiway_merge.h
--- gcc-4.4.1.orig/libstdc++-v3/include/parallel/multiway_merge.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/include/parallel/multiway_merge.h	2009-09-11 09:36:00.000000000 -0700
@@ -1224,7 +1224,7 @@
                 offsets[num_threads - 1].begin(),  comp);
         }
     }
-
+  delete[] borders;
 
   for (int slab = 0; slab < num_threads; ++slab)
     {
@@ -1305,11 +1305,8 @@
         std::iterator_traits<RandomAccessIterator1>::value_type value_type;
 
       // Leave only non-empty sequences.
-      std::pair<RandomAccessIterator1, RandomAccessIterator1>* ne_seqs =
-        static_cast<std::pair<RandomAccessIterator1, RandomAccessIterator1>*>(
-        ::operator new(
-            sizeof(std::pair<RandomAccessIterator1, RandomAccessIterator1>)
-              * (seqs_end - seqs_begin)));
+      typedef std::pair<RandomAccessIterator1, RandomAccessIterator1> seq_type;
+      seq_type* ne_seqs = new seq_type[seqs_end - seqs_begin];
       int k = 0;
       difference_type total_length = 0;
       for (RandomAccessIteratorIterator raii = seqs_begin;
@@ -1319,9 +1316,7 @@
           if(seq_length > 0)
             {
               total_length += seq_length;
-              //ne_seqs[k] = *raii;
-              new(&(ne_seqs[k++]))
-                std::pair<RandomAccessIterator1, RandomAccessIterator1>(*raii);
+              ne_seqs[k++] = *raii;
             }
         }
 
@@ -1331,7 +1326,7 @@
 
       if (total_length == 0 || k == 0)
       {
-        ::operator delete(ne_seqs);
+        delete[] ne_seqs;
         return target;
       }
 
@@ -1366,8 +1361,7 @@
           for (int c = 0; c < k; ++c)
             target_position += pieces[iam][c].first;
 
-          std::pair<RandomAccessIterator1, RandomAccessIterator1>* chunks
-            = new std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];
+          seq_type* chunks = new seq_type[k];
 
           for (int s = 0; s < k; ++s)
             {
@@ -1399,6 +1393,7 @@
         }
 
       delete[] pieces;
+      delete[] ne_seqs;
 
       return target + length;
     }
diff -Naur gcc-4.4.1.orig/libstdc++-v3/include/std/valarray gcc-4.4.1/libstdc++-v3/include/std/valarray
--- gcc-4.4.1.orig/libstdc++-v3/include/std/valarray	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/include/std/valarray	2009-07-22 03:25:53.000000000 -0700
@@ -1,7 +1,7 @@
 // The template and inlines for the -*- C++ -*- valarray class.
 
 // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-// 2006, 2007, 2009
+// 2006, 2007, 2008, 2009
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -647,7 +647,7 @@
   template<typename _Tp>
     inline
     valarray<_Tp>::valarray(initializer_list<_Tp> __l)
-      : _M_size(__l.size()), _M_data(__valarray_get_storage<_Tp>(__l.size()))
+    : _M_size(__l.size()), _M_data(__valarray_get_storage<_Tp>(__l.size()))
     { std::__valarray_copy_construct (__l.begin(), __l.end(), _M_data); }
 #endif
 
@@ -681,6 +681,7 @@
     {
       _GLIBCXX_DEBUG_ASSERT(_M_size == __l.size());
       std::__valarray_copy(__l.begin(), __l.size(), _M_data);
+      return *this;
     }
 #endif
 
diff -Naur gcc-4.4.1.orig/libstdc++-v3/src/Makefile.am gcc-4.4.1/libstdc++-v3/src/Makefile.am
--- gcc-4.4.1.orig/libstdc++-v3/src/Makefile.am	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/src/Makefile.am	2009-08-26 12:04:11.000000000 -0700
@@ -277,6 +277,11 @@
 atomic.o: atomic.cc
 	$(CXXCOMPILE) -std=gnu++0x -c $<
 
+fstream-inst.lo: fstream-inst.cc
+	$(LTCXXCOMPILE) -std=gnu++0x -c $<
+fstream-inst.o: fstream-inst.cc
+	$(CXXCOMPILE) -std=gnu++0x -c $<
+
 string-inst.lo: string-inst.cc
 	$(LTCXXCOMPILE) -std=gnu++0x -c $<
 string-inst.o: string-inst.cc
diff -Naur gcc-4.4.1.orig/libstdc++-v3/src/Makefile.in gcc-4.4.1/libstdc++-v3/src/Makefile.in
--- gcc-4.4.1.orig/libstdc++-v3/src/Makefile.in	2009-01-16 18:03:25.000000000 -0800
+++ gcc-4.4.1/libstdc++-v3/src/Makefile.in	2009-08-26 12:04:11.000000000 -0700
@@ -888,6 +888,11 @@
 atomic.o: atomic.cc
 	$(CXXCOMPILE) -std=gnu++0x -c $<
 
+fstream-inst.lo: fstream-inst.cc
+	$(LTCXXCOMPILE) -std=gnu++0x -c $<
+fstream-inst.o: fstream-inst.cc
+	$(CXXCOMPILE) -std=gnu++0x -c $<
+
 string-inst.lo: string-inst.cc
 	$(LTCXXCOMPILE) -std=gnu++0x -c $<
 string-inst.o: string-inst.cc
diff -Naur gcc-4.4.1.orig/libstdc++-v3/testsuite/util/testsuite_abi.cc gcc-4.4.1/libstdc++-v3/testsuite/util/testsuite_abi.cc
--- gcc-4.4.1.orig/libstdc++-v3/testsuite/util/testsuite_abi.cc	2009-05-05 14:44:27.000000000 -0700
+++ gcc-4.4.1/libstdc++-v3/testsuite/util/testsuite_abi.cc	2009-08-26 12:04:11.000000000 -0700
@@ -184,6 +184,7 @@
       known_versions.push_back("GLIBCXX_3.4.10");
       known_versions.push_back("GLIBCXX_3.4.11");
       known_versions.push_back("GLIBCXX_3.4.12");
+      known_versions.push_back("GLIBCXX_3.4.13");
       known_versions.push_back("GLIBCXX_LDBL_3.4");
       known_versions.push_back("GLIBCXX_LDBL_3.4.7");
       known_versions.push_back("GLIBCXX_LDBL_3.4.10");
