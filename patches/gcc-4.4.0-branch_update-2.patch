Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 06-05-2009
Initial Package Version: 4.4.0
Origin: Upstream
Upstream Status: Applied
Description: This is a branch update for gcc-4.4.0, and should be
             rechecked periodically.

diff -Naur gcc-4.4.0.orig/configure gcc-4.4.0/configure
--- gcc-4.4.0.orig/configure	2009-04-21 02:08:08.000000000 -0700
+++ gcc-4.4.0/configure	2009-04-24 21:10:29.000000000 -0700
@@ -272,7 +272,7 @@
 PACKAGE_BUGREPORT=
 
 ac_unique_file="move-if-change"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS TOPLEVEL_CONFIGURE_ARGUMENTS build build_cpu build_vendor build_os build_noncanonical host_noncanonical target_noncanonical host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN LN_S build_libsubdir build_subdir host_subdir target_subdir CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE do_compare gmplibs gmpinc ppllibs pplinc clooglibs clooginc stage1_languages SYSROOT_CFLAGS_FOR_TARGET DEBUG_PREFIX_CFLAGS_FOR_TARGET CFLAGS_FOR_TARGET CXXFLAGS_FOR_TARGET RPATH_ENVVAR GCC_SHLIB_SUBDIR tooldir build_tooldir CONFIGURE_GDB_TK GDB_TK INSTALL_GDB_TK build_configargs build_configdirs host_configargs configdirs target_configargs AR_FOR_BUILD AS_FOR_BUILD CC_FOR_BUILD CFLAGS_FOR_BUILD CXXFLAGS_FOR_BUILD CXX_FOR_BUILD DLLTOOL_FOR_BUILD GCJ_FOR_BUILD GFORTRAN_FOR_BUILD LDFLAGS_FOR_BUILD LD_FOR_BUILD NM_FOR_BUILD RANLIB_FOR_BUILD WINDMC_FOR_BUILD WINDRES_FOR_BUILD config_shell YACC BISON M4 LEX FLEX MAKEINFO EXPECT RUNTEST AR AS DLLTOOL LD LIPO NM RANLIB STRIP WINDRES WINDMC OBJCOPY OBJDUMP CC_FOR_TARGET CXX_FOR_TARGET GCC_FOR_TARGET GCJ_FOR_TARGET GFORTRAN_FOR_TARGET AR_FOR_TARGET AS_FOR_TARGET DLLTOOL_FOR_TARGET LD_FOR_TARGET LIPO_FOR_TARGET NM_FOR_TARGET OBJDUMP_FOR_TARGET RANLIB_FOR_TARGET STRIP_FOR_TARGET WINDRES_FOR_TARGET WINDMC_FOR_TARGET RAW_CXX_FOR_TARGET FLAGS_FOR_TARGET COMPILER_AS_FOR_TARGET COMPILER_LD_FOR_TARGET COMPILER_NM_FOR_TARGET MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT stage1_cflags stage1_checking stage2_werror_flag datarootdir docdir pdfdir htmldir LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS TOPLEVEL_CONFIGURE_ARGUMENTS build build_cpu build_vendor build_os build_noncanonical host_noncanonical target_noncanonical host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN LN_S build_libsubdir build_subdir host_subdir target_subdir CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE do_compare gmplibs gmpinc extra_mpfr_configure_flags ppllibs pplinc clooglibs clooginc stage1_languages SYSROOT_CFLAGS_FOR_TARGET DEBUG_PREFIX_CFLAGS_FOR_TARGET CFLAGS_FOR_TARGET CXXFLAGS_FOR_TARGET RPATH_ENVVAR GCC_SHLIB_SUBDIR tooldir build_tooldir CONFIGURE_GDB_TK GDB_TK INSTALL_GDB_TK build_configargs build_configdirs host_configargs configdirs target_configargs AR_FOR_BUILD AS_FOR_BUILD CC_FOR_BUILD CFLAGS_FOR_BUILD CXXFLAGS_FOR_BUILD CXX_FOR_BUILD DLLTOOL_FOR_BUILD GCJ_FOR_BUILD GFORTRAN_FOR_BUILD LDFLAGS_FOR_BUILD LD_FOR_BUILD NM_FOR_BUILD RANLIB_FOR_BUILD WINDMC_FOR_BUILD WINDRES_FOR_BUILD config_shell YACC BISON M4 LEX FLEX MAKEINFO EXPECT RUNTEST AR AS DLLTOOL LD LIPO NM RANLIB STRIP WINDRES WINDMC OBJCOPY OBJDUMP CC_FOR_TARGET CXX_FOR_TARGET GCC_FOR_TARGET GCJ_FOR_TARGET GFORTRAN_FOR_TARGET AR_FOR_TARGET AS_FOR_TARGET DLLTOOL_FOR_TARGET LD_FOR_TARGET LIPO_FOR_TARGET NM_FOR_TARGET OBJDUMP_FOR_TARGET RANLIB_FOR_TARGET STRIP_FOR_TARGET WINDRES_FOR_TARGET WINDMC_FOR_TARGET RAW_CXX_FOR_TARGET FLAGS_FOR_TARGET COMPILER_AS_FOR_TARGET COMPILER_LD_FOR_TARGET COMPILER_NM_FOR_TARGET MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT stage1_cflags stage1_checking stage2_werror_flag datarootdir docdir pdfdir htmldir LIBOBJS LTLIBOBJS'
 ac_subst_files='serialization_dependencies host_makefile_frag target_makefile_frag alphaieee_frag ospace_frag'
 ac_pwd=`pwd`
 
@@ -4596,6 +4596,7 @@
 if test "x$with_gmp$with_gmp_include$with_gmp_lib" = x && test -d ${srcdir}/gmp; then
   gmplibs='-L$$r/$(HOST_SUBDIR)/gmp/.libs -L$$r/$(HOST_SUBDIR)/gmp/_libs '"$gmplibs"
   gmpinc='-I$$r/$(HOST_SUBDIR)/gmp -I$$s/gmp '"$gmpinc"
+  extra_mpfr_configure_flags='--with-gmp-build=$$r/$(HOST_SUBDIR)/gmp'
   # Do not test the gmp version.  Assume that it is sufficient, since
   # it is in the source tree, and the library has not been built yet
   # but it would be included on the link line in the version check below
@@ -4810,6 +4811,7 @@
 
 
 
+
 # Allow host libstdc++ to be specified for static linking with PPL.
 
 # Check whether --with-host-libstdcxx or --without-host-libstdcxx was given.
@@ -13251,6 +13253,7 @@
 s,@do_compare@,$do_compare,;t t
 s,@gmplibs@,$gmplibs,;t t
 s,@gmpinc@,$gmpinc,;t t
+s,@extra_mpfr_configure_flags@,$extra_mpfr_configure_flags,;t t
 s,@ppllibs@,$ppllibs,;t t
 s,@pplinc@,$pplinc,;t t
 s,@clooglibs@,$clooglibs,;t t
diff -Naur gcc-4.4.0.orig/configure.ac gcc-4.4.0/configure.ac
--- gcc-4.4.0.orig/configure.ac	2009-04-14 01:57:33.000000000 -0700
+++ gcc-4.4.0/configure.ac	2009-04-24 21:10:29.000000000 -0700
@@ -1250,6 +1250,7 @@
 if test "x$with_gmp$with_gmp_include$with_gmp_lib" = x && test -d ${srcdir}/gmp; then
   gmplibs='-L$$r/$(HOST_SUBDIR)/gmp/.libs -L$$r/$(HOST_SUBDIR)/gmp/_libs '"$gmplibs"
   gmpinc='-I$$r/$(HOST_SUBDIR)/gmp -I$$s/gmp '"$gmpinc"
+  extra_mpfr_configure_flags='--with-gmp-build=$$r/$(HOST_SUBDIR)/gmp'
   # Do not test the gmp version.  Assume that it is sufficient, since
   # it is in the source tree, and the library has not been built yet
   # but it would be included on the link line in the version check below
@@ -1314,6 +1315,7 @@
 # Flags needed for both GMP and/or MPFR
 AC_SUBST(gmplibs)
 AC_SUBST(gmpinc)
+AC_SUBST(extra_mpfr_configure_flags)
 
 # Allow host libstdc++ to be specified for static linking with PPL.
 AC_ARG_WITH(host-libstdcxx, [  --with-host-libstdcxx=L Use linker arguments L to link with libstdc++
diff -Naur gcc-4.4.0.orig/contrib/dg-extract-results.sh gcc-4.4.0/contrib/dg-extract-results.sh
--- gcc-4.4.0.orig/contrib/dg-extract-results.sh	2008-10-24 02:00:54.000000000 -0700
+++ gcc-4.4.0/contrib/dg-extract-results.sh	2009-04-27 12:13:16.000000000 -0700
@@ -6,7 +6,7 @@
 # The resulting file can be used with test result comparison scripts for
 # results from tests that were run in parallel.  See usage() below.
 
-# Copyright (C) 2008 Free Software Foundation
+# Copyright (C) 2008, 2009 Free Software Foundation
 # Contributed by Janis Johnson <janis187@us.ibm.com>
 #
 # This file is part of GCC.
@@ -148,26 +148,28 @@
   ACATS_AWK=${TMP}/acats.awk
   cat <<EOF > $ACATS_AWK
 BEGIN {
-  print_prologue=1; chapter=""; insummary=0
+  print_prologue=1; curfile=""; insummary=0
   passcnt=0; failcnt=0; unsupcnt=0; failures=""
 }
-/=== acats configuration ===/ {
+/^[ \t]*=== acats configuration ===/ {
   insummary=0
   if (print_prologue) print
   next
 }
-/=== acats tests ===/ {
+/^[ \t]*=== acats tests ===/ {
   if (print_prologue) print
   print_prologue=0
   next
 }
 /^Running chapter / {
-  chapter=\$3
-  print > "${TMP}/chapter-"chapter
+  if (curfile) close (curfile)
+  curfile="${TMP}/chapter-"\$3
+  print >> curfile
   next
 }
-/=== acats Summary ===/ {
-  chapter=""
+/^[ \t]*=== acats Summary ===/ {
+  if (curfile) close (curfile)
+  curfile=""
   insummary=1
   next
 }
@@ -182,7 +184,7 @@
 }
 {
   if (print_prologue) { print; next }
-  if (chapter) print > "${TMP}/chapter-"chapter
+  if (curfile) print >> curfile
 }
 END {
   system ("cat ${TMP}/chapter-*")
@@ -194,6 +196,7 @@
 }
 EOF
 
+  rm -f ${TMP}/chapter-*
   $AWK -f $ACATS_AWK $SUM_FILES
   exit 0
 fi
@@ -270,6 +273,7 @@
   expfileno=1
   cnt=0
   print_using=0
+  need_close=0
 }
 /^EXPFILE: / {
   expfiles[expfileno] = \$2
@@ -287,8 +291,10 @@
 /^Running / {
   print_using=0
   if (variant == curvar) {
+    if (need_close) close(curfile)
     curfile="${TMP}/list"expfilesr[\$2]
     expfileseen[\$2]=expfileseen[\$2] + 1
+    need_close=0
     testname="00"
     next
   }
@@ -303,11 +309,12 @@
 /^$/ { if ("$MODE" == "sum") next }
 { if (variant == curvar && curfile) {
     if ("$MODE" == "sum") {
-      printf "%s %08d|", testname, cnt > curfile
+      printf "%s %08d|", testname, cnt >> curfile
       cnt = cnt + 1
     }
     filewritten[curfile]=1
-    print > curfile
+    need_close=1
+    print >> curfile
   } else
     next
 }
diff -Naur gcc-4.4.0.orig/gcc/ada/gcc-interface/utils2.c gcc-4.4.0/gcc/ada/gcc-interface/utils2.c
--- gcc-4.4.0.orig/gcc/ada/gcc-interface/utils2.c	2008-11-09 01:50:02.000000000 -0800
+++ gcc-4.4.0/gcc/ada/gcc-interface/utils2.c	2009-04-22 15:33:59.000000000 -0700
@@ -6,7 +6,7 @@
  *                                                                          *
  *                          C Implementation File                           *
  *                                                                          *
- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *
+ *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *
  *                                                                          *
  * GNAT is free software;  you can  redistribute it  and/or modify it under *
  * terms of the  GNU General Public License as published  by the Free Soft- *
@@ -1010,11 +1010,15 @@
 
     case PLUS_EXPR:
     case MINUS_EXPR:
-      /* Avoid doing arithmetics in BOOLEAN_TYPE like the other compilers.
-	 Contrary to C, Ada doesn't allow arithmetics in Standard.Boolean
-	 but we can generate addition or subtraction for 'Succ and 'Pred.  */
-      if (operation_type && TREE_CODE (operation_type) == BOOLEAN_TYPE)
-	operation_type = left_base_type = right_base_type = integer_type_node;
+      /* Avoid doing arithmetics in ENUMERAL_TYPE or BOOLEAN_TYPE like the
+	 other compilers.  Contrary to C, Ada doesn't allow arithmetics in
+	 these types but can generate addition/subtraction for Succ/Pred.  */
+      if (operation_type
+	  && (TREE_CODE (operation_type) == ENUMERAL_TYPE
+	      || TREE_CODE (operation_type) == BOOLEAN_TYPE))
+	operation_type = left_base_type = right_base_type
+	  = gnat_type_for_mode (TYPE_MODE (operation_type),
+				TYPE_UNSIGNED (operation_type));
 
       /* ... fall through ... */
 
@@ -2199,7 +2203,7 @@
 	  add_stmt (build3 (COND_EXPR, void_type_node,
 			    build_binary_op (GE_EXPR, long_integer_type_node,
 					     convert (long_integer_type_node,
-						      addr64expr), 
+						      addr64expr),
 					     malloc64low),
 			    build_call_raise (CE_Range_Check_Failed, gnat_actual,
 					      N_Raise_Constraint_Error),
diff -Naur gcc-4.4.0.orig/gcc/ada/gcc-interface/utils.c gcc-4.4.0/gcc/ada/gcc-interface/utils.c
--- gcc-4.4.0.orig/gcc/ada/gcc-interface/utils.c	2008-12-09 02:35:15.000000000 -0800
+++ gcc-4.4.0/gcc/ada/gcc-interface/utils.c	2009-04-22 15:02:39.000000000 -0700
@@ -1570,6 +1570,15 @@
   TREE_STATIC (var_decl)
     = !extern_flag && (public_flag || static_flag || global_bindings_p ());
 
+  /* For an external constant whose initializer is not absolute, do not emit
+     debug info.  In DWARF this would mean a global relocation in a read-only
+     section which runs afoul of the PE-COFF runtime relocation mechanism.  */
+  if (extern_flag
+      && constant_p
+      && initializer_constant_valid_p (var_init, TREE_TYPE (var_init))
+	   != null_pointer_node)
+    DECL_IGNORED_P (var_decl) = 1;
+
   if (asm_name && VAR_OR_FUNCTION_DECL_P (var_decl))
     SET_DECL_ASSEMBLER_NAME (var_decl, asm_name);
 
diff -Naur gcc-4.4.0.orig/gcc/alias.c gcc-4.4.0/gcc/alias.c
--- gcc-4.4.0.orig/gcc/alias.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/alias.c	2009-04-27 04:55:13.000000000 -0700
@@ -1438,15 +1438,16 @@
 	  return x;
       return 0;
 
+    case LO_SUM:
+      /* The standard form is (lo_sum reg sym) so look only at the
+         second operand.  */
+      return find_base_term (XEXP (x, 1));
+
     case CONST:
       x = XEXP (x, 0);
       if (GET_CODE (x) != PLUS && GET_CODE (x) != MINUS)
 	return 0;
       /* Fall through.  */
-    case LO_SUM:
-      /* The standard form is (lo_sum reg sym) so look only at the
-         second operand.  */
-      return find_base_term (XEXP (x, 1));
     case PLUS:
     case MINUS:
       {
@@ -2250,14 +2251,13 @@
    Variant of true_dependence which assumes MEM has already been
    canonicalized (hence we no longer do that here).
    The mem_addr argument has been added, since true_dependence computed
-   this value prior to canonicalizing.  */
+   this value prior to canonicalizing.
+   If x_addr is non-NULL, it is used in preference of XEXP (x, 0).  */
 
 int
 canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,
-		       const_rtx x, bool (*varies) (const_rtx, bool))
+		       const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool))
 {
-  rtx x_addr;
-
   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
     return 1;
 
@@ -2283,7 +2283,8 @@
   if (nonoverlapping_memrefs_p (x, mem))
     return 0;
 
-  x_addr = get_addr (XEXP (x, 0));
+  if (! x_addr)
+    x_addr = get_addr (XEXP (x, 0));
 
   if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))
     return 0;
diff -Naur gcc-4.4.0.orig/gcc/builtins.c gcc-4.4.0/gcc/builtins.c
--- gcc-4.4.0.orig/gcc/builtins.c	2009-03-30 10:42:27.000000000 -0700
+++ gcc-4.4.0/gcc/builtins.c	2009-05-29 08:47:31.000000000 -0700
@@ -4176,7 +4176,7 @@
 
     arg1_rtx = get_memory_rtx (arg1, len);
     arg2_rtx = get_memory_rtx (arg2, len);
-    arg3_rtx = expand_normal (len);
+    arg3_rtx = expand_normal (fold_convert (sizetype, len));
 
     /* Set MEM_SIZE as appropriate.  */
     if (GET_CODE (arg3_rtx) == CONST_INT)
diff -Naur gcc-4.4.0.orig/gcc/cfgrtl.c gcc-4.4.0/gcc/cfgrtl.c
--- gcc-4.4.0.orig/gcc/cfgrtl.c	2008-12-12 13:16:09.000000000 -0800
+++ gcc-4.4.0/gcc/cfgrtl.c	2009-05-21 16:17:37.000000000 -0700
@@ -53,6 +53,7 @@
 #include "toplev.h"
 #include "tm_p.h"
 #include "obstack.h"
+#include "insn-attr.h"
 #include "insn-config.h"
 #include "cfglayout.h"
 #include "expr.h"
@@ -427,13 +428,27 @@
   return 0;
 }
 
+static unsigned int
+rest_of_pass_free_cfg (void)
+{
+#ifdef DELAY_SLOTS
+  /* The resource.c machinery uses DF but the CFG isn't guaranteed to be
+     valid at that point so it would be too late to call df_analyze.  */
+  if (optimize > 0 && flag_delayed_branch)
+    df_analyze ();
+#endif
+
+  free_bb_for_insn ();
+  return 0;
+}
+
 struct rtl_opt_pass pass_free_cfg =
 {
  {
   RTL_PASS,
   NULL,                                 /* name */
   NULL,                                 /* gate */
-  free_bb_for_insn,                     /* execute */
+  rest_of_pass_free_cfg,                /* execute */
   NULL,                                 /* sub */
   NULL,                                 /* next */
   0,                                    /* static_pass_number */
diff -Naur gcc-4.4.0.orig/gcc/config/arm/arm.c gcc-4.4.0/gcc/config/arm/arm.c
--- gcc-4.4.0.orig/gcc/config/arm/arm.c	2009-02-24 23:18:01.000000000 -0800
+++ gcc-4.4.0/gcc/config/arm/arm.c	2009-06-02 00:18:16.000000000 -0700
@@ -16883,7 +16883,7 @@
 
   if (push && pushed_words && dwarf2out_do_frame ())
     {
-      char *l = dwarf2out_cfi_label ();
+      char *l = dwarf2out_cfi_label (false);
       int pushed_mask = real_regs;
 
       *cfa_offset += pushed_words * 4;
@@ -17781,7 +17781,7 @@
 	 the stack pointer.  */
       if (dwarf2out_do_frame ())
 	{
-	  char *l = dwarf2out_cfi_label ();
+	  char *l = dwarf2out_cfi_label (false);
 
 	  cfa_offset = cfa_offset + crtl->args.pretend_args_size;
 	  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);
@@ -17830,7 +17830,7 @@
 
       if (dwarf2out_do_frame ())
 	{
-	  char *l = dwarf2out_cfi_label ();
+	  char *l = dwarf2out_cfi_label (false);
 
 	  cfa_offset = cfa_offset + 16;
 	  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);
diff -Naur gcc-4.4.0.orig/gcc/config/arm/arm.h gcc-4.4.0/gcc/config/arm/arm.h
--- gcc-4.4.0.orig/gcc/config/arm/arm.h	2009-03-17 13:18:21.000000000 -0700
+++ gcc-4.4.0/gcc/config/arm/arm.h	2009-04-22 17:31:13.000000000 -0700
@@ -2244,7 +2244,9 @@
 #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)	\
   if (TARGET_32BIT)					\
     ARM_GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)
-
+
+/* Define this for compatibility reasons. */
+#define HANDLE_PRAGMA_PACK_PUSH_POP
 
 /* Specify the machine mode that this machine uses
    for the index in the tablejump instruction.  */
diff -Naur gcc-4.4.0.orig/gcc/config/arm/arm.md gcc-4.4.0/gcc/config/arm/arm.md
--- gcc-4.4.0.orig/gcc/config/arm/arm.md	2009-04-04 05:25:06.000000000 -0700
+++ gcc-4.4.0/gcc/config/arm/arm.md	2009-05-16 06:28:27.000000000 -0700
@@ -8214,7 +8214,7 @@
 
 (define_insn "cstoresi_nltu_thumb1"
   [(set (match_operand:SI 0 "s_register_operand" "=l,l")
-        (neg:SI (gtu:SI (match_operand:SI 1 "s_register_operand" "l,*h")
+        (neg:SI (ltu:SI (match_operand:SI 1 "s_register_operand" "l,*h")
 			(match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r"))))]
   "TARGET_THUMB1"
   "cmp\\t%1, %2\;sbc\\t%0, %0, %0"
diff -Naur gcc-4.4.0.orig/gcc/config/i386/driver-i386.c gcc-4.4.0/gcc/config/i386/driver-i386.c
--- gcc-4.4.0.orig/gcc/config/i386/driver-i386.c	2008-11-04 05:29:43.000000000 -0800
+++ gcc-4.4.0/gcc/config/i386/driver-i386.c	2009-05-27 07:54:00.000000000 -0700
@@ -336,7 +336,11 @@
 enum vendor_signatures
 {
   SIG_INTEL =	0x756e6547 /* Genu */,
-  SIG_AMD =	0x68747541 /* Auth */,
+  SIG_AMD =	0x68747541 /* Auth */
+};
+
+enum processor_signatures
+{
   SIG_GEODE =	0x646f6547 /* Geod */
 };
 
@@ -374,6 +378,9 @@
   /* Extended features */
   unsigned int has_lahf_lm = 0, has_sse4a = 0;
   unsigned int has_longmode = 0, has_3dnowp = 0, has_3dnow = 0;
+  unsigned int has_sse4_1 = 0, has_sse4_2 = 0;
+  unsigned int has_popcnt = 0, has_aes = 0, has_avx = 0;
+  unsigned int has_pclmul = 0;
 
   bool arch;
 
@@ -397,7 +404,13 @@
 
   has_sse3 = ecx & bit_SSE3;
   has_ssse3 = ecx & bit_SSSE3;
+  has_sse4_1 = ecx & bit_SSE4_1;
+  has_sse4_2 = ecx & bit_SSE4_2;
+  has_avx = ecx & bit_AVX;
   has_cmpxchg16b = ecx & bit_CMPXCHG16B;
+  has_popcnt = ecx & bit_POPCNT;
+  has_aes = ecx & bit_AES;
+  has_pclmul = ecx & bit_PCLMUL;
 
   has_cmpxchg8b = edx & bit_CMPXCHG8B;
   has_cmov = edx & bit_CMOV;
@@ -433,19 +446,27 @@
 
   if (vendor == SIG_AMD)
     {
-      processor = PROCESSOR_PENTIUM;
+      unsigned int name;
 
-      if (has_mmx)
-	processor = PROCESSOR_K6;
-      if (has_3dnowp)
-	processor = PROCESSOR_ATHLON;
-      if (has_sse2 || has_longmode)
-	processor = PROCESSOR_K8;
-      if (has_sse4a)
+      /* Detect geode processor by its processor signature.  */
+      if (ext_level > 0x80000001)
+	__cpuid (0x80000002, name, ebx, ecx, edx);
+      else
+	name = 0;
+
+      if (name == SIG_GEODE)
+	processor = PROCESSOR_GEODE;
+      else if (has_sse4a)
 	processor = PROCESSOR_AMDFAM10;
+      else if (has_sse2 || has_longmode)
+	processor = PROCESSOR_K8;
+      else if (has_3dnowp)
+	processor = PROCESSOR_ATHLON;
+      else if (has_mmx)
+	processor = PROCESSOR_K6;
+      else
+	processor = PROCESSOR_PENTIUM;
     }
-  else if (vendor == SIG_GEODE)
-    processor = PROCESSOR_GEODE;
   else
     {
       switch (family)
@@ -576,6 +597,18 @@
 	options = concat (options, "-mcx16 ", NULL);
       if (has_lahf_lm)
 	options = concat (options, "-msahf ", NULL);
+      if (has_aes)
+	options = concat (options, "-maes ", NULL);
+      if (has_pclmul)
+	options = concat (options, "-mpclmul ", NULL);
+      if (has_popcnt)
+	options = concat (options, "-mpopcnt ", NULL);
+      if (has_avx)
+	options = concat (options, "-mavx ", NULL);
+      else if (has_sse4_2)
+	options = concat (options, "-msse4.2 ", NULL);
+      else if (has_sse4_1)
+	options = concat (options, "-msse4.1 ", NULL);
     }
 
 done:
diff -Naur gcc-4.4.0.orig/gcc/config/i386/i386.c gcc-4.4.0/gcc/config/i386/i386.c
--- gcc-4.4.0.orig/gcc/config/i386/i386.c	2009-04-14 13:27:30.000000000 -0700
+++ gcc-4.4.0/gcc/config/i386/i386.c	2009-05-25 05:13:38.000000000 -0700
@@ -5357,7 +5357,10 @@
       case X86_64_SSE_CLASS:
       case X86_64_SSESF_CLASS:
       case X86_64_SSEDF_CLASS:
-	return gen_reg_or_parallel (mode, orig_mode, SSE_REGNO (sse_regno));
+	if (mode != BLKmode)
+	  return gen_reg_or_parallel (mode, orig_mode, 
+				      SSE_REGNO (sse_regno));
+	break;
       case X86_64_X87_CLASS:
       case X86_64_COMPLEX_X87_CLASS:
 	return gen_rtx_REG (mode, FIRST_STACK_REG);
@@ -7301,10 +7304,12 @@
   cfun->machine->accesses_prev_frame = 1;
 }
 
-#if (defined(HAVE_GAS_HIDDEN) && (SUPPORTS_ONE_ONLY - 0)) || TARGET_MACHO
-# define USE_HIDDEN_LINKONCE 1
-#else
-# define USE_HIDDEN_LINKONCE 0
+#ifndef USE_HIDDEN_LINKONCE
+# if (defined(HAVE_GAS_HIDDEN) && (SUPPORTS_ONE_ONLY - 0)) || TARGET_MACHO
+#  define USE_HIDDEN_LINKONCE 1
+# else
+#  define USE_HIDDEN_LINKONCE 0
+# endif
 #endif
 
 static int pic_labels_used;
diff -Naur gcc-4.4.0.orig/gcc/config/i386/linux.h gcc-4.4.0/gcc/config/i386/linux.h
--- gcc-4.4.0.orig/gcc/config/i386/linux.h	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/config/i386/linux.h	2009-05-21 06:21:30.000000000 -0700
@@ -153,7 +153,9 @@
 	fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
 	/* Make sure that we have at least 8 byte alignment if > 8 byte \
 	   alignment is preferred.  */					\
-	if ((LOG) > 3 && (1 << (LOG)) > ((MAX_SKIP) + 1))		\
+	if ((LOG) > 3							\
+	    && (1 << (LOG)) > ((MAX_SKIP) + 1)				\
+	    && (MAX_SKIP) >= 7)						\
 	  fprintf ((FILE), "\t.p2align 3\n");				\
       }									\
     }									\
diff -Naur gcc-4.4.0.orig/gcc/config/i386/sol2.h gcc-4.4.0/gcc/config/i386/sol2.h
--- gcc-4.4.0.orig/gcc/config/i386/sol2.h	2008-09-09 09:17:37.000000000 -0700
+++ gcc-4.4.0/gcc/config/i386/sol2.h	2009-05-25 05:13:38.000000000 -0700
@@ -1,6 +1,6 @@
 /* Target definitions for GCC for Intel 80386 running Solaris 2
    Copyright (C) 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2007, 2008 Free Software Foundation, Inc.
+   2004, 2007, 2008, 2009 Free Software Foundation, Inc.
    Contributed by Fred Fish (fnf@cygnus.com).
 
 This file is part of GCC.
@@ -112,3 +112,9 @@
 /* We do not need NT_VERSION notes.  */
 #undef X86_FILE_START_VERSION_DIRECTIVE
 #define X86_FILE_START_VERSION_DIRECTIVE false
+
+/* Only recent versions of Solaris 11 ld properly support hidden .gnu.linkonce
+   sections, so don't use them.  */
+#ifndef TARGET_GNU_LD
+#define USE_HIDDEN_LINKONCE 0
+#endif
diff -Naur gcc-4.4.0.orig/gcc/config/i386/sse.md gcc-4.4.0/gcc/config/i386/sse.md
--- gcc-4.4.0.orig/gcc/config/i386/sse.md	2009-03-12 10:43:14.000000000 -0700
+++ gcc-4.4.0/gcc/config/i386/sse.md	2009-05-06 06:20:41.000000000 -0700
@@ -978,7 +978,7 @@
 	  (match_operand:AVXMODEF2P 2 "nonimmediate_operand" "xm")))]
   "AVX_VEC_FLOAT_MODE_P (<MODE>mode) && flag_finite_math_only
    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
-  "v<maxminfprefix>p<ssemodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
+  "v<maxminfprefix>p<avxmodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseadd")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
diff -Naur gcc-4.4.0.orig/gcc/config/i386/x86-64.h gcc-4.4.0/gcc/config/i386/x86-64.h
--- gcc-4.4.0.orig/gcc/config/i386/x86-64.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/gcc/config/i386/x86-64.h	2009-05-21 06:21:30.000000000 -0700
@@ -74,7 +74,9 @@
 	fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
 	/* Make sure that we have at least 8 byte alignment if > 8 byte \
 	   alignment is preferred.  */					\
-	if ((LOG) > 3 && (1 << (LOG)) > ((MAX_SKIP) + 1))		\
+	if ((LOG) > 3							\
+	    && (1 << (LOG)) > ((MAX_SKIP) + 1)				\
+	    && (MAX_SKIP) >= 7)						\
 	  fprintf ((FILE), "\t.p2align 3\n");				\
       }									\
     }									\
diff -Naur gcc-4.4.0.orig/gcc/config/m32c/m32c.c gcc-4.4.0/gcc/config/m32c/m32c.c
--- gcc-4.4.0.orig/gcc/config/m32c/m32c.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/config/m32c/m32c.c	2009-05-04 16:53:28.000000000 -0700
@@ -417,6 +417,9 @@
     }
   else
     target_memregs = 16;
+
+  if (TARGET_A24)
+    flag_ivopts = 0;
 }
 
 /* Defining data structures for per-function information */
@@ -2043,6 +2046,31 @@
       return 1;
     }
 
+  /* If we see an RTX like (subreg:PSI (reg:SI ...)) we need to reload
+     the subreg.  We need to check for PLUS and non-PLUS cases.  */
+
+  if (GET_CODE (*x) == SUBREG
+      && GET_MODE (XEXP (*x, 0)) == SImode)
+    {
+      if (type == RELOAD_OTHER)
+	type = RELOAD_FOR_OTHER_ADDRESS;
+      push_reload (*x, NULL_RTX, x, NULL,
+		   A_REGS, Pmode, VOIDmode, 0, 0, opnum,
+		   type);
+      return 1;
+    }
+  if (GET_CODE (*x) == PLUS
+      && GET_CODE (XEXP (*x, 0)) == SUBREG
+      && GET_MODE (XEXP (XEXP (*x, 0), 0)) == SImode)
+    {
+      if (type == RELOAD_OTHER)
+	type = RELOAD_FOR_OTHER_ADDRESS;
+      push_reload (XEXP (*x, 0), NULL_RTX, &(XEXP (*x, 0)), NULL,
+		   A_REGS, Pmode, VOIDmode, 0, 0, opnum,
+		   type);
+      return 1;
+    }
+
   return 0;
 }
 
diff -Naur gcc-4.4.0.orig/gcc/config/rs6000/rs6000-c.c gcc-4.4.0/gcc/config/rs6000/rs6000-c.c
--- gcc-4.4.0.orig/gcc/config/rs6000/rs6000-c.c	2009-03-28 10:29:57.000000000 -0700
+++ gcc-4.4.0/gcc/config/rs6000/rs6000-c.c	2009-05-29 00:14:20.000000000 -0700
@@ -91,6 +91,7 @@
 static GTY(()) tree pixel_keyword;
 static GTY(()) tree __bool_keyword;
 static GTY(()) tree bool_keyword;
+static GTY(()) tree _Bool_keyword;
 
 /* Preserved across calls.  */
 static tree expand_bool_pixel;
@@ -111,6 +112,9 @@
       if (ident == C_CPP_HASHNODE (bool_keyword))
 	return C_CPP_HASHNODE (__bool_keyword);
 
+      if (ident == C_CPP_HASHNODE (_Bool_keyword))
+	return C_CPP_HASHNODE (__bool_keyword);
+
       return ident;
     }
 
@@ -141,6 +145,9 @@
 
   bool_keyword = get_identifier ("bool");
   C_CPP_HASHNODE (bool_keyword)->flags |= NODE_CONDITIONAL;
+
+  _Bool_keyword = get_identifier ("_Bool");
+  C_CPP_HASHNODE (_Bool_keyword)->flags |= NODE_CONDITIONAL;
 }
 
 /* Called to decide whether a conditional macro should be expanded.
@@ -295,6 +302,7 @@
 	  builtin_define ("vector=vector");
 	  builtin_define ("pixel=pixel");
 	  builtin_define ("bool=bool");
+	  builtin_define ("_Bool=_Bool");
 	  init_vector_keywords ();
 
 	  /* Enable context-sensitive macros.  */
diff -Naur gcc-4.4.0.orig/gcc/config/s390/constraints.md gcc-4.4.0/gcc/config/s390/constraints.md
--- gcc-4.4.0.orig/gcc/config/s390/constraints.md	2008-05-28 07:11:19.000000000 -0700
+++ gcc-4.4.0/gcc/config/s390/constraints.md	2009-04-24 07:51:17.000000000 -0700
@@ -129,13 +129,13 @@
 (define_constraint "I"
   "An 8-bit constant (0..255)"
   (and (match_code "const_int")
-       (match_test "(unsigned int) ival <= 255")))
+       (match_test "(unsigned HOST_WIDE_INT) ival <= 255")))
 
 
 (define_constraint "J"
   "A 12-bit constant (0..4095)"
   (and (match_code "const_int")
-       (match_test "(unsigned int) ival <= 4095")))
+       (match_test "(unsigned HOST_WIDE_INT) ival <= 4095")))
 
 
 (define_constraint "K"
diff -Naur gcc-4.4.0.orig/gcc/config/sh/sh.c gcc-4.4.0/gcc/config/sh/sh.c
--- gcc-4.4.0.orig/gcc/config/sh/sh.c	2009-03-25 15:23:27.000000000 -0700
+++ gcc-4.4.0/gcc/config/sh/sh.c	2009-05-24 15:18:47.000000000 -0700
@@ -6908,6 +6908,8 @@
 
   tmp = gen_frame_mem (Pmode, tmp);
   emit_insn (GEN_MOV (tmp, ra));
+  /* Tell this store isn't dead.  */
+  emit_use (tmp);
 }
 
 /* Clear variables at function end.  */
diff -Naur gcc-4.4.0.orig/gcc/config/sh/sh.md gcc-4.4.0/gcc/config/sh/sh.md
--- gcc-4.4.0.orig/gcc/config/sh/sh.md	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/config/sh/sh.md	2009-06-02 17:10:00.000000000 -0700
@@ -3999,6 +3999,34 @@
   [(set_attr "length" "4")
    (set_attr "type" "arith")])
 
+;; Expander for DImode shift left with SImode operations.
+
+(define_expand "ashldi3_std"
+  [(set (match_operand:DI 0 "arith_reg_dest" "=r")
+	(ashift:DI (match_operand:DI 1 "arith_reg_operand" "r")
+                   (match_operand:DI 2 "const_int_operand" "n")))]
+  "TARGET_SH1 && INTVAL (operands[2]) < 32"
+  "
+{
+  int low_word = (TARGET_LITTLE_ENDIAN ? 0 : 1);
+  int high_word = (TARGET_LITTLE_ENDIAN ? 1 : 0);
+  rtx low_src = operand_subword (operands[1], low_word, 0, DImode);
+  rtx high_src = operand_subword (operands[1], high_word, 0, DImode);
+  rtx dst = gen_reg_rtx (DImode);
+  rtx low_dst = operand_subword (dst, low_word, 1, DImode);
+  rtx high_dst = operand_subword (dst, high_word, 1, DImode);
+  rtx tmp0, tmp1;
+
+  tmp0 = gen_reg_rtx (SImode);
+  tmp1 = gen_reg_rtx (SImode);
+  emit_insn (gen_lshrsi3 (tmp0, low_src, GEN_INT (32 - INTVAL (operands[2]))));
+  emit_insn (gen_ashlsi3 (low_dst, low_src, operands[2]));  
+  emit_insn (gen_ashlsi3 (tmp1, high_src, operands[2]));  
+  emit_insn (gen_iorsi3 (high_dst, tmp0, tmp1));
+  emit_move_insn (operands[0], dst);
+  DONE;
+}")
+
 (define_insn "ashldi3_media"
   [(set (match_operand:DI 0 "arith_reg_dest" "=r,r")
 	(ashift:DI (match_operand:DI 1 "arith_reg_operand" "r,r")
@@ -4031,8 +4059,19 @@
       emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
-  if (GET_CODE (operands[2]) != CONST_INT
-      || INTVAL (operands[2]) != 1)
+  if (GET_CODE (operands[2]) == CONST_INT
+      && INTVAL (operands[2]) == 1)
+    {
+      emit_insn (gen_ashldi3_k (operands[0], operands[1]));
+      DONE;
+    }
+  else if (GET_CODE (operands[2]) == CONST_INT
+      && INTVAL (operands[2]) < 32)
+    {
+      emit_insn (gen_ashldi3_std (operands[0], operands[1], operands[2]));
+      DONE;
+    }
+  else
     FAIL;
 }")
 
diff -Naur gcc-4.4.0.orig/gcc/config/spu/spu-builtins.h gcc-4.4.0/gcc/config/spu/spu-builtins.h
--- gcc-4.4.0.orig/gcc/config/spu/spu-builtins.h	2007-08-02 03:49:31.000000000 -0700
+++ gcc-4.4.0/gcc/config/spu/spu-builtins.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,119 +0,0 @@
-/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.
-
-   This file is free software; you can redistribute it and/or modify it under
-   the terms of the GNU General Public License as published by the Free
-   Software Foundation; either version 3 of the License, or (at your option) 
-   any later version.
-
-   This file is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-   for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GCC; see the file COPYING3.  If not see
-   <http://www.gnu.org/licenses/>.  */
-
-/* built-ins */
-
-enum spu_builtin_type_index
-{
-  SPU_BTI_END_OF_PARAMS,
-
-  /* We create new type nodes for these. */
-  SPU_BTI_V16QI,
-  SPU_BTI_V8HI,
-  SPU_BTI_V4SI,
-  SPU_BTI_V2DI,
-  SPU_BTI_V4SF,
-  SPU_BTI_V2DF,
-  SPU_BTI_UV16QI,
-  SPU_BTI_UV8HI,
-  SPU_BTI_UV4SI,
-  SPU_BTI_UV2DI,
-
-  /* A 16-byte type. (Implemented with V16QI_type_node) */
-  SPU_BTI_QUADWORD,
-
-  /* These all correspond to intSI_type_node */
-  SPU_BTI_7,
-  SPU_BTI_S7,
-  SPU_BTI_U7,
-  SPU_BTI_S10,
-  SPU_BTI_S10_4,
-  SPU_BTI_U14,
-  SPU_BTI_16,
-  SPU_BTI_S16,
-  SPU_BTI_S16_2,
-  SPU_BTI_U16,
-  SPU_BTI_U16_2,
-  SPU_BTI_U18,
-
-  /* These correspond to the standard types */
-  SPU_BTI_INTQI, 
-  SPU_BTI_INTHI, 
-  SPU_BTI_INTSI, 
-  SPU_BTI_INTDI, 
-
-  SPU_BTI_UINTQI,
-  SPU_BTI_UINTHI,
-  SPU_BTI_UINTSI,
-  SPU_BTI_UINTDI,
-
-  SPU_BTI_FLOAT, 
-  SPU_BTI_DOUBLE,
-
-  SPU_BTI_VOID,   
-  SPU_BTI_PTR,   
-
-  SPU_BTI_MAX
-};
-
-#define V16QI_type_node               (spu_builtin_types[SPU_BTI_V16QI])
-#define V8HI_type_node                (spu_builtin_types[SPU_BTI_V8HI])
-#define V4SI_type_node                (spu_builtin_types[SPU_BTI_V4SI])
-#define V2DI_type_node                (spu_builtin_types[SPU_BTI_V2DI])
-#define V4SF_type_node                (spu_builtin_types[SPU_BTI_V4SF])
-#define V2DF_type_node                (spu_builtin_types[SPU_BTI_V2DF])
-#define unsigned_V16QI_type_node      (spu_builtin_types[SPU_BTI_UV16QI])
-#define unsigned_V8HI_type_node       (spu_builtin_types[SPU_BTI_UV8HI])
-#define unsigned_V4SI_type_node       (spu_builtin_types[SPU_BTI_UV4SI])
-#define unsigned_V2DI_type_node       (spu_builtin_types[SPU_BTI_UV2DI])
-
-extern GTY(()) tree spu_builtin_types[SPU_BTI_MAX];
-
-/* Some builtins require special handling.  This enum differentiates. */
-enum spu_builtin_type {
-    B_INSN,
-    B_JUMP,
-    B_BISLED,
-    B_CALL,
-    B_HINT,
-    B_OVERLOAD, 
-    B_INTERNAL
-};
-
-typedef enum {
-#define DEF_BUILTIN(fcode, icode, name, type, params) fcode,
-#include "spu-builtins.def"
-#undef DEF_BUILTIN
-   NUM_SPU_BUILTINS
-} spu_function_code;
-
-struct spu_builtin_description {
-    spu_function_code fcode;
-    enum insn_code icode;
-    const char *name;
-    enum spu_builtin_type type;
-
-    /* The first element of parm is always the return type.  The rest
-     * are a zero terminated list of parameters. */
-    int parm[5];
-
-    tree fndecl;
-};
-
-extern GTY(()) struct spu_builtin_description spu_builtins[];
-
-
-
diff -Naur gcc-4.4.0.orig/gcc/config/spu/spu.c gcc-4.4.0/gcc/config/spu/spu.c
--- gcc-4.4.0.orig/gcc/config/spu/spu.c	2009-03-12 07:00:21.000000000 -0700
+++ gcc-4.4.0/gcc/config/spu/spu.c	2009-04-23 15:50:16.000000000 -0700
@@ -52,13 +52,79 @@
 #include "machmode.h"
 #include "gimple.h"
 #include "tm-constrs.h"
-#include "spu-builtins.h"
 #include "ddg.h"
 #include "sbitmap.h"
 #include "timevar.h"
 #include "df.h"
 
 /* Builtin types, data and prototypes. */
+
+enum spu_builtin_type_index
+{
+  SPU_BTI_END_OF_PARAMS,
+
+  /* We create new type nodes for these. */
+  SPU_BTI_V16QI,
+  SPU_BTI_V8HI,
+  SPU_BTI_V4SI,
+  SPU_BTI_V2DI,
+  SPU_BTI_V4SF,
+  SPU_BTI_V2DF,
+  SPU_BTI_UV16QI,
+  SPU_BTI_UV8HI,
+  SPU_BTI_UV4SI,
+  SPU_BTI_UV2DI,
+
+  /* A 16-byte type. (Implemented with V16QI_type_node) */
+  SPU_BTI_QUADWORD,
+
+  /* These all correspond to intSI_type_node */
+  SPU_BTI_7,
+  SPU_BTI_S7,
+  SPU_BTI_U7,
+  SPU_BTI_S10,
+  SPU_BTI_S10_4,
+  SPU_BTI_U14,
+  SPU_BTI_16,
+  SPU_BTI_S16,
+  SPU_BTI_S16_2,
+  SPU_BTI_U16,
+  SPU_BTI_U16_2,
+  SPU_BTI_U18,
+
+  /* These correspond to the standard types */
+  SPU_BTI_INTQI, 
+  SPU_BTI_INTHI, 
+  SPU_BTI_INTSI, 
+  SPU_BTI_INTDI, 
+
+  SPU_BTI_UINTQI,
+  SPU_BTI_UINTHI,
+  SPU_BTI_UINTSI,
+  SPU_BTI_UINTDI,
+
+  SPU_BTI_FLOAT, 
+  SPU_BTI_DOUBLE,
+
+  SPU_BTI_VOID,   
+  SPU_BTI_PTR,   
+
+  SPU_BTI_MAX
+};
+
+#define V16QI_type_node               (spu_builtin_types[SPU_BTI_V16QI])
+#define V8HI_type_node                (spu_builtin_types[SPU_BTI_V8HI])
+#define V4SI_type_node                (spu_builtin_types[SPU_BTI_V4SI])
+#define V2DI_type_node                (spu_builtin_types[SPU_BTI_V2DI])
+#define V4SF_type_node                (spu_builtin_types[SPU_BTI_V4SF])
+#define V2DF_type_node                (spu_builtin_types[SPU_BTI_V2DF])
+#define unsigned_V16QI_type_node      (spu_builtin_types[SPU_BTI_UV16QI])
+#define unsigned_V8HI_type_node       (spu_builtin_types[SPU_BTI_UV8HI])
+#define unsigned_V4SI_type_node       (spu_builtin_types[SPU_BTI_UV4SI])
+#define unsigned_V2DI_type_node       (spu_builtin_types[SPU_BTI_UV2DI])
+
+static GTY(()) tree spu_builtin_types[SPU_BTI_MAX];
+
 struct spu_builtin_range
 {
   int low, high;
@@ -202,8 +268,6 @@
 static enum machine_mode
 spu_libgcc_shift_count_mode (void);
 
-/* Built in types.  */
-tree spu_builtin_types[SPU_BTI_MAX];
 
 /*  TARGET overrides.  */
 
@@ -5067,6 +5131,16 @@
 
 /* Create the built-in types and functions */
 
+enum spu_function_code
+{
+#define DEF_BUILTIN(fcode, icode, name, type, params) fcode,
+#include "spu-builtins.def"
+#undef DEF_BUILTIN
+   NUM_SPU_BUILTINS
+};
+
+extern GTY(()) struct spu_builtin_description spu_builtins[NUM_SPU_BUILTINS];
+
 struct spu_builtin_description spu_builtins[] = {
 #define DEF_BUILTIN(fcode, icode, name, type, params) \
   {fcode, icode, name, type, params, NULL_TREE},
@@ -6298,3 +6372,5 @@
   return default_section_type_flags (decl, name, reloc);
 }
 
+#include "gt-spu.h"
+
diff -Naur gcc-4.4.0.orig/gcc/config/spu/spu-c.c gcc-4.4.0/gcc/config/spu/spu-c.c
--- gcc-4.4.0.orig/gcc/config/spu/spu-c.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/config/spu/spu-c.c	2009-04-23 15:50:16.000000000 -0700
@@ -32,7 +32,6 @@
 #include "insn-codes.h"
 #include "recog.h"
 #include "optabs.h"
-#include "spu-builtins.h"
 
 
 /* Keep the vector keywords handy for fast comparisons.  */
@@ -101,8 +100,7 @@
 #define SCALAR_TYPE_P(t) (INTEGRAL_TYPE_P (t) \
 			  || SCALAR_FLOAT_TYPE_P (t) \
 			  || POINTER_TYPE_P (t))
-  spu_function_code new_fcode, fcode =
-    DECL_FUNCTION_CODE (fndecl) - END_BUILTINS;
+  int new_fcode, fcode = DECL_FUNCTION_CODE (fndecl) - END_BUILTINS;
   struct spu_builtin_description *desc;
   tree match = NULL_TREE;
 
@@ -122,8 +120,15 @@
       tree decl = spu_builtins[new_fcode].fndecl;
       tree params = TYPE_ARG_TYPES (TREE_TYPE (decl));
       tree arg, param;
+      bool all_scalar;
       int p;
 
+      /* Check whether all parameters are scalar.  */
+      all_scalar = true;
+      for (param = params; param != void_list_node; param = TREE_CHAIN (param))
+	if (!SCALAR_TYPE_P (TREE_VALUE (param)))
+	  all_scalar = false;
+
       for (param = params, arg = fnargs, p = 0;
 	   param != void_list_node;
 	   param = TREE_CHAIN (param), arg = TREE_CHAIN (arg), p++)
@@ -155,10 +160,7 @@
 	     parameter. */
 	  if ((!SCALAR_TYPE_P (param_type)
 	       || !SCALAR_TYPE_P (arg_type)
-	       || ((fcode == SPU_SPLATS || fcode == SPU_PROMOTE
-		    || fcode == SPU_HCMPEQ || fcode == SPU_HCMPGT
-		    || fcode == SPU_MASKB || fcode == SPU_MASKH
-		    || fcode == SPU_MASKW) && p == 0))
+	       || (all_scalar && p == 0))
 	      && !comptypes (TYPE_MAIN_VARIANT (param_type),
 			     TYPE_MAIN_VARIANT (arg_type)))
 	    break;
diff -Naur gcc-4.4.0.orig/gcc/config/spu/spu.h gcc-4.4.0/gcc/config/spu/spu.h
--- gcc-4.4.0.orig/gcc/config/spu/spu.h	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/config/spu/spu.h	2009-04-23 15:50:16.000000000 -0700
@@ -622,3 +622,33 @@
 extern GTY(()) rtx spu_compare_op0;
 extern GTY(()) rtx spu_compare_op1;
 
+
+/* Builtins.  */
+
+enum spu_builtin_type
+{
+  B_INSN,
+  B_JUMP,
+  B_BISLED,
+  B_CALL,
+  B_HINT,
+  B_OVERLOAD,
+  B_INTERNAL
+};
+
+struct spu_builtin_description GTY(())
+{
+  int fcode;
+  int icode;
+  const char *name;
+  enum spu_builtin_type type;
+
+  /* The first element of parm is always the return type.  The rest
+     are a zero terminated list of parameters.  */
+  int parm[5];
+
+  tree fndecl;
+};
+
+extern struct spu_builtin_description spu_builtins[];
+
diff -Naur gcc-4.4.0.orig/gcc/config/spu/t-spu-elf gcc-4.4.0/gcc/config/spu/t-spu-elf
--- gcc-4.4.0.orig/gcc/config/spu/t-spu-elf	2009-03-26 07:36:27.000000000 -0700
+++ gcc-4.4.0/gcc/config/spu/t-spu-elf	2009-04-23 15:50:16.000000000 -0700
@@ -85,13 +85,10 @@
   output.h $(BASIC_BLOCK_H) $(INTEGRATE_H) toplev.h $(GGC_H) $(HASHTAB_H) \
   $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h cfglayout.h \
   $(srcdir)/config/spu/spu-protos.h \
-  $(srcdir)/config/spu/spu-builtins.h \
   $(srcdir)/config/spu/spu-builtins.def 
 
 spu-c.o: $(srcdir)/config/spu/spu-c.c \
     $(srcdir)/config/spu/spu-protos.h \
-    $(srcdir)/config/spu/spu-builtins.h \
-    $(srcdir)/config/spu/spu-builtins.def \
     $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(CPPLIB_H) \
     $(TM_P_H) c-pragma.h errors.h coretypes.h $(TM_H) insn-codes.h
 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/spu/spu-c.c
diff -Naur gcc-4.4.0.orig/gcc/config/vax/vax.c gcc-4.4.0/gcc/config/vax/vax.c
--- gcc-4.4.0.orig/gcc/config/vax/vax.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/config/vax/vax.c	2009-06-02 00:18:16.000000000 -0700
@@ -122,7 +122,7 @@
 
   if (dwarf2out_do_frame ())
     {
-      const char *label = dwarf2out_cfi_label ();
+      const char *label = dwarf2out_cfi_label (false);
       int offset = 0;
 
       for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)
diff -Naur gcc-4.4.0.orig/gcc/cp/call.c gcc-4.4.0/gcc/cp/call.c
--- gcc-4.4.0.orig/gcc/cp/call.c	2009-04-13 13:56:45.000000000 -0700
+++ gcc-4.4.0/gcc/cp/call.c	2009-06-03 11:11:53.000000000 -0700
@@ -1384,9 +1384,37 @@
   if (conv)
     return conv;
 
-  if (is_std_init_list (to) && expr
-      && BRACE_ENCLOSED_INITIALIZER_P (expr))
-    return build_list_conv (to, expr, flags);
+  if (expr && BRACE_ENCLOSED_INITIALIZER_P (expr))
+    {
+      if (is_std_init_list (to))
+	return build_list_conv (to, expr, flags);
+
+      /* Allow conversion from an initializer-list with one element to a
+	 scalar type.  */
+      if (SCALAR_TYPE_P (to))
+	{
+	  int nelts = CONSTRUCTOR_NELTS (expr);
+	  tree elt;
+
+	  if (nelts == 0)
+	    elt = integer_zero_node;
+	  else if (nelts == 1)
+	    elt = CONSTRUCTOR_ELT (expr, 0)->value;
+	  else
+	    elt = error_mark_node;
+
+	  conv = implicit_conversion (to, TREE_TYPE (elt), elt,
+				      c_cast_p, flags);
+	  if (conv)
+	    {
+	      conv->check_narrowing = true;
+	      if (BRACE_ENCLOSED_INITIALIZER_P (elt))
+		/* Too many levels of braces, i.e. '{{1}}'.  */
+		conv->bad_p = true;
+	      return conv;
+	    }
+	}
+    }
 
   if (expr != NULL_TREE
       && (MAYBE_CLASS_TYPE_P (from)
@@ -4069,8 +4097,20 @@
 	default:
 	  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))
 	    {
-	      op_error (code, code2, arg1, arg2, arg3, "no match");
-	      print_z_candidates (candidates);
+		/* If one of the arguments of the operator represents
+		   an invalid use of member function pointer, try to report
+		   a meaningful error ...  */
+		if (invalid_nonstatic_memfn_p (arg1, tf_error)
+		    || invalid_nonstatic_memfn_p (arg2, tf_error)
+		    || invalid_nonstatic_memfn_p (arg3, tf_error))
+		  /* We displayed the error message.  */;
+		else
+		  {
+		    /* ... Otherwise, report the more generic
+		       "no matching operator found" error */
+		    op_error (code, code2, arg1, arg2, arg3, "no match");
+		    print_z_candidates (candidates);
+		  }
 	    }
 	  result = error_mark_node;
 	  break;
@@ -4517,12 +4557,21 @@
 
   if (convs->bad_p
       && convs->kind != ck_user
+      && convs->kind != ck_list
       && convs->kind != ck_ambig
       && convs->kind != ck_ref_bind
       && convs->kind != ck_rvalue
       && convs->kind != ck_base)
     {
       conversion *t = convs;
+
+      /* Give a helpful error if this is bad because of excess braces.  */
+      if (BRACE_ENCLOSED_INITIALIZER_P (expr)
+	  && SCALAR_TYPE_P (totype)
+	  && CONSTRUCTOR_NELTS (expr) > 0
+	  && BRACE_ENCLOSED_INITIALIZER_P (CONSTRUCTOR_ELT (expr, 0)->value))
+	permerror (input_location, "too many braces around initializer for %qT", totype);
+
       for (; t; t = convs->u.next)
 	{
 	  if (t->kind == ck_user || !t->bad_p)
@@ -4596,6 +4645,17 @@
 	return expr;
       }
     case ck_identity:
+      if (BRACE_ENCLOSED_INITIALIZER_P (expr))
+	{
+	  int nelts = CONSTRUCTOR_NELTS (expr);
+	  if (nelts == 0)
+	    expr = integer_zero_node;
+	  else if (nelts == 1)
+	    expr = CONSTRUCTOR_ELT (expr, 0)->value;
+	  else
+	    gcc_unreachable ();
+	}
+
       if (type_unknown_p (expr))
 	expr = instantiate_type (totype, expr, complain);
       /* Convert a constant to its underlying value, unless we are
diff -Naur gcc-4.4.0.orig/gcc/cp/cvt.c gcc-4.4.0/gcc/cp/cvt.c
--- gcc-4.4.0.orig/gcc/cp/cvt.c	2008-08-18 04:17:52.000000000 -0700
+++ gcc-4.4.0/gcc/cp/cvt.c	2009-04-23 04:13:57.000000000 -0700
@@ -760,8 +760,15 @@
     }
 
   if (flags & LOOKUP_COMPLAIN)
-    error ("conversion from %qT to non-scalar type %qT requested",
-	   TREE_TYPE (expr), type);
+    {
+      /* If the conversion failed and expr was an invalid use of pointer to
+	 member function, try to report a meaningful error.  */
+      if (invalid_nonstatic_memfn_p (expr, tf_warning_or_error))
+	/* We displayed the error message.  */;
+      else
+	error ("conversion from %qT to non-scalar type %qT requested",
+	       TREE_TYPE (expr), type);
+    }
   return error_mark_node;
 }
 
diff -Naur gcc-4.4.0.orig/gcc/cp/decl.c gcc-4.4.0/gcc/cp/decl.c
--- gcc-4.4.0.orig/gcc/cp/decl.c	2009-04-06 21:38:10.000000000 -0700
+++ gcc-4.4.0/gcc/cp/decl.c	2009-06-03 11:11:53.000000000 -0700
@@ -5533,7 +5533,9 @@
 	  TREE_TYPE (decl) = error_mark_node;
 	  return;
 	}
-      else if (describable_type (init))
+      if (TREE_CODE (init) == TREE_LIST)
+	init = build_x_compound_expr_from_list (init, "initializer");
+      if (describable_type (init))
 	{
 	  type = TREE_TYPE (decl) = do_auto_deduction (type, init, auto_node);
 	  if (type == error_mark_node)
diff -Naur gcc-4.4.0.orig/gcc/cp/parser.c gcc-4.4.0/gcc/cp/parser.c
--- gcc-4.4.0.orig/gcc/cp/parser.c	2009-04-10 12:01:16.000000000 -0700
+++ gcc-4.4.0/gcc/cp/parser.c	2009-04-22 12:16:13.000000000 -0700
@@ -10477,6 +10477,12 @@
          argument pack. */
       if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))
         {
+	  if (argument == error_mark_node)
+	    {
+	      cp_token *token = cp_lexer_peek_token (parser->lexer);
+	      error ("%Hexpected parameter pack before %<...%>",
+		     &token->location);
+	    }
           /* Consume the `...' token. */
           cp_lexer_consume_token (parser->lexer);
 
diff -Naur gcc-4.4.0.orig/gcc/cp/pt.c gcc-4.4.0/gcc/cp/pt.c
--- gcc-4.4.0.orig/gcc/cp/pt.c	2009-04-13 12:27:20.000000000 -0700
+++ gcc-4.4.0/gcc/cp/pt.c	2009-05-06 13:43:41.000000000 -0700
@@ -9144,6 +9144,14 @@
 
 	max = tsubst_expr (omax, args, complain, in_decl,
 			   /*integral_constant_expression_p=*/false);
+
+	/* Fix up type of the magic NOP_EXPR with TREE_SIDE_EFFECTS if
+	   needed.  */
+	if (TREE_CODE (max) == NOP_EXPR
+	    && TREE_SIDE_EFFECTS (omax)
+	    && !TREE_TYPE (max))
+	  TREE_TYPE (max) = TREE_TYPE (TREE_OPERAND (max, 0));
+
 	max = fold_decl_constant_value (max);
 
 	/* If we're in a partial instantiation, preserve the magic NOP_EXPR
@@ -9974,11 +9982,15 @@
 
       if (r == NULL)
 	{
+	  tree c;
 	  /* This can happen for a parameter name used later in a function
 	     declaration (such as in a late-specified return type).  Just
 	     make a dummy decl, since it's only used for its type.  */
 	  gcc_assert (skip_evaluation);	  
-	  r = tsubst_decl (t, args, complain);
+	  /* We copy T because want to tsubst the PARM_DECL only,
+	     not the following PARM_DECLs that are chained to T.  */
+	  c = copy_node (t);
+	  r = tsubst_decl (c, args, complain);
 	  /* Give it the template pattern as its context; its true context
 	     hasn't been instantiated yet and this is good enough for
 	     mangling.  */
@@ -13532,6 +13544,13 @@
 	  && !template_parameter_pack_p (parm))
 	return 1;
 
+      /* If the argument deduction results is a METHOD_TYPE,
+         then there is a problem.
+         METHOD_TYPE doesn't map to any real C++ type the result of
+	 the deduction can not be of that type.  */
+      if (TREE_CODE (arg) == METHOD_TYPE)
+	return 1;
+
       TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;
       return 0;
 
diff -Naur gcc-4.4.0.orig/gcc/cp/semantics.c gcc-4.4.0/gcc/cp/semantics.c
--- gcc-4.4.0.orig/gcc/cp/semantics.c	2009-04-06 12:41:02.000000000 -0700
+++ gcc-4.4.0/gcc/cp/semantics.c	2009-05-17 13:34:30.000000000 -0700
@@ -2838,16 +2838,16 @@
 						     done, address_p,
 						     template_p,
 						     template_arg_p);
-		  else if (dependent_scope_p (scope))
-		    decl = build_qualified_name (/*type=*/NULL_TREE,
-						 scope,
-						 id_expression,
-						 template_p);
-		  else if (DECL_P (decl))
-		    decl = build_qualified_name (TREE_TYPE (decl),
-						 scope,
-						 id_expression,
-						 template_p);
+		  else
+		    {
+		      tree type = NULL_TREE;
+		      if (DECL_P (decl) && !dependent_scope_p (scope))
+			type = TREE_TYPE (decl);
+		      decl = build_qualified_name (type,
+						   scope,
+						   id_expression,
+						   template_p);
+		    }
 		}
 	      if (TREE_TYPE (decl))
 		decl = convert_from_reference (decl);
diff -Naur gcc-4.4.0.orig/gcc/cp/typeck.c gcc-4.4.0/gcc/cp/typeck.c
--- gcc-4.4.0.orig/gcc/cp/typeck.c	2009-04-06 21:38:10.000000000 -0700
+++ gcc-4.4.0/gcc/cp/typeck.c	2009-06-03 11:11:53.000000000 -0700
@@ -260,6 +260,19 @@
   enum tree_code code2 = TREE_CODE (t2);
   tree attributes;
 
+  /* In what follows, we slightly generalize the rules given in [expr] so
+     as to deal with `long long' and `complex'.  First, merge the
+     attributes.  */
+  attributes = (*targetm.merge_type_attributes) (t1, t2);
+
+  if (SCOPED_ENUM_P (t1) || SCOPED_ENUM_P (t2))
+    {
+      if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))
+	return build_type_attribute_variant (t1, attributes);
+      else
+	return NULL_TREE;
+    }
+
   /* FIXME: Attributes.  */
   gcc_assert (ARITHMETIC_TYPE_P (t1)
 	      || TREE_CODE (t1) == VECTOR_TYPE
@@ -268,11 +281,6 @@
 	      || TREE_CODE (t2) == VECTOR_TYPE
 	      || UNSCOPED_ENUM_P (t2));
 
-  /* In what follows, we slightly generalize the rules given in [expr] so
-     as to deal with `long long' and `complex'.  First, merge the
-     attributes.  */
-  attributes = (*targetm.merge_type_attributes) (t1, t2);
-
   /* If one type is complex, form the common type of the non-complex
      components, then make that complex.  Use T1 or T2 if it is the
      required type.  */
@@ -1508,7 +1516,7 @@
 bool
 invalid_nonstatic_memfn_p (const_tree expr, tsubst_flags_t complain)
 {
-  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (expr))
+  if (expr && DECL_NONSTATIC_MEMBER_FUNCTION_P (expr))
     {
       if (complain & tf_error)
         error ("invalid use of non-static member function");
@@ -2437,6 +2445,10 @@
 
   if (processing_template_decl)
     {
+      /* Retain the type if we know the operand is a pointer so that
+	 describable_type doesn't make auto deduction break.  */
+      if (TREE_TYPE (expr) && POINTER_TYPE_P (TREE_TYPE (expr)))
+	return build_min (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);
       if (type_dependent_expression_p (expr))
 	return build_min_nt (INDIRECT_REF, expr);
       expr = build_non_dependent_expr (expr);
@@ -3589,9 +3601,9 @@
 
       build_type = boolean_type_node;
       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE
-	   || code0 == COMPLEX_TYPE)
+	   || code0 == COMPLEX_TYPE || code0 == ENUMERAL_TYPE)
 	  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE
-	      || code1 == COMPLEX_TYPE))
+	      || code1 == COMPLEX_TYPE || code1 == ENUMERAL_TYPE))
 	short_compare = 1;
       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)
 	       || (TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)))
@@ -3863,9 +3875,10 @@
       break;
     }
 
-  if (((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)
+  if (((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE
+	|| code0 == ENUMERAL_TYPE)
        && (code1 == INTEGER_TYPE || code1 == REAL_TYPE
-	   || code1 == COMPLEX_TYPE)))
+	   || code1 == COMPLEX_TYPE || code1 == ENUMERAL_TYPE)))
     arithmetic_types_p = 1;
   else
     {
@@ -5967,8 +5980,11 @@
 
   if (modifycode == INIT_EXPR)
     {
-      if (TREE_CODE (rhs) == CONSTRUCTOR)
+      if (BRACE_ENCLOSED_INITIALIZER_P (rhs))
+	/* Do the default thing.  */;
+      else if (TREE_CODE (rhs) == CONSTRUCTOR)
 	{
+	  /* Compound literal.  */
 	  if (! same_type_p (TREE_TYPE (rhs), lhstype))
 	    /* Call convert to generate an error; see PR 11063.  */
 	    rhs = convert (lhstype, rhs);
diff -Naur gcc-4.4.0.orig/gcc/cse.c gcc-4.4.0/gcc/cse.c
--- gcc-4.4.0.orig/gcc/cse.c	2009-03-14 01:10:55.000000000 -0700
+++ gcc-4.4.0/gcc/cse.c	2009-04-27 04:55:13.000000000 -0700
@@ -1,6 +1,6 @@
 /* Common subexpression elimination for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -1658,7 +1658,7 @@
 {
   struct check_dependence_data *d = (struct check_dependence_data *) data;
   if (*x && MEM_P (*x))
-    return canon_true_dependence (d->exp, d->mode, d->addr, *x,
+    return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX,
 		    		  cse_rtx_varies_p);
   else
     return 0;
diff -Naur gcc-4.4.0.orig/gcc/cselib.c gcc-4.4.0/gcc/cselib.c
--- gcc-4.4.0.orig/gcc/cselib.c	2008-12-22 15:41:17.000000000 -0800
+++ gcc-4.4.0/gcc/cselib.c	2009-04-27 04:55:13.000000000 -0700
@@ -1,6 +1,6 @@
 /* Common subexpression elimination library for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -1483,7 +1483,7 @@
 	    }
 	  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)
 	      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx), mem_addr,
-		      			  x, cselib_rtx_varies_p))
+		      			  x, NULL_RTX, cselib_rtx_varies_p))
 	    {
 	      has_mem = true;
 	      num_mems++;
diff -Naur gcc-4.4.0.orig/gcc/DATESTAMP gcc-4.4.0/gcc/DATESTAMP
--- gcc-4.4.0.orig/gcc/DATESTAMP	2009-04-20 17:16:42.000000000 -0700
+++ gcc-4.4.0/gcc/DATESTAMP	2009-06-04 17:16:45.000000000 -0700
@@ -1 +1 @@
-20090421
+20090605
diff -Naur gcc-4.4.0.orig/gcc/dbxout.c gcc-4.4.0/gcc/dbxout.c
--- gcc-4.4.0.orig/gcc/dbxout.c	2009-02-27 11:49:42.000000000 -0800
+++ gcc-4.4.0/gcc/dbxout.c	2009-04-22 15:24:45.000000000 -0700
@@ -3593,7 +3593,7 @@
   while (block)
     {
       /* Ignore blocks never expanded or otherwise marked as real.  */
-      if (TREE_ASM_WRITTEN (block))
+      if (TREE_USED (block) && TREE_ASM_WRITTEN (block))
 	{
 	  int did_output;
 	  int blocknum = BLOCK_NUMBER (block);
diff -Naur gcc-4.4.0.orig/gcc/dfp.c gcc-4.4.0/gcc/dfp.c
--- gcc-4.4.0.orig/gcc/dfp.c	2008-06-18 18:13:53.000000000 -0700
+++ gcc-4.4.0/gcc/dfp.c	2009-05-07 14:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /* Decimal floating point support.
-   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -132,6 +132,7 @@
   decNumber dn;
   decimal32 d32;
   decContext set;
+  int32_t image;
 
   decContextDefault (&set, DEC_INIT_DECIMAL128);
   set.traps = 0;
@@ -139,7 +140,8 @@
   decimal_to_decnumber (r, &dn); 
   decimal32FromNumber (&d32, &dn, &set);
 
-  buf[0] = *(uint32_t *) d32.bytes;
+  memcpy (&image, d32.bytes, sizeof (int32_t));
+  buf[0] = image;
 }
 
 /* Decode an IEEE 754 decimal32 type into a real.  */
@@ -151,11 +153,13 @@
   decNumber dn;
   decimal32 d32;
   decContext set;
+  int32_t image;
 
   decContextDefault (&set, DEC_INIT_DECIMAL128);
   set.traps = 0;
 
-  *((uint32_t *) d32.bytes) = (uint32_t) buf[0];
+  image = buf[0];
+  memcpy (&d32.bytes, &image, sizeof (int32_t));
 
   decimal32ToNumber (&d32, &dn);
   decimal_from_decnumber (r, &dn, &set); 
@@ -170,6 +174,7 @@
   decNumber dn;
   decimal64 d64;
   decContext set;
+  int32_t image;
 
   decContextDefault (&set, DEC_INIT_DECIMAL128);
   set.traps = 0;
@@ -179,13 +184,17 @@
 
   if (WORDS_BIGENDIAN == FLOAT_WORDS_BIG_ENDIAN)
     {
-      buf[0] = *(uint32_t *) &d64.bytes[0];
-      buf[1] = *(uint32_t *) &d64.bytes[4];
+      memcpy (&image, &d64.bytes[0], sizeof (int32_t));
+      buf[0] = image;
+      memcpy (&image, &d64.bytes[4], sizeof (int32_t));
+      buf[1] = image;
     }
   else
     {
-      buf[0] = *(uint32_t *) &d64.bytes[4];
-      buf[1] = *(uint32_t *) &d64.bytes[0];
+      memcpy (&image, &d64.bytes[4], sizeof (int32_t));
+      buf[0] = image;
+      memcpy (&image, &d64.bytes[0], sizeof (int32_t));
+      buf[1] = image;
     }
 }
 
@@ -198,19 +207,24 @@
   decNumber dn;
   decimal64 d64;
   decContext set;
+  int32_t image;
 
   decContextDefault (&set, DEC_INIT_DECIMAL128);
   set.traps = 0;
 
   if (WORDS_BIGENDIAN == FLOAT_WORDS_BIG_ENDIAN)
     {
-      *((uint32_t *) &d64.bytes[0]) = (uint32_t) buf[0];
-      *((uint32_t *) &d64.bytes[4]) = (uint32_t) buf[1];
+      image = buf[0];
+      memcpy (&d64.bytes[0], &image, sizeof (int32_t));
+      image = buf[1];
+      memcpy (&d64.bytes[4], &image, sizeof (int32_t));
     }
   else
     {
-      *((uint32_t *) &d64.bytes[0]) = (uint32_t) buf[1];
-      *((uint32_t *) &d64.bytes[4]) = (uint32_t) buf[0];
+      image = buf[1];
+      memcpy (&d64.bytes[0], &image, sizeof (int32_t));
+      image = buf[0];
+      memcpy (&d64.bytes[4], &image, sizeof (int32_t));
     }
 
   decimal64ToNumber (&d64, &dn);
@@ -226,6 +240,7 @@
   decNumber dn;
   decContext set;
   decimal128 d128;
+  int32_t image;
 
   decContextDefault (&set, DEC_INIT_DECIMAL128);
   set.traps = 0;
@@ -235,17 +250,25 @@
 
   if (WORDS_BIGENDIAN == FLOAT_WORDS_BIG_ENDIAN)
     {
-      buf[0] = *(uint32_t *) &d128.bytes[0];
-      buf[1] = *(uint32_t *) &d128.bytes[4];
-      buf[2] = *(uint32_t *) &d128.bytes[8];
-      buf[3] = *(uint32_t *) &d128.bytes[12];
+      memcpy (&image, &d128.bytes[0], sizeof (int32_t));
+      buf[0] = image;
+      memcpy (&image, &d128.bytes[4], sizeof (int32_t));
+      buf[1] = image;
+      memcpy (&image, &d128.bytes[8], sizeof (int32_t));
+      buf[2] = image;
+      memcpy (&image, &d128.bytes[12], sizeof (int32_t));
+      buf[3] = image;
     }
   else
     {
-      buf[0] = *(uint32_t *) &d128.bytes[12];
-      buf[1] = *(uint32_t *) &d128.bytes[8];
-      buf[2] = *(uint32_t *) &d128.bytes[4];
-      buf[3] = *(uint32_t *) &d128.bytes[0];
+      memcpy (&image, &d128.bytes[12], sizeof (int32_t));
+      buf[0] = image;
+      memcpy (&image, &d128.bytes[8], sizeof (int32_t));
+      buf[1] = image;
+      memcpy (&image, &d128.bytes[4], sizeof (int32_t));
+      buf[2] = image;
+      memcpy (&image, &d128.bytes[0], sizeof (int32_t));
+      buf[3] = image;
     }
 }
 
@@ -258,23 +281,32 @@
   decNumber dn;
   decimal128 d128;
   decContext set;
+  int32_t image;
 
   decContextDefault (&set, DEC_INIT_DECIMAL128);
   set.traps = 0;
 
   if (WORDS_BIGENDIAN == FLOAT_WORDS_BIG_ENDIAN)
     {
-      *((uint32_t *) &d128.bytes[0])  = (uint32_t) buf[0];
-      *((uint32_t *) &d128.bytes[4])  = (uint32_t) buf[1];
-      *((uint32_t *) &d128.bytes[8])  = (uint32_t) buf[2];
-      *((uint32_t *) &d128.bytes[12]) = (uint32_t) buf[3];
+      image = buf[0];
+      memcpy (&d128.bytes[0],  &image, sizeof (int32_t));
+      image = buf[1];
+      memcpy (&d128.bytes[4],  &image, sizeof (int32_t));
+      image = buf[2];
+      memcpy (&d128.bytes[8],  &image, sizeof (int32_t));
+      image = buf[3];
+      memcpy (&d128.bytes[12], &image, sizeof (int32_t));
     }
   else
     {
-      *((uint32_t *) &d128.bytes[0])  = (uint32_t) buf[3];
-      *((uint32_t *) &d128.bytes[4])  = (uint32_t) buf[2];
-      *((uint32_t *) &d128.bytes[8])  = (uint32_t) buf[1];
-      *((uint32_t *) &d128.bytes[12]) = (uint32_t) buf[0];
+      image = buf[3];
+      memcpy (&d128.bytes[0],  &image, sizeof (int32_t));
+      image = buf[2];
+      memcpy (&d128.bytes[4],  &image, sizeof (int32_t));
+      image = buf[1];
+      memcpy (&d128.bytes[8],  &image, sizeof (int32_t));
+      image = buf[0];
+      memcpy (&d128.bytes[12], &image, sizeof (int32_t));
     }
 
   decimal128ToNumber (&d128, &dn);
diff -Naur gcc-4.4.0.orig/gcc/doc/gccint.texi gcc-4.4.0/gcc/doc/gccint.texi
--- gcc-4.4.0.orig/gcc/doc/gccint.texi	2008-09-21 08:05:14.000000000 -0700
+++ gcc-4.4.0/gcc/doc/gccint.texi	2009-05-23 10:55:01.000000000 -0700
@@ -109,10 +109,10 @@
 * Options::         Option specification files.
 * Passes::          Order of passes, what they do, and what each file is for.
 * Trees::           The source representation used by the C and C++ front ends.
-* RTL::             The intermediate representation that most passes work on.
 * GENERIC::         Language-independent representation generated by Front Ends
 * GIMPLE::          Tuple representation used by Tree SSA optimizers
 * Tree SSA::        Analysis and optimization of GIMPLE
+* RTL::             Machine-dependent low-level intermediate representation.
 * Control Flow::    Maintaining and manipulating the control flow graph.
 * Loop Analysis and Representation:: Analysis and representation of loops
 * Machine Desc::    How to write machine description instruction patterns.
diff -Naur gcc-4.4.0.orig/gcc/doc/md.texi gcc-4.4.0/gcc/doc/md.texi
--- gcc-4.4.0.orig/gcc/doc/md.texi	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/doc/md.texi	2009-05-07 01:14:55.000000000 -0700
@@ -5111,8 +5111,6 @@
 Operand 0 is the memory on which the atomic operation is performed.
 Operand 1 is the second operand to the binary operator.
 
-The ``nand'' operation is @code{~op0 & op1}.
-
 This pattern must issue any memory barrier instructions such that all
 memory operations before the atomic operation occur before the atomic
 operation and all memory operations after the atomic operation occur
diff -Naur gcc-4.4.0.orig/gcc/doc/passes.texi gcc-4.4.0/gcc/doc/passes.texi
--- gcc-4.4.0.orig/gcc/doc/passes.texi	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/doc/passes.texi	2009-05-23 10:55:01.000000000 -0700
@@ -21,7 +21,7 @@
 * Parsing pass::         The language front end turns text into bits.
 * Gimplification pass::  The bits are turned into something we can optimize.
 * Pass manager::         Sequencing the optimization passes.
-* Tree-SSA passes::      Optimizations on a high-level representation.
+* Tree SSA passes::      Optimizations on a high-level representation.
 * RTL passes::           Optimizations on a low-level representation.
 @end menu
 
@@ -94,8 +94,8 @@
 should be passed to @code{cgraph_finalize_function}.
 
 TODO: I know rest_of_compilation currently has all sorts of
-rtl-generation semantics.  I plan to move all code generation
-bits (both tree and rtl) to compile_function.  Should we hide
+RTL generation semantics.  I plan to move all code generation
+bits (both Tree and RTL) to compile_function.  Should we hide
 cgraph from the front ends and move back to rest_of_compilation
 as the official interface?  Possibly we should rename all three
 interfaces such that the names match in some meaningful way and
@@ -172,12 +172,12 @@
 
 TODO: describe the global variables set up by the pass manager,
 and a brief description of how a new pass should use it.
-I need to look at what info rtl passes use first@enddots{}
+I need to look at what info RTL passes use first@enddots{}
 
-@node Tree-SSA passes
-@section Tree-SSA passes
+@node Tree SSA passes
+@section Tree SSA passes
 
-The following briefly describes the tree optimization passes that are
+The following briefly describes the Tree optimization passes that are
 run after gimplification and what source files they are located in.
 
 @itemize @bullet
@@ -401,7 +401,7 @@
 The optimizations performed by this pass are:
 
 Loop invariant motion.  This pass moves only invariants that
-would be hard to handle on rtl level (function calls, operations that expand to
+would be hard to handle on RTL level (function calls, operations that expand to
 nontrivial sequences of insns).  With @option{-funswitch-loops} it also moves
 operands of conditions that are invariant out of the loop, so that we can use
 just trivial invariantness analysis in loop unswitching.  The pass also includes
@@ -422,8 +422,8 @@
 out of the loops.  To achieve this, a duplicate of the loop is created for
 each possible outcome of conditional jump(s).  The pass is implemented in
 @file{tree-ssa-loop-unswitch.c}.  This pass should eventually replace the
-rtl-level loop unswitching in @file{loop-unswitch.c}, but currently
-the rtl-level pass is not completely redundant yet due to deficiencies
+RTL level loop unswitching in @file{loop-unswitch.c}, but currently
+the RTL level pass is not completely redundant yet due to deficiencies
 in tree level alias analysis.
 
 The optimizations also use various utility functions contained in
@@ -651,8 +651,8 @@
 @node RTL passes
 @section RTL passes
 
-The following briefly describes the rtl generation and optimization
-passes that are run after tree optimization.
+The following briefly describes the RTL generation and optimization
+passes that are run after the Tree optimization passes.
 
 @itemize @bullet
 @item RTL generation
@@ -679,15 +679,15 @@
 and @code{gencodes}, tell this pass which standard names are available
 for use and which patterns correspond to them.
 
-@item Generate exception handling landing pads
+@item Generation of exception landing pads
 
 This pass generates the glue that handles communication between the
 exception handling library routines and the exception handlers within
 the function.  Entry points in the function that are invoked by the
 exception handling library are called @dfn{landing pads}.  The code
-for this pass is located within @file{except.c}.
+for this pass is located in @file{except.c}.
 
-@item Cleanup control flow graph
+@item Control flow graph cleanup
 
 This pass removes unreachable code, simplifies jumps to next, jumps to
 jump, jumps across jumps, etc.  The pass is run multiple times.
@@ -702,16 +702,16 @@
 variables that come from a single definition, and
 seeing if the result can be simplified.  It performs copy propagation
 and addressing mode selection.  The pass is run twice, with values
-being propagated into loops only on the second run.  It is located in
-@file{fwprop.c}.
+being propagated into loops only on the second run.  The code is
+located in @file{fwprop.c}.
 
 @item Common subexpression elimination
 
 This pass removes redundant computation within basic blocks, and
 optimizes addressing modes based on cost.  The pass is run twice.
-The source is located in @file{cse.c}.
+The code for this pass is located in @file{cse.c}.
 
-@item Global common subexpression elimination.
+@item Global common subexpression elimination
 
 This pass performs two
 different types of GCSE  depending on whether you are optimizing for
@@ -755,22 +755,13 @@
 assignments with arithmetic, boolean value producing comparison
 instructions, and conditional move instructions.  In the very last
 invocation after reload, it will generate predicated instructions
-when supported by the target.  The pass is located in @file{ifcvt.c}.
+when supported by the target.  The code is located in @file{ifcvt.c}.
 
 @item Web construction
 
 This pass splits independent uses of each pseudo-register.  This can
 improve effect of the other transformation, such as CSE or register
-allocation.  Its source files are @file{web.c}.
-
-@item Life analysis
-
-This pass computes which pseudo-registers are live at each point in
-the program, and makes the first instruction that uses a value point
-at the instruction that computed the value.  It then deletes
-computations whose results are never used, and combines memory
-references with add or subtract instructions to make autoincrement or
-autodecrement addressing.  The pass is located in @file{flow.c}.
+allocation.  The code for this pass is located in @file{web.c}.
 
 @item Instruction combination
 
@@ -778,23 +769,23 @@
 are related by data flow into single instructions.  It combines the
 RTL expressions for the instructions by substitution, simplifies the
 result using algebra, and then attempts to match the result against
-the machine description.  The pass is located in @file{combine.c}.
+the machine description.  The code is located in @file{combine.c}.
 
 @item Register movement
 
 This pass looks for cases where matching constraints would force an
 instruction to need a reload, and this reload would be a
 register-to-register move.  It then attempts to change the registers
-used by the instruction to avoid the move instruction.
-The pass is located in @file{regmove.c}.
+used by the instruction to avoid the move instruction.  The code is
+located in @file{regmove.c}.
 
-@item Optimize mode switching
+@item Mode switching optimization
 
 This pass looks for instructions that require the processor to be in a
 specific ``mode'' and minimizes the number of mode changes required to
 satisfy all users.  What these modes are, and what they apply to are
-completely target-specific.
-The source is located in @file{mode-switching.c}.
+completely target-specific.  The code for this pass is located in
+@file{mode-switching.c}.
 
 @cindex modulo scheduling
 @cindex sms, swing, software pipelining
@@ -802,8 +793,8 @@
 
 This pass looks at innermost loops and reorders their instructions
 by overlapping different iterations.  Modulo scheduling is performed
-immediately before instruction scheduling.
-The pass is located in (@file{modulo-sched.c}).
+immediately before instruction scheduling.  The code for this pass is
+located in @file{modulo-sched.c}.
 
 @item Instruction scheduling
 
@@ -813,7 +804,7 @@
 It re-orders instructions within a basic block to try to separate the
 definition and use of items that otherwise would cause pipeline
 stalls.  This pass is performed twice, before and after register
-allocation.  The pass is located in @file{haifa-sched.c},
+allocation.  The code for this pass is located in @file{haifa-sched.c},
 @file{sched-deps.c}, @file{sched-ebb.c}, @file{sched-rgn.c} and
 @file{sched-vis.c}.
 
@@ -884,13 +875,13 @@
 position in code and generates notes describing the variable locations
 to RTL code.  The location lists are then generated according to these
 notes to debug information if the debugging information format supports
-location lists.
+location lists.  The code is located in @file{var-tracking.c}.
 
 @item Delayed branch scheduling
 
 This optional pass attempts to find instructions that can go into the
-delay slots of other instructions, usually jumps and calls.  The
-source file name is @file{reorg.c}.
+delay slots of other instructions, usually jumps and calls.  The code
+for this pass is located in @file{reorg.c}.
 
 @item Branch shortening
 
@@ -899,13 +890,14 @@
 In this pass, the compiler figures out what how far each instruction
 will be from each other instruction, and therefore whether the usual
 instructions, or the longer sequences, must be used for each branch.
+The code for this pass is located in @file{final.c}.
 
 @item Register-to-stack conversion
 
 Conversion from usage of some hard registers to usage of a register
 stack may be done at this point.  Currently, this is supported only
-for the floating-point registers of the Intel 80387 coprocessor.   The
-source file name is @file{reg-stack.c}.
+for the floating-point registers of the Intel 80387 coprocessor.  The
+code for this pass is located in @file{reg-stack.c}.
 
 @item Final
 
diff -Naur gcc-4.4.0.orig/gcc/doc/rtl.texi gcc-4.4.0/gcc/doc/rtl.texi
--- gcc-4.4.0.orig/gcc/doc/rtl.texi	2008-10-15 17:51:34.000000000 -0700
+++ gcc-4.4.0/gcc/doc/rtl.texi	2009-05-23 10:55:01.000000000 -0700
@@ -10,10 +10,10 @@
 @cindex representation of RTL
 @cindex Register Transfer Language (RTL)
 
-Most of the work of the compiler is done on an intermediate representation
-called register transfer language.  In this language, the instructions to be
-output are described, pretty much one by one, in an algebraic form that
-describes what the instruction does.
+The last part of the compiler work is done on a low-level intermediate
+representation called Register Transfer Language.  In this language, the
+instructions to be output are described, pretty much one by one, in an
+algebraic form that describes what the instruction does.
 
 RTL is inspired by Lisp lists.  It has both an internal form, made up of
 structures that point at other structures, and a textual form that is used
diff -Naur gcc-4.4.0.orig/gcc/dojump.c gcc-4.4.0/gcc/dojump.c
--- gcc-4.4.0.orig/gcc/dojump.c	2009-01-09 05:43:14.000000000 -0800
+++ gcc-4.4.0/gcc/dojump.c	2009-05-07 08:36:23.000000000 -0700
@@ -141,7 +141,8 @@
     }
 
   /* Fill in the integers.  */
-  XEXP (and_test, 1) = GEN_INT ((unsigned HOST_WIDE_INT) 1 << bitnum);
+  XEXP (and_test, 1)
+    = immed_double_const ((unsigned HOST_WIDE_INT) 1 << bitnum, 0, mode);
   XEXP (XEXP (shift_test, 0), 1) = GEN_INT (bitnum);
 
   return (rtx_cost (and_test, IF_THEN_ELSE, optimize_insn_for_speed_p ())
@@ -475,10 +476,10 @@
 		  && prefer_and_bit_test (TYPE_MODE (argtype),
 					  TREE_INT_CST_LOW (shift)))
 		{
-		  HOST_WIDE_INT mask = (HOST_WIDE_INT) 1
-				       << TREE_INT_CST_LOW (shift);
+		  unsigned HOST_WIDE_INT mask
+		    = (unsigned HOST_WIDE_INT) 1 << TREE_INT_CST_LOW (shift);
 		  do_jump (build2 (BIT_AND_EXPR, argtype, arg,
-				   build_int_cst_type (argtype, mask)),
+				   build_int_cst_wide_type (argtype, mask, 0)),
 			   clr_label, set_label);
 		  break;
 		}
diff -Naur gcc-4.4.0.orig/gcc/dse.c gcc-4.4.0/gcc/dse.c
--- gcc-4.4.0.orig/gcc/dse.c	2009-03-18 10:04:26.000000000 -0700
+++ gcc-4.4.0/gcc/dse.c	2009-05-13 14:42:03.000000000 -0700
@@ -223,7 +223,7 @@
   /* This canonized mem.  */
   rtx mem;
 
-  /* The result of get_addr on mem.  */
+  /* Canonized MEM address for use by canon_true_dependence.  */
   rtx mem_addr;
 
   /* If this is non-zero, it is the alias set of a spill location.  */
@@ -476,8 +476,8 @@
      do read dependency.  */
   rtx base_mem;
   
-  /* Canonized version of base_mem, most likely the same thing.  */
-  rtx canon_base_mem;
+  /* Canonized version of base_mem's address.  */
+  rtx canon_base_addr;
 
   /* These two sets of two bitmaps are used to keep track of how many
      stores are actually referencing that position from this base.  We
@@ -705,7 +705,7 @@
       gi->rtx_base = base;
       gi->id = rtx_group_next_id++;
       gi->base_mem = gen_rtx_MEM (QImode, base);
-      gi->canon_base_mem = canon_rtx (gi->base_mem);
+      gi->canon_base_addr = canon_rtx (base);
       gi->store1_n = BITMAP_ALLOC (NULL);
       gi->store1_p = BITMAP_ALLOC (NULL);
       gi->store2_n = BITMAP_ALLOC (NULL);
@@ -1286,7 +1286,7 @@
 static int
 record_store (rtx body, bb_info_t bb_info)
 {
-  rtx mem, rhs, const_rhs;
+  rtx mem, rhs, const_rhs, mem_addr;
   HOST_WIDE_INT offset = 0;
   HOST_WIDE_INT width = 0;
   alias_set_type spill_alias_set;
@@ -1456,6 +1456,23 @@
   ptr = active_local_stores;
   last = NULL;
   redundant_reason = NULL;
+  mem = canon_rtx (mem);
+  /* For alias_set != 0 canon_true_dependence should be never called.  */
+  if (spill_alias_set)
+    mem_addr = NULL_RTX;
+  else
+    {
+      if (group_id < 0)
+	mem_addr = base->val_rtx;
+      else
+	{
+	  group_info_t group
+	    = VEC_index (group_info_t, rtx_group_vec, group_id);
+	  mem_addr = group->canon_base_addr;
+	}
+      if (offset)
+	mem_addr = plus_constant (mem_addr, offset);
+    }
 
   while (ptr)
     {
@@ -1547,13 +1564,13 @@
 	  if (canon_true_dependence (s_info->mem, 
 				     GET_MODE (s_info->mem),
 				     s_info->mem_addr,
-				     mem, rtx_varies_p))
+				     mem, mem_addr, rtx_varies_p))
 	    {
 	      s_info->rhs = NULL;
 	      s_info->const_rhs = NULL;
 	    }
 	}
-      
+
       /* An insn can be deleted if every position of every one of
 	 its s_infos is zero.  */
       if (any_positions_needed_p (s_info)
@@ -1580,9 +1597,9 @@
   /* Finish filling in the store_info.  */
   store_info->next = insn_info->store_rec;
   insn_info->store_rec = store_info;
-  store_info->mem = canon_rtx (mem);
+  store_info->mem = mem;
   store_info->alias_set = spill_alias_set;
-  store_info->mem_addr = get_addr (XEXP (mem, 0));
+  store_info->mem_addr = mem_addr;
   store_info->cse_base = base;
   if (width > HOST_BITS_PER_WIDE_INT)
     {
@@ -2006,7 +2023,7 @@
 static int
 check_mem_read_rtx (rtx *loc, void *data)
 {
-  rtx mem = *loc;
+  rtx mem = *loc, mem_addr;
   bb_info_t bb_info;
   insn_info_t insn_info;
   HOST_WIDE_INT offset = 0;
@@ -2058,6 +2075,22 @@
   read_info->end = offset + width;
   read_info->next = insn_info->read_rec;
   insn_info->read_rec = read_info;
+  /* For alias_set != 0 canon_true_dependence should be never called.  */
+  if (spill_alias_set)
+    mem_addr = NULL_RTX;
+  else
+    {
+      if (group_id < 0)
+	mem_addr = base->val_rtx;
+      else
+	{
+	  group_info_t group
+	    = VEC_index (group_info_t, rtx_group_vec, group_id);
+	  mem_addr = group->canon_base_addr;
+	}
+      if (offset)
+	mem_addr = plus_constant (mem_addr, offset);
+    }
 
   /* We ignore the clobbers in store_info.  The is mildly aggressive,
      but there really should not be a clobber followed by a read.  */
@@ -2128,7 +2161,7 @@
 	      = canon_true_dependence (store_info->mem, 
 				       GET_MODE (store_info->mem),
 				       store_info->mem_addr,
-				       mem, rtx_varies_p);
+				       mem, mem_addr, rtx_varies_p);
 	  
 	  else if (group_id == store_info->group_id)
 	    {
@@ -2139,7 +2172,7 @@
 		  = canon_true_dependence (store_info->mem, 
 					   GET_MODE (store_info->mem),
 					   store_info->mem_addr,
-					   mem, rtx_varies_p);
+					   mem, mem_addr, rtx_varies_p);
 	      
 	      /* If this read is just reading back something that we just
 		 stored, rewrite the read.  */
@@ -2212,6 +2245,7 @@
 	  if (store_info->rhs
 	      && store_info->group_id == -1
 	      && store_info->cse_base == base
+	      && width != -1
 	      && offset >= store_info->begin
 	      && offset + width <= store_info->end
 	      && all_positions_needed_p (store_info,
@@ -2224,7 +2258,7 @@
 	    remove = canon_true_dependence (store_info->mem, 
 					    GET_MODE (store_info->mem),
 					    store_info->mem_addr,
-					    mem, rtx_varies_p);
+					    mem, mem_addr, rtx_varies_p);
 	  
 	  if (remove)
 	    {
@@ -3066,8 +3100,9 @@
 		  if ((read_info->group_id < 0)
 		      && canon_true_dependence (group->base_mem, 
 						QImode,
-						group->canon_base_mem,
-						read_info->mem, rtx_varies_p))
+						group->canon_base_addr,
+						read_info->mem, NULL_RTX,
+						rtx_varies_p))
 		    {
 		      if (kill)
 			bitmap_ior_into (kill, group->group_kill);
diff -Naur gcc-4.4.0.orig/gcc/dwarf2out.c gcc-4.4.0/gcc/dwarf2out.c
--- gcc-4.4.0.orig/gcc/dwarf2out.c	2009-03-23 16:21:38.000000000 -0700
+++ gcc-4.4.0/gcc/dwarf2out.c	2009-06-03 10:32:45.000000000 -0700
@@ -694,14 +694,15 @@
   *p = cfi;
 }
 
-/* Generate a new label for the CFI info to refer to.  */
+/* Generate a new label for the CFI info to refer to.  FORCE is true
+   if a label needs to be output even when using .cfi_* directives.  */
 
 char *
-dwarf2out_cfi_label (void)
+dwarf2out_cfi_label (bool force)
 {
   static char label[20];
 
-  if (dwarf2out_do_cfi_asm ())
+  if (!force && dwarf2out_do_cfi_asm ())
     {
       /* In this case, we will be emitting the asm directive instead of
 	 the label, so just return a placeholder to keep the rest of the
@@ -729,11 +730,59 @@
     {
       if (label)
 	{
-	  output_cfi_directive (cfi);
+	  dw_fde_ref fde = current_fde ();
+
+	  gcc_assert (fde != NULL);
 
 	  /* We still have to add the cfi to the list so that
-	     lookup_cfa works later on.  */
-	  list_head = &current_fde ()->dw_fde_cfi;
+	     lookup_cfa works later on.  When -g2 and above we
+	     even need to force emitting of CFI labels and
+	     add to list a DW_CFA_set_loc for convert_cfa_to_fb_loc_list
+	     purposes.  */
+	  switch (cfi->dw_cfi_opc)
+	    {
+	    case DW_CFA_def_cfa_offset:
+	    case DW_CFA_def_cfa_offset_sf:
+	    case DW_CFA_def_cfa_register:
+	    case DW_CFA_def_cfa:
+	    case DW_CFA_def_cfa_sf:
+	    case DW_CFA_def_cfa_expression:
+	    case DW_CFA_restore_state:
+	      if (write_symbols != DWARF2_DEBUG
+		  && write_symbols != VMS_AND_DWARF2_DEBUG)
+		break;
+	      if (debug_info_level <= DINFO_LEVEL_TERSE)
+		break;
+
+	      if (*label == 0 || strcmp (label, "<do not output>") == 0)
+		label = dwarf2out_cfi_label (true);
+
+	      if (fde->dw_fde_current_label == NULL
+		  || strcmp (label, fde->dw_fde_current_label) != 0)
+		{
+		  dw_cfi_ref xcfi;
+
+		  label = xstrdup (label);
+
+		  /* Set the location counter to the new label.  */
+		  xcfi = new_cfi ();
+		  /* It doesn't metter whether DW_CFA_set_loc
+		     or DW_CFA_advance_loc4 is added here, those aren't
+		     emitted into assembly, only looked up by
+		     convert_cfa_to_fb_loc_list.  */
+		  xcfi->dw_cfi_opc = DW_CFA_set_loc;
+		  xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;
+		  add_cfi (&fde->dw_fde_cfi, xcfi);
+		  fde->dw_fde_current_label = label;
+		}
+	      break;
+	    default:
+	      break;
+	    }
+
+	  output_cfi_directive (cfi);
+
+	  list_head = &fde->dw_fde_cfi;
 	}
       /* ??? If this is a CFI for the CIE, we don't emit.  This
 	 assumes that the standard CIE contents that the assembler
@@ -748,7 +797,7 @@
       gcc_assert (fde != NULL);
 
       if (*label == 0)
-	label = dwarf2out_cfi_label ();
+	label = dwarf2out_cfi_label (false);
 
       if (fde->dw_fde_current_label == NULL
 	  || strcmp (label, fde->dw_fde_current_label) != 0)
@@ -1464,7 +1513,7 @@
   if (offset == 0)
     return;
 
-  label = dwarf2out_cfi_label ();
+  label = dwarf2out_cfi_label (false);
   dwarf2out_args_size_adjust (offset, label);
 }
 
@@ -2417,7 +2466,7 @@
       return;
     }
 
-  label = dwarf2out_cfi_label ();
+  label = dwarf2out_cfi_label (false);
   src = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);
   if (src)
     insn = XEXP (src, 0);
@@ -2731,42 +2780,42 @@
     case DW_CFA_offset:
     case DW_CFA_offset_extended:
     case DW_CFA_offset_extended_sf:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_offset %lu, "HOST_WIDE_INT_PRINT_DEC"\n",
 	       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);
       break;
 
     case DW_CFA_restore:
     case DW_CFA_restore_extended:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_restore %lu\n", r);
       break;
 
     case DW_CFA_undefined:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_undefined %lu\n", r);
       break;
 
     case DW_CFA_same_value:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_same_value %lu\n", r);
       break;
 
     case DW_CFA_def_cfa:
     case DW_CFA_def_cfa_sf:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_def_cfa %lu, "HOST_WIDE_INT_PRINT_DEC"\n",
 	       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);
       break;
 
     case DW_CFA_def_cfa_register:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_def_cfa_register %lu\n", r);
       break;
 
     case DW_CFA_register:
-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);
-      r2 = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, 0);
+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);
+      r2 = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, 1);
       fprintf (asm_out_file, "\t.cfi_register %lu, %lu\n", r, r2);
       break;
 
@@ -14646,6 +14695,12 @@
       /* Prevent broken recursion; we can't hand off to the same type.  */
       gcc_assert (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) != type);
 
+      /* Use the DIE of the containing namespace as the parent DIE of
+         the type description DIE we want to generate.  */
+      if (DECL_CONTEXT (TYPE_NAME (type))
+	  && TREE_CODE (DECL_CONTEXT (TYPE_NAME (type))) == NAMESPACE_DECL)
+	context_die = lookup_decl_die (DECL_CONTEXT (TYPE_NAME (type)));
+
       TREE_ASM_WRITTEN (type) = 1;
       gen_decl_die (TYPE_NAME (type), NULL, context_die);
       return;
diff -Naur gcc-4.4.0.orig/gcc/fold-const.c gcc-4.4.0/gcc/fold-const.c
--- gcc-4.4.0.orig/gcc/fold-const.c	2009-03-11 08:24:00.000000000 -0700
+++ gcc-4.4.0/gcc/fold-const.c	2009-05-20 14:11:10.000000000 -0700
@@ -5293,31 +5293,34 @@
 	break;
 
       case GT_EXPR:
-	/* If C1 is C2 - 1, this is max(A, C2).  */
+	/* If C1 is C2 - 1, this is max(A, C2), but use ARG00's type for
+	   MAX_EXPR, to preserve the signedness of the comparison.  */
 	if (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),
 			       OEP_ONLY_CONST)
 	    && operand_equal_p (arg01,
 				const_binop (MINUS_EXPR, arg2,
 					     build_int_cst (type, 1), 0),
 				OEP_ONLY_CONST))
-	  return pedantic_non_lvalue (fold_build2 (MAX_EXPR,
-						   type,
-						   fold_convert (type, arg1),
-						   arg2));
+	  return pedantic_non_lvalue (fold_convert (type,
+				      fold_build2 (MAX_EXPR, TREE_TYPE (arg00),
+						   arg00,
+						   fold_convert (TREE_TYPE (arg00),
+							         arg2))));
 	break;
 
       case GE_EXPR:
-	/* If C1 is C2 + 1, this is max(A, C2).  */
+	/* If C1 is C2 + 1, this is max(A, C2), with the same care as above.  */
 	if (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),
 			       OEP_ONLY_CONST)
 	    && operand_equal_p (arg01,
 				const_binop (PLUS_EXPR, arg2,
 					     build_int_cst (type, 1), 0),
 				OEP_ONLY_CONST))
-	  return pedantic_non_lvalue (fold_build2 (MAX_EXPR,
-						   type,
-						   fold_convert (type, arg1),
-						   arg2));
+	  return pedantic_non_lvalue (fold_convert (type,
+				      fold_build2 (MAX_EXPR, TREE_TYPE (arg00),
+						   arg00,
+						   fold_convert (TREE_TYPE (arg00),
+							         arg2))));
 	break;
       case NE_EXPR:
 	break;
@@ -11360,6 +11363,8 @@
 	      if (prec < HOST_BITS_PER_WIDE_INT
 		  || newmask == ~(unsigned HOST_WIDE_INT) 0)
 		{
+		  tree newmaskt;
+
 		  if (shift_type != TREE_TYPE (arg0))
 		    {
 		      tem = fold_build2 (TREE_CODE (arg0), shift_type,
@@ -11370,9 +11375,9 @@
 		    }
 		  else
 		    tem = op0;
-		  return fold_build2 (BIT_AND_EXPR, type, tem,
-				      build_int_cst_type (TREE_TYPE (op1),
-							  newmask));
+		  newmaskt = build_int_cst_type (TREE_TYPE (op1), newmask);
+		  if (!tree_int_cst_equal (newmaskt, arg1))
+		    return fold_build2 (BIT_AND_EXPR, type, tem, newmaskt);
 		}
 	    }
 	}
@@ -11861,7 +11866,8 @@
 	      if (code == LROTATE_EXPR || code == RROTATE_EXPR)
 	        low = low % TYPE_PRECISION (type);
 	      else if (TYPE_UNSIGNED (type) || code == LSHIFT_EXPR)
-	        return build_int_cst (type, 0);
+		return omit_one_operand (type, build_int_cst (type, 0),
+					 TREE_OPERAND (arg0, 0));
 	      else
 		low = TYPE_PRECISION (type) - 1;
 	    }
diff -Naur gcc-4.4.0.orig/gcc/fortran/data.c gcc-4.4.0/gcc/fortran/data.c
--- gcc-4.4.0.orig/gcc/fortran/data.c	2008-07-28 17:45:52.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/data.c	2009-06-04 10:01:45.000000000 -0700
@@ -416,7 +416,11 @@
     }
 
   if (ref || last_ts->type == BT_CHARACTER)
-    expr = create_character_intializer (init, last_ts, ref, rvalue);
+    {
+      if (lvalue->ts.cl->length == NULL && !(ref && ref->u.ss.length != NULL))
+	return FAILURE;
+      expr = create_character_intializer (init, last_ts, ref, rvalue);
+    }
   else
     {
       /* Overwriting an existing initializer is non-standard but usually only
diff -Naur gcc-4.4.0.orig/gcc/fortran/f95-lang.c gcc-4.4.0/gcc/fortran/f95-lang.c
--- gcc-4.4.0.orig/gcc/fortran/f95-lang.c	2008-10-07 11:15:32.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/f95-lang.c	2009-04-22 04:37:04.000000000 -0700
@@ -917,12 +917,12 @@
   gfc_define_builtin ("__builtin_fmodf", mfunc_float[1], 
 		      BUILT_IN_FMODF, "fmodf", true);
 
-  gfc_define_builtin ("__builtin_infl", mfunc_longdouble[3], 
-		      BUILT_IN_INFL, "__builtin_infl", true);
-  gfc_define_builtin ("__builtin_inf", mfunc_double[3], 
-		      BUILT_IN_INF, "__builtin_inf", true);
-  gfc_define_builtin ("__builtin_inff", mfunc_float[3], 
-		      BUILT_IN_INFF, "__builtin_inff", true);
+  gfc_define_builtin ("__builtin_huge_vall", mfunc_longdouble[3], 
+		      BUILT_IN_HUGE_VALL, "__builtin_huge_vall", true);
+  gfc_define_builtin ("__builtin_huge_val", mfunc_double[3], 
+		      BUILT_IN_HUGE_VAL, "__builtin_huge_val", true);
+  gfc_define_builtin ("__builtin_huge_valf", mfunc_float[3], 
+		      BUILT_IN_HUGE_VALF, "__builtin_huge_valf", true);
 
   /* lround{f,,l} and llround{f,,l} */
   type = tree_cons (NULL_TREE, float_type_node, void_list_node);
diff -Naur gcc-4.4.0.orig/gcc/fortran/module.c gcc-4.4.0/gcc/fortran/module.c
--- gcc-4.4.0.orig/gcc/fortran/module.c	2009-02-26 23:45:47.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/module.c	2009-05-22 05:54:23.000000000 -0700
@@ -4738,7 +4738,7 @@
   if ((file = fopen (filename, "r")) == NULL)
     return -1;
 
-  /* Read two lines.  */
+  /* Read the first line.  */
   if (fgets (buf, sizeof (buf) - 1, file) == NULL)
     {
       fclose (file);
@@ -4748,8 +4748,12 @@
   /* The file also needs to be overwritten if the version number changed.  */
   n = strlen ("GFORTRAN module version '" MOD_VERSION "' created");
   if (strncmp (buf, "GFORTRAN module version '" MOD_VERSION "' created", n) != 0)
-    return -1;
+    {
+      fclose (file);
+      return -1;
+    }
  
+  /* Read a second line.  */
   if (fgets (buf, sizeof (buf) - 1, file) == NULL)
     {
       fclose (file);
diff -Naur gcc-4.4.0.orig/gcc/fortran/simplify.c gcc-4.4.0/gcc/fortran/simplify.c
--- gcc-4.4.0.orig/gcc/fortran/simplify.c	2009-03-06 01:06:51.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/simplify.c	2009-06-03 12:39:09.000000000 -0700
@@ -2410,10 +2410,13 @@
   bs = gfc_integer_kinds[i].bit_size;
   if (mpz_cmp_si (e->value.integer, 0) == 0)
     lz = bs;
+  else if (mpz_cmp_si (e->value.integer, 0) < 0)
+    lz = 0;
   else
     lz = bs - mpz_sizeinbase (e->value.integer, 2);
 
-  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind, &e->where);
+  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind,
+				&e->where);
   mpz_set_ui (result->value.integer, lz);
 
   return result;
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-array.c gcc-4.4.0/gcc/fortran/trans-array.c
--- gcc-4.4.0.orig/gcc/fortran/trans-array.c	2009-02-25 22:23:42.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/trans-array.c	2009-05-10 09:14:37.000000000 -0700
@@ -1246,10 +1246,11 @@
 		  gfc_init_se (&se, NULL);
 		  gfc_conv_constant (&se, p->expr);
 
+		  if (c->expr->ts.type != BT_CHARACTER)
+		    se.expr = fold_convert (type, se.expr);
 		  /* For constant character array constructors we build
 		     an array of pointers.  */
-		  if (p->expr->ts.type == BT_CHARACTER
-		      && POINTER_TYPE_P (type))
+		  else if (POINTER_TYPE_P (type))
 		    se.expr = gfc_build_addr_expr
 				(gfc_get_pchar_type (p->expr->ts.kind),
 				 se.expr);
@@ -1618,7 +1619,9 @@
     {
       gfc_init_se (&se, NULL);
       gfc_conv_constant (&se, c->expr);
-      if (c->expr->ts.type == BT_CHARACTER && POINTER_TYPE_P (type))
+      if (c->expr->ts.type != BT_CHARACTER)
+	se.expr = fold_convert (type, se.expr);
+      else if (POINTER_TYPE_P (type))
 	se.expr = gfc_build_addr_expr (gfc_get_pchar_type (c->expr->ts.kind),
 				       se.expr);
       list = tree_cons (build_int_cst (gfc_array_index_type, nelem),
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans.c gcc-4.4.0/gcc/fortran/trans.c
--- gcc-4.4.0.orig/gcc/fortran/trans.c	2008-11-01 06:26:19.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/trans.c	2009-05-10 08:34:55.000000000 -0700
@@ -1109,12 +1109,14 @@
 	    if (code->resolved_isym
 		&& code->resolved_isym->id == GFC_ISYM_MVBITS)
 	      is_mvbits = true;
-	    res = gfc_trans_call (code, is_mvbits);
+	    res = gfc_trans_call (code, is_mvbits, NULL_TREE,
+				  NULL_TREE, false);
 	  }
 	  break;
 
 	case EXEC_ASSIGN_CALL:
-	  res = gfc_trans_call (code, true);
+	  res = gfc_trans_call (code, true, NULL_TREE,
+				NULL_TREE, false);
 	  break;
 
 	case EXEC_RETURN:
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-decl.c gcc-4.4.0/gcc/fortran/trans-decl.c
--- gcc-4.4.0.orig/gcc/fortran/trans-decl.c	2009-04-08 07:03:33.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/trans-decl.c	2009-06-03 12:39:09.000000000 -0700
@@ -141,6 +141,8 @@
 tree gfor_fndecl_size0;
 tree gfor_fndecl_size1;
 tree gfor_fndecl_iargc;
+tree gfor_fndecl_clz128;
+tree gfor_fndecl_ctz128;
 
 /* Intrinsic functions implemented in Fortran.  */
 tree gfor_fndecl_sc_kind;
@@ -2488,6 +2490,19 @@
     gfc_build_library_function_decl (get_identifier (PREFIX ("iargc")),
 				     gfc_int4_type_node,
 				     0);
+
+  if (gfc_type_for_size (128, true))
+    {
+      tree uint128 = gfc_type_for_size (128, true);
+
+      gfor_fndecl_clz128 =
+	gfc_build_library_function_decl (get_identifier (PREFIX ("clz128")),
+					 integer_type_node, 1, uint128);
+
+      gfor_fndecl_ctz128 =
+	gfc_build_library_function_decl (get_identifier (PREFIX ("ctz128")),
+					 integer_type_node, 1, uint128);
+    }
 }
 
 
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-expr.c gcc-4.4.0/gcc/fortran/trans-expr.c
--- gcc-4.4.0.orig/gcc/fortran/trans-expr.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/trans-expr.c	2009-05-10 08:34:55.000000000 -0700
@@ -1526,48 +1526,6 @@
 }
 
 
-/* Translate the call for an elemental subroutine call used in an operator
-   assignment.  This is a simplified version of gfc_conv_function_call.  */
-
-tree
-gfc_conv_operator_assign (gfc_se *lse, gfc_se *rse, gfc_symbol *sym)
-{
-  tree args;
-  tree tmp;
-  gfc_se se;
-  stmtblock_t block;
-
-  /* Only elemental subroutines with two arguments.  */
-  gcc_assert (sym->attr.elemental && sym->attr.subroutine);
-  gcc_assert (sym->formal->next->next == NULL);
-
-  gfc_init_block (&block);
-
-  gfc_add_block_to_block (&block, &lse->pre);
-  gfc_add_block_to_block (&block, &rse->pre);
-
-  /* Build the argument list for the call, including hidden string lengths.  */
-  args = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (lse->expr));
-  args = gfc_chainon_list (args, build_fold_addr_expr (rse->expr));
-  if (lse->string_length != NULL_TREE)
-    args = gfc_chainon_list (args, lse->string_length);
-  if (rse->string_length != NULL_TREE)
-    args = gfc_chainon_list (args, rse->string_length);    
-
-  /* Build the function call.  */
-  gfc_init_se (&se, NULL);
-  gfc_conv_function_val (&se, sym);
-  tmp = TREE_TYPE (TREE_TYPE (TREE_TYPE (se.expr)));
-  tmp = build_call_list (tmp, se.expr, args);
-  gfc_add_expr_to_block (&block, tmp);
-
-  gfc_add_block_to_block (&block, &lse->post);
-  gfc_add_block_to_block (&block, &rse->post);
-
-  return gfc_finish_block (&block);
-}
-
-
 /* Initialize MAPPING.  */
 
 void
@@ -2782,7 +2740,18 @@
 	      break;
 	    }
 
+	  if (e->expr_type == EXPR_OP
+		&& e->value.op.op == INTRINSIC_PARENTHESES
+		&& e->value.op.op1->expr_type == EXPR_VARIABLE)
+	    {
+	      tree local_tmp;
+	      local_tmp = gfc_evaluate_now (tmp, &se->pre);
+	      local_tmp = gfc_copy_alloc_comp (e->ts.derived, local_tmp, tmp, parm_rank);
+	      gfc_add_expr_to_block (&se->post, local_tmp);
+	    }
+
 	  tmp = gfc_deallocate_alloc_comp (e->ts.derived, tmp, parm_rank);
+
 	  gfc_add_expr_to_block (&se->post, tmp);
         }
 
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans.h gcc-4.4.0/gcc/fortran/trans.h
--- gcc-4.4.0.orig/gcc/fortran/trans.h	2008-12-18 02:05:54.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/trans.h	2009-06-03 12:39:09.000000000 -0700
@@ -310,9 +310,6 @@
 /* Does an intrinsic map directly to an external library call.  */
 int gfc_is_intrinsic_libcall (gfc_expr *);
 
-/* Used to call the elemental subroutines used in operator assignments.  */
-tree gfc_conv_operator_assign (gfc_se *, gfc_se *, gfc_symbol *);
-
 /* Also used to CALL subroutines.  */
 int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,
 			    tree);
@@ -594,6 +591,8 @@
 extern GTY(()) tree gfor_fndecl_size0;
 extern GTY(()) tree gfor_fndecl_size1;
 extern GTY(()) tree gfor_fndecl_iargc;
+extern GTY(()) tree gfor_fndecl_clz128;
+extern GTY(()) tree gfor_fndecl_ctz128;
 
 /* Implemented in Fortran.  */
 extern GTY(()) tree gfor_fndecl_sc_kind;
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-intrinsic.c gcc-4.4.0/gcc/fortran/trans-intrinsic.c
--- gcc-4.4.0.orig/gcc/fortran/trans-intrinsic.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/trans-intrinsic.c	2009-06-03 12:39:09.000000000 -0700
@@ -2707,53 +2707,51 @@
   tree leadz;
   tree bit_size;
   tree tmp;
-  int arg_kind;
-  int i, n, s;
+  tree func;
+  int s, argsize;
 
   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);
+  argsize = TYPE_PRECISION (TREE_TYPE (arg));
 
   /* Which variant of __builtin_clz* should we call?  */
-  arg_kind = expr->value.function.actual->expr->ts.kind;
-  i = gfc_validate_kind (BT_INTEGER, arg_kind, false);
-  switch (arg_kind)
+  if (argsize <= INT_TYPE_SIZE)
     {
-      case 1:
-      case 2:
-      case 4:
-        arg_type = unsigned_type_node;
-	n = BUILT_IN_CLZ;
-	break;
-
-      case 8:
-        arg_type = long_unsigned_type_node;
-	n = BUILT_IN_CLZL;
-	break;
-
-      case 16:
-        arg_type = long_long_unsigned_type_node;
-	n = BUILT_IN_CLZLL;
-	break;
-
-      default:
-        gcc_unreachable ();
+      arg_type = unsigned_type_node;
+      func = built_in_decls[BUILT_IN_CLZ];
+    }
+  else if (argsize <= LONG_TYPE_SIZE)
+    {
+      arg_type = long_unsigned_type_node;
+      func = built_in_decls[BUILT_IN_CLZL];
+    }
+  else if (argsize <= LONG_LONG_TYPE_SIZE)
+    {
+      arg_type = long_long_unsigned_type_node;
+      func = built_in_decls[BUILT_IN_CLZLL];
+    }
+  else
+    {
+      gcc_assert (argsize == 128);
+      arg_type = gfc_build_uint_type (argsize);
+      func = gfor_fndecl_clz128;
     }
 
-  /* Convert the actual argument to the proper argument type for the built-in
+  /* Convert the actual argument twice: first, to the unsigned type of the
+     same size; then, to the proper argument type for the built-in
      function.  But the return type is of the default INTEGER kind.  */
+  arg = fold_convert (gfc_build_uint_type (argsize), arg);
   arg = fold_convert (arg_type, arg);
   result_type = gfc_get_int_type (gfc_default_integer_kind);
 
   /* Compute LEADZ for the case i .ne. 0.  */
-  s = TYPE_PRECISION (arg_type) - gfc_integer_kinds[i].bit_size;
-  tmp = fold_convert (result_type, build_call_expr (built_in_decls[n], 1, arg));
+  s = TYPE_PRECISION (arg_type) - argsize;
+  tmp = fold_convert (result_type, build_call_expr (func, 1, arg));
   leadz = fold_build2 (MINUS_EXPR, result_type,
 		       tmp, build_int_cst (result_type, s));
 
   /* Build BIT_SIZE.  */
-  bit_size = build_int_cst (result_type, gfc_integer_kinds[i].bit_size);
+  bit_size = build_int_cst (result_type, argsize);
 
-  /* ??? For some combinations of targets and integer kinds, the condition
-	 can be avoided if CLZ_DEFINED_VALUE_AT_ZERO is used.  Later.  */
   cond = fold_build2 (EQ_EXPR, boolean_type_node,
 		      arg, build_int_cst (arg_type, 0));
   se->expr = fold_build3 (COND_EXPR, result_type, cond, bit_size, leadz);
@@ -2774,50 +2772,48 @@
   tree result_type;
   tree trailz;
   tree bit_size;
-  int arg_kind;
-  int i, n;
+  tree func;
+  int argsize;
 
   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);
+  argsize = TYPE_PRECISION (TREE_TYPE (arg));
 
-  /* Which variant of __builtin_clz* should we call?  */
-  arg_kind = expr->value.function.actual->expr->ts.kind;
-  i = gfc_validate_kind (BT_INTEGER, arg_kind, false);
-  switch (expr->ts.kind)
+  /* Which variant of __builtin_ctz* should we call?  */
+  if (argsize <= INT_TYPE_SIZE)
     {
-      case 1:
-      case 2:
-      case 4:
-        arg_type = unsigned_type_node;
-	n = BUILT_IN_CTZ;
-	break;
-
-      case 8:
-        arg_type = long_unsigned_type_node;
-	n = BUILT_IN_CTZL;
-	break;
-
-      case 16:
-        arg_type = long_long_unsigned_type_node;
-	n = BUILT_IN_CTZLL;
-	break;
-
-      default:
-        gcc_unreachable ();
+      arg_type = unsigned_type_node;
+      func = built_in_decls[BUILT_IN_CTZ];
+    }
+  else if (argsize <= LONG_TYPE_SIZE)
+    {
+      arg_type = long_unsigned_type_node;
+      func = built_in_decls[BUILT_IN_CTZL];
+    }
+  else if (argsize <= LONG_LONG_TYPE_SIZE)
+    {
+      arg_type = long_long_unsigned_type_node;
+      func = built_in_decls[BUILT_IN_CTZLL];
+    }
+  else
+    {
+      gcc_assert (argsize == 128);
+      arg_type = gfc_build_uint_type (argsize);
+      func = gfor_fndecl_ctz128;
     }
 
-  /* Convert the actual argument to the proper argument type for the built-in
+  /* Convert the actual argument twice: first, to the unsigned type of the
+     same size; then, to the proper argument type for the built-in
      function.  But the return type is of the default INTEGER kind.  */
+  arg = fold_convert (gfc_build_uint_type (argsize), arg);
   arg = fold_convert (arg_type, arg);
   result_type = gfc_get_int_type (gfc_default_integer_kind);
 
   /* Compute TRAILZ for the case i .ne. 0.  */
-  trailz = fold_convert (result_type, build_call_expr (built_in_decls[n], 1, arg));
+  trailz = fold_convert (result_type, build_call_expr (func, 1, arg));
 
   /* Build BIT_SIZE.  */
-  bit_size = build_int_cst (result_type, gfc_integer_kinds[i].bit_size);
+  bit_size = build_int_cst (result_type, argsize);
 
-  /* ??? For some combinations of targets and integer kinds, the condition
-	 can be avoided if CTZ_DEFINED_VALUE_AT_ZERO is used.  Later.  */
   cond = fold_build2 (EQ_EXPR, boolean_type_node,
 		      arg, build_int_cst (arg_type, 0));
   se->expr = fold_build3 (COND_EXPR, result_type, cond, bit_size, trailz);
@@ -3129,32 +3125,32 @@
 
 
 /* NEAREST (s, dir) is translated into
-     tmp = copysign (INF, dir);
+     tmp = copysign (HUGE_VAL, dir);
      return nextafter (s, tmp);
  */
 static void
 gfc_conv_intrinsic_nearest (gfc_se * se, gfc_expr * expr)
 {
   tree args[2], type, tmp;
-  int nextafter, copysign, inf;
+  int nextafter, copysign, huge_val;
 
   switch (expr->ts.kind)
     {
       case 4:
 	nextafter = BUILT_IN_NEXTAFTERF;
 	copysign = BUILT_IN_COPYSIGNF;
-	inf = BUILT_IN_INFF;
+	huge_val = BUILT_IN_HUGE_VALF;
 	break;
       case 8:
 	nextafter = BUILT_IN_NEXTAFTER;
 	copysign = BUILT_IN_COPYSIGN;
-	inf = BUILT_IN_INF;
+	huge_val = BUILT_IN_HUGE_VAL;
 	break;
       case 10:
       case 16:
 	nextafter = BUILT_IN_NEXTAFTERL;
 	copysign = BUILT_IN_COPYSIGNL;
-	inf = BUILT_IN_INFL;
+	huge_val = BUILT_IN_HUGE_VALL;
 	break;
       default:
 	gcc_unreachable ();
@@ -3163,7 +3159,7 @@
   type = gfc_typenode_for_spec (&expr->ts);
   gfc_conv_intrinsic_function_args (se, expr, args, 2);
   tmp = build_call_expr (built_in_decls[copysign], 2,
-			 build_call_expr (built_in_decls[inf], 0),
+			 build_call_expr (built_in_decls[huge_val], 0),
 			 fold_convert (type, args[1]));
   se->expr = build_call_expr (built_in_decls[nextafter], 2,
 			      fold_convert (type, args[0]), tmp);
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-stmt.c gcc-4.4.0/gcc/fortran/trans-stmt.c
--- gcc-4.4.0.orig/gcc/fortran/trans-stmt.c	2009-01-27 10:07:54.000000000 -0800
+++ gcc-4.4.0/gcc/fortran/trans-stmt.c	2009-05-10 08:34:55.000000000 -0700
@@ -270,9 +270,11 @@
 	  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));
 	  gfc_add_block_to_block (&se->pre, &parmse.pre);
 
-	  /* If we've got INTENT(INOUT), initialize the array temporary with
-	     a copy of the values.  */
-	  if (fsym->attr.intent == INTENT_INOUT)
+	  /* If we've got INTENT(INOUT) or a derived type with INTENT(OUT),
+	     initialize the array temporary with a copy of the values.  */
+	  if (fsym->attr.intent == INTENT_INOUT
+		|| (fsym->ts.type ==BT_DERIVED
+		      && fsym->attr.intent == INTENT_OUT))
 	    initial = parmse.expr;
 	  else
 	    initial = NULL_TREE;
@@ -332,12 +334,16 @@
 /* Translate the CALL statement.  Builds a call to an F95 subroutine.  */
 
 tree
-gfc_trans_call (gfc_code * code, bool dependency_check)
+gfc_trans_call (gfc_code * code, bool dependency_check,
+		tree mask, tree count1, bool invert)
 {
   gfc_se se;
   gfc_ss * ss;
   int has_alternate_specifier;
   gfc_dep_check check_variable;
+  tree index = NULL_TREE;
+  tree maskexpr = NULL_TREE;
+  tree tmp;
 
   /* A CALL starts a new block because the actual arguments may have to
      be evaluated first.  */
@@ -429,10 +435,31 @@
       gfc_start_scalarized_body (&loop, &body);
       gfc_init_block (&block);
 
+      if (mask && count1)
+	{
+	  /* Form the mask expression according to the mask.  */
+	  index = count1;
+	  maskexpr = gfc_build_array_ref (mask, index, NULL);
+	  if (invert)
+	    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr),
+				    maskexpr);
+	}
+
       /* Add the subroutine call to the block.  */
-      gfc_conv_function_call (&loopse, code->resolved_sym, code->ext.actual,
-			      NULL_TREE);
-      gfc_add_expr_to_block (&loopse.pre, loopse.expr);
+      gfc_conv_function_call (&loopse, code->resolved_sym,
+			      code->ext.actual, NULL_TREE);
+
+      if (mask && count1)
+	{
+	  tmp = build3_v (COND_EXPR, maskexpr, loopse.expr,
+			  build_empty_stmt ());
+	  gfc_add_expr_to_block (&loopse.pre, tmp);
+	  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,
+			     count1, gfc_index_one_node);
+	  gfc_add_modify (&loopse.pre, count1, tmp);
+	}
+      else
+	gfc_add_expr_to_block (&loopse.pre, loopse.expr);
 
       gfc_add_block_to_block (&block, &loopse.pre);
       gfc_add_block_to_block (&block, &loopse.post);
@@ -2981,7 +3008,7 @@
 	/* Explicit subroutine calls are prevented by the frontend but interface
 	   assignments can legitimately produce them.  */
 	case EXEC_ASSIGN_CALL:
-	  assign = gfc_trans_call (c, true);
+	  assign = gfc_trans_call (c, true, NULL_TREE, NULL_TREE, false);
           tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1);
           gfc_add_expr_to_block (&block, tmp);
           break;
@@ -3176,7 +3203,7 @@
 gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,
 			tree mask, bool invert,
                         tree count1, tree count2,
-			gfc_symbol *sym)
+			gfc_code *cnext)
 {
   gfc_se lse;
   gfc_se rse;
@@ -3190,6 +3217,10 @@
   stmtblock_t body;
   tree index, maskexpr;
 
+  /* A defined assignment. */  
+  if (cnext && cnext->resolved_sym)
+    return gfc_trans_call (cnext, true, mask, count1, invert);
+
 #if 0
   /* TODO: handle this special case.
      Special case a single function returning an array.  */
@@ -3291,11 +3322,8 @@
     maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr), maskexpr);
 
   /* Use the scalar assignment as is.  */
-  if (sym == NULL)
-    tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,
-				   loop.temp_ss != NULL, false);
-  else
-    tmp = gfc_conv_operator_assign (&lse, &rse, sym);
+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,
+				 loop.temp_ss != NULL, false);
 
   tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());
 
@@ -3562,7 +3590,7 @@
                       tmp = gfc_trans_where_assign (expr1, expr2,
 						    cmask, invert,
 						    count1, count2,
-						    cnext->resolved_sym);
+						    cnext);
 
                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,
                                                           tmp, 1);
@@ -3580,7 +3608,7 @@
                   tmp = gfc_trans_where_assign (expr1, expr2,
 						cmask, invert,
 						count1, count2,
-						cnext->resolved_sym);
+						cnext);
                   gfc_add_expr_to_block (block, tmp);
 
                 }
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-stmt.h gcc-4.4.0/gcc/fortran/trans-stmt.h
--- gcc-4.4.0.orig/gcc/fortran/trans-stmt.h	2008-04-05 15:23:27.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/trans-stmt.h	2009-05-10 08:34:55.000000000 -0700
@@ -39,7 +39,7 @@
 tree gfc_trans_entry (gfc_code *);
 tree gfc_trans_pause (gfc_code *);
 tree gfc_trans_stop (gfc_code *);
-tree gfc_trans_call (gfc_code *, bool);
+tree gfc_trans_call (gfc_code *, bool, tree, tree, bool);
 tree gfc_trans_return (gfc_code *);
 tree gfc_trans_if (gfc_code *);
 tree gfc_trans_arithmetic_if (gfc_code *);
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-types.c gcc-4.4.0/gcc/fortran/trans-types.c
--- gcc-4.4.0.orig/gcc/fortran/trans-types.c	2009-03-30 07:53:17.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/trans-types.c	2009-06-03 12:39:09.000000000 -0700
@@ -595,7 +595,7 @@
   return make_signed_type (mode_precision);
 }
 
-static tree
+tree
 gfc_build_uint_type (int size)
 {
   if (size == CHAR_TYPE_SIZE)
diff -Naur gcc-4.4.0.orig/gcc/fortran/trans-types.h gcc-4.4.0/gcc/fortran/trans-types.h
--- gcc-4.4.0.orig/gcc/fortran/trans-types.h	2008-05-18 15:45:05.000000000 -0700
+++ gcc-4.4.0/gcc/fortran/trans-types.h	2009-06-03 12:39:09.000000000 -0700
@@ -68,6 +68,7 @@
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (enum machine_mode, int);
+tree gfc_build_uint_type (int);
 
 tree gfc_get_element_type (tree);
 tree gfc_get_array_type_bounds (tree, int, tree *, tree *, int,
diff -Naur gcc-4.4.0.orig/gcc/fwprop.c gcc-4.4.0/gcc/fwprop.c
--- gcc-4.4.0.orig/gcc/fwprop.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/fwprop.c	2009-04-26 11:58:04.000000000 -0700
@@ -1,5 +1,5 @@
 /* RTL-based forward propagation pass for GNU compiler.
-   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
    Contributed by Paolo Bonzini and Steven Bosscher.
 
 This file is part of GCC.
@@ -852,6 +852,80 @@
     return false;
 }
 
+/* Try to replace USE with SRC (defined in DEF_INSN) in __asm.  */
+
+static bool
+forward_propagate_asm (df_ref use, rtx def_insn, rtx def_set, rtx reg)
+{
+  rtx use_insn = DF_REF_INSN (use), src, use_pat, asm_operands, new_rtx, *loc;
+  int speed_p, i;
+  df_ref *use_vec;
+
+  gcc_assert ((DF_REF_FLAGS (use) & DF_REF_IN_NOTE) == 0);
+
+  src = SET_SRC (def_set);
+  use_pat = PATTERN (use_insn);
+
+  /* In __asm don't replace if src might need more registers than
+     reg, as that could increase register pressure on the __asm.  */
+  use_vec = DF_INSN_USES (def_insn);
+  if (use_vec[0] && use_vec[1])
+    return false;
+
+  speed_p = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));
+  asm_operands = NULL_RTX;
+  switch (GET_CODE (use_pat))
+    {
+    case ASM_OPERANDS:
+      asm_operands = use_pat;
+      break;
+    case SET:
+      if (MEM_P (SET_DEST (use_pat)))
+	{
+	  loc = &SET_DEST (use_pat);
+	  new_rtx = propagate_rtx (*loc, GET_MODE (*loc), reg, src, speed_p);
+	  if (new_rtx)
+	    validate_unshare_change (use_insn, loc, new_rtx, true);
+	}
+      asm_operands = SET_SRC (use_pat);
+      break;
+    case PARALLEL:
+      for (i = 0; i < XVECLEN (use_pat, 0); i++)
+	if (GET_CODE (XVECEXP (use_pat, 0, i)) == SET)
+	  {
+	    if (MEM_P (SET_DEST (XVECEXP (use_pat, 0, i))))
+	      {
+		loc = &SET_DEST (XVECEXP (use_pat, 0, i));
+		new_rtx = propagate_rtx (*loc, GET_MODE (*loc), reg,
+					 src, speed_p);
+		if (new_rtx)
+		  validate_unshare_change (use_insn, loc, new_rtx, true);
+	      }
+	    asm_operands = SET_SRC (XVECEXP (use_pat, 0, i));
+	  }
+	else if (GET_CODE (XVECEXP (use_pat, 0, i)) == ASM_OPERANDS)
+	  asm_operands = XVECEXP (use_pat, 0, i);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  gcc_assert (asm_operands && GET_CODE (asm_operands) == ASM_OPERANDS);
+  for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (asm_operands); i++)
+    {
+      loc = &ASM_OPERANDS_INPUT (asm_operands, i);
+      new_rtx = propagate_rtx (*loc, GET_MODE (*loc), reg, src, speed_p);
+      if (new_rtx)
+	validate_unshare_change (use_insn, loc, new_rtx, true);
+    }
+
+  if (num_changes_pending () == 0 || !apply_change_group ())
+    return false;
+
+  num_changes++;
+  return true;
+}
+
 /* Try to replace USE with SRC (defined in DEF_INSN) and simplify the
    result.  */
 
@@ -863,12 +937,16 @@
   rtx src, reg, new_rtx, *loc;
   bool set_reg_equal;
   enum machine_mode mode;
+  int asm_use = -1;
+
+  if (INSN_CODE (use_insn) < 0)
+    asm_use = asm_noperands (PATTERN (use_insn));
 
-  if (!use_set)
+  if (!use_set && asm_use < 0)
     return false;
 
   /* Do not propagate into PC, CC0, etc.  */
-  if (GET_MODE (SET_DEST (use_set)) == VOIDmode)
+  if (use_set && GET_MODE (SET_DEST (use_set)) == VOIDmode)
     return false;
 
   /* If def and use are subreg, check if they match.  */
@@ -900,7 +978,7 @@
   if (MEM_P (src) && MEM_READONLY_P (src))
     {
       rtx x = avoid_constant_pool_reference (src);
-      if (x != src)
+      if (x != src && use_set)
 	{
           rtx note = find_reg_note (use_insn, REG_EQUAL, NULL_RTX);
 	  rtx old_rtx = note ? XEXP (note, 0) : SET_SRC (use_set);
@@ -911,6 +989,9 @@
       return false;
     }
 
+  if (asm_use >= 0)
+    return forward_propagate_asm (use, def_insn, def_set, reg);
+
   /* Else try simplifying.  */
 
   if (DF_REF_TYPE (use) == DF_REF_REG_MEM_STORE)
diff -Naur gcc-4.4.0.orig/gcc/gcse.c gcc-4.4.0/gcc/gcse.c
--- gcc-4.4.0.orig/gcc/gcse.c	2008-08-29 03:35:57.000000000 -0700
+++ gcc-4.4.0/gcc/gcse.c	2009-04-27 04:55:13.000000000 -0700
@@ -1,7 +1,7 @@
 /* Global common subexpression elimination/Partial redundancy elimination
    and global constant/copy propagation for GNU compiler.
    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-   2006, 2007, 2008 Free Software Foundation, Inc.
+   2006, 2007, 2008, 2009 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -2516,7 +2516,7 @@
 		    dest_addr = XEXP (list_entry, 0);
 
 		    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,
-					       x, rtx_addr_varies_p))
+					       x, NULL_RTX, rtx_addr_varies_p))
 		      {
 			if (set_p)
 			  SET_BIT (bmap[bb_index], indx);
diff -Naur gcc-4.4.0.orig/gcc/gimple.h gcc-4.4.0/gcc/gimple.h
--- gcc-4.4.0.orig/gcc/gimple.h	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/gimple.h	2009-05-18 03:13:43.000000000 -0700
@@ -1394,35 +1394,6 @@
   return (gimple_has_ops (g)) ? (bool) g->gsbase.modified : false;
 }
 
-/* Return the type of the main expression computed by STMT.  Return
-   void_type_node if the statement computes nothing.  */
-
-static inline tree
-gimple_expr_type (const_gimple stmt)
-{
-  enum gimple_code code = gimple_code (stmt);
-
-  if (code == GIMPLE_ASSIGN || code == GIMPLE_CALL)
-    {
-      tree type = TREE_TYPE (gimple_get_lhs (stmt));
-      /* Integral sub-types are never the type of the expression,
-         but they still can be the type of the result as the base
-	 type (in which expressions are computed) is trivially
-	 convertible to one of its sub-types.  So always return
-	 the base type here.  */
-      if (INTEGRAL_TYPE_P (type)
-	  && TREE_TYPE (type)
-	  /* But only if they are trivially convertible.  */
-	  && useless_type_conversion_p (type, TREE_TYPE (type)))
-	type = TREE_TYPE (type);
-      return type;
-    }
-  else if (code == GIMPLE_COND)
-    return boolean_type_node;
-  else
-    return void_type_node;
-}
-
 
 /* Return the tree code for the expression computed by STMT.  This is
    only valid for GIMPLE_COND, GIMPLE_CALL and GIMPLE_ASSIGN.  For
@@ -4285,6 +4256,55 @@
 }
 
 
+/* Return the type of the main expression computed by STMT.  Return
+   void_type_node if the statement computes nothing.  */
+
+static inline tree
+gimple_expr_type (const_gimple stmt)
+{
+  enum gimple_code code = gimple_code (stmt);
+
+  if (code == GIMPLE_ASSIGN || code == GIMPLE_CALL)
+    {
+      tree type;
+      /* In general we want to pass out a type that can be substituted
+         for both the RHS and the LHS types if there is a possibly
+	 useless conversion involved.  That means returning the
+	 original RHS type as far as we can reconstruct it.  */
+      if (code == GIMPLE_CALL)
+	type = gimple_call_return_type (stmt);
+      else
+	switch (gimple_assign_rhs_code (stmt))
+	  {
+	  case POINTER_PLUS_EXPR:
+	    type = TREE_TYPE (gimple_assign_rhs1 (stmt));
+	    break;
+
+	  default:
+	    /* As fallback use the type of the LHS.  */
+	    type = TREE_TYPE (gimple_get_lhs (stmt));
+	    break;
+	  }
+
+      /* Integral sub-types are never the type of the expression,
+         but they still can be the type of the result as the base
+	 type (in which expressions are computed) is trivially
+	 convertible to one of its sub-types.  So always return
+	 the base type here.  */
+      if (INTEGRAL_TYPE_P (type)
+	  && TREE_TYPE (type)
+	  /* But only if they are trivially convertible.  */
+	  && useless_type_conversion_p (type, TREE_TYPE (type)))
+	type = TREE_TYPE (type);
+      return type;
+    }
+  else if (code == GIMPLE_COND)
+    return boolean_type_node;
+  else
+    return void_type_node;
+}
+
+
 /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */
 
 static inline gimple_stmt_iterator
diff -Naur gcc-4.4.0.orig/gcc/gimplify.c gcc-4.4.0/gcc/gimplify.c
--- gcc-4.4.0.orig/gcc/gimplify.c	2009-03-11 18:02:16.000000000 -0700
+++ gcc-4.4.0/gcc/gimplify.c	2009-05-12 09:19:29.000000000 -0700
@@ -1628,20 +1628,63 @@
 	}
       len = i;
 
+      if (!VEC_empty (tree, labels))
+	sort_case_labels (labels);
+
       if (!default_case)
 	{
-	  gimple new_default;
+	  tree type = TREE_TYPE (switch_expr);
 
 	  /* If the switch has no default label, add one, so that we jump
-	     around the switch body.  */
-	  default_case = build3 (CASE_LABEL_EXPR, void_type_node, NULL_TREE,
-	                         NULL_TREE, create_artificial_label ());
-	  new_default = gimple_build_label (CASE_LABEL (default_case));
-	  gimplify_seq_add_stmt (&switch_body_seq, new_default);
-	}
+	     around the switch body.  If the labels already cover the whole
+	     range of type, add the default label pointing to one of the
+	     existing labels.  */
+	  if (type == void_type_node)
+	    type = TREE_TYPE (SWITCH_COND (switch_expr));
+	  if (len
+	      && INTEGRAL_TYPE_P (type)
+	      && TYPE_MIN_VALUE (type)
+	      && TYPE_MAX_VALUE (type)
+	      && tree_int_cst_equal (CASE_LOW (VEC_index (tree, labels, 0)),
+				     TYPE_MIN_VALUE (type)))
+	    {
+	      tree low, high = CASE_HIGH (VEC_index (tree, labels, len - 1));
+	      if (!high)
+		high = CASE_LOW (VEC_index (tree, labels, len - 1));
+	      if (tree_int_cst_equal (high, TYPE_MAX_VALUE (type)))
+		{
+		  for (i = 1; i < len; i++)
+		    {
+		      high = CASE_LOW (VEC_index (tree, labels, i));
+		      low = CASE_HIGH (VEC_index (tree, labels, i - 1));
+		      if (!low)
+			low = CASE_LOW (VEC_index (tree, labels, i - 1));
+		      if ((TREE_INT_CST_LOW (low) + 1
+			   != TREE_INT_CST_LOW (high))
+			  || (TREE_INT_CST_HIGH (low)
+			      + (TREE_INT_CST_LOW (high) == 0)
+			      != TREE_INT_CST_HIGH (high)))
+			break;
+		    }
+		  if (i == len)
+		    default_case = build3 (CASE_LABEL_EXPR, void_type_node,
+					   NULL_TREE, NULL_TREE,
+					   CASE_LABEL (VEC_index (tree,
+								  labels, 0)));
+		}
+	    }
 
-      if (!VEC_empty (tree, labels))
-	sort_case_labels (labels);
+	  if (!default_case)
+	    {
+	      gimple new_default;
+
+	      default_case = build3 (CASE_LABEL_EXPR, void_type_node,
+				     NULL_TREE, NULL_TREE,
+				     create_artificial_label ());
+	      new_default = gimple_build_label (CASE_LABEL (default_case));
+	      gimplify_seq_add_stmt (&switch_body_seq, new_default);
+	    }
+	}
 
       gimple_switch = gimple_build_switch_vec (SWITCH_COND (switch_expr), 
                                                default_case, labels);
diff -Naur gcc-4.4.0.orig/gcc/ipa-utils.h gcc-4.4.0/gcc/ipa-utils.h
--- gcc-4.4.0.orig/gcc/ipa-utils.h	2007-07-26 01:37:01.000000000 -0700
+++ gcc-4.4.0/gcc/ipa-utils.h	2009-05-14 08:52:58.000000000 -0700
@@ -23,9 +23,6 @@
 #include "tree.h"
 #include "cgraph.h"
 
-/* Used for parsing attributes of asm code.  */
-extern tree memory_identifier_string;
-
 struct ipa_dfs_info {
   int dfn_number;
   int low_link;
diff -Naur gcc-4.4.0.orig/gcc/ira-color.c gcc-4.4.0/gcc/ira-color.c
--- gcc-4.4.0.orig/gcc/ira-color.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/ira-color.c	2009-04-22 13:16:13.000000000 -0700
@@ -285,8 +285,8 @@
 	    continue;
 
 	  cost = (cp->second == allocno
-		  ? ira_register_move_cost[mode][rclass][cover_class]
-		  : ira_register_move_cost[mode][cover_class][rclass]);
+		  ? ira_get_register_move_cost (mode, rclass, cover_class)
+		  : ira_get_register_move_cost (mode, cover_class, rclass));
 	  if (decr_p)
 	    cost = -cost;
 
@@ -1069,7 +1069,7 @@
 	      * ira_loop_edge_freq (loop_node, regno, true)
 	      + ira_memory_move_cost[mode][rclass][0]
 	      * ira_loop_edge_freq (loop_node, regno, false))
-	     - (ira_register_move_cost[mode][rclass][rclass]
+	     - (ira_get_register_move_cost (mode, rclass, rclass)
 		* (ira_loop_edge_freq (loop_node, regno, false)
 		   + ira_loop_edge_freq (loop_node, regno, true))));
   return cost;
@@ -2037,7 +2037,7 @@
 	  else
 	    {
 	      cover_class = ALLOCNO_COVER_CLASS (subloop_allocno);
-	      cost = (ira_register_move_cost[mode][rclass][rclass] 
+	      cost = (ira_get_register_move_cost (mode, rclass, rclass)
 		      * (exit_freq + enter_freq));
 	      ira_allocate_and_set_or_copy_costs
 		(&ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno), cover_class,
@@ -2162,7 +2162,7 @@
 		    += (ira_memory_move_cost[mode][rclass][0] * exit_freq
 			+ ira_memory_move_cost[mode][rclass][1] * enter_freq);
 		  if (hard_regno2 != hard_regno)
-		    cost -= (ira_register_move_cost[mode][rclass][rclass]
+		    cost -= (ira_get_register_move_cost (mode, rclass, rclass)
 			     * (exit_freq + enter_freq));
 		}
 	    }
@@ -2181,7 +2181,7 @@
 		    += (ira_memory_move_cost[mode][rclass][1] * exit_freq
 			+ ira_memory_move_cost[mode][rclass][0] * enter_freq);
 		  if (hard_regno2 != hard_regno)
-		    cost -= (ira_register_move_cost[mode][rclass][rclass]
+		    cost -= (ira_get_register_move_cost (mode, rclass, rclass)
 			     * (exit_freq + enter_freq));
 		}
 	    }
@@ -2247,8 +2247,8 @@
       if (i < 0)
 	continue;
       cost = (cp->first == a
-	      ? ira_register_move_cost[mode][rclass][cover_class]
-	      : ira_register_move_cost[mode][cover_class][rclass]);
+	      ? ira_get_register_move_cost (mode, rclass, cover_class)
+	      : ira_get_register_move_cost (mode, cover_class, rclass));
       ira_allocate_and_set_or_copy_costs
 	(&ALLOCNO_UPDATED_HARD_REG_COSTS (a),
 	 cover_class, ALLOCNO_COVER_CLASS_COST (a),
diff -Naur gcc-4.4.0.orig/gcc/ira-conflicts.c gcc-4.4.0/gcc/ira-conflicts.c
--- gcc-4.4.0.orig/gcc/ira-conflicts.c	2009-03-12 07:39:55.000000000 -0700
+++ gcc-4.4.0/gcc/ira-conflicts.c	2009-05-03 12:40:35.000000000 -0700
@@ -411,9 +411,9 @@
     /* Can not be tied.  It is not in the cover class.  */
     return false;
   if (HARD_REGISTER_P (reg1))
-    cost = ira_register_move_cost[mode][cover_class][rclass] * freq;
+    cost = ira_get_register_move_cost (mode, cover_class, rclass) * freq;
   else
-    cost = ira_register_move_cost[mode][rclass][cover_class] * freq;
+    cost = ira_get_register_move_cost (mode, rclass, cover_class) * freq;
   for (;;)
     {
       ira_allocate_and_set_costs
@@ -806,7 +806,7 @@
       if ((! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)
 	  /* For debugging purposes don't put user defined variables in
 	     callee-clobbered registers.  */
-	  || (optimize <= 1
+	  || (optimize == 0
 	      && (attrs = REG_ATTRS (regno_reg_rtx [ALLOCNO_REGNO (a)])) != NULL
 	      && (decl = attrs->decl) != NULL
 	      && VAR_OR_FUNCTION_DECL_P (decl)
diff -Naur gcc-4.4.0.orig/gcc/ira-costs.c gcc-4.4.0/gcc/ira-costs.c
--- gcc-4.4.0.orig/gcc/ira-costs.c	2008-12-18 05:49:47.000000000 -0800
+++ gcc-4.4.0/gcc/ira-costs.c	2009-04-22 13:16:13.000000000 -0700
@@ -138,9 +138,6 @@
   sri.extra_cost = 0;
   secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);
 
-  if (ira_register_move_cost[mode] == NULL)
-    ira_init_register_move_cost (mode);
-
   if (secondary_class != NO_REGS)
     {
       if (!move_cost[mode])
@@ -294,19 +291,17 @@
 		     needs to do a copy, which is one insn.  */
 		  struct costs *pp = this_op_costs[i];
 
-		  if (ira_register_move_cost[mode] == NULL)
-		    ira_init_register_move_cost (mode);
-
 		  for (k = 0; k < cost_classes_num; k++)
 		    {
 		      rclass = cost_classes[k];
 		      pp->cost[k]
-			= ((recog_data.operand_type[i] != OP_OUT
-			    ? ira_may_move_in_cost[mode][rclass]
-			      [classes[i]] * frequency : 0)
-			   + (recog_data.operand_type[i] != OP_IN
-			      ? ira_may_move_out_cost[mode][classes[i]]
-			        [rclass] * frequency : 0));
+			= (((recog_data.operand_type[i] != OP_OUT
+			     ? ira_get_may_move_cost (mode, rclass,
+						      classes[i], true) : 0)
+			    + (recog_data.operand_type[i] != OP_IN
+			       ? ira_get_may_move_cost (mode, classes[i],
+							rclass, false) : 0))
+			   * frequency);
 		    }
 
 		  /* If the alternative actually allows memory, make
@@ -342,8 +337,9 @@
 				 : 0));
 		      else if (ira_reg_class_intersect
 			       [pref_class][classes[i]] == NO_REGS)
-			alt_cost += (ira_register_move_cost
-				     [mode][pref_class][classes[i]]);
+			alt_cost += ira_get_register_move_cost (mode,
+								pref_class,
+								classes[i]);
 		    }
 		  if (REGNO (ops[i]) != REGNO (ops[j])
 		      && ! find_reg_note (insn, REG_DEAD, op))
@@ -540,19 +536,17 @@
 		{
 		  struct costs *pp = this_op_costs[i];
 
-		  if (ira_register_move_cost[mode] == NULL)
-		    ira_init_register_move_cost (mode);
-
 		  for (k = 0; k < cost_classes_num; k++)
 		    {
 		      rclass = cost_classes[k];
 		      pp->cost[k]
-			= ((recog_data.operand_type[i] != OP_OUT
-			    ? ira_may_move_in_cost[mode][rclass]
-			      [classes[i]] * frequency : 0)
-			   + (recog_data.operand_type[i] != OP_IN
-			      ? ira_may_move_out_cost[mode][classes[i]]
-			        [rclass] * frequency : 0));
+			= (((recog_data.operand_type[i] != OP_OUT
+			     ? ira_get_may_move_cost (mode, rclass,
+						      classes[i], true) : 0)
+			    + (recog_data.operand_type[i] != OP_IN
+			       ? ira_get_may_move_cost (mode, classes[i],
+							rclass, false) : 0))
+			   * frequency);
 		    }
 
 		  /* If the alternative actually allows memory, make
@@ -587,8 +581,9 @@
 				 : 0));
 		      else if (ira_reg_class_intersect[pref_class][classes[i]]
 			       == NO_REGS)
-			alt_cost += (ira_register_move_cost
-				     [mode][pref_class][classes[i]]);
+			alt_cost += ira_get_register_move_cost (mode,
+								pref_class,
+								classes[i]);
 		    }
 		}
 	    }
@@ -901,13 +896,11 @@
 			       ALLOCNO_NUM (ira_curr_regno_allocno_map
 					    [REGNO (x)]));
 	pp->mem_cost += (ira_memory_move_cost[Pmode][rclass][1] * scale) / 2;
-	if (ira_register_move_cost[Pmode] == NULL)
-	  ira_init_register_move_cost (Pmode);
 	for (k = 0; k < cost_classes_num; k++)
 	  {
 	    i = cost_classes[k];
 	    pp->cost[k]
-	      += (ira_may_move_in_cost[Pmode][i][rclass] * scale) / 2;
+	      += (ira_get_may_move_cost (Pmode, i, rclass, true) * scale) / 2;
 	  }
       }
       break;
@@ -1425,8 +1418,9 @@
 	continue;
       mode = ALLOCNO_MODE (a);
       hard_reg_class = REGNO_REG_CLASS (hard_regno);
-      cost = (to_p ? ira_register_move_cost[mode][hard_reg_class][rclass]
-	      : ira_register_move_cost[mode][rclass][hard_reg_class]) * freq;
+      cost
+	= (to_p ? ira_get_register_move_cost (mode, hard_reg_class, rclass)
+	   : ira_get_register_move_cost (mode, rclass, hard_reg_class)) * freq;
       ira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (a), rclass,
 				  ALLOCNO_COVER_CLASS_COST (a));
       ira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),
@@ -1579,9 +1573,6 @@
 void
 ira_costs (void)
 {
-  ira_allocno_t a;
-  ira_allocno_iterator ai;
-
   allocno_costs = (struct costs *) ira_allocate (max_struct_costs_size
 					       * ira_allocnos_num);
   total_costs = (struct costs *) ira_allocate (max_struct_costs_size
@@ -1594,12 +1585,6 @@
 				       * max_reg_num ());
   find_allocno_class_costs ();
   setup_allocno_cover_class_and_costs ();
-  /* Because we could process operands only as subregs, check mode of
-     the registers themselves too.  */
-  FOR_EACH_ALLOCNO (a, ai)
-    if (ira_register_move_cost[ALLOCNO_MODE (a)] == NULL
-	&& have_regs_of_mode[ALLOCNO_MODE (a)])
-      ira_init_register_move_cost (ALLOCNO_MODE (a));
   ira_free (common_classes);
   ira_free (allocno_pref_buffer);
   ira_free (total_costs);
diff -Naur gcc-4.4.0.orig/gcc/ira-emit.c gcc-4.4.0/gcc/ira-emit.c
--- gcc-4.4.0.orig/gcc/ira-emit.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/ira-emit.c	2009-04-22 13:16:13.000000000 -0700
@@ -812,7 +812,8 @@
 	}
       else
 	{
-	  cost = ira_register_move_cost[mode][cover_class][cover_class] * freq;
+	  cost = (ira_get_register_move_cost (mode, cover_class, cover_class)
+		  * freq);
 	  ira_shuffle_cost += cost;
 	}
       ira_overall_cost += cost;
diff -Naur gcc-4.4.0.orig/gcc/ira-int.h gcc-4.4.0/gcc/ira-int.h
--- gcc-4.4.0.orig/gcc/ira-int.h	2009-03-18 10:04:26.000000000 -0700
+++ gcc-4.4.0/gcc/ira-int.h	2009-04-22 13:16:13.000000000 -0700
@@ -730,21 +730,24 @@
 extern HARD_REG_SET ira_reg_mode_hard_regset
                     [FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];
 
-/* Arrays analogous to macros MEMORY_MOVE_COST and
-   REGISTER_MOVE_COST.  */
+/* Arrays analogous to macros MEMORY_MOVE_COST and REGISTER_MOVE_COST.
+   Don't use ira_register_move_cost directly.  Use function of
+   ira_get_may_move_cost instead.  */
 extern short ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];
 extern move_table *ira_register_move_cost[MAX_MACHINE_MODE];
 
 /* Similar to may_move_in_cost but it is calculated in IRA instead of
    regclass.  Another difference we take only available hard registers
    into account to figure out that one register class is a subset of
-   the another one.  */
+   the another one.  Don't use it directly.  Use function of
+   ira_get_may_move_cost instead.  */
 extern move_table *ira_may_move_in_cost[MAX_MACHINE_MODE];
 
 /* Similar to may_move_out_cost but it is calculated in IRA instead of
    regclass.  Another difference we take only available hard registers
    into account to figure out that one register class is a subset of
-   the another one.  */
+   the another one.  Don't use it directly.  Use function of
+   ira_get_may_move_cost instead.  */
 extern move_table *ira_may_move_out_cost[MAX_MACHINE_MODE];
 
 /* Register class subset relation: TRUE if the first class is a subset
@@ -941,6 +944,34 @@
 
 
 
+/* Return cost of moving value of MODE from register of class FROM to
+   register of class TO.  */
+static inline int
+ira_get_register_move_cost (enum machine_mode mode,
+			    enum reg_class from, enum reg_class to)
+{
+  if (ira_register_move_cost[mode] == NULL)
+    ira_init_register_move_cost (mode);
+  return ira_register_move_cost[mode][from][to];
+}
+
+/* Return cost of moving value of MODE from register of class FROM to
+   register of class TO.  Return zero if IN_P is true and FROM is
+   subset of TO or if IN_P is false and FROM is superset of TO.  */
+static inline int
+ira_get_may_move_cost (enum machine_mode mode,
+		       enum reg_class from, enum reg_class to,
+		       bool in_p)
+{
+  if (ira_register_move_cost[mode] == NULL)
+    ira_init_register_move_cost (mode);
+  return (in_p
+	  ? ira_may_move_in_cost[mode][from][to]
+	  : ira_may_move_out_cost[mode][from][to]);
+}
+
+
+
 /* The iterator for all allocnos.  */
 typedef struct {
   /* The number of the current element in IRA_ALLOCNOS.  */
diff -Naur gcc-4.4.0.orig/gcc/ira-lives.c gcc-4.4.0/gcc/ira-lives.c
--- gcc-4.4.0.orig/gcc/ira-lives.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/ira-lives.c	2009-04-22 13:16:13.000000000 -0700
@@ -782,10 +782,11 @@
 		  [ira_class_hard_regs[cl][0]]) >= 0
 	      && reg_class_size[cl] <= (unsigned) CLASS_MAX_NREGS (cl, mode))
 	    {
-	      /* ??? FREQ */
-	      cost = freq * (in_p
-			     ? ira_register_move_cost[mode][cover_class][cl]
-			     : ira_register_move_cost[mode][cl][cover_class]);
+	      cost
+		= (freq
+		   * (in_p
+		      ? ira_get_register_move_cost (mode, cover_class, cl)
+		      : ira_get_register_move_cost (mode, cl, cover_class)));
 	      ira_allocate_and_set_costs
 		(&ALLOCNO_CONFLICT_HARD_REG_COSTS (operand_a), cover_class, 0);
 	      ALLOCNO_CONFLICT_HARD_REG_COSTS (operand_a)
diff -Naur gcc-4.4.0.orig/gcc/Makefile.in gcc-4.4.0/gcc/Makefile.in
--- gcc-4.4.0.orig/gcc/Makefile.in	2009-03-25 05:00:32.000000000 -0700
+++ gcc-4.4.0/gcc/Makefile.in	2009-05-21 16:17:37.000000000 -0700
@@ -2785,7 +2785,8 @@
    value-prof.h $(TREE_INLINE_H) $(TARGET_H)
 cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
-   output.h $(TOPLEV_H) $(FUNCTION_H) except.h $(TM_P_H) insn-config.h $(EXPR_H) \
+   output.h $(TOPLEV_H) $(FUNCTION_H) except.h $(TM_P_H) $(INSN_ATTR_H) \
+   insn-config.h $(EXPR_H) \
    $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \
    tree-pass.h $(DF_H) $(GGC_H)
 cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
diff -Naur gcc-4.4.0.orig/gcc/po/exgettext gcc-4.4.0/gcc/po/exgettext
--- gcc-4.4.0.orig/gcc/po/exgettext	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/gcc/po/exgettext	2009-04-22 09:30:26.000000000 -0700
@@ -83,7 +83,7 @@
 echo "scanning for keywords and %e strings..." >&2
 
 ( cd $srcdir
-  lang_subdirs=`echo */config-lang.in | sed -e 's|config-lang\.in||g'`
+  lang_subdirs=`echo */config-lang.in */*/config-lang.in | sed -e 's|config-lang\.in||g'`
   { for dir in "" config/ config/*/ $lang_subdirs
     do  for glob in '*.c' '*.h' '*.def'
         do  eval echo $dir$glob
diff -Naur gcc-4.4.0.orig/gcc/po/gcc.pot gcc-4.4.0/gcc/po/gcc.pot
--- gcc-4.4.0.orig/gcc/po/gcc.pot	2009-03-28 00:27:17.000000000 -0700
+++ gcc-4.4.0/gcc/po/gcc.pot	2009-04-22 09:34:22.000000000 -0700
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
-"POT-Creation-Date: 2009-03-28 07:24+0000\n"
+"POT-Creation-Date: 2009-04-22 16:32+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -286,49 +286,49 @@
 msgid "<command-line>"
 msgstr ""
 
-#: c-typeck.c:2491 c-typeck.c:4961 c-typeck.c:4964 c-typeck.c:4972
-#: c-typeck.c:5002 c-typeck.c:6388
+#: c-typeck.c:2491 c-typeck.c:4965 c-typeck.c:4968 c-typeck.c:4976
+#: c-typeck.c:5006 c-typeck.c:6392
 msgid "initializer element is not constant"
 msgstr ""
 
-#: c-typeck.c:4751
+#: c-typeck.c:4755
 msgid "array initialized from parenthesized string constant"
 msgstr ""
 
-#: c-typeck.c:4813 cp/typeck2.c:757
+#: c-typeck.c:4817 cp/typeck2.c:757
 #, gcc-internal-format
 msgid "char-array initialized from wide string"
 msgstr ""
 
-#: c-typeck.c:4821
+#: c-typeck.c:4825
 msgid "wide character array initialized from non-wide string"
 msgstr ""
 
-#: c-typeck.c:4827
+#: c-typeck.c:4831
 msgid "wide character array initialized from incompatible wide string"
 msgstr ""
 
-#: c-typeck.c:4845 cp/typeck2.c:785
+#: c-typeck.c:4849 cp/typeck2.c:785
 #, gcc-internal-format
 msgid "initializer-string for array of chars is too long"
 msgstr ""
 
-#: c-typeck.c:4851
+#: c-typeck.c:4855
 msgid "array of inappropriate type initialized from string constant"
 msgstr ""
 
 #. ??? This should not be an error when inlining calls to
 #. unprototyped functions.
-#: c-typeck.c:4918 c-typeck.c:4421 cp/typeck.c:1645
+#: c-typeck.c:4922 c-typeck.c:4425 cp/typeck.c:1645
 #, gcc-internal-format
 msgid "invalid use of non-lvalue array"
 msgstr ""
 
-#: c-typeck.c:4944
+#: c-typeck.c:4948
 msgid "array initialized from non-constant array expression"
 msgstr ""
 
-#: c-typeck.c:5009 c-typeck.c:6393
+#: c-typeck.c:5013 c-typeck.c:6397
 #, gcc-internal-format
 msgid "initializer element is not computable at load time"
 msgstr ""
@@ -337,108 +337,108 @@
 #. of VLAs themselves count as VLAs, it does not make
 #. sense to permit them to be initialized given that
 #. ordinary VLAs may not be initialized.
-#: c-typeck.c:5020 c-decl.c:3224 c-decl.c:3239
+#: c-typeck.c:5024 c-decl.c:3224 c-decl.c:3239
 #, gcc-internal-format
 msgid "variable-sized object may not be initialized"
 msgstr ""
 
-#: c-typeck.c:5024
+#: c-typeck.c:5028
 msgid "invalid initializer"
 msgstr ""
 
-#: c-typeck.c:5498
+#: c-typeck.c:5502
 msgid "extra brace group at end of initializer"
 msgstr ""
 
-#: c-typeck.c:5518
+#: c-typeck.c:5522
 msgid "missing braces around initializer"
 msgstr ""
 
-#: c-typeck.c:5579
+#: c-typeck.c:5583
 msgid "braces around scalar initializer"
 msgstr ""
 
-#: c-typeck.c:5636
+#: c-typeck.c:5640
 msgid "initialization of flexible array member in a nested context"
 msgstr ""
 
-#: c-typeck.c:5639
+#: c-typeck.c:5643
 msgid "initialization of a flexible array member"
 msgstr ""
 
-#: c-typeck.c:5667
+#: c-typeck.c:5671
 msgid "missing initializer"
 msgstr ""
 
-#: c-typeck.c:5689
+#: c-typeck.c:5693
 msgid "empty scalar initializer"
 msgstr ""
 
-#: c-typeck.c:5694
+#: c-typeck.c:5698
 msgid "extra elements in scalar initializer"
 msgstr ""
 
-#: c-typeck.c:5791 c-typeck.c:5851
+#: c-typeck.c:5795 c-typeck.c:5855
 msgid "array index in non-array initializer"
 msgstr ""
 
-#: c-typeck.c:5796 c-typeck.c:5904
+#: c-typeck.c:5800 c-typeck.c:5908
 msgid "field name not in record or union initializer"
 msgstr ""
 
-#: c-typeck.c:5842
+#: c-typeck.c:5846
 msgid "array index in initializer not of integer type"
 msgstr ""
 
-#: c-typeck.c:5847 c-typeck.c:5849
+#: c-typeck.c:5851 c-typeck.c:5853
 msgid "nonconstant array index in initializer"
 msgstr ""
 
-#: c-typeck.c:5853 c-typeck.c:5856
+#: c-typeck.c:5857 c-typeck.c:5860
 msgid "array index in initializer exceeds array bounds"
 msgstr ""
 
-#: c-typeck.c:5867
+#: c-typeck.c:5871
 msgid "empty index range in initializer"
 msgstr ""
 
-#: c-typeck.c:5876
+#: c-typeck.c:5880
 msgid "array index range in initializer exceeds array bounds"
 msgstr ""
 
-#: c-typeck.c:5958 c-typeck.c:5984 c-typeck.c:6460
+#: c-typeck.c:5962 c-typeck.c:5988 c-typeck.c:6464
 msgid "initialized field with side-effects overwritten"
 msgstr ""
 
-#: c-typeck.c:5960 c-typeck.c:5986 c-typeck.c:6462
+#: c-typeck.c:5964 c-typeck.c:5990 c-typeck.c:6466
 msgid "initialized field overwritten"
 msgstr ""
 
-#: c-typeck.c:6676
+#: c-typeck.c:6680
 msgid "excess elements in char array initializer"
 msgstr ""
 
-#: c-typeck.c:6683 c-typeck.c:6730
+#: c-typeck.c:6687 c-typeck.c:6734
 msgid "excess elements in struct initializer"
 msgstr ""
 
-#: c-typeck.c:6745
+#: c-typeck.c:6749
 msgid "non-static initialization of a flexible array member"
 msgstr ""
 
-#: c-typeck.c:6814
+#: c-typeck.c:6818
 msgid "excess elements in union initializer"
 msgstr ""
 
-#: c-typeck.c:6902
+#: c-typeck.c:6906
 msgid "excess elements in array initializer"
 msgstr ""
 
-#: c-typeck.c:6933
+#: c-typeck.c:6937
 msgid "excess elements in vector initializer"
 msgstr ""
 
-#: c-typeck.c:6958
+#: c-typeck.c:6962
 msgid "excess elements in scalar initializer"
 msgstr ""
 
@@ -708,13 +708,13 @@
 #. handle them.
 #. We can't handle floating point constants;
 #. PRINT_OPERAND must handle them.
-#: final.c:3493 vmsdbgout.c:487 config/i386/i386.c:10138
+#: final.c:3493 vmsdbgout.c:487 config/i386/i386.c:10175
 #: config/pdp11/pdp11.c:1710
 #, c-format
 msgid "floating constant misused"
 msgstr ""
 
-#: final.c:3555 vmsdbgout.c:544 config/i386/i386.c:10225
+#: final.c:3555 vmsdbgout.c:544 config/i386/i386.c:10262
 #: config/pdp11/pdp11.c:1757
 #, c-format
 msgid "invalid expression as operand"
@@ -1811,82 +1811,82 @@
 msgid "This switch lacks documentation"
 msgstr ""
 
-#: opts.c:1306
+#: opts.c:1268
 msgid "[enabled]"
 msgstr ""
 
-#: opts.c:1306
+#: opts.c:1268
 msgid "[disabled]"
 msgstr ""
 
-#: opts.c:1321
+#: opts.c:1283
 #, c-format
 msgid " No options with the desired characteristics were found\n"
 msgstr ""
 
-#: opts.c:1330
+#: opts.c:1292
 #, c-format
 msgid ""
 " None found.  Use --help=%s to show *all* the options supported by the %s "
 "front-end\n"
 msgstr ""
 
-#: opts.c:1336
+#: opts.c:1298
 #, c-format
 msgid ""
 " All options with the desired characteristics have already been displayed\n"
 msgstr ""
 
-#: opts.c:1390
+#: opts.c:1352
 msgid "The following options are target specific"
 msgstr ""
 
-#: opts.c:1393
+#: opts.c:1355
 msgid "The following options control compiler warning messages"
 msgstr ""
 
-#: opts.c:1396
+#: opts.c:1358
 msgid "The following options control optimizations"
 msgstr ""
 
-#: opts.c:1399 opts.c:1438
+#: opts.c:1361 opts.c:1400
 msgid "The following options are language-independent"
 msgstr ""
 
-#: opts.c:1402
+#: opts.c:1364
 msgid "The --param option recognizes the following as parameters"
 msgstr ""
 
-#: opts.c:1408
+#: opts.c:1370
 msgid "The following options are specific to just the language "
 msgstr ""
 
-#: opts.c:1410
+#: opts.c:1372
 msgid "The following options are supported by the language "
 msgstr ""
 
-#: opts.c:1421
+#: opts.c:1383
 msgid "The following options are not documented"
 msgstr ""
 
-#: opts.c:1423
+#: opts.c:1385
 msgid "The following options take separate arguments"
 msgstr ""
 
-#: opts.c:1425
+#: opts.c:1387
 msgid "The following options take joined arguments"
 msgstr ""
 
-#: opts.c:1436
+#: opts.c:1398
 msgid "The following options are language-related"
 msgstr ""
 
-#: opts.c:1596
+#: opts.c:1558
 #, c-format
 msgid "warning: --help argument %.*s is ambiguous, please be more specific\n"
 msgstr ""
 
-#: opts.c:1604
+#: opts.c:1566
 #, c-format
 msgid "warning: unrecognized argument to --help= option: %.*s\n"
 msgstr ""
@@ -3078,47 +3078,47 @@
 msgid "missing operand"
 msgstr ""
 
-#: config/avr/avr.c:1196
+#: config/avr/avr.c:1209
 #, c-format
 msgid "address operand requires constraint for X, Y, or Z register"
 msgstr ""
 
-#: config/avr/avr.c:1308
+#: config/avr/avr.c:1321
 msgid "bad address, not (reg+disp):"
 msgstr ""
 
-#: config/avr/avr.c:1315
+#: config/avr/avr.c:1328
 msgid "bad address, not post_inc or pre_dec:"
 msgstr ""
 
-#: config/avr/avr.c:1326
+#: config/avr/avr.c:1339
 msgid "internal compiler error.  Bad address:"
 msgstr ""
 
-#: config/avr/avr.c:1339
+#: config/avr/avr.c:1352
 msgid "internal compiler error.  Unknown mode:"
 msgstr ""
 
-#: config/avr/avr.c:1934 config/avr/avr.c:2622
+#: config/avr/avr.c:1947 config/avr/avr.c:2635
 msgid "invalid insn:"
 msgstr ""
 
-#: config/avr/avr.c:1973 config/avr/avr.c:2059 config/avr/avr.c:2108
-#: config/avr/avr.c:2136 config/avr/avr.c:2231 config/avr/avr.c:2400
-#: config/avr/avr.c:2661 config/avr/avr.c:2773
+#: config/avr/avr.c:1986 config/avr/avr.c:2072 config/avr/avr.c:2121
+#: config/avr/avr.c:2149 config/avr/avr.c:2244 config/avr/avr.c:2413
+#: config/avr/avr.c:2674 config/avr/avr.c:2786
 msgid "incorrect insn:"
 msgstr ""
 
-#: config/avr/avr.c:2155 config/avr/avr.c:2316 config/avr/avr.c:2471
-#: config/avr/avr.c:2839
+#: config/avr/avr.c:2168 config/avr/avr.c:2329 config/avr/avr.c:2484
+#: config/avr/avr.c:2852
 msgid "unknown move insn:"
 msgstr ""
 
-#: config/avr/avr.c:3069
+#: config/avr/avr.c:3082
 msgid "bad shift insn:"
 msgstr ""
 
-#: config/avr/avr.c:3185 config/avr/avr.c:3605 config/avr/avr.c:3963
+#: config/avr/avr.c:3198 config/avr/avr.c:3618 config/avr/avr.c:3976
 msgid "internal compiler error.  Incorrect shift:"
 msgstr ""
 
@@ -3132,7 +3132,7 @@
 msgid "invalid const_double operand"
 msgstr ""
 
-#: config/cris/cris.c:504 c-typeck.c:4700 c-typeck.c:4716 c-typeck.c:4733
+#: config/cris/cris.c:504 c-typeck.c:4704 c-typeck.c:4720 c-typeck.c:4737
 #: final.c:3000 final.c:3002 gcc.c:4828 loop-iv.c:2825 loop-iv.c:2834
 #: rtl-error.c:105 toplev.c:601 tree-ssa-loop-niter.c:1882 cp/typeck.c:4720
 #: java/expr.c:411
@@ -3369,51 +3369,51 @@
 msgid " (frv)"
 msgstr ""
 
-#: config/i386/i386.c:10219
+#: config/i386/i386.c:10256
 #, c-format
 msgid "invalid UNSPEC as operand"
 msgstr ""
 
-#: config/i386/i386.c:10944 config/i386/i386.c:10983 config/i386/i386.c:11157
+#: config/i386/i386.c:10981 config/i386/i386.c:11020 config/i386/i386.c:11194
 #, c-format
 msgid "operand is not a condition code, invalid operand code 'D'"
 msgstr ""
 
-#: config/i386/i386.c:11008
+#: config/i386/i386.c:11045
 #, c-format
 msgid ""
 "operand is neither a constant nor a condition code, invalid operand code 'C'"
 msgstr ""
 
-#: config/i386/i386.c:11018
+#: config/i386/i386.c:11055
 #, c-format
 msgid ""
 "operand is neither a constant nor a condition code, invalid operand code 'F'"
 msgstr ""
 
-#: config/i386/i386.c:11036
+#: config/i386/i386.c:11073
 #, c-format
 msgid ""
 "operand is neither a constant nor a condition code, invalid operand code 'c'"
 msgstr ""
 
-#: config/i386/i386.c:11046
+#: config/i386/i386.c:11083
 #, c-format
 msgid ""
 "operand is neither a constant nor a condition code, invalid operand code 'f'"
 msgstr ""
 
-#: config/i386/i386.c:11171
+#: config/i386/i386.c:11208
 #, c-format
 msgid "invalid operand code '%c'"
 msgstr ""
 
-#: config/i386/i386.c:11220
+#: config/i386/i386.c:11257
 #, c-format
 msgid "invalid constraints for operand"
 msgstr ""
 
-#: config/i386/i386.c:18908
+#: config/i386/i386.c:18945
 msgid "unknown insn mode"
 msgstr ""
 
@@ -3439,15 +3439,15 @@
 msgid "ia64_print_operand: unknown code"
 msgstr ""
 
-#: config/ia64/ia64.c:10473
+#: config/ia64/ia64.c:10485
 msgid "invalid conversion from %<__fpreg%>"
 msgstr ""
 
-#: config/ia64/ia64.c:10476
+#: config/ia64/ia64.c:10488
 msgid "invalid conversion to %<__fpreg%>"
 msgstr ""
 
-#: config/ia64/ia64.c:10489 config/ia64/ia64.c:10500
+#: config/ia64/ia64.c:10501 config/ia64/ia64.c:10512
 msgid "invalid operation on %<__fpreg%>"
 msgstr ""
 
@@ -3860,11 +3860,11 @@
 msgid "candidates are:"
 msgstr ""
 
-#: cp/call.c:6824
+#: cp/call.c:6885
 msgid "candidate 1:"
 msgstr ""
 
-#: cp/call.c:6825
+#: cp/call.c:6886
 msgid "candidate 2:"
 msgstr ""
 
@@ -5935,33 +5935,33 @@
 "Extension: BOZ literal at %L used to initialize non-integer variable '%s'"
 msgstr ""
 
-#: fortran/expr.c:2956 fortran/resolve.c:6536
+#: fortran/expr.c:2956 fortran/resolve.c:6539
 #, no-c-format
 msgid ""
 "Extension: BOZ literal at %L outside a DATA statement and outside INT/REAL/"
 "DBLE/CMPLX"
 msgstr ""
 
-#: fortran/expr.c:2966 fortran/resolve.c:6546
+#: fortran/expr.c:2966 fortran/resolve.c:6549
 #, no-c-format
 msgid "BOZ literal at %L is bitwise transferred non-integer symbol '%s'"
 msgstr ""
 
-#: fortran/expr.c:2974 fortran/resolve.c:6555
+#: fortran/expr.c:2974 fortran/resolve.c:6558
 #, no-c-format
 msgid ""
 "Arithmetic underflow of bit-wise transferred BOZ at %L. This check can be "
 "disabled with the option -fno-range-check"
 msgstr ""
 
-#: fortran/expr.c:2978 fortran/resolve.c:6559
+#: fortran/expr.c:2978 fortran/resolve.c:6562
 #, no-c-format
 msgid ""
 "Arithmetic overflow of bit-wise transferred BOZ at %L. This check can be "
 "disabled with the option -fno-range-check"
 msgstr ""
 
-#: fortran/expr.c:2982 fortran/resolve.c:6563
+#: fortran/expr.c:2982 fortran/resolve.c:6566
 #, no-c-format
 msgid ""
 "Arithmetic NaN of bit-wise transferred BOZ at %L. This check can be disabled "
@@ -6192,12 +6192,12 @@
 msgid "Second argument of defined assignment at %L must be INTENT(IN)"
 msgstr ""
 
-#: fortran/interface.c:662 fortran/resolve.c:10327
+#: fortran/interface.c:662 fortran/resolve.c:10330
 #, no-c-format
 msgid "First argument of operator interface at %L must be INTENT(IN)"
 msgstr ""
 
-#: fortran/interface.c:666 fortran/resolve.c:10339
+#: fortran/interface.c:666 fortran/resolve.c:10342
 #, no-c-format
 msgid "Second argument of operator interface at %L must be INTENT(IN)"
 msgstr ""
@@ -7106,7 +7106,7 @@
 msgid "Block label is not appropriate for IF statement at %C"
 msgstr ""
 
-#: fortran/match.c:1570 fortran/primary.c:2881
+#: fortran/match.c:1570 fortran/primary.c:2888
 #, no-c-format
 msgid "Cannot assign to a named constant at %C"
 msgstr ""
@@ -7713,7 +7713,7 @@
 msgid "Syntax error in !$OMP THREADPRIVATE list at %C"
 msgstr ""
 
-#: fortran/openmp.c:759 fortran/resolve.c:6445 fortran/resolve.c:6798
+#: fortran/openmp.c:759 fortran/resolve.c:6448 fortran/resolve.c:6801
 #, no-c-format
 msgid "IF clause at %L requires a scalar LOGICAL expression"
 msgstr ""
@@ -8226,166 +8226,166 @@
 msgid "Fortran 2003:  CONTAINS block in derived type definition at %C"
 msgstr ""
 
-#: fortran/parse.c:2046
+#: fortran/parse.c:2037
 #, no-c-format
 msgid "ENUM declaration at %C has no ENUMERATORS"
 msgstr ""
 
-#: fortran/parse.c:2140
+#: fortran/parse.c:2131
 #, no-c-format
 msgid "Unexpected %s statement in INTERFACE block at %C"
 msgstr ""
 
-#: fortran/parse.c:2166
+#: fortran/parse.c:2157
 #, no-c-format
 msgid "SUBROUTINE at %C does not belong in a generic function interface"
 msgstr ""
 
-#: fortran/parse.c:2170
+#: fortran/parse.c:2161
 #, no-c-format
 msgid "FUNCTION at %C does not belong in a generic subroutine interface"
 msgstr ""
 
-#: fortran/parse.c:2180
+#: fortran/parse.c:2171
 #, no-c-format
 msgid ""
 "Name '%s' of ABSTRACT INTERFACE at %C cannot be the same as an intrinsic type"
 msgstr ""
 
-#: fortran/parse.c:2211
+#: fortran/parse.c:2202
 #, no-c-format
 msgid "Unexpected %s statement at %C in INTERFACE body"
 msgstr ""
 
-#: fortran/parse.c:2225
+#: fortran/parse.c:2216
 #, no-c-format
 msgid ""
 "INTERFACE procedure '%s' at %L has the same name as the enclosing procedure"
 msgstr ""
 
-#: fortran/parse.c:2411
+#: fortran/parse.c:2402
 #, no-c-format
 msgid "%s statement must appear in a MODULE"
 msgstr ""
 
-#: fortran/parse.c:2418
+#: fortran/parse.c:2409
 #, no-c-format
 msgid "%s statement at %C follows another accessibility specification"
 msgstr ""
 
-#: fortran/parse.c:2468
+#: fortran/parse.c:2459
 #, no-c-format
 msgid "Bad kind expression for function '%s' at %L"
 msgstr ""
 
-#: fortran/parse.c:2472
+#: fortran/parse.c:2463
 #, no-c-format
 msgid "The type for function '%s' at %L is not accessible"
 msgstr ""
 
-#: fortran/parse.c:2530
+#: fortran/parse.c:2521
 #, no-c-format
 msgid "ELSEWHERE statement at %C follows previous unmasked ELSEWHERE"
 msgstr ""
 
-#: fortran/parse.c:2551
+#: fortran/parse.c:2542
 #, no-c-format
 msgid "Unexpected %s statement in WHERE block at %C"
 msgstr ""
 
-#: fortran/parse.c:2610
+#: fortran/parse.c:2601
 #, no-c-format
 msgid "Unexpected %s statement in FORALL block at %C"
 msgstr ""
 
-#: fortran/parse.c:2661
+#: fortran/parse.c:2652
 #, no-c-format
 msgid "ELSE IF statement at %C cannot follow ELSE statement at %L"
 msgstr ""
 
-#: fortran/parse.c:2679
+#: fortran/parse.c:2670
 #, no-c-format
 msgid "Duplicate ELSE statements at %L and %C"
 msgstr ""
 
-#: fortran/parse.c:2740
+#: fortran/parse.c:2731
 #, no-c-format
 msgid "Expected a CASE or END SELECT statement following SELECT CASE at %C"
 msgstr ""
 
-#: fortran/parse.c:2798
+#: fortran/parse.c:2789
 #, no-c-format
 msgid "Variable '%s' at %C cannot be redefined inside loop beginning at %L"
 msgstr ""
 
-#: fortran/parse.c:2832
+#: fortran/parse.c:2823
 #, no-c-format
 msgid "End of nonblock DO statement at %C is within another block"
 msgstr ""
 
-#: fortran/parse.c:2841
+#: fortran/parse.c:2832
 #, no-c-format
 msgid "End of nonblock DO statement at %C is interwoven with another DO loop"
 msgstr ""
 
-#: fortran/parse.c:2890
+#: fortran/parse.c:2881
 #, no-c-format
 msgid "Statement label in ENDDO at %C doesn't match DO label"
 msgstr ""
 
-#: fortran/parse.c:2906
+#: fortran/parse.c:2897
 #, no-c-format
 msgid "named block DO at %L requires matching ENDDO name"
 msgstr ""
 
-#: fortran/parse.c:3165
+#: fortran/parse.c:3156
 #, no-c-format
 msgid "Name after !$omp critical and !$omp end critical does not match at %C"
 msgstr ""
 
-#: fortran/parse.c:3221
+#: fortran/parse.c:3212
 #, no-c-format
 msgid "%s statement at %C cannot terminate a non-block DO loop"
 msgstr ""
 
-#: fortran/parse.c:3408
+#: fortran/parse.c:3399
 #, no-c-format
 msgid "Contained procedure '%s' at %C is already ambiguous"
 msgstr ""
 
-#: fortran/parse.c:3458
+#: fortran/parse.c:3449
 #, no-c-format
 msgid "Unexpected %s statement in CONTAINS section at %C"
 msgstr ""
 
-#: fortran/parse.c:3482
+#: fortran/parse.c:3473
 #, no-c-format
 msgid ""
 "Fortran 2008: CONTAINS statement without FUNCTION or SUBROUTINE statement at "
 "%C"
 msgstr ""
 
-#: fortran/parse.c:3553
+#: fortran/parse.c:3544
 #, no-c-format
 msgid "CONTAINS statement at %C is already in a contained program unit"
 msgstr ""
 
-#: fortran/parse.c:3602
+#: fortran/parse.c:3593
 #, no-c-format
 msgid "Global name '%s' at %L is already being used as a %s at %L"
 msgstr ""
 
-#: fortran/parse.c:3623
+#: fortran/parse.c:3614
 #, no-c-format
 msgid "Blank BLOCK DATA at %C conflicts with prior BLOCK DATA at %L"
 msgstr ""
 
-#: fortran/parse.c:3649
+#: fortran/parse.c:3640
 #, no-c-format
 msgid "Unexpected %s statement in BLOCK DATA at %C"
 msgstr ""
 
-#: fortran/parse.c:3692
+#: fortran/parse.c:3683
 #, no-c-format
 msgid "Unexpected %s statement in MODULE at %C"
 msgstr ""
@@ -8393,7 +8393,7 @@
 #. If we see a duplicate main program, shut down.  If the second
 #. instance is an implied main program, i.e. data decls or executable
 #. statements, we're in for lots of errors.
-#: fortran/parse.c:3875
+#: fortran/parse.c:3866
 #, no-c-format
 msgid "Two main PROGRAMs at %L and %C"
 msgstr ""
@@ -8546,138 +8546,138 @@
 msgid "Syntax error in COMPLEX constant at %C"
 msgstr ""
 
-#: fortran/primary.c:1476
+#: fortran/primary.c:1483
 #, no-c-format
 msgid "Keyword '%s' at %C has already appeared in the current argument list"
 msgstr ""
 
-#: fortran/primary.c:1540
+#: fortran/primary.c:1547
 #, no-c-format
 msgid "Extension: argument list function at %C"
 msgstr ""
 
-#: fortran/primary.c:1607
+#: fortran/primary.c:1614
 #, no-c-format
 msgid "Expected alternate return label at %C"
 msgstr ""
 
-#: fortran/primary.c:1625
+#: fortran/primary.c:1632
 #, no-c-format
 msgid "Missing keyword name in actual argument list at %C"
 msgstr ""
 
-#: fortran/primary.c:1670
+#: fortran/primary.c:1677
 #, no-c-format
 msgid "Syntax error in argument list at %C"
 msgstr ""
 
-#: fortran/primary.c:1765
+#: fortran/primary.c:1772
 #, no-c-format
 msgid "Expected structure component name at %C"
 msgstr ""
 
-#: fortran/primary.c:1802
+#: fortran/primary.c:1809
 #, no-c-format
 msgid "Expected argument list at %C"
 msgstr ""
 
-#: fortran/primary.c:2096
+#: fortran/primary.c:2103
 #, no-c-format
 msgid ""
 "Fortran 2003: Structure constructor with missing optional arguments at %C"
 msgstr ""
 
-#: fortran/primary.c:2104
+#: fortran/primary.c:2111
 #, no-c-format
 msgid ""
 "No initializer for component '%s' given in the structure constructor at %C!"
 msgstr ""
 
-#: fortran/primary.c:2160
+#: fortran/primary.c:2167
 #, no-c-format
 msgid "Can't construct ABSTRACT type '%s' at %C"
 msgstr ""
 
-#: fortran/primary.c:2188
+#: fortran/primary.c:2195
 #, no-c-format
 msgid "Fortran 2003: Structure constructor with named arguments at %C"
 msgstr ""
 
-#: fortran/primary.c:2203
+#: fortran/primary.c:2210
 #, no-c-format
 msgid "Component initializer without name after component named %s at %C!"
 msgstr ""
 
-#: fortran/primary.c:2206
+#: fortran/primary.c:2213
 #, no-c-format
 msgid "Too many components in structure constructor at %C!"
 msgstr ""
 
-#: fortran/primary.c:2239
+#: fortran/primary.c:2246
 #, no-c-format
 msgid "Component '%s' is initialized twice in the structure constructor at %C!"
 msgstr ""
 
-#: fortran/primary.c:2295
+#: fortran/primary.c:2302
 #, no-c-format
 msgid ""
 "component '%s' at %L has already been set by a parent derived type "
 "constructor"
 msgstr ""
 
-#: fortran/primary.c:2318
+#: fortran/primary.c:2325
 #, no-c-format
 msgid "Syntax error in structure constructor at %C"
 msgstr ""
 
-#: fortran/primary.c:2408
+#: fortran/primary.c:2415
 #, no-c-format
 msgid ""
 "'%s' at %C is the name of a recursive function and so refers to the result "
 "variable. Use an explicit RESULT variable for direct recursion (12.5.2.1)"
 msgstr ""
 
-#: fortran/primary.c:2529
+#: fortran/primary.c:2536
 #, no-c-format
 msgid "Unexpected use of subroutine name '%s' at %C"
 msgstr ""
 
-#: fortran/primary.c:2560
+#: fortran/primary.c:2567
 #, no-c-format
 msgid "Statement function '%s' requires argument list at %C"
 msgstr ""
 
-#: fortran/primary.c:2563
+#: fortran/primary.c:2570
 #, no-c-format
 msgid "Function '%s' requires an argument list at %C"
 msgstr ""
 
-#: fortran/primary.c:2608
+#: fortran/primary.c:2615
 #, no-c-format
 msgid "Missing argument to '%s' at %C"
 msgstr ""
 
-#: fortran/primary.c:2749
+#: fortran/primary.c:2756
 #, no-c-format
 msgid "Missing argument list in function '%s' at %C"
 msgstr ""
 
-#: fortran/primary.c:2777
+#: fortran/primary.c:2784
 #, no-c-format
 msgid "Symbol at %C is not appropriate for an expression"
 msgstr ""
 
-#: fortran/primary.c:2845
+#: fortran/primary.c:2852
 #, no-c-format
 msgid "Assigning to PROTECTED variable at %C"
 msgstr ""
 
-#: fortran/primary.c:2879
+#: fortran/primary.c:2886
 #, no-c-format
 msgid "Named constant at %C in an EQUIVALENCE"
 msgstr ""
 
-#: fortran/primary.c:2914
+#: fortran/primary.c:2921
 #, no-c-format
 msgid "'%s' at %C is not a variable"
 msgstr ""
@@ -8713,7 +8713,7 @@
 msgid "Dummy procedure at %L not allowed in ELEMENTAL procedure"
 msgstr ""
 
-#: fortran/resolve.c:188 fortran/resolve.c:1277
+#: fortran/resolve.c:188 fortran/resolve.c:1280
 #, no-c-format
 msgid ""
 "Unable to find a specific INTRINSIC procedure for the reference '%s' at %L"
@@ -8850,136 +8850,136 @@
 "Derived type variable '%s' in COMMON at %L may not have default initializer"
 msgstr ""
 
-#: fortran/resolve.c:745
+#: fortran/resolve.c:748
 #, no-c-format
 msgid "COMMON block '%s' at %L is used as PARAMETER at %L"
 msgstr ""
 
-#: fortran/resolve.c:749
+#: fortran/resolve.c:752
 #, no-c-format
 msgid "COMMON block '%s' at %L is also an intrinsic procedure"
 msgstr ""
 
-#: fortran/resolve.c:753
+#: fortran/resolve.c:756
 #, no-c-format
 msgid "Fortran 2003: COMMON block '%s' at %L that is also a function result"
 msgstr ""
 
-#: fortran/resolve.c:758
+#: fortran/resolve.c:761
 #, no-c-format
 msgid "Fortran 2003: COMMON block '%s' at %L that is also a global procedure"
 msgstr ""
 
-#: fortran/resolve.c:820
+#: fortran/resolve.c:823
 #, no-c-format
 msgid "Components of structure constructor '%s' at %L are PRIVATE"
 msgstr ""
 
-#: fortran/resolve.c:842
+#: fortran/resolve.c:845
 #, no-c-format
 msgid ""
 "The rank of the element in the derived type constructor at %L does not match "
 "that of the component (%d/%d)"
 msgstr ""
 
-#: fortran/resolve.c:855
+#: fortran/resolve.c:858
 #, no-c-format
 msgid ""
 "The element in the derived type constructor at %L, for pointer component '%"
 "s', is %s but should be %s"
 msgstr ""
 
-#: fortran/resolve.c:868
+#: fortran/resolve.c:871
 #, no-c-format
 msgid ""
 "The NULL in the derived type constructor at %L is being applied to component "
 "'%s', which is neither a POINTER nor ALLOCATABLE"
 msgstr ""
 
-#: fortran/resolve.c:882
+#: fortran/resolve.c:885
 #, no-c-format
 msgid ""
 "The element in the derived type constructor at %L, for pointer component '%"
 "s' should be a POINTER or a TARGET"
 msgstr ""
 
-#: fortran/resolve.c:1003
+#: fortran/resolve.c:1006
 #, no-c-format
 msgid ""
 "The upper bound in the last dimension must appear in the reference to the "
 "assumed size array '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:1065
+#: fortran/resolve.c:1068
 #, no-c-format
 msgid "'%s' at %L is ambiguous"
 msgstr ""
 
-#: fortran/resolve.c:1069
+#: fortran/resolve.c:1072
 #, no-c-format
 msgid "GENERIC procedure '%s' is not allowed as an actual argument at %L"
 msgstr ""
 
-#: fortran/resolve.c:1148
+#: fortran/resolve.c:1151
 #, no-c-format
 msgid ""
 "Non-RECURSIVE procedure '%s' at %L is possibly calling itself recursively.  "
 "Declare it RECURSIVE or use -frecursive"
 msgstr ""
 
-#: fortran/resolve.c:1181 fortran/resolve.c:6008 fortran/resolve.c:6763
+#: fortran/resolve.c:1184 fortran/resolve.c:6011 fortran/resolve.c:6766
 #, no-c-format
 msgid "Label %d referenced at %L is never defined"
 msgstr ""
 
-#: fortran/resolve.c:1226
+#: fortran/resolve.c:1229
 #, no-c-format
 msgid "Statement function '%s' at %L is not allowed as an actual argument"
 msgstr ""
 
-#: fortran/resolve.c:1234
+#: fortran/resolve.c:1237
 #, no-c-format
 msgid "Intrinsic '%s' at %L is not allowed as an actual argument"
 msgstr ""
 
-#: fortran/resolve.c:1241
+#: fortran/resolve.c:1244
 #, no-c-format
 msgid "Internal procedure '%s' is not allowed as an actual argument at %L"
 msgstr ""
 
-#: fortran/resolve.c:1247
+#: fortran/resolve.c:1250
 #, no-c-format
 msgid ""
 "ELEMENTAL non-INTRINSIC procedure '%s' is not allowed as an actual argument "
 "at %L"
 msgstr ""
 
-#: fortran/resolve.c:1299
+#: fortran/resolve.c:1302
 #, no-c-format
 msgid "Symbol '%s' at %L is ambiguous"
 msgstr ""
 
-#: fortran/resolve.c:1350
+#: fortran/resolve.c:1353
 #, no-c-format
 msgid "By-value argument at %L is not of numeric type"
 msgstr ""
 
-#: fortran/resolve.c:1357
+#: fortran/resolve.c:1360
 #, no-c-format
 msgid "By-value argument at %L cannot be an array or an array section"
 msgstr ""
 
-#: fortran/resolve.c:1371
+#: fortran/resolve.c:1374
 #, no-c-format
 msgid "By-value argument at %L is not allowed in this context"
 msgstr ""
 
-#: fortran/resolve.c:1383
+#: fortran/resolve.c:1386
 #, no-c-format
 msgid "Passing internal procedure at %L by location not allowed"
 msgstr ""
 
-#: fortran/resolve.c:1508
+#: fortran/resolve.c:1511
 #, no-c-format
 msgid ""
 "'%s' at %L is an array and OPTIONAL; IF IT IS MISSING, it cannot be the "
@@ -8987,572 +8987,572 @@
 "argument with the same rank (12.4.1.5)"
 msgstr ""
 
-#: fortran/resolve.c:1530
+#: fortran/resolve.c:1533
 msgid "elemental procedure"
 msgstr ""
 
-#: fortran/resolve.c:1547
+#: fortran/resolve.c:1550
 #, no-c-format
 msgid ""
 "Actual argument at %L for INTENT(%s) dummy '%s' of ELEMENTAL subroutine '%s' "
 "is a scalar, but another actual argument is an array"
 msgstr ""
 
-#: fortran/resolve.c:1684
+#: fortran/resolve.c:1687
 #, no-c-format
 msgid "There is no specific function for the generic '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:1693
+#: fortran/resolve.c:1696
 #, no-c-format
 msgid ""
 "Generic function '%s' at %L is not consistent with a specific intrinsic "
 "interface"
 msgstr ""
 
-#: fortran/resolve.c:1748
+#: fortran/resolve.c:1751
 #, no-c-format
 msgid ""
 "Function '%s' at %L is INTRINSIC but is not compatible with an intrinsic"
 msgstr ""
 
-#: fortran/resolve.c:1794
+#: fortran/resolve.c:1797
 #, no-c-format
 msgid "Unable to resolve the specific function '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:1850 fortran/resolve.c:10258
+#: fortran/resolve.c:1853 fortran/resolve.c:10261
 #, no-c-format
 msgid "Function '%s' at %L has no IMPLICIT type"
 msgstr ""
 
-#: fortran/resolve.c:2059
+#: fortran/resolve.c:2062
 #, no-c-format
 msgid "Argument to '%s' at %L is not a variable"
 msgstr ""
 
-#: fortran/resolve.c:2107
+#: fortran/resolve.c:2110
 #, no-c-format
 msgid "More actual than formal arguments in '%s' call at %L"
 msgstr ""
 
-#: fortran/resolve.c:2116
+#: fortran/resolve.c:2119
 #, no-c-format
 msgid ""
 "Parameter '%s' to '%s' at %L must be either a TARGET or an associated pointer"
 msgstr ""
 
-#: fortran/resolve.c:2139
+#: fortran/resolve.c:2142
 #, no-c-format
 msgid ""
 "Allocatable variable '%s' used as a parameter to '%s' at %L must not be an "
 "array of zero size"
 msgstr ""
 
-#: fortran/resolve.c:2156
+#: fortran/resolve.c:2159
 #, no-c-format
 msgid ""
 "Assumed-shape array '%s' at %L cannot be an argument to the procedure '%s' "
 "because it is not C interoperable"
 msgstr ""
 
-#: fortran/resolve.c:2166
+#: fortran/resolve.c:2169
 #, no-c-format
 msgid ""
 "Deferred-shape array '%s' at %L cannot be an argument to the procedure '%s' "
 "because it is not C interoperable"
 msgstr ""
 
-#: fortran/resolve.c:2189 fortran/resolve.c:2226
+#: fortran/resolve.c:2192 fortran/resolve.c:2229
 #, no-c-format
 msgid "CHARACTER argument '%s' to '%s' at %L must have a length of 1"
 msgstr ""
 
 #. Case 1c, section 15.1.2.5, J3/04-007: an associated
 #. scalar pointer.
-#: fortran/resolve.c:2202
+#: fortran/resolve.c:2205
 #, no-c-format
 msgid "Argument '%s' to '%s' at %L must be an associated scalar POINTER"
 msgstr ""
 
-#: fortran/resolve.c:2218
+#: fortran/resolve.c:2221
 #, no-c-format
 msgid "Parameter '%s' to '%s' at %L must be a scalar"
 msgstr ""
 
 #. TODO: Update this error message to allow for procedure
 #. pointers once they are implemented.
-#: fortran/resolve.c:2240
+#: fortran/resolve.c:2243
 #, no-c-format
 msgid "Parameter '%s' to '%s' at %L must be a procedure"
 msgstr ""
 
-#: fortran/resolve.c:2248
+#: fortran/resolve.c:2251
 #, no-c-format
 msgid "Parameter '%s' to '%s' at %L must be BIND(C)"
 msgstr ""
 
-#: fortran/resolve.c:2294
+#: fortran/resolve.c:2297
 #, no-c-format
 msgid "Intrinsic subroutine '%s' used as a function at %L"
 msgstr ""
 
-#: fortran/resolve.c:2301
+#: fortran/resolve.c:2304
 #, no-c-format
 msgid "'%s' at %L is not a function"
 msgstr ""
 
-#: fortran/resolve.c:2307
+#: fortran/resolve.c:2310
 #, no-c-format
 msgid "ABSTRACT INTERFACE '%s' must not be referenced at %L"
 msgstr ""
 
 #. Internal procedures are taken care of in resolve_contained_fntype.
-#: fortran/resolve.c:2352
+#: fortran/resolve.c:2355
 #, no-c-format
 msgid ""
 "Function '%s' is declared CHARACTER(*) and cannot be used at %L since it is "
 "not a dummy argument"
 msgstr ""
 
-#: fortran/resolve.c:2405
+#: fortran/resolve.c:2408
 #, no-c-format
 msgid ""
 "User defined non-ELEMENTAL function '%s' at %L not allowed in WORKSHARE "
 "construct"
 msgstr ""
 
-#: fortran/resolve.c:2455
+#: fortran/resolve.c:2458
 #, no-c-format
 msgid "reference to non-PURE function '%s' at %L inside a FORALL %s"
 msgstr ""
 
-#: fortran/resolve.c:2462
+#: fortran/resolve.c:2465
 #, no-c-format
 msgid ""
 "Function reference to '%s' at %L is to a non-PURE procedure within a PURE "
 "procedure"
 msgstr ""
 
-#: fortran/resolve.c:2478
+#: fortran/resolve.c:2481
 #, no-c-format
 msgid ""
 "ENTRY '%s' at %L cannot be called recursively, as function '%s' is not "
 "RECURSIVE"
 msgstr ""
 
-#: fortran/resolve.c:2482
+#: fortran/resolve.c:2485
 #, no-c-format
 msgid ""
 "Function '%s' at %L cannot be called recursively, as it is not RECURSIVE"
 msgstr ""
 
-#: fortran/resolve.c:2529
+#: fortran/resolve.c:2532
 #, no-c-format
 msgid "Subroutine call to '%s' in FORALL block at %L is not PURE"
 msgstr ""
 
-#: fortran/resolve.c:2532
+#: fortran/resolve.c:2535
 #, no-c-format
 msgid "Subroutine call to '%s' at %L is not PURE"
 msgstr ""
 
-#: fortran/resolve.c:2595
+#: fortran/resolve.c:2598
 #, no-c-format
 msgid "There is no specific subroutine for the generic '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:2604
+#: fortran/resolve.c:2607
 #, no-c-format
 msgid ""
 "Generic subroutine '%s' at %L is not consistent with an intrinsic subroutine "
 "interface"
 msgstr ""
 
-#: fortran/resolve.c:2712
+#: fortran/resolve.c:2715
 #, no-c-format
 msgid "Missing SHAPE parameter for call to %s at %L"
 msgstr ""
 
-#: fortran/resolve.c:2720
+#: fortran/resolve.c:2723
 #, no-c-format
 msgid "SHAPE parameter for call to %s at %L must be a rank 1 INTEGER array"
 msgstr ""
 
-#: fortran/resolve.c:2805
+#: fortran/resolve.c:2808
 #, no-c-format
 msgid ""
 "Subroutine '%s' at %L is INTRINSIC but is not compatible with an intrinsic"
 msgstr ""
 
-#: fortran/resolve.c:2849
+#: fortran/resolve.c:2852
 #, no-c-format
 msgid "Unable to resolve the specific subroutine '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:2909
+#: fortran/resolve.c:2912
 #, no-c-format
 msgid "'%s' at %L has a type, which is not consistent with the CALL at %L"
 msgstr ""
 
-#: fortran/resolve.c:2942
+#: fortran/resolve.c:2945
 #, no-c-format
 msgid ""
 "ENTRY '%s' at %L cannot be called recursively, as subroutine '%s' is not "
 "RECURSIVE"
 msgstr ""
 
-#: fortran/resolve.c:2946
+#: fortran/resolve.c:2949
 #, no-c-format
 msgid ""
 "SUBROUTINE '%s' at %L cannot be called recursively, as it is not RECURSIVE"
 msgstr ""
 
-#: fortran/resolve.c:3020
+#: fortran/resolve.c:3023
 #, no-c-format
 msgid "Shapes for operands at %L and %L are not conformable"
 msgstr ""
 
-#: fortran/resolve.c:3071
+#: fortran/resolve.c:3074
 #, c-format
 msgid "Invalid context for NULL() pointer at %%L"
 msgstr ""
 
-#: fortran/resolve.c:3087
+#: fortran/resolve.c:3090
 #, c-format
 msgid "Operand of unary numeric operator '%s' at %%L is %s"
 msgstr ""
 
-#: fortran/resolve.c:3103
+#: fortran/resolve.c:3106
 #, c-format
 msgid "Operands of binary numeric operator '%s' at %%L are %s/%s"
 msgstr ""
 
-#: fortran/resolve.c:3118
+#: fortran/resolve.c:3121
 #, c-format
 msgid "Operands of string concatenation operator at %%L are %s/%s"
 msgstr ""
 
-#: fortran/resolve.c:3137
+#: fortran/resolve.c:3140
 #, c-format
 msgid "Operands of logical operator '%s' at %%L are %s/%s"
 msgstr ""
 
-#: fortran/resolve.c:3151
+#: fortran/resolve.c:3154
 #, c-format
 msgid "Operand of .not. operator at %%L is %s"
 msgstr ""
 
-#: fortran/resolve.c:3165
+#: fortran/resolve.c:3168
 msgid "COMPLEX quantities cannot be compared at %L"
 msgstr ""
 
-#: fortran/resolve.c:3194
+#: fortran/resolve.c:3197
 #, c-format
 msgid "Logicals at %%L must be compared with %s instead of %s"
 msgstr ""
 
-#: fortran/resolve.c:3200
+#: fortran/resolve.c:3203
 #, c-format
 msgid "Operands of comparison operator '%s' at %%L are %s/%s"
 msgstr ""
 
-#: fortran/resolve.c:3208
+#: fortran/resolve.c:3211
 #, c-format
 msgid "Unknown operator '%s' at %%L"
 msgstr ""
 
-#: fortran/resolve.c:3210
+#: fortran/resolve.c:3213
 #, c-format
 msgid "Operand of user operator '%s' at %%L is %s"
 msgstr ""
 
-#: fortran/resolve.c:3213
+#: fortran/resolve.c:3216
 #, c-format
 msgid "Operands of user operator '%s' at %%L are %s/%s"
 msgstr ""
 
-#: fortran/resolve.c:3299
+#: fortran/resolve.c:3302
 #, c-format
 msgid "Inconsistent ranks for operator at %%L and %%L"
 msgstr ""
 
-#: fortran/resolve.c:3496
+#: fortran/resolve.c:3499
 #, no-c-format
 msgid "Array reference at %L is out of bounds (%ld < %ld) in dimension %d"
 msgstr ""
 
-#: fortran/resolve.c:3504
+#: fortran/resolve.c:3507
 #, no-c-format
 msgid "Array reference at %L is out of bounds (%ld > %ld) in dimension %d"
 msgstr ""
 
-#: fortran/resolve.c:3523
+#: fortran/resolve.c:3526
 #, no-c-format
 msgid "Illegal stride of zero at %L"
 msgstr ""
 
-#: fortran/resolve.c:3540
+#: fortran/resolve.c:3543
 #, no-c-format
 msgid ""
 "Lower array reference at %L is out of bounds (%ld < %ld) in dimension %d"
 msgstr ""
 
-#: fortran/resolve.c:3548
+#: fortran/resolve.c:3551
 #, no-c-format
 msgid ""
 "Lower array reference at %L is out of bounds (%ld > %ld) in dimension %d"
 msgstr ""
 
-#: fortran/resolve.c:3564
+#: fortran/resolve.c:3567
 #, no-c-format
 msgid ""
 "Upper array reference at %L is out of bounds (%ld < %ld) in dimension %d"
 msgstr ""
 
-#: fortran/resolve.c:3573
+#: fortran/resolve.c:3576
 #, no-c-format
 msgid ""
 "Upper array reference at %L is out of bounds (%ld > %ld) in dimension %d"
 msgstr ""
 
-#: fortran/resolve.c:3612
+#: fortran/resolve.c:3615
 #, no-c-format
 msgid "Rightmost upper bound of assumed size array section not specified at %L"
 msgstr ""
 
-#: fortran/resolve.c:3622
+#: fortran/resolve.c:3625
 #, no-c-format
 msgid "Rank mismatch in array reference at %L (%d/%d)"
 msgstr ""
 
-#: fortran/resolve.c:3650
+#: fortran/resolve.c:3653
 #, no-c-format
 msgid "Array index at %L must be scalar"
 msgstr ""
 
-#: fortran/resolve.c:3656
+#: fortran/resolve.c:3659
 #, no-c-format
 msgid "Array index at %L must be of INTEGER type, found %s"
 msgstr ""
 
-#: fortran/resolve.c:3662
+#: fortran/resolve.c:3665
 #, no-c-format
 msgid "Extension: REAL array index at %L"
 msgstr ""
 
-#: fortran/resolve.c:3692
+#: fortran/resolve.c:3695
 #, no-c-format
 msgid "Argument dim at %L must be scalar"
 msgstr ""
 
-#: fortran/resolve.c:3699
+#: fortran/resolve.c:3702
 #, no-c-format
 msgid "Argument dim at %L must be of INTEGER type"
 msgstr ""
 
-#: fortran/resolve.c:3820
+#: fortran/resolve.c:3823
 #, no-c-format
 msgid "Array index at %L is an array of rank %d"
 msgstr ""
 
-#: fortran/resolve.c:3857
+#: fortran/resolve.c:3860
 #, no-c-format
 msgid "Substring start index at %L must be of type INTEGER"
 msgstr ""
 
-#: fortran/resolve.c:3864
+#: fortran/resolve.c:3867
 #, no-c-format
 msgid "Substring start index at %L must be scalar"
 msgstr ""
 
-#: fortran/resolve.c:3873
+#: fortran/resolve.c:3876
 #, no-c-format
 msgid "Substring start index at %L is less than one"
 msgstr ""
 
-#: fortran/resolve.c:3886
+#: fortran/resolve.c:3889
 #, no-c-format
 msgid "Substring end index at %L must be of type INTEGER"
 msgstr ""
 
-#: fortran/resolve.c:3893
+#: fortran/resolve.c:3896
 #, no-c-format
 msgid "Substring end index at %L must be scalar"
 msgstr ""
 
-#: fortran/resolve.c:3903
+#: fortran/resolve.c:3906
 #, no-c-format
 msgid "Substring end index at %L exceeds the string length"
 msgstr ""
 
-#: fortran/resolve.c:4041
+#: fortran/resolve.c:4044
 #, no-c-format
 msgid ""
 "Component to the right of a part reference with nonzero rank must not have "
 "the POINTER attribute at %L"
 msgstr ""
 
-#: fortran/resolve.c:4048
+#: fortran/resolve.c:4051
 #, no-c-format
 msgid ""
 "Component to the right of a part reference with nonzero rank must not have "
 "the ALLOCATABLE attribute at %L"
 msgstr ""
 
-#: fortran/resolve.c:4067
+#: fortran/resolve.c:4070
 #, no-c-format
 msgid ""
 "Two or more part references with nonzero rank must not be specified at %L"
 msgstr ""
 
-#: fortran/resolve.c:4246
+#: fortran/resolve.c:4249
 #, no-c-format
 msgid ""
 "Variable '%s', used in a specification expression, is referenced at %L "
 "before the ENTRY statement in which it is a parameter"
 msgstr ""
 
-#: fortran/resolve.c:4251
+#: fortran/resolve.c:4254
 #, no-c-format
 msgid ""
 "Variable '%s' is used at %L before the ENTRY statement in which it is a "
 "parameter"
 msgstr ""
 
-#: fortran/resolve.c:4535
+#: fortran/resolve.c:4538
 #, no-c-format
 msgid "Passed-object at %L must be scalar"
 msgstr ""
 
 #. Nothing matching found!
-#: fortran/resolve.c:4645
+#: fortran/resolve.c:4648
 #, no-c-format
 msgid ""
 "Found no matching specific binding for the call to the GENERIC '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:4665
+#: fortran/resolve.c:4668
 #, no-c-format
 msgid "'%s' at %L should be a SUBROUTINE"
 msgstr ""
 
-#: fortran/resolve.c:4701
+#: fortran/resolve.c:4704
 #, no-c-format
 msgid "'%s' at %L should be a FUNCTION"
 msgstr ""
 
-#: fortran/resolve.c:4837
+#: fortran/resolve.c:4840
 #, no-c-format
 msgid "%s at %L must be a scalar"
 msgstr ""
 
-#: fortran/resolve.c:4847
+#: fortran/resolve.c:4850
 #, no-c-format
 msgid "Deleted feature: %s at %L must be integer"
 msgstr ""
 
-#: fortran/resolve.c:4851 fortran/resolve.c:4858
+#: fortran/resolve.c:4854 fortran/resolve.c:4861
 #, no-c-format
 msgid "%s at %L must be INTEGER"
 msgstr ""
 
-#: fortran/resolve.c:4878
+#: fortran/resolve.c:4881
 #, no-c-format
 msgid "Cannot assign to loop variable in PURE procedure at %L"
 msgstr ""
 
-#: fortran/resolve.c:4902
+#: fortran/resolve.c:4905
 #, no-c-format
 msgid "Step expression in DO loop at %L cannot be zero"
 msgstr ""
 
-#: fortran/resolve.c:4978
+#: fortran/resolve.c:4981
 #, no-c-format
 msgid "FORALL index-name at %L must be a scalar INTEGER"
 msgstr ""
 
-#: fortran/resolve.c:4983
+#: fortran/resolve.c:4986
 #, no-c-format
 msgid "FORALL start expression at %L must be a scalar INTEGER"
 msgstr ""
 
-#: fortran/resolve.c:4990
+#: fortran/resolve.c:4993
 #, no-c-format
 msgid "FORALL end expression at %L must be a scalar INTEGER"
 msgstr ""
 
-#: fortran/resolve.c:4998
+#: fortran/resolve.c:5001
 #, no-c-format
 msgid "FORALL stride expression at %L must be a scalar %s"
 msgstr ""
 
-#: fortran/resolve.c:5003
+#: fortran/resolve.c:5006
 #, no-c-format
 msgid "FORALL stride expression at %L cannot be zero"
 msgstr ""
 
-#: fortran/resolve.c:5019
+#: fortran/resolve.c:5022
 #, no-c-format
 msgid "FORALL index '%s' may not appear in triplet specification at %L"
 msgstr ""
 
-#: fortran/resolve.c:5099
+#: fortran/resolve.c:5102
 #, no-c-format
 msgid ""
 "Expression in DEALLOCATE statement at %L must be ALLOCATABLE or a POINTER"
 msgstr ""
 
-#: fortran/resolve.c:5106
+#: fortran/resolve.c:5109
 #, no-c-format
 msgid "Cannot deallocate INTENT(IN) variable '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:5210
+#: fortran/resolve.c:5213
 #, no-c-format
 msgid ""
 "The STAT variable '%s' in an ALLOCATE statement must not be allocated in the "
 "same statement at %L"
 msgstr ""
 
-#: fortran/resolve.c:5246
+#: fortran/resolve.c:5249
 #, no-c-format
 msgid "Expression in ALLOCATE statement at %L must be ALLOCATABLE or a POINTER"
 msgstr ""
 
-#: fortran/resolve.c:5254
+#: fortran/resolve.c:5257
 #, no-c-format
 msgid "Cannot allocate INTENT(IN) variable '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:5278
+#: fortran/resolve.c:5281
 #, no-c-format
 msgid "Array specification required in ALLOCATE statement at %L"
 msgstr ""
 
-#: fortran/resolve.c:5308
+#: fortran/resolve.c:5311
 #, no-c-format
 msgid "Bad array specification in ALLOCATE statement at %L"
 msgstr ""
 
-#: fortran/resolve.c:5328
+#: fortran/resolve.c:5331
 #, no-c-format
 msgid ""
 "'%s' must not appear in the array specification at %L in the same ALLOCATE "
 "statement where it is itself allocated"
 msgstr ""
 
-#: fortran/resolve.c:5351
+#: fortran/resolve.c:5354
 #, no-c-format
 msgid "STAT variable '%s' of %s statement at %C cannot be INTENT(IN)"
 msgstr ""
 
-#: fortran/resolve.c:5355
+#: fortran/resolve.c:5358
 #, no-c-format
 msgid "Illegal STAT variable in %s statement at %C for a PURE procedure"
 msgstr ""
 
-#: fortran/resolve.c:5360
+#: fortran/resolve.c:5363
 #, no-c-format
 msgid "STAT tag in %s statement at %L must be of type INTEGER"
 msgstr ""
@@ -9561,99 +9561,99 @@
 #. element in the list.  Either way, we must
 #. issue an error and get the next case from P.
 #. FIXME: Sort P and Q by line number.
-#: fortran/resolve.c:5523
+#: fortran/resolve.c:5526
 #, no-c-format
 msgid "CASE label at %L overlaps with CASE label at %L"
 msgstr ""
 
-#: fortran/resolve.c:5574
+#: fortran/resolve.c:5577
 #, no-c-format
 msgid "Expression in CASE statement at %L must be of type %s"
 msgstr ""
 
-#: fortran/resolve.c:5585
+#: fortran/resolve.c:5588
 #, no-c-format
 msgid "Expression in CASE statement at %L must be of kind %d"
 msgstr ""
 
-#: fortran/resolve.c:5597
+#: fortran/resolve.c:5600
 #, no-c-format
 msgid "Expression in CASE statement at %L must be scalar"
 msgstr ""
 
-#: fortran/resolve.c:5643
+#: fortran/resolve.c:5646
 #, no-c-format
 msgid ""
 "Selection expression in computed GOTO statement at %L must be a scalar "
 "integer expression"
 msgstr ""
 
-#: fortran/resolve.c:5661
+#: fortran/resolve.c:5664
 #, no-c-format
 msgid "Argument of SELECT statement at %L cannot be %s"
 msgstr ""
 
-#: fortran/resolve.c:5670
+#: fortran/resolve.c:5673
 #, no-c-format
 msgid "Argument of SELECT statement at %L must be a scalar expression"
 msgstr ""
 
-#: fortran/resolve.c:5735
+#: fortran/resolve.c:5738
 #, no-c-format
 msgid ""
 "The DEFAULT CASE at %L cannot be followed by a second DEFAULT CASE at %L"
 msgstr ""
 
-#: fortran/resolve.c:5761
+#: fortran/resolve.c:5764
 #, no-c-format
 msgid "Logical range in CASE statement at %L is not allowed"
 msgstr ""
 
-#: fortran/resolve.c:5773
+#: fortran/resolve.c:5776
 #, no-c-format
 msgid "constant logical value in CASE statement is repeated at %L"
 msgstr ""
 
-#: fortran/resolve.c:5787
+#: fortran/resolve.c:5790
 #, no-c-format
 msgid "Range specification at %L can never be matched"
 msgstr ""
 
-#: fortran/resolve.c:5890
+#: fortran/resolve.c:5893
 #, no-c-format
 msgid "Logical SELECT CASE block at %L has more that two cases"
 msgstr ""
 
-#: fortran/resolve.c:5928
+#: fortran/resolve.c:5931
 #, no-c-format
 msgid "Data transfer element at %L cannot have POINTER components"
 msgstr ""
 
-#: fortran/resolve.c:5935
+#: fortran/resolve.c:5938
 #, no-c-format
 msgid "Data transfer element at %L cannot have ALLOCATABLE components"
 msgstr ""
 
-#: fortran/resolve.c:5942
+#: fortran/resolve.c:5945
 #, no-c-format
 msgid "Data transfer element at %L cannot have PRIVATE components"
 msgstr ""
 
-#: fortran/resolve.c:5951
+#: fortran/resolve.c:5954
 #, no-c-format
 msgid ""
 "Data transfer element at %L cannot be a full reference to an assumed-size "
 "array"
 msgstr ""
 
-#: fortran/resolve.c:6015
+#: fortran/resolve.c:6018
 #, no-c-format
 msgid ""
 "Statement at %L is not a valid branch target statement for the branch "
 "statement at %L"
 msgstr ""
 
-#: fortran/resolve.c:6024
+#: fortran/resolve.c:6027
 #, no-c-format
 msgid "Branch at %L may result in an infinite loop"
 msgstr ""
@@ -9661,118 +9661,118 @@
 #. The label is not in an enclosing block, so illegal.  This was
 #. allowed in Fortran 66, so we allow it as extension.  No
 #. further checks are necessary in this case.
-#: fortran/resolve.c:6037
+#: fortran/resolve.c:6040
 #, no-c-format
 msgid "Label at %L is not in the same block as the GOTO statement at %L"
 msgstr ""
 
-#: fortran/resolve.c:6052 fortran/resolve.c:6066
+#: fortran/resolve.c:6055 fortran/resolve.c:6069
 #, no-c-format
 msgid "Deleted feature: GOTO at %L jumps to END of construct at %L"
 msgstr ""
 
-#: fortran/resolve.c:6143
+#: fortran/resolve.c:6146
 #, no-c-format
 msgid "WHERE mask at %L has inconsistent shape"
 msgstr ""
 
-#: fortran/resolve.c:6159
+#: fortran/resolve.c:6162
 #, no-c-format
 msgid "WHERE assignment target at %L has inconsistent shape"
 msgstr ""
 
-#: fortran/resolve.c:6167 fortran/resolve.c:6254
+#: fortran/resolve.c:6170 fortran/resolve.c:6257
 #, no-c-format
 msgid "Non-ELEMENTAL user-defined assignment in WHERE at %L"
 msgstr ""
 
-#: fortran/resolve.c:6177 fortran/resolve.c:6264
+#: fortran/resolve.c:6180 fortran/resolve.c:6267
 #, no-c-format
 msgid "Unsupported statement inside WHERE at %L"
 msgstr ""
 
-#: fortran/resolve.c:6208
+#: fortran/resolve.c:6211
 #, no-c-format
 msgid "Assignment to a FORALL index variable at %L"
 msgstr ""
 
-#: fortran/resolve.c:6217
+#: fortran/resolve.c:6220
 #, no-c-format
 msgid ""
 "The FORALL with index '%s' is not used on the left side of the assignment at "
 "%L and so might cause multiple assignment to this object"
 msgstr ""
 
-#: fortran/resolve.c:6386
+#: fortran/resolve.c:6389
 #, no-c-format
 msgid "An outer FORALL construct already has an index with this name %L"
 msgstr ""
 
-#: fortran/resolve.c:6453
+#: fortran/resolve.c:6456
 #, no-c-format
 msgid "WHERE/ELSEWHERE clause at %L requires a LOGICAL array"
 msgstr ""
 
-#: fortran/resolve.c:6515
+#: fortran/resolve.c:6518
 #, no-c-format
 msgid "Subroutine '%s' called instead of assignment at %L must be PURE"
 msgstr ""
 
-#: fortran/resolve.c:6588
+#: fortran/resolve.c:6591
 #, no-c-format
 msgid "CHARACTER expression will be truncated in assignment (%d/%d) at %L"
 msgstr ""
 
-#: fortran/resolve.c:6613
+#: fortran/resolve.c:6616
 #, no-c-format
 msgid "Cannot assign to variable '%s' in PURE procedure at %L"
 msgstr ""
 
-#: fortran/resolve.c:6625
+#: fortran/resolve.c:6628
 #, no-c-format
 msgid ""
 "The impure variable at %L is assigned to a derived type variable with a "
 "POINTER component in a PURE procedure (12.6)"
 msgstr ""
 
-#: fortran/resolve.c:6731
+#: fortran/resolve.c:6734
 #, no-c-format
 msgid "ASSIGNED GOTO statement at %L requires an INTEGER variable"
 msgstr ""
 
-#: fortran/resolve.c:6734
+#: fortran/resolve.c:6737
 #, no-c-format
 msgid "Variable '%s' has not been assigned a target label at %L"
 msgstr ""
 
-#: fortran/resolve.c:6745
+#: fortran/resolve.c:6748
 #, no-c-format
 msgid ""
 "Alternate RETURN statement at %L requires a SCALAR-INTEGER return specifier"
 msgstr ""
 
-#: fortran/resolve.c:6771
+#: fortran/resolve.c:6774
 #, no-c-format
 msgid "ASSIGN statement at %L requires a scalar default INTEGER variable"
 msgstr ""
 
-#: fortran/resolve.c:6786
+#: fortran/resolve.c:6789
 #, no-c-format
 msgid "Arithmetic IF statement at %L requires a numeric expression"
 msgstr ""
 
-#: fortran/resolve.c:6832
+#: fortran/resolve.c:6835
 #, no-c-format
 msgid ""
 "Exit condition of DO WHILE loop at %L must be a scalar LOGICAL expression"
 msgstr ""
 
-#: fortran/resolve.c:6914
+#: fortran/resolve.c:6917
 #, no-c-format
 msgid "FORALL mask clause at %L requires a LOGICAL expression"
 msgstr ""
 
-#: fortran/resolve.c:6986 fortran/resolve.c:7042
+#: fortran/resolve.c:6989 fortran/resolve.c:7045
 #, no-c-format
 msgid ""
 "Binding label '%s' for common block '%s' at %L collides with the global "
@@ -9780,14 +9780,14 @@
 msgstr ""
 
 #. Common block names match but binding labels do not.
-#: fortran/resolve.c:7007
+#: fortran/resolve.c:7010
 #, no-c-format
 msgid ""
 "Binding label '%s' for common block '%s' at %L does not match the binding "
 "label '%s' for common block '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:7054
+#: fortran/resolve.c:7057
 #, no-c-format
 msgid ""
 "Binding label '%s' for common block '%s' at %L collides with global entity '%"
@@ -9795,57 +9795,57 @@
 msgstr ""
 
 #. Make sure global procedures don't collide with anything.
-#: fortran/resolve.c:7106
+#: fortran/resolve.c:7109
 #, no-c-format
 msgid "Binding label '%s' at %L collides with the global entity '%s' at %L"
 msgstr ""
 
 #. Make sure procedures in interface bodies don't collide.
-#: fortran/resolve.c:7119
+#: fortran/resolve.c:7122
 #, no-c-format
 msgid ""
 "Binding label '%s' in interface body at %L collides with the global entity '%"
 "s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:7132
+#: fortran/resolve.c:7135
 #, no-c-format
 msgid "Binding label '%s' at %L collides with global entity '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:7209
+#: fortran/resolve.c:7212
 #, no-c-format
 msgid "CHARACTER variable has zero length at %L"
 msgstr ""
 
-#: fortran/resolve.c:7496
+#: fortran/resolve.c:7499
 #, no-c-format
 msgid "Allocatable array '%s' at %L must have a deferred shape"
 msgstr ""
 
-#: fortran/resolve.c:7499
+#: fortran/resolve.c:7502
 #, no-c-format
 msgid "Scalar object '%s' at %L may not be ALLOCATABLE"
 msgstr ""
 
-#: fortran/resolve.c:7506
+#: fortran/resolve.c:7509
 #, no-c-format
 msgid "Array pointer '%s' at %L must have a deferred shape"
 msgstr ""
 
-#: fortran/resolve.c:7517
+#: fortran/resolve.c:7520
 #, no-c-format
 msgid "Array '%s' at %L cannot have a deferred shape"
 msgstr ""
 
-#: fortran/resolve.c:7545
+#: fortran/resolve.c:7548
 #, no-c-format
 msgid ""
 "The type '%s' cannot be host associated at %L because it is blocked by an "
 "incompatible object of the same name declared at %L"
 msgstr ""
 
-#: fortran/resolve.c:7568
+#: fortran/resolve.c:7571
 #, no-c-format
 msgid ""
 "Object '%s' at %L must have the SAVE attribute for default initialization of "
@@ -9854,181 +9854,181 @@
 
 #. The shape of a main program or module array needs to be
 #. constant.
-#: fortran/resolve.c:7615
+#: fortran/resolve.c:7618
 #, no-c-format
 msgid "The module or main program array '%s' at %L must have constant shape"
 msgstr ""
 
-#: fortran/resolve.c:7628
+#: fortran/resolve.c:7631
 #, no-c-format
 msgid ""
 "Entity with assumed character length at %L must be a dummy argument or a "
 "PARAMETER"
 msgstr ""
 
-#: fortran/resolve.c:7647
+#: fortran/resolve.c:7650
 #, no-c-format
 msgid "'%s' at %L must have constant character length in this context"
 msgstr ""
 
-#: fortran/resolve.c:7683
+#: fortran/resolve.c:7686
 #, no-c-format
 msgid "Allocatable '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7686
+#: fortran/resolve.c:7689
 #, no-c-format
 msgid "External '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7690
+#: fortran/resolve.c:7693
 #, no-c-format
 msgid "Dummy '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7693
+#: fortran/resolve.c:7696
 #, no-c-format
 msgid "Intrinsic '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7696
+#: fortran/resolve.c:7699
 #, no-c-format
 msgid "Function result '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7699
+#: fortran/resolve.c:7702
 #, no-c-format
 msgid "Automatic array '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7722
+#: fortran/resolve.c:7725
 #, no-c-format
 msgid "Although not referenced, '%s' at %L has ambiguous interfaces"
 msgstr ""
 
-#: fortran/resolve.c:7741
+#: fortran/resolve.c:7744
 #, no-c-format
 msgid ""
 "Character-valued statement function '%s' at %L must have constant length"
 msgstr ""
 
-#: fortran/resolve.c:7749
+#: fortran/resolve.c:7752
 #, no-c-format
 msgid ""
 "Automatic character length function '%s' at %L must have an explicit "
 "interface"
 msgstr ""
 
-#: fortran/resolve.c:7774
+#: fortran/resolve.c:7777
 #, no-c-format
 msgid ""
 "Fortran 2003: '%s' is of a PRIVATE type and cannot be a dummy argument of '%"
 "s', which is PUBLIC at %L"
 msgstr ""
 
-#: fortran/resolve.c:7797 fortran/resolve.c:7822
+#: fortran/resolve.c:7800 fortran/resolve.c:7825
 #, no-c-format
 msgid ""
 "Fortran 2003: Procedure '%s' in PUBLIC interface '%s' at %L takes dummy "
 "arguments of '%s' which is PRIVATE"
 msgstr ""
 
-#: fortran/resolve.c:7840
+#: fortran/resolve.c:7843
 #, no-c-format
 msgid "Function '%s' at %L cannot have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7849
+#: fortran/resolve.c:7852
 #, no-c-format
 msgid "External object '%s' at %L may not have an initializer"
 msgstr ""
 
-#: fortran/resolve.c:7857
+#: fortran/resolve.c:7860
 #, no-c-format
 msgid "ELEMENTAL function '%s' at %L must have a scalar result"
 msgstr ""
 
-#: fortran/resolve.c:7878
+#: fortran/resolve.c:7881
 #, no-c-format
 msgid "CHARACTER(*) function '%s' at %L cannot be array-valued"
 msgstr ""
 
-#: fortran/resolve.c:7882
+#: fortran/resolve.c:7885
 #, no-c-format
 msgid "CHARACTER(*) function '%s' at %L cannot be pointer-valued"
 msgstr ""
 
-#: fortran/resolve.c:7886
+#: fortran/resolve.c:7889
 #, no-c-format
 msgid "CHARACTER(*) function '%s' at %L cannot be pure"
 msgstr ""
 
-#: fortran/resolve.c:7890
+#: fortran/resolve.c:7893
 #, no-c-format
 msgid "CHARACTER(*) function '%s' at %L cannot be recursive"
 msgstr ""
 
-#: fortran/resolve.c:7899
+#: fortran/resolve.c:7902
 #, no-c-format
 msgid "CHARACTER(*) function '%s' at %L is obsolescent in fortran 95"
 msgstr ""
 
-#: fortran/resolve.c:7952
+#: fortran/resolve.c:7955
 #, no-c-format
 msgid "PROCEDURE attribute conflicts with SAVE attribute in '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:7959
+#: fortran/resolve.c:7962
 #, no-c-format
 msgid "PROCEDURE attribute conflicts with INTENT attribute in '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8003
+#: fortran/resolve.c:8006
 #, no-c-format
 msgid "FINAL procedure '%s' at %L is not a SUBROUTINE"
 msgstr ""
 
-#: fortran/resolve.c:8011
+#: fortran/resolve.c:8014
 #, no-c-format
 msgid "FINAL procedure at %L must have exactly one argument"
 msgstr ""
 
-#: fortran/resolve.c:8020
+#: fortran/resolve.c:8023
 #, no-c-format
 msgid "Argument of FINAL procedure at %L must be of type '%s'"
 msgstr ""
 
-#: fortran/resolve.c:8028
+#: fortran/resolve.c:8031
 #, no-c-format
 msgid "Argument of FINAL procedure at %L must not be a POINTER"
 msgstr ""
 
-#: fortran/resolve.c:8034
+#: fortran/resolve.c:8037
 #, no-c-format
 msgid "Argument of FINAL procedure at %L must not be ALLOCATABLE"
 msgstr ""
 
-#: fortran/resolve.c:8040
+#: fortran/resolve.c:8043
 #, no-c-format
 msgid "Argument of FINAL procedure at %L must not be OPTIONAL"
 msgstr ""
 
-#: fortran/resolve.c:8048
+#: fortran/resolve.c:8051
 #, no-c-format
 msgid "Argument of FINAL procedure at %L must not be INTENT(OUT)"
 msgstr ""
 
-#: fortran/resolve.c:8056
+#: fortran/resolve.c:8059
 #, no-c-format
 msgid "Non-scalar FINAL procedure at %L should have assumed shape argument"
 msgstr ""
 
-#: fortran/resolve.c:8075
+#: fortran/resolve.c:8078
 #, no-c-format
 msgid "FINAL procedure '%s' declared at %L has the same rank (%d) as '%s'"
 msgstr ""
 
-#: fortran/resolve.c:8108
+#: fortran/resolve.c:8111
 #, no-c-format
 msgid ""
 "Only array FINAL procedures declared for derived type '%s' defined at %L, "
@@ -10036,302 +10036,302 @@
 msgstr ""
 
 #. TODO:  Remove this error when finalization is finished.
-#: fortran/resolve.c:8113
+#: fortran/resolve.c:8116
 #, no-c-format
 msgid "Finalization at %L is not yet implemented"
 msgstr ""
 
-#: fortran/resolve.c:8139
+#: fortran/resolve.c:8142
 #, no-c-format
 msgid "Can't overwrite GENERIC '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8151
+#: fortran/resolve.c:8154
 #, no-c-format
 msgid "'%s' at %L overrides a procedure binding declared NON_OVERRIDABLE"
 msgstr ""
 
-#: fortran/resolve.c:8159
+#: fortran/resolve.c:8162
 #, no-c-format
 msgid "'%s' at %L overrides a PURE procedure and must also be PURE"
 msgstr ""
 
-#: fortran/resolve.c:8168
+#: fortran/resolve.c:8171
 #, no-c-format
 msgid "'%s' at %L overrides an ELEMENTAL procedure and must also be ELEMENTAL"
 msgstr ""
 
-#: fortran/resolve.c:8174
+#: fortran/resolve.c:8177
 #, no-c-format
 msgid ""
 "'%s' at %L overrides a non-ELEMENTAL procedure and must not be ELEMENTAL, "
 "either"
 msgstr ""
 
-#: fortran/resolve.c:8183
+#: fortran/resolve.c:8186
 #, no-c-format
 msgid "'%s' at %L overrides a SUBROUTINE and must also be a SUBROUTINE"
 msgstr ""
 
-#: fortran/resolve.c:8194
+#: fortran/resolve.c:8197
 #, no-c-format
 msgid "'%s' at %L overrides a FUNCTION and must also be a FUNCTION"
 msgstr ""
 
-#: fortran/resolve.c:8205
+#: fortran/resolve.c:8208
 #, no-c-format
 msgid ""
 "'%s' at %L and the overridden FUNCTION should have matching result types"
 msgstr ""
 
-#: fortran/resolve.c:8216
+#: fortran/resolve.c:8219
 #, no-c-format
 msgid "'%s' at %L overrides a PUBLIC procedure and must not be PRIVATE"
 msgstr ""
 
-#: fortran/resolve.c:8245
+#: fortran/resolve.c:8248
 #, no-c-format
 msgid ""
 "Dummy argument '%s' of '%s' at %L should be named '%s' as to match the "
 "corresponding argument of the overridden procedure"
 msgstr ""
 
-#: fortran/resolve.c:8258
+#: fortran/resolve.c:8261
 #, no-c-format
 msgid ""
 "Types mismatch for dummy argument '%s' of '%s' %L in in respect to the "
 "overridden procedure"
 msgstr ""
 
-#: fortran/resolve.c:8268
+#: fortran/resolve.c:8271
 #, no-c-format
 msgid ""
 "'%s' at %L must have the same number of formal arguments as the overridden "
 "procedure"
 msgstr ""
 
-#: fortran/resolve.c:8277
+#: fortran/resolve.c:8280
 #, no-c-format
 msgid "'%s' at %L overrides a NOPASS binding and must also be NOPASS"
 msgstr ""
 
-#: fortran/resolve.c:8288
+#: fortran/resolve.c:8291
 #, no-c-format
 msgid "'%s' at %L overrides a binding with PASS and must also be PASS"
 msgstr ""
 
-#: fortran/resolve.c:8295
+#: fortran/resolve.c:8298
 #, no-c-format
 msgid ""
 "Passed-object dummy argument of '%s' at %L must be at the same position as "
 "the passed-object dummy argument of the overridden procedure"
 msgstr ""
 
-#: fortran/resolve.c:8326
+#: fortran/resolve.c:8329
 #, no-c-format
 msgid "'%s' and '%s' can't be mixed FUNCTION/SUBROUTINE for GENERIC '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8335
+#: fortran/resolve.c:8338
 #, no-c-format
 msgid "'%s' and '%s' for GENERIC '%s' at %L are ambiguous"
 msgstr ""
 
-#: fortran/resolve.c:8404
+#: fortran/resolve.c:8407
 #, no-c-format
 msgid "Undefined specific binding '%s' as target of GENERIC '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8416
+#: fortran/resolve.c:8419
 #, no-c-format
 msgid "GENERIC '%s' at %L must target a specific binding, '%s' is GENERIC, too"
 msgstr ""
 
-#: fortran/resolve.c:8446
+#: fortran/resolve.c:8449
 #, no-c-format
 msgid "GENERIC '%s' at %L can't overwrite specific binding with the same name"
 msgstr ""
 
-#: fortran/resolve.c:8504
+#: fortran/resolve.c:8507
 #, no-c-format
 msgid ""
 "'%s' must be a module procedure or an external procedure with an explicit "
 "interface at %L"
 msgstr ""
 
-#: fortran/resolve.c:8541
+#: fortran/resolve.c:8544
 #, no-c-format
 msgid "Procedure '%s' with PASS(%s) at %L has no argument '%s'"
 msgstr ""
 
-#: fortran/resolve.c:8555
+#: fortran/resolve.c:8558
 #, no-c-format
 msgid "Procedure '%s' with PASS at %L must have at least one argument"
 msgstr ""
 
-#: fortran/resolve.c:8567
+#: fortran/resolve.c:8570
 #, no-c-format
 msgid ""
 "Argument '%s' of '%s' with PASS(%s) at %L must be of the derived-type '%s'"
 msgstr ""
 
-#: fortran/resolve.c:8573
+#: fortran/resolve.c:8576
 #, no-c-format
 msgid ""
 "Polymorphic entities are not yet implemented, non-polymorphic passed-object "
 "dummy argument of '%s' at %L accepted"
 msgstr ""
 
-#: fortran/resolve.c:8598
+#: fortran/resolve.c:8601
 #, no-c-format
 msgid "Procedure '%s' at %L has the same name as a component of '%s'"
 msgstr ""
 
-#: fortran/resolve.c:8607
+#: fortran/resolve.c:8610
 #, no-c-format
 msgid ""
 "Procedure '%s' at %L has the same name as an inherited component of '%s'"
 msgstr ""
 
-#: fortran/resolve.c:8675
+#: fortran/resolve.c:8678
 #, no-c-format
 msgid "Non-extensible derived-type '%s' at %L must not be ABSTRACT"
 msgstr ""
 
-#: fortran/resolve.c:8692
+#: fortran/resolve.c:8695
 #, no-c-format
 msgid ""
 "Component '%s' of '%s' at %L has the same name as an inherited type-bound "
 "procedure"
 msgstr ""
 
-#: fortran/resolve.c:8704
+#: fortran/resolve.c:8707
 #, no-c-format
 msgid ""
 "Character length of component '%s' needs to be a constant specification "
 "expression at %L"
 msgstr ""
 
-#: fortran/resolve.c:8719
+#: fortran/resolve.c:8722
 #, no-c-format
 msgid ""
 "The component '%s' is a PRIVATE type and cannot be a component of '%s', "
 "which is PUBLIC at %L"
 msgstr ""
 
-#: fortran/resolve.c:8729
+#: fortran/resolve.c:8732
 #, no-c-format
 msgid ""
 "Component %s of SEQUENCE type declared at %L does not have the SEQUENCE "
 "attribute"
 msgstr ""
 
-#: fortran/resolve.c:8740
+#: fortran/resolve.c:8743
 #, no-c-format
 msgid ""
 "The pointer component '%s' of '%s' at %L is a type that has not been declared"
 msgstr ""
 
-#: fortran/resolve.c:8768
+#: fortran/resolve.c:8771
 #, no-c-format
 msgid "Component '%s' of '%s' at %L must have constant array bounds"
 msgstr ""
 
-#: fortran/resolve.c:8809
+#: fortran/resolve.c:8812
 #, no-c-format
 msgid ""
 "NAMELIST object '%s' was declared PRIVATE and cannot be member of PUBLIC "
 "namelist '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8819
+#: fortran/resolve.c:8822
 #, no-c-format
 msgid ""
 "NAMELIST object '%s' has use-associated PRIVATE components and cannot be "
 "member of namelist '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8832
+#: fortran/resolve.c:8835
 #, no-c-format
 msgid ""
 "NAMELIST object '%s' has PRIVATE components and cannot be a member of PUBLIC "
 "namelist '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8844
+#: fortran/resolve.c:8847
 #, no-c-format
 msgid ""
 "NAMELIST array object '%s' must not have assumed shape in namelist '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8853
+#: fortran/resolve.c:8856
 #, no-c-format
 msgid ""
 "NAMELIST array object '%s' must have constant shape in namelist '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8865
+#: fortran/resolve.c:8868
 #, no-c-format
 msgid ""
 "NAMELIST object '%s' in namelist '%s' at %L cannot have ALLOCATABLE "
 "components"
 msgstr ""
 
-#: fortran/resolve.c:8873
+#: fortran/resolve.c:8876
 #, no-c-format
 msgid ""
 "NAMELIST object '%s' in namelist '%s' at %L cannot have POINTER components"
 msgstr ""
 
-#: fortran/resolve.c:8899
+#: fortran/resolve.c:8902
 #, no-c-format
 msgid "PROCEDURE attribute conflicts with NAMELIST attribute in '%s' at %L"
 msgstr ""
 
-#: fortran/resolve.c:8918
+#: fortran/resolve.c:8921
 #, no-c-format
 msgid "Parameter array '%s' at %L cannot be automatic or of deferred shape"
 msgstr ""
 
-#: fortran/resolve.c:8929
+#: fortran/resolve.c:8932
 #, no-c-format
 msgid ""
 "Implicitly typed PARAMETER '%s' at %L doesn't match a later IMPLICIT type"
 msgstr ""
 
-#: fortran/resolve.c:8940
+#: fortran/resolve.c:8943
 #, no-c-format
 msgid "Incompatible derived type in PARAMETER at %L"
 msgstr ""
 
-#: fortran/resolve.c:8999
+#: fortran/resolve.c:9002
 #, no-c-format
 msgid ""
 "Interface '%s', used by procedure '%s' at %L, is declared in a later "
 "PROCEDURE statement"
 msgstr ""
 
-#: fortran/resolve.c:9047
+#: fortran/resolve.c:9050
 #, no-c-format
 msgid "Interface '%s' of procedure '%s' at %L must be explicit"
 msgstr ""
 
-#: fortran/resolve.c:9080
+#: fortran/resolve.c:9083
 #, no-c-format
 msgid "Type specified for intrinsic function '%s' at %L is ignored"
 msgstr ""
 
-#: fortran/resolve.c:9087
+#: fortran/resolve.c:9090
 #, no-c-format
 msgid "Intrinsic subroutine '%s' at %L shall not have a type specifier"
 msgstr ""
 
-#: fortran/resolve.c:9094
+#: fortran/resolve.c:9097
 #, no-c-format
 msgid "'%s' declared INTRINSIC at %L does not exist"
 msgstr ""
 
-#: fortran/resolve.c:9103
+#: fortran/resolve.c:9106
 #, no-c-format
 msgid ""
 "The intrinsic '%s' declared INTRINSIC at %L is not available in the current "
@@ -10339,229 +10339,229 @@
 "intrinsics in order to use it."
 msgstr ""
 
-#: fortran/resolve.c:9147
+#: fortran/resolve.c:9150
 #, no-c-format
 msgid "Assumed size array at %L must be a dummy argument"
 msgstr ""
 
-#: fortran/resolve.c:9150
+#: fortran/resolve.c:9153
 #, no-c-format
 msgid "Assumed shape array at %L must be a dummy argument"
 msgstr ""
 
-#: fortran/resolve.c:9162
+#: fortran/resolve.c:9165
 #, no-c-format
 msgid "Symbol at %L is not a DUMMY variable"
 msgstr ""
 
-#: fortran/resolve.c:9168
+#: fortran/resolve.c:9171
 #, no-c-format
 msgid ""
 "'%s' at %L cannot have the VALUE attribute because it is not a dummy argument"
 msgstr ""
 
-#: fortran/resolve.c:9178
+#: fortran/resolve.c:9181
 #, no-c-format
 msgid ""
 "Character dummy variable '%s' at %L with VALUE attribute must have constant "
 "length"
 msgstr ""
 
-#: fortran/resolve.c:9187
+#: fortran/resolve.c:9190
 #, no-c-format
 msgid ""
 "C interoperable character dummy variable '%s' at %L with VALUE attribute "
 "must have length one"
 msgstr ""
 
-#: fortran/resolve.c:9213
+#: fortran/resolve.c:9216
 #, no-c-format
 msgid ""
 "Variable '%s' at %L cannot be BIND(C) because it is neither a COMMON block "
 "nor declared at the module level scope"
 msgstr ""
 
-#: fortran/resolve.c:9266
+#: fortran/resolve.c:9269
 #, no-c-format
 msgid "The derived type '%s' at %L is of type '%s', which has not been defined"
 msgstr ""
 
-#: fortran/resolve.c:9307
+#: fortran/resolve.c:9310
 #, no-c-format
 msgid "Fortran 2003: PUBLIC %s '%s' at %L of PRIVATE derived type '%s'"
 msgstr ""
 
-#: fortran/resolve.c:9326
+#: fortran/resolve.c:9329
 #, no-c-format
 msgid ""
 "The INTENT(OUT) dummy argument '%s' at %L is ASSUMED SIZE and so cannot have "
 "a default initializer"
 msgstr ""
 
-#: fortran/resolve.c:9385
+#: fortran/resolve.c:9388
 #, no-c-format
 msgid "Threadprivate at %L isn't SAVEd"
 msgstr ""
 
-#: fortran/resolve.c:9470
+#: fortran/resolve.c:9473
 #, no-c-format
 msgid "BLOCK DATA element '%s' at %L must be in COMMON"
 msgstr ""
 
-#: fortran/resolve.c:9476
+#: fortran/resolve.c:9479
 #, no-c-format
 msgid "DATA array '%s' at %L must be specified in a previous declaration"
 msgstr ""
 
-#: fortran/resolve.c:9521
+#: fortran/resolve.c:9524
 #, no-c-format
 msgid "Nonconstant array section at %L in DATA statement"
 msgstr ""
 
-#: fortran/resolve.c:9534
+#: fortran/resolve.c:9537
 #, no-c-format
 msgid "DATA statement at %L has more variables than values"
 msgstr ""
 
-#: fortran/resolve.c:9628
+#: fortran/resolve.c:9631
 #, no-c-format
 msgid "iterator start at %L does not simplify"
 msgstr ""
 
-#: fortran/resolve.c:9635
+#: fortran/resolve.c:9638
 #, no-c-format
 msgid "iterator end at %L does not simplify"
 msgstr ""
 
-#: fortran/resolve.c:9642
+#: fortran/resolve.c:9645
 #, no-c-format
 msgid "iterator step at %L does not simplify"
 msgstr ""
 
-#: fortran/resolve.c:9768
+#: fortran/resolve.c:9771
 #, no-c-format
 msgid "DATA statement at %L has more values than variables"
 msgstr ""
 
-#: fortran/resolve.c:9859
+#: fortran/resolve.c:9862
 #, no-c-format
 msgid "Label %d at %L defined but not used"
 msgstr ""
 
-#: fortran/resolve.c:9864
+#: fortran/resolve.c:9867
 #, no-c-format
 msgid "Label %d at %L defined but cannot be used"
 msgstr ""
 
-#: fortran/resolve.c:9949
+#: fortran/resolve.c:9952
 #, no-c-format
 msgid ""
 "Derived type variable '%s' at %L must have SEQUENCE attribute to be an "
 "EQUIVALENCE object"
 msgstr ""
 
-#: fortran/resolve.c:9958
+#: fortran/resolve.c:9961
 #, no-c-format
 msgid ""
 "Derived type variable '%s' at %L cannot have ALLOCATABLE components to be an "
 "EQUIVALENCE object"
 msgstr ""
 
-#: fortran/resolve.c:9966
+#: fortran/resolve.c:9969
 #, no-c-format
 msgid ""
 "Derived type variable '%s' at %L with default initialization cannot be in "
 "EQUIVALENCE with a variable in COMMON"
 msgstr ""
 
-#: fortran/resolve.c:9983
+#: fortran/resolve.c:9986
 #, no-c-format
 msgid ""
 "Derived type variable '%s' at %L with pointer component(s) cannot be an "
 "EQUIVALENCE object"
 msgstr ""
 
-#: fortran/resolve.c:10088
+#: fortran/resolve.c:10091
 #, no-c-format
 msgid "Syntax error in EQUIVALENCE statement at %L"
 msgstr ""
 
-#: fortran/resolve.c:10103
+#: fortran/resolve.c:10106
 #, no-c-format
 msgid ""
 "Either all or none of the objects in the EQUIVALENCE set at %L shall have "
 "the PROTECTED attribute"
 msgstr ""
 
-#: fortran/resolve.c:10115
+#: fortran/resolve.c:10118
 #, no-c-format
 msgid ""
 "Common block member '%s' at %L cannot be an EQUIVALENCE object in the pure "
 "procedure '%s'"
 msgstr ""
 
-#: fortran/resolve.c:10124
+#: fortran/resolve.c:10127
 #, no-c-format
 msgid "Named constant '%s' at %L cannot be an EQUIVALENCE object"
 msgstr ""
 
-#: fortran/resolve.c:10203
+#: fortran/resolve.c:10206
 #, no-c-format
 msgid ""
 "Array '%s' at %L with non-constant bounds cannot be an EQUIVALENCE object"
 msgstr ""
 
-#: fortran/resolve.c:10214
+#: fortran/resolve.c:10217
 #, no-c-format
 msgid "Structure component '%s' at %L cannot be an EQUIVALENCE object"
 msgstr ""
 
-#: fortran/resolve.c:10225
+#: fortran/resolve.c:10228
 #, no-c-format
 msgid "Substring at %L has length zero"
 msgstr ""
 
-#: fortran/resolve.c:10269
+#: fortran/resolve.c:10272
 #, no-c-format
 msgid "Fortran 2003: PUBLIC function '%s' at %L of PRIVATE type '%s'"
 msgstr ""
 
-#: fortran/resolve.c:10282
+#: fortran/resolve.c:10285
 #, no-c-format
 msgid "ENTRY '%s' at %L has no IMPLICIT type"
 msgstr ""
 
-#: fortran/resolve.c:10308
+#: fortran/resolve.c:10311
 #, no-c-format
 msgid "User operator procedure '%s' at %L must be a FUNCTION"
 msgstr ""
 
-#: fortran/resolve.c:10315
+#: fortran/resolve.c:10318
 #, no-c-format
 msgid "User operator procedure '%s' at %L cannot be assumed character length"
 msgstr ""
 
-#: fortran/resolve.c:10321
+#: fortran/resolve.c:10324
 #, no-c-format
 msgid "User operator procedure '%s' at %L must have at least one argument"
 msgstr ""
 
-#: fortran/resolve.c:10331
+#: fortran/resolve.c:10334
 #, no-c-format
 msgid "First argument of operator interface at %L cannot be optional"
 msgstr ""
 
-#: fortran/resolve.c:10343
+#: fortran/resolve.c:10346
 #, no-c-format
 msgid "Second argument of operator interface at %L cannot be optional"
 msgstr ""
 
-#: fortran/resolve.c:10347
+#: fortran/resolve.c:10350
 #, no-c-format
 msgid "Operator interface at %L must have, at most, two arguments"
 msgstr ""
 
-#: fortran/resolve.c:10401
+#: fortran/resolve.c:10404
 #, no-c-format
 msgid "Contained procedure '%s' at %L of a PURE procedure must also be PURE"
 msgstr ""
@@ -11367,32 +11367,32 @@
 msgid "Assigning value other than 0 or 1 to LOGICAL has undefined result at %L"
 msgstr ""
 
-#: fortran/trans-decl.c:2868 fortran/trans-decl.c:3906
+#: fortran/trans-decl.c:2870 fortran/trans-decl.c:3908
 #, no-c-format
 msgid "Return value of function '%s' at %L not set"
 msgstr ""
 
-#: fortran/trans-decl.c:3527
+#: fortran/trans-decl.c:3529
 #, no-c-format
 msgid "Dummy argument '%s' at %L was declared INTENT(OUT) but was not set"
 msgstr ""
 
-#: fortran/trans-decl.c:3531
+#: fortran/trans-decl.c:3533
 #, no-c-format
 msgid "Unused dummy argument '%s' at %L"
 msgstr ""
 
-#: fortran/trans-decl.c:3537
+#: fortran/trans-decl.c:3539
 #, no-c-format
 msgid "Unused variable '%s' declared at %L"
 msgstr ""
 
-#: fortran/trans-decl.c:3583
+#: fortran/trans-decl.c:3585
 #, no-c-format
 msgid "Unused parameter '%s' declared at %L"
 msgstr ""
 
-#: fortran/trans-decl.c:3597
+#: fortran/trans-decl.c:3599
 #, no-c-format
 msgid "Return value '%s' of function '%s' declared at %L not set"
 msgstr ""
@@ -11662,7 +11662,7 @@
 msgid "GCC does not support -C or -CC without -E"
 msgstr ""
 
-#: gcc.c:828 java/jvspec.c:80
+#: gcc.c:828 java/jvspec.c:80 ada/gcc-interface/lang-specs.h:33
 msgid "-pg and -fomit-frame-pointer are incompatible"
 msgstr ""
 
@@ -11670,46 +11670,50 @@
 msgid "-E or -x required when input is from standard input"
 msgstr ""
 
-#: config/darwin.h:270
+#: config/darwin.h:274
 msgid "-current_version only allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:272
+#: config/darwin.h:276
 msgid "-install_name only allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:277
+#: config/darwin.h:281
 msgid "-bundle not allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:278
+#: config/darwin.h:282
 msgid "-bundle_loader not allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:279
+#: config/darwin.h:283
 msgid "-client_name not allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:284
+#: config/darwin.h:288
 msgid "-force_flat_namespace not allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:286
+#: config/darwin.h:290
 msgid "-keep_private_externs not allowed with -dynamiclib"
 msgstr ""
 
-#: config/darwin.h:287
+#: config/darwin.h:291
 msgid "-private_bundle not allowed with -dynamiclib"
 msgstr ""
 
+#: ada/gcc-interface/lang-specs.h:34
+msgid "-c or -S required for Ada"
+msgstr ""
+
 #: config/sparc/sol2-bi.h:189 config/sparc/sol2-bi.h:194
 #: config/sparc/sol2-gld-bi.h:17 config/sparc/sol2-gld-bi.h:22
 msgid "does not support multilib"
 msgstr ""
 
-#: config/rs6000/linux64.h:345 config/rs6000/linux64.h:347
-#: config/rs6000/sysv4.h:902 config/rs6000/sysv4.h:904 config/linux.h:106
-#: config/linux.h:108 config/alpha/linux-elf.h:33 config/alpha/linux-elf.h:35
+#: config/rs6000/linux64.h:350 config/rs6000/linux64.h:352
+#: config/rs6000/sysv4.h:907 config/rs6000/sysv4.h:909 config/linux.h:111
+#: config/linux.h:113 config/alpha/linux-elf.h:33 config/alpha/linux-elf.h:35
 msgid "-mglibc and -muclibc used together"
 msgstr ""
 
@@ -16257,1218 +16261,1214 @@
 msgstr ""
 
 #: common.opt:99
-msgid "Warn on calls to these functions"
-msgstr ""
-
-#: common.opt:103
 msgid "Treat all warnings as errors"
 msgstr ""
 
-#: common.opt:107
+#: common.opt:103
 msgid "Treat specified warning as error"
 msgstr ""
 
-#: common.opt:111
+#: common.opt:107
 msgid "Print extra (possibly unwanted) warnings"
 msgstr ""
 
-#: common.opt:115
+#: common.opt:111
 msgid "Exit on the first error occurred"
 msgstr ""
 
-#: common.opt:119
+#: common.opt:115
 msgid ""
 "-Wframe-larger-than=<number> Warn if a function's stack frame requires more "
 "than <number> bytes"
 msgstr ""
 
-#: common.opt:123
+#: common.opt:119
 msgid "Warn when an inlined function cannot be inlined"
 msgstr ""
 
-#: common.opt:130
+#: common.opt:126
 msgid "Warn if an object is larger than <number> bytes"
 msgstr ""
 
-#: common.opt:134
+#: common.opt:130
 msgid ""
 "Warn when a logical operator is suspicously always evaluating to true or "
 "false"
 msgstr ""
 
-#: common.opt:138
+#: common.opt:134
 msgid "Warn if the loop cannot be optimized due to nontrivial assumptions."
 msgstr ""
 
-#: common.opt:142
+#: common.opt:138
 msgid ""
 "Warn about functions which might be candidates for __attribute__((noreturn))"
 msgstr ""
 
-#: common.opt:146
+#: common.opt:142
 msgid "Warn about constructs not instrumented by -fmudflap"
 msgstr ""
 
-#: common.opt:150
+#: common.opt:146
 msgid "Warn about overflow in arithmetic expressions"
 msgstr ""
 
-#: common.opt:154
+#: common.opt:150
 msgid "Warn when the packed attribute has no effect on struct layout"
 msgstr ""
 
-#: common.opt:158
+#: common.opt:154
 msgid "Warn when padding is required to align structure members"
 msgstr ""
 
-#: common.opt:162
+#: common.opt:158
 msgid "Warn when one local variable shadows another"
 msgstr ""
 
-#: common.opt:166
+#: common.opt:162
 msgid "Warn when not issuing stack smashing protection for some reason"
 msgstr ""
 
-#: common.opt:170 common.opt:174
+#: common.opt:166 common.opt:170
 msgid "Warn about code which might break strict aliasing rules"
 msgstr ""
 
-#: common.opt:178 common.opt:182
+#: common.opt:174 common.opt:178
 msgid "Warn about optimizations that assume that signed overflow is undefined"
 msgstr ""
 
-#: common.opt:186
+#: common.opt:182
 msgid "Warn about enumerated switches, with no default, missing a case"
 msgstr ""
 
-#: common.opt:190
+#: common.opt:186
 msgid "Warn about enumerated switches missing a \"default:\" statement"
 msgstr ""
 
-#: common.opt:194
+#: common.opt:190
 msgid "Warn about all enumerated switches missing a specific case"
 msgstr ""
 
-#: common.opt:198
+#: common.opt:194
 msgid "Do not suppress warnings from system headers"
 msgstr ""
 
-#: common.opt:202
+#: common.opt:198
 msgid ""
 "Warn if a comparison is always true or always false due to the limited range "
 "of the data type"
 msgstr ""
 
-#: common.opt:206
+#: common.opt:202
 msgid "Warn about uninitialized automatic variables"
 msgstr ""
 
-#: common.opt:210
+#: common.opt:206
 msgid "Warn about code that will never be executed"
 msgstr ""
 
-#: common.opt:214
+#: common.opt:210
 msgid "Enable all -Wunused- warnings"
 msgstr ""
 
-#: common.opt:218
+#: common.opt:214
 msgid "Warn when a function is unused"
 msgstr ""
 
-#: common.opt:222
+#: common.opt:218
 msgid "Warn when a label is unused"
 msgstr ""
 
-#: common.opt:226
+#: common.opt:222
 msgid "Warn when a function parameter is unused"
 msgstr ""
 
-#: common.opt:230
+#: common.opt:226
 msgid "Warn when an expression value is unused"
 msgstr ""
 
-#: common.opt:234
+#: common.opt:230
 msgid "Warn when a variable is unused"
 msgstr ""
 
-#: common.opt:238
+#: common.opt:234
 msgid "Warn instead of error in case profiles in -fprofile-use do not match"
 msgstr ""
 
-#: common.opt:242
+#: common.opt:238
 msgid "Emit declaration information into <file>"
 msgstr ""
 
-#: common.opt:255
+#: common.opt:251
 msgid "Enable dumps from specific passes of the compiler"
 msgstr ""
 
-#: common.opt:259
+#: common.opt:255
 msgid "Set the file basename to be used for dumps"
 msgstr ""
 
-#: common.opt:279
+#: common.opt:275
 msgid "Align the start of functions"
 msgstr ""
 
-#: common.opt:286
+#: common.opt:282
 msgid "Align labels which are only reached by jumping"
 msgstr ""
 
-#: common.opt:293
+#: common.opt:289
 msgid "Align all labels"
 msgstr ""
 
-#: common.opt:300
+#: common.opt:296
 msgid "Align the start of loops"
 msgstr ""
 
-#: common.opt:315
+#: common.opt:311
 msgid "Specify that arguments may alias each other and globals"
 msgstr ""
 
-#: common.opt:319
+#: common.opt:315
 msgid "Assume arguments may alias globals but not each other"
 msgstr ""
 
-#: common.opt:323
+#: common.opt:319
 msgid "Assume arguments alias neither each other nor globals"
 msgstr ""
 
-#: common.opt:327
+#: common.opt:323
 msgid "Assume arguments alias no other storage"
 msgstr ""
 
-#: common.opt:331
+#: common.opt:327
 msgid "Generate unwind tables that are exact at each instruction boundary"
 msgstr ""
 
-#: common.opt:335
+#: common.opt:331
 msgid "Generate auto-inc/dec instructions"
 msgstr ""
 
-#: common.opt:343
+#: common.opt:339
 msgid "Generate code to check bounds before indexing arrays"
 msgstr ""
 
-#: common.opt:347
+#: common.opt:343
 msgid "Replace add, compare, branch with branch on count register"
 msgstr ""
 
-#: common.opt:351
+#: common.opt:347
 msgid "Use profiling information for branch probabilities"
 msgstr ""
 
-#: common.opt:355
+#: common.opt:351
 msgid ""
 "Perform branch target load optimization before prologue / epilogue threading"
 msgstr ""
 
-#: common.opt:359
+#: common.opt:355
 msgid ""
 "Perform branch target load optimization after prologue / epilogue threading"
 msgstr ""
 
-#: common.opt:363
+#: common.opt:359
 msgid ""
 "Restrict target load migration not to re-use registers in any basic block"
 msgstr ""
 
-#: common.opt:367
+#: common.opt:363
 msgid "Mark <register> as being preserved across functions"
 msgstr ""
 
-#: common.opt:371
+#: common.opt:367
 msgid "Mark <register> as being corrupted by function calls"
 msgstr ""
 
-#: common.opt:378
+#: common.opt:374
 msgid "Save registers around function calls"
 msgstr ""
 
-#: common.opt:382
+#: common.opt:378
 msgid "Compare the results of several data dependence analyzers."
 msgstr ""
 
-#: common.opt:386
+#: common.opt:382
 msgid "Do not put uninitialized globals in the common section"
 msgstr ""
 
-#: common.opt:390
+#: common.opt:386
 msgid "Do not perform optimizations increasing noticeably stack usage"
 msgstr ""
 
-#: common.opt:394
+#: common.opt:390
 msgid "Perform a register copy-propagation optimization pass"
 msgstr ""
 
-#: common.opt:398
+#: common.opt:394
 msgid "Perform cross-jumping optimization"
 msgstr ""
 
-#: common.opt:402
+#: common.opt:398
 msgid "When running CSE, follow jumps to their targets"
 msgstr ""
 
-#: common.opt:406
+#: common.opt:402
 msgid "When running CSE, follow conditional jumps"
 msgstr ""
 
-#: common.opt:410
+#: common.opt:406
 msgid "Omit range reduction step when performing complex division"
 msgstr ""
 
-#: common.opt:414
+#: common.opt:410
 msgid "Complex multiplication and division follow Fortran rules"
 msgstr ""
 
-#: common.opt:418
+#: common.opt:414
 msgid "Place data items into their own section"
 msgstr ""
 
-#: common.opt:422
+#: common.opt:418
 msgid "List all available debugging counters with their limits and counts."
 msgstr ""
 
-#: common.opt:426
+#: common.opt:422
 msgid ""
 "-fdbg-cnt=<counter>:<limit>[,<counter>:<limit>,...]    Set the debug counter "
 "limit.   "
 msgstr ""
 
-#: common.opt:430
+#: common.opt:426
 msgid "Map one directory name to another in debug information"
 msgstr ""
 
-#: common.opt:436
+#: common.opt:432
 msgid "Defer popping functions args from stack until later"
 msgstr ""
 
-#: common.opt:440
+#: common.opt:436
 msgid "Attempt to fill delay slots of branch instructions"
 msgstr ""
 
-#: common.opt:444
+#: common.opt:440
 msgid "Delete useless null pointer checks"
 msgstr ""
 
-#: common.opt:448
+#: common.opt:444
 msgid ""
 "How often to emit source location at the beginning of line-wrapped "
 "diagnostics"
 msgstr ""
 
-#: common.opt:452
+#: common.opt:448
 msgid ""
 "Amend appropriate diagnostic messages with the command line option that "
 "controls them"
 msgstr ""
 
-#: common.opt:456
+#: common.opt:452
 msgid "Dump various compiler internals to a file"
 msgstr ""
 
-#: common.opt:460
+#: common.opt:456
 msgid "Suppress output of addresses in debugging dumps"
 msgstr ""
 
-#: common.opt:464
+#: common.opt:460
 msgid ""
 "Suppress output of instruction numbers, line number notes and addresses in "
 "debugging dumps"
 msgstr ""
 
-#: common.opt:468
+#: common.opt:464
 msgid "Enable CFI tables via GAS assembler directives."
 msgstr ""
 
-#: common.opt:472
+#: common.opt:468
 msgid "Perform early inlining"
 msgstr ""
 
-#: common.opt:476
+#: common.opt:472
 msgid "Perform DWARF2 duplicate elimination"
 msgstr ""
 
-#: common.opt:480 common.opt:484
+#: common.opt:476 common.opt:480
 msgid "Perform unused type elimination in debug info"
 msgstr ""
 
-#: common.opt:488
+#: common.opt:484
 msgid "Do not suppress C++ class debug information."
 msgstr ""
 
-#: common.opt:492
+#: common.opt:488
 msgid "Enable exception handling"
 msgstr ""
 
-#: common.opt:496
+#: common.opt:492
 msgid "Perform a number of minor, expensive optimizations"
 msgstr ""
 
-#: common.opt:503
+#: common.opt:499
 msgid "Assume no NaNs or infinities are generated"
 msgstr ""
 
-#: common.opt:507
+#: common.opt:503
 msgid "Mark <register> as being unavailable to the compiler"
 msgstr ""
 
-#: common.opt:511
+#: common.opt:507
 msgid "Don't allocate floats and doubles in extended-precision registers"
 msgstr ""
 
-#: common.opt:515 common.opt:728 common.opt:949 common.opt:1105
-#: common.opt:1164 common.opt:1180 common.opt:1240
+#: common.opt:511 common.opt:724 common.opt:945 common.opt:1101
+#: common.opt:1160 common.opt:1176 common.opt:1236
 msgid "Does nothing.  Preserved for backward compatibility."
 msgstr ""
 
-#: common.opt:519
+#: common.opt:515
 msgid "Perform a forward propagation pass on RTL"
 msgstr ""
 
-#: common.opt:526
+#: common.opt:522
 msgid "Allow function addresses to be held in registers"
 msgstr ""
 
-#: common.opt:530
+#: common.opt:526
 msgid "Place each function into its own section"
 msgstr ""
 
-#: common.opt:534
+#: common.opt:530
 msgid "Perform global common subexpression elimination"
 msgstr ""
 
-#: common.opt:538
+#: common.opt:534
 msgid ""
 "Perform enhanced load motion during global common subexpression elimination"
 msgstr ""
 
-#: common.opt:542
+#: common.opt:538
 msgid "Perform store motion after global common subexpression elimination"
 msgstr ""
 
-#: common.opt:546
+#: common.opt:542
 msgid ""
 "Perform redundant load after store elimination in global common subexpression"
 msgstr ""
 
-#: common.opt:551
+#: common.opt:547
 msgid ""
 "Perform global common subexpression elimination after register allocation"
 msgstr ""
 
-#: common.opt:557
+#: common.opt:553
 msgid "Enable in and out of Graphite representation"
 msgstr ""
 
-#: common.opt:561
+#: common.opt:557
 msgid "Enable Loop Strip Mining transformation"
 msgstr ""
 
-#: common.opt:565
+#: common.opt:561
 msgid "Enable Loop Interchange transformation"
 msgstr ""
 
-#: common.opt:569
+#: common.opt:565
 msgid "Enable Loop Blocking transformation"
 msgstr ""
 
-#: common.opt:574
+#: common.opt:570
 msgid "Enable Graphite Identity transformation"
 msgstr ""
 
-#: common.opt:578
+#: common.opt:574
 msgid "Enable guessing of branch probabilities"
 msgstr ""
 
-#: common.opt:586
+#: common.opt:582
 msgid "Process #ident directives"
 msgstr ""
 
-#: common.opt:590
+#: common.opt:586
 msgid "Perform conversion of conditional jumps to branchless equivalents"
 msgstr ""
 
-#: common.opt:594
+#: common.opt:590
 msgid "Perform conversion of conditional jumps to conditional execution"
 msgstr ""
 
-#: common.opt:602
+#: common.opt:598
 msgid "Do not generate .size directives"
 msgstr ""
 
-#: common.opt:606
+#: common.opt:602
 msgid "Perform indirect inlining"
 msgstr ""
 
-#: common.opt:615
+#: common.opt:611
 msgid "Pay attention to the \"inline\" keyword"
 msgstr ""
 
-#: common.opt:619
+#: common.opt:615
 msgid ""
 "Integrate simple functions into their callers when code size is known to not "
 "growth"
 msgstr ""
 
-#: common.opt:623
+#: common.opt:619
 msgid "Integrate simple functions into their callers"
 msgstr ""
 
-#: common.opt:627
+#: common.opt:623
 msgid "Integrate functions called once into their callers"
 msgstr ""
 
-#: common.opt:634
+#: common.opt:630
 msgid "Limit the size of inlined functions to <number>"
 msgstr ""
 
-#: common.opt:638
+#: common.opt:634
 msgid "Instrument function entry and exit with profiling calls"
 msgstr ""
 
-#: common.opt:642
+#: common.opt:638
 msgid ""
 "-finstrument-functions-exclude-function-list=name,...  Do not instrument "
 "listed functions"
 msgstr ""
 
-#: common.opt:646
+#: common.opt:642
 msgid ""
 "-finstrument-functions-exclude-file-list=filename,...  Do not instrument "
 "functions listed in files"
 msgstr ""
 
-#: common.opt:650
+#: common.opt:646
 msgid "Perform Interprocedural constant propagation"
 msgstr ""
 
-#: common.opt:654
+#: common.opt:650
 msgid "Perform cloning to make Interprocedural constant propagation stronger"
 msgstr ""
 
-#: common.opt:658
+#: common.opt:654
 msgid "Discover pure and const functions"
 msgstr ""
 
-#: common.opt:662
+#: common.opt:658
 msgid "Perform interprocedural points-to analysis"
 msgstr ""
 
-#: common.opt:666
+#: common.opt:662
 msgid "Discover readonly and non addressable static variables"
 msgstr ""
 
-#: common.opt:670
+#: common.opt:666
 msgid "Type based escape and alias analysis"
 msgstr ""
 
-#: common.opt:674
+#: common.opt:670
 msgid "Perform matrix layout flattening and transposing based"
 msgstr ""
 
-#: common.opt:679
+#: common.opt:675
 msgid "Perform structure layout optimizations based"
 msgstr ""
 
-#: common.opt:684
+#: common.opt:680
 msgid "-fira-algorithm=[CB|priority] Set the used IRA algorithm"
 msgstr ""
 
-#: common.opt:688
+#: common.opt:684
 msgid "-fira-region=[one|all|mixed] Set regions for IRA"
 msgstr ""
 
-#: common.opt:692
+#: common.opt:688
 msgid "Do optimistic coalescing."
 msgstr ""
 
-#: common.opt:696
+#: common.opt:692
 msgid "Share slots for saving different hard registers."
 msgstr ""
 
-#: common.opt:700
+#: common.opt:696
 msgid "Share stack slots for spilled pseudo-registers."
 msgstr ""
 
-#: common.opt:704
+#: common.opt:700
 msgid "-fira-verbose=<number> Control IRA's level of diagnostic messages."
 msgstr ""
 
-#: common.opt:708
+#: common.opt:704
 msgid "Optimize induction variables on trees"
 msgstr ""
 
-#: common.opt:712
+#: common.opt:708
 msgid "Use jump tables for sufficiently large switch statements"
 msgstr ""
 
-#: common.opt:716
+#: common.opt:712
 msgid "Generate code for functions even if they are fully inlined"
 msgstr ""
 
-#: common.opt:720
+#: common.opt:716
 msgid "Emit static const variables even if they are not used"
 msgstr ""
 
-#: common.opt:724
+#: common.opt:720
 msgid "Give external symbols a leading underscore"
 msgstr ""
 
-#: common.opt:732
+#: common.opt:728
 msgid "Set errno after built-in math functions"
 msgstr ""
 
-#: common.opt:736
+#: common.opt:732
 msgid "Report on permanent memory allocation"
 msgstr ""
 
-#: common.opt:743
+#: common.opt:739
 msgid "Attempt to merge identical constants and constant variables"
 msgstr ""
 
-#: common.opt:747
+#: common.opt:743
 msgid "Attempt to merge identical constants across compilation units"
 msgstr ""
 
-#: common.opt:751
+#: common.opt:747
 msgid "Attempt to merge identical debug strings across compilation units"
 msgstr ""
 
-#: common.opt:755
+#: common.opt:751
 msgid ""
 "Limit diagnostics to <number> characters per line.  0 suppresses line-"
 "wrapping"
 msgstr ""
 
-#: common.opt:759
+#: common.opt:755
 msgid "Perform SMS based modulo scheduling before the first scheduling pass"
 msgstr ""
 
-#: common.opt:763
+#: common.opt:759
 msgid "Perform SMS based modulo scheduling with register moves allowed"
 msgstr ""
 
-#: common.opt:767
+#: common.opt:763
 msgid "Move loop invariant computations out of loops"
 msgstr ""
 
-#: common.opt:771
+#: common.opt:767
 msgid "Add mudflap bounds-checking instrumentation for single-threaded program"
 msgstr ""
 
-#: common.opt:775
+#: common.opt:771
 msgid "Add mudflap bounds-checking instrumentation for multi-threaded program"
 msgstr ""
 
-#: common.opt:779
+#: common.opt:775
 msgid "Ignore read operations when inserting mudflap instrumentation"
 msgstr ""
 
-#: common.opt:783
+#: common.opt:779
 msgid "Use the RTL dead code elimination pass"
 msgstr ""
 
-#: common.opt:787
+#: common.opt:783
 msgid "Use the RTL dead store elimination pass"
 msgstr ""
 
-#: common.opt:791
+#: common.opt:787
 msgid ""
 "Enable/Disable the traditional scheduling in loops that already passed "
 "modulo scheduling"
 msgstr ""
 
-#: common.opt:795
+#: common.opt:791
 msgid "Support synchronous non-call exceptions"
 msgstr ""
 
-#: common.opt:799
+#: common.opt:795
 msgid "When possible do not generate stack frames"
 msgstr ""
 
-#: common.opt:803
+#: common.opt:799
 msgid "Do the full register move optimization pass"
 msgstr ""
 
-#: common.opt:807
+#: common.opt:803
 msgid "Optimize sibling and tail recursive calls"
 msgstr ""
 
-#: common.opt:811 common.opt:815
+#: common.opt:807 common.opt:811
 msgid "Report on memory allocation before interprocedural optimization"
 msgstr ""
 
-#: common.opt:819
+#: common.opt:815
 msgid "Pack structure members together without holes"
 msgstr ""
 
-#: common.opt:823
+#: common.opt:819
 msgid "Set initial maximum structure member alignment"
 msgstr ""
 
-#: common.opt:827
+#: common.opt:823
 msgid "Return small aggregates in memory, not registers"
 msgstr ""
 
-#: common.opt:831
+#: common.opt:827
 msgid "Perform loop peeling"
 msgstr ""
 
-#: common.opt:835
+#: common.opt:831
 msgid "Enable machine specific peephole optimizations"
 msgstr ""
 
-#: common.opt:839
+#: common.opt:835
 msgid "Enable an RTL peephole pass before sched2"
 msgstr ""
 
-#: common.opt:843
+#: common.opt:839
 msgid "Generate position-independent code if possible (large mode)"
 msgstr ""
 
-#: common.opt:847
+#: common.opt:843
 msgid ""
 "Generate position-independent code for executables if possible (large mode)"
 msgstr ""
 
-#: common.opt:851
+#: common.opt:847
 msgid "Generate position-independent code if possible (small mode)"
 msgstr ""
 
-#: common.opt:855
+#: common.opt:851
 msgid ""
 "Generate position-independent code for executables if possible (small mode)"
 msgstr ""
 
-#: common.opt:859
+#: common.opt:855
 msgid "Run predictive commoning optimization."
 msgstr ""
 
-#: common.opt:863
+#: common.opt:859
 msgid "Generate prefetch instructions, if available, for arrays in loops"
 msgstr ""
 
-#: common.opt:867
+#: common.opt:863
 msgid "Enable basic program profiling code"
 msgstr ""
 
-#: common.opt:871
+#: common.opt:867
 msgid "Insert arc-based program profiling code"
 msgstr ""
 
-#: common.opt:875
+#: common.opt:871
 msgid "Set the top-level directory for storing the profile data."
 msgstr ""
 
-#: common.opt:880
+#: common.opt:876
 msgid "Enable correction of flow inconsistent profile data input"
 msgstr ""
 
-#: common.opt:884
+#: common.opt:880
 msgid ""
 "Enable common options for generating profile info for profile feedback "
 "directed optimizations"
 msgstr ""
 
-#: common.opt:888
+#: common.opt:884
 msgid ""
 "Enable common options for generating profile info for profile feedback "
 "directed optimizations, and set -fprofile-dir="
 msgstr ""
 
-#: common.opt:892
+#: common.opt:888
 msgid ""
 "Enable common options for performing profile feedback directed optimizations"
 msgstr ""
 
-#: common.opt:896
+#: common.opt:892
 msgid ""
 "Enable common options for performing profile feedback directed "
 "optimizations, and set -fprofile-dir="
 msgstr ""
 
-#: common.opt:900
+#: common.opt:896
 msgid "Insert code to profile values of expressions"
 msgstr ""
 
-#: common.opt:907
+#: common.opt:903
 msgid "Make compile reproducible using <string>"
 msgstr ""
 
-#: common.opt:917
+#: common.opt:913
 msgid "Record gcc command line switches in the object file."
 msgstr ""
 
-#: common.opt:921
+#: common.opt:917
 msgid "Return small aggregates in registers"
 msgstr ""
 
-#: common.opt:925
+#: common.opt:921
 msgid "Enables a register move optimization"
 msgstr ""
 
-#: common.opt:929
+#: common.opt:925
 msgid "Perform a register renaming optimization pass"
 msgstr ""
 
-#: common.opt:933
+#: common.opt:929
 msgid "Reorder basic blocks to improve code placement"
 msgstr ""
 
-#: common.opt:937
+#: common.opt:933
 msgid "Reorder basic blocks and partition into hot and cold sections"
 msgstr ""
 
-#: common.opt:941
+#: common.opt:937
 msgid "Reorder functions to improve code placement"
 msgstr ""
 
-#: common.opt:945
+#: common.opt:941
 msgid "Add a common subexpression elimination pass after loop optimizations"
 msgstr ""
 
-#: common.opt:953
+#: common.opt:949
 msgid "Disable optimizations that assume default FP rounding behavior"
 msgstr ""
 
-#: common.opt:957
+#: common.opt:953
 msgid "Enable scheduling across basic blocks"
 msgstr ""
 
-#: common.opt:961
+#: common.opt:957
 msgid "Allow speculative motion of non-loads"
 msgstr ""
 
-#: common.opt:965
+#: common.opt:961
 msgid "Allow speculative motion of some loads"
 msgstr ""
 
-#: common.opt:969
+#: common.opt:965
 msgid "Allow speculative motion of more loads"
 msgstr ""
 
-#: common.opt:973
+#: common.opt:969
 msgid "Set the verbosity level of the scheduler"
 msgstr ""
 
-#: common.opt:977
+#: common.opt:973
 msgid "If scheduling post reload, do superblock scheduling"
 msgstr ""
 
-#: common.opt:981
+#: common.opt:977
 msgid "If scheduling post reload, do trace scheduling"
 msgstr ""
 
-#: common.opt:985
+#: common.opt:981
 msgid "Reschedule instructions before register allocation"
 msgstr ""
 
-#: common.opt:989
+#: common.opt:985
 msgid "Reschedule instructions after register allocation"
 msgstr ""
 
-#: common.opt:996
+#: common.opt:992
 msgid "Schedule instructions using selective scheduling algorithm"
 msgstr ""
 
-#: common.opt:1000
+#: common.opt:996
 msgid "Run selective scheduling after reload"
 msgstr ""
 
-#: common.opt:1004
+#: common.opt:1000
 msgid "Perform software pipelining of inner loops during selective scheduling"
 msgstr ""
 
-#: common.opt:1008
+#: common.opt:1004
 msgid "Perform software pipelining of outer loops during selective scheduling"
 msgstr ""
 
-#: common.opt:1012
+#: common.opt:1008
 msgid "Reschedule pipelined regions without pipelining"
 msgstr ""
 
-#: common.opt:1018
+#: common.opt:1014
 msgid "Allow premature scheduling of queued insns"
 msgstr ""
 
-#: common.opt:1022
+#: common.opt:1018
 msgid "Set number of queued insns that can be prematurely scheduled"
 msgstr ""
 
-#: common.opt:1030 common.opt:1034
+#: common.opt:1026 common.opt:1030
 msgid ""
 "Set dependence distance checking in premature scheduling of queued insns"
 msgstr ""
 
-#: common.opt:1038
+#: common.opt:1034
 msgid "Access data in the same section from shared anchor points"
 msgstr ""
 
-#: common.opt:1042
+#: common.opt:1038
 msgid "Perform sequence abstraction optimization on RTL"
 msgstr ""
 
-#: common.opt:1046
+#: common.opt:1042
 msgid "Eliminate redundant sign extensions using LCM."
 msgstr ""
 
-#: common.opt:1050
+#: common.opt:1046
 msgid "Show column numbers in diagnostics, when available.  Default off"
 msgstr ""
 
-#: common.opt:1054
+#: common.opt:1050
 msgid "Disable optimizations observable by IEEE signaling NaNs"
 msgstr ""
 
-#: common.opt:1058
+#: common.opt:1054
 msgid ""
 "Disable floating point optimizations that ignore the IEEE signedness of zero"
 msgstr ""
 
-#: common.opt:1062
+#: common.opt:1058
 msgid "Convert floating point constants to single precision constants"
 msgstr ""
 
-#: common.opt:1066
+#: common.opt:1062
 msgid "Split lifetimes of induction variables when loops are unrolled"
 msgstr ""
 
-#: common.opt:1070
+#: common.opt:1066
 msgid "Split wide types into independent registers"
 msgstr ""
 
-#: common.opt:1074
+#: common.opt:1070
 msgid "Apply variable expansion when loops are unrolled"
 msgstr ""
 
-#: common.opt:1078
+#: common.opt:1074
 msgid "Insert stack checking code into the program"
 msgstr ""
 
-#: common.opt:1082
+#: common.opt:1078
 msgid ""
 "Insert stack checking code into the program.  Same as -fstack-check=specific"
 msgstr ""
 
-#: common.opt:1089
+#: common.opt:1085
 msgid "Trap if the stack goes past <register>"
 msgstr ""
 
-#: common.opt:1093
+#: common.opt:1089
 msgid "Trap if the stack goes past symbol <name>"
 msgstr ""
 
-#: common.opt:1097
+#: common.opt:1093
 msgid "Use propolice as a stack protection method"
 msgstr ""
 
-#: common.opt:1101
+#: common.opt:1097
 msgid "Use a stack protection method for every function"
 msgstr ""
 
-#: common.opt:1113
+#: common.opt:1109
 msgid "Assume strict aliasing rules apply"
 msgstr ""
 
-#: common.opt:1117
+#: common.opt:1113
 msgid "Treat signed overflow as undefined"
 msgstr ""
 
-#: common.opt:1121
+#: common.opt:1117
 msgid "Check for syntax errors, then stop"
 msgstr ""
 
-#: common.opt:1125
+#: common.opt:1121
 msgid "Create data files needed by \"gcov\""
 msgstr ""
 
-#: common.opt:1129
+#: common.opt:1125
 msgid "Perform jump threading optimizations"
 msgstr ""
 
-#: common.opt:1133
+#: common.opt:1129
 msgid "Report the time taken by each compiler pass"
 msgstr ""
 
-#: common.opt:1137
+#: common.opt:1133
 msgid "Set the default thread-local storage code generation model"
 msgstr ""
 
-#: common.opt:1141
+#: common.opt:1137
 msgid "Reorder top level functions, variables, and asms"
 msgstr ""
 
-#: common.opt:1145
+#: common.opt:1141
 msgid "Perform superblock formation via tail duplication"
 msgstr ""
 
-#: common.opt:1152
+#: common.opt:1148
 msgid "Assume floating-point operations can trap"
 msgstr ""
 
-#: common.opt:1156
+#: common.opt:1152
 msgid "Trap for signed overflow in addition, subtraction and multiplication"
 msgstr ""
 
-#: common.opt:1160
+#: common.opt:1156
 msgid "Enable SSA-CCP optimization on trees"
 msgstr ""
 
-#: common.opt:1168
+#: common.opt:1164
 msgid "Enable loop header copying on trees"
 msgstr ""
 
-#: common.opt:1172
+#: common.opt:1168
 msgid "Replace SSA temporaries with better names in copies"
 msgstr ""
 
-#: common.opt:1176
+#: common.opt:1172
 msgid "Enable copy propagation on trees"
 msgstr ""
 
-#: common.opt:1184
+#: common.opt:1180
 msgid "Transform condition stores into unconditional ones"
 msgstr ""
 
-#: common.opt:1188
+#: common.opt:1184
 msgid "Perform conversions of switch initializations."
 msgstr ""
 
-#: common.opt:1192
+#: common.opt:1188
 msgid "Enable SSA dead code elimination optimization on trees"
 msgstr ""
 
-#: common.opt:1196
+#: common.opt:1192
 msgid "Enable dominator optimizations"
 msgstr ""
 
-#: common.opt:1200
+#: common.opt:1196
 msgid "Enable dead store elimination"
 msgstr ""
 
-#: common.opt:1204
+#: common.opt:1200
 msgid "Enable Full Redundancy Elimination (FRE) on trees"
 msgstr ""
 
-#: common.opt:1208
+#: common.opt:1204
 msgid "Enable loop distribution on trees"
 msgstr ""
 
-#: common.opt:1212
+#: common.opt:1208
 msgid "Enable loop invariant motion on trees"
 msgstr ""
 
-#: common.opt:1216
+#: common.opt:1212
 msgid "Enable linear loop transforms on trees"
 msgstr ""
 
-#: common.opt:1220
+#: common.opt:1216
 msgid "Create canonical induction variables in loops"
 msgstr ""
 
-#: common.opt:1224
+#: common.opt:1220
 msgid "Enable loop optimizations on tree level"
 msgstr ""
 
-#: common.opt:1228
+#: common.opt:1224
 msgid "Enable automatic parallelization of loops"
 msgstr ""
 
-#: common.opt:1232
+#: common.opt:1228
 msgid "Enable SSA-PRE optimization on trees"
 msgstr ""
 
-#: common.opt:1236
+#: common.opt:1232
 msgid "Enable reassociation on tree level"
 msgstr ""
 
-#: common.opt:1244
+#: common.opt:1240
 msgid "Enable SSA code sinking on trees"
 msgstr ""
 
-#: common.opt:1248
+#: common.opt:1244
 msgid "Perform scalar replacement of aggregates"
 msgstr ""
 
-#: common.opt:1252
+#: common.opt:1248
 msgid "Replace temporary expressions in the SSA->normal pass"
 msgstr ""
 
-#: common.opt:1256
+#: common.opt:1252
 msgid "Perform live range splitting during the SSA->normal pass"
 msgstr ""
 
-#: common.opt:1260
+#: common.opt:1256
 msgid "Perform Value Range Propagation on trees"
 msgstr ""
 
-#: common.opt:1264
+#: common.opt:1260
 msgid "Compile whole compilation unit at a time"
 msgstr ""
 
-#: common.opt:1268
+#: common.opt:1264
 msgid "Perform loop unrolling when iteration count is known"
 msgstr ""
 
-#: common.opt:1272
+#: common.opt:1268
 msgid "Perform loop unrolling for all loops"
 msgstr ""
 
-#: common.opt:1279
+#: common.opt:1275
 msgid "Allow loop optimizations to assume that the loops behave in normal way"
 msgstr ""
 
-#: common.opt:1283
+#: common.opt:1279
 msgid "Allow optimization for floating-point arithmetic which may change the"
 msgstr ""
 
-#: common.opt:1288
+#: common.opt:1284
 msgid "Same as -fassociative-math for expressions which include division."
 msgstr ""
 
-#: common.opt:1296
+#: common.opt:1292
 msgid "Allow math optimizations that may violate IEEE or ISO standards"
 msgstr ""
 
-#: common.opt:1300
+#: common.opt:1296
 msgid "Perform loop unswitching"
 msgstr ""
 
-#: common.opt:1304
+#: common.opt:1300
 msgid "Just generate unwind tables for exception handling"
 msgstr ""
 
-#: common.opt:1308
+#: common.opt:1304
 msgid "Perform variable tracking"
 msgstr ""
 
-#: common.opt:1312
+#: common.opt:1308
 msgid "Perform variable tracking and also tag variables that are uninitialized"
 msgstr ""
 
-#: common.opt:1316
+#: common.opt:1312
 msgid "Enable loop vectorization on trees"
 msgstr ""
 
-#: common.opt:1320
+#: common.opt:1316
 msgid "Enable use of cost model in vectorization"
 msgstr ""
 
-#: common.opt:1324
+#: common.opt:1320
 msgid "Enable loop versioning when doing loop vectorization on trees"
 msgstr ""
 
-#: common.opt:1328
+#: common.opt:1324
 msgid "Set the verbosity level of the vectorizer"
 msgstr ""
 
-#: common.opt:1332
+#: common.opt:1328
 msgid "Enable copy propagation of scalar-evolution information."
 msgstr ""
 
-#: common.opt:1342
+#: common.opt:1338
 msgid "Add extra commentary to assembler output"
 msgstr ""
 
-#: common.opt:1346
+#: common.opt:1342
 msgid "Set the default symbol visibility"
 msgstr ""
 
-#: common.opt:1351
+#: common.opt:1347
 msgid "Use expression value profiles in optimizations"
 msgstr ""
 
-#: common.opt:1355
+#: common.opt:1351
 msgid "Construct webs and split unrelated uses of single variable"
 msgstr ""
 
-#: common.opt:1359
+#: common.opt:1355
 msgid "Enable conditional dead code elimination for builtin calls"
 msgstr ""
 
-#: common.opt:1363
+#: common.opt:1359
 msgid "Perform whole program optimizations"
 msgstr ""
 
-#: common.opt:1367
+#: common.opt:1363
 msgid "Assume signed arithmetic overflow wraps around"
 msgstr ""
 
-#: common.opt:1371
+#: common.opt:1367
 msgid "Put zero initialized data in the bss section"
 msgstr ""
 
-#: common.opt:1375
+#: common.opt:1371
 msgid "Generate debug information in default format"
 msgstr ""
 
-#: common.opt:1379
+#: common.opt:1375
 msgid "Generate debug information in COFF format"
 msgstr ""
 
-#: common.opt:1383
+#: common.opt:1379
 msgid "Generate debug information in DWARF v2 format"
 msgstr ""
 
-#: common.opt:1387
+#: common.opt:1383
 msgid "Generate debug information in default extended format"
 msgstr ""
 
-#: common.opt:1391
+#: common.opt:1387
 msgid "Generate debug information in STABS format"
 msgstr ""
 
-#: common.opt:1395
+#: common.opt:1391
 msgid "Generate debug information in extended STABS format"
 msgstr ""
 
-#: common.opt:1399
+#: common.opt:1395
 msgid "Generate debug information in VMS format"
 msgstr ""
 
-#: common.opt:1403
+#: common.opt:1399
 msgid "Generate debug information in XCOFF format"
 msgstr ""
 
-#: common.opt:1407
+#: common.opt:1403
 msgid "Generate debug information in extended XCOFF format"
 msgstr ""
 
-#: common.opt:1411
+#: common.opt:1407
 msgid "Place output into <file>"
 msgstr ""
 
-#: common.opt:1415
+#: common.opt:1411
 msgid "Enable function profiling"
 msgstr ""
 
-#: common.opt:1419
+#: common.opt:1415
 msgid "Issue warnings needed for strict compliance to the standard"
 msgstr ""
 
-#: common.opt:1423
+#: common.opt:1419
 msgid "Like -pedantic but issue them as errors"
 msgstr ""
 
-#: common.opt:1427
+#: common.opt:1423
 msgid "Do not display functions compiled or elapsed time"
 msgstr ""
 
-#: common.opt:1431
+#: common.opt:1427
 msgid "Display the compiler's version"
 msgstr ""
 
-#: common.opt:1435
+#: common.opt:1431
 msgid "Suppress warnings"
 msgstr ""
 
-#: common.opt:1439
+#: common.opt:1435
 msgid "Create a shared library"
 msgstr ""
 
-#: common.opt:1443
+#: common.opt:1439
 msgid "Create a position independent executable"
 msgstr ""
 
@@ -17508,47 +17508,52 @@
 "branch target register load optimization is not intended to be run twice"
 msgstr ""
 
-#: builtins.c:1039
+#: builtins.c:479
+#, gcc-internal-format
+msgid "offset outside bounds of constant string"
+msgstr ""
+
+#: builtins.c:1042
 #, gcc-internal-format
 msgid "second argument to %<__builtin_prefetch%> must be a constant"
 msgstr ""
 
-#: builtins.c:1046
+#: builtins.c:1049
 #, gcc-internal-format
 msgid "invalid second argument to %<__builtin_prefetch%>; using zero"
 msgstr ""
 
-#: builtins.c:1054
+#: builtins.c:1057
 #, gcc-internal-format
 msgid "third argument to %<__builtin_prefetch%> must be a constant"
 msgstr ""
 
-#: builtins.c:1061
+#: builtins.c:1064
 #, gcc-internal-format
 msgid "invalid third argument to %<__builtin_prefetch%>; using zero"
 msgstr ""
 
-#: builtins.c:4665
+#: builtins.c:4668
 #, gcc-internal-format
 msgid "argument of %<__builtin_args_info%> must be constant"
 msgstr ""
 
-#: builtins.c:4671
+#: builtins.c:4674
 #, gcc-internal-format
 msgid "argument of %<__builtin_args_info%> out of range"
 msgstr ""
 
-#: builtins.c:4677
+#: builtins.c:4680
 #, gcc-internal-format
 msgid "missing argument in %<__builtin_args_info%>"
 msgstr ""
 
-#: builtins.c:4813 gimplify.c:2324
+#: builtins.c:4816 gimplify.c:2324
 #, gcc-internal-format
 msgid "too few arguments to function %<va_start%>"
 msgstr ""
 
-#: builtins.c:4971
+#: builtins.c:4974
 #, gcc-internal-format
 msgid "first argument to %<va_arg%> not of type %<va_list%>"
 msgstr ""
@@ -17556,93 +17561,93 @@
 #. Unfortunately, this is merely undefined, rather than a constraint
 #. violation, so we cannot make this an error.  If this call is never
 #. executed, the program is still strictly conforming.
-#: builtins.c:4986
+#: builtins.c:4989
 #, gcc-internal-format
 msgid "%qT is promoted to %qT when passed through %<...%>"
 msgstr ""
 
-#: builtins.c:4991
+#: builtins.c:4994
 #, gcc-internal-format
 msgid "(so you should pass %qT not %qT to %<va_arg%>)"
 msgstr ""
 
 #. We can, however, treat "undefined" any way we please.
 #. Call abort to encourage the user to fix the program.
-#: builtins.c:4998 c-typeck.c:2451
+#: builtins.c:5001 c-typeck.c:2451
 #, gcc-internal-format
 msgid "if this code is reached, the program will abort"
 msgstr ""
 
-#: builtins.c:5122
+#: builtins.c:5125
 #, gcc-internal-format
 msgid "invalid argument to %<__builtin_frame_address%>"
 msgstr ""
 
-#: builtins.c:5124
+#: builtins.c:5127
 #, gcc-internal-format
 msgid "invalid argument to %<__builtin_return_address%>"
 msgstr ""
 
-#: builtins.c:5137
+#: builtins.c:5140
 #, gcc-internal-format
 msgid "unsupported argument to %<__builtin_frame_address%>"
 msgstr ""
 
-#: builtins.c:5139
+#: builtins.c:5142
 #, gcc-internal-format
 msgid "unsupported argument to %<__builtin_return_address%>"
 msgstr ""
 
-#: builtins.c:5685
+#: builtins.c:5688
 #, gcc-internal-format
 msgid "both arguments to %<__builtin___clear_cache%> must be pointers"
 msgstr ""
 
-#: builtins.c:6047 builtins.c:6062
+#: builtins.c:6050 builtins.c:6065
 #, gcc-internal-format
 msgid "%qD changed semantics in GCC 4.4"
 msgstr ""
 
 #. All valid uses of __builtin_va_arg_pack () are removed during
 #. inlining.
-#: builtins.c:6448 expr.c:8051
+#: builtins.c:6451 expr.c:8051
 msgid "%Kinvalid use of %<__builtin_va_arg_pack ()%>"
 msgstr ""
 
 #. All valid uses of __builtin_va_arg_pack_len () are removed during
 #. inlining.
-#: builtins.c:6454
+#: builtins.c:6457
 msgid "%Kinvalid use of %<__builtin_va_arg_pack_len ()%>"
 msgstr ""
 
-#: builtins.c:6750
+#: builtins.c:6753
 #, gcc-internal-format
 msgid "%<__builtin_longjmp%> second argument must be 1"
 msgstr ""
 
-#: builtins.c:7386
+#: builtins.c:7389
 #, gcc-internal-format
 msgid "target format does not support infinity"
 msgstr ""
 
-#: builtins.c:11730
+#: builtins.c:11733
 #, gcc-internal-format
 msgid "%<va_start%> used in function with fixed args"
 msgstr ""
 
-#: builtins.c:11738
+#: builtins.c:11741
 #, gcc-internal-format
 msgid "wrong number of arguments to function %<va_start%>"
 msgstr ""
 
 #. Evidently an out of date version of <stdarg.h>; can't validate
 #. va_start's second argument, but can still work as intended.
-#: builtins.c:11751
+#: builtins.c:11754
 #, gcc-internal-format
 msgid "%<__builtin_next_arg%> called without an argument"
 msgstr ""
 
-#: builtins.c:11756
+#: builtins.c:11759
 #, gcc-internal-format
 msgid "wrong number of arguments to function %<__builtin_next_arg%>"
 msgstr ""
@@ -17652,39 +17657,39 @@
 #. argument.  We just warn and set the arg to be the last
 #. argument so that we will get wrong-code because of
 #. it.
-#: builtins.c:11783
+#: builtins.c:11786
 #, gcc-internal-format
 msgid "second parameter of %<va_start%> not last named argument"
 msgstr ""
 
-#: builtins.c:11793
+#: builtins.c:11796
 #, gcc-internal-format
 msgid ""
 "undefined behaviour when second parameter of %<va_start%> is declared with %"
 "<register%> storage"
 msgstr ""
 
-#: builtins.c:11908
+#: builtins.c:11911
 msgid "%Kfirst argument of %D must be a pointer, second integer constant"
 msgstr ""
 
-#: builtins.c:11921
+#: builtins.c:11924
 msgid "%Klast argument of %D is not integer constant between 0 and 3"
 msgstr ""
 
-#: builtins.c:11966 builtins.c:12131 builtins.c:12190
+#: builtins.c:11969 builtins.c:12134 builtins.c:12193
 msgid "%Kcall to %D will always overflow destination buffer"
 msgstr ""
 
-#: builtins.c:12121
+#: builtins.c:12124
 msgid "%Kcall to %D might overflow destination buffer"
 msgstr ""
 
-#: builtins.c:12211
+#: builtins.c:12214
 msgid "%Kattempt to free a non-heap object %qD"
 msgstr ""
 
-#: builtins.c:12214
+#: builtins.c:12217
 msgid "%Kattempt to free a non-heap object"
 msgstr ""
 
@@ -17884,704 +17889,701 @@
 msgid "comparison of unsigned expression < 0 is always false"
 msgstr ""
 
-#: c-common.c:3225
+#: c-common.c:3224
 #, gcc-internal-format
 msgid "pointer of type %<void *%> used in arithmetic"
 msgstr ""
 
-#: c-common.c:3231
+#: c-common.c:3230
 #, gcc-internal-format
 msgid "pointer to a function used in arithmetic"
 msgstr ""
 
-#: c-common.c:3237
+#: c-common.c:3236
 #, gcc-internal-format
 msgid "pointer to member function used in arithmetic"
 msgstr ""
 
-#: c-common.c:3319
-#, gcc-internal-format
-msgid "offset %<%wd%> outside bounds of constant string"
-msgstr ""
-
-#: c-common.c:3422
+#: c-common.c:3396
 #, gcc-internal-format
 msgid "the address of %qD will always evaluate as %<true%>"
 msgstr ""
 
-#: c-common.c:3498 cp/semantics.c:594 cp/typeck.c:6638
+#: c-common.c:3472 cp/semantics.c:594 cp/typeck.c:6638
 #, gcc-internal-format
 msgid "suggest parentheses around assignment used as truth value"
 msgstr ""
 
-#: c-common.c:3577 c-typeck.c:8970
+#: c-common.c:3551 c-typeck.c:8974
 #, gcc-internal-format
 msgid "invalid use of %<restrict%>"
 msgstr ""
 
-#: c-common.c:3794
+#: c-common.c:3768
 #, gcc-internal-format
 msgid "invalid application of %<sizeof%> to a function type"
 msgstr ""
 
-#: c-common.c:3807
+#: c-common.c:3781
 #, gcc-internal-format
 msgid "invalid application of %qs to a void type"
 msgstr ""
 
-#: c-common.c:3815
+#: c-common.c:3789
 #, gcc-internal-format
 msgid "invalid application of %qs to incomplete type %qT "
 msgstr ""
 
-#: c-common.c:3856
+#: c-common.c:3830
 #, gcc-internal-format
 msgid "%<__alignof%> applied to a bit-field"
 msgstr ""
 
-#: c-common.c:4495
+#: c-common.c:4469
 #, gcc-internal-format
 msgid "cannot disable built-in function %qs"
 msgstr ""
 
-#: c-common.c:4686
+#: c-common.c:4660
 #, gcc-internal-format
 msgid "pointers are not permitted as case values"
 msgstr ""
 
-#: c-common.c:4693
+#: c-common.c:4667
 #, gcc-internal-format
 msgid "range expressions in switch statements are non-standard"
 msgstr ""
 
-#: c-common.c:4719
+#: c-common.c:4693
 #, gcc-internal-format
 msgid "empty range specified"
 msgstr ""
 
-#: c-common.c:4779
+#: c-common.c:4753
 #, gcc-internal-format
 msgid "duplicate (or overlapping) case value"
 msgstr ""
 
-#: c-common.c:4780
+#: c-common.c:4754
 #, gcc-internal-format
 msgid "%Jthis is the first entry overlapping that value"
 msgstr ""
 
-#: c-common.c:4784
+#: c-common.c:4758
 #, gcc-internal-format
 msgid "duplicate case value"
 msgstr ""
 
-#: c-common.c:4785
+#: c-common.c:4759
 #, gcc-internal-format
 msgid "%Jpreviously used here"
 msgstr ""
 
-#: c-common.c:4789
+#: c-common.c:4763
 #, gcc-internal-format
 msgid "multiple default labels in one switch"
 msgstr ""
 
-#: c-common.c:4790
+#: c-common.c:4764
 #, gcc-internal-format
 msgid "%Jthis is the first default label"
 msgstr ""
 
-#: c-common.c:4841
+#: c-common.c:4815
 #, gcc-internal-format
 msgid "%Jcase value %qs not in enumerated type"
 msgstr ""
 
-#: c-common.c:4845
+#: c-common.c:4819
 #, gcc-internal-format
 msgid "%Jcase value %qs not in enumerated type %qT"
 msgstr ""
 
-#: c-common.c:4904
+#: c-common.c:4878
 #, gcc-internal-format
 msgid "%Hswitch missing default case"
 msgstr ""
 
-#: c-common.c:4975
+#: c-common.c:4949
 #, gcc-internal-format
 msgid "%Henumeration value %qE not handled in switch"
 msgstr ""
 
-#: c-common.c:5010
+#: c-common.c:4984
 #, gcc-internal-format
 msgid "taking the address of a label is non-standard"
 msgstr ""
 
-#: c-common.c:5166
+#: c-common.c:5140
 #, gcc-internal-format
 msgid "%qE attribute ignored for field of type %qT"
 msgstr ""
 
-#: c-common.c:5177 c-common.c:5196 c-common.c:5214 c-common.c:5241
-#: c-common.c:5268 c-common.c:5294 c-common.c:5313 c-common.c:5337
-#: c-common.c:5360 c-common.c:5383 c-common.c:5404 c-common.c:5425
-#: c-common.c:5449 c-common.c:5475 c-common.c:5512 c-common.c:5539
-#: c-common.c:5582 c-common.c:5666 c-common.c:5696 c-common.c:5715
-#: c-common.c:6050 c-common.c:6066 c-common.c:6114 c-common.c:6137
-#: c-common.c:6201 c-common.c:6329 c-common.c:6395 c-common.c:6439
-#: c-common.c:6485 c-common.c:6555 c-common.c:6579 c-common.c:6865
-#: c-common.c:6888 c-common.c:6927 c-common.c:7016 c-common.c:7156
+#: c-common.c:5151 c-common.c:5170 c-common.c:5188 c-common.c:5215
+#: c-common.c:5242 c-common.c:5268 c-common.c:5287 c-common.c:5311
+#: c-common.c:5334 c-common.c:5357 c-common.c:5378 c-common.c:5399
+#: c-common.c:5423 c-common.c:5449 c-common.c:5486 c-common.c:5513
+#: c-common.c:5556 c-common.c:5640 c-common.c:5670 c-common.c:5689
+#: c-common.c:6024 c-common.c:6040 c-common.c:6088 c-common.c:6111
+#: c-common.c:6175 c-common.c:6303 c-common.c:6369 c-common.c:6413
+#: c-common.c:6459 c-common.c:6529 c-common.c:6553 c-common.c:6839
+#: c-common.c:6862 c-common.c:6901 c-common.c:6990 c-common.c:7130
+#: ada/gcc-interface/utils.c:5186 ada/gcc-interface/utils.c:5359
+#: ada/gcc-interface/utils.c:5378
 #, gcc-internal-format
 msgid "%qE attribute ignored"
 msgstr ""
 
-#: c-common.c:5259 c-common.c:5285
+#: c-common.c:5233 c-common.c:5259
 #, gcc-internal-format
 msgid "%qE attribute conflicts with attribute %s"
 msgstr ""
 
-#: c-common.c:5506
+#: c-common.c:5480
 #, gcc-internal-format
 msgid "%qE attribute have effect only on public objects"
 msgstr ""
 
-#: c-common.c:5603
+#: c-common.c:5577
 #, gcc-internal-format
 msgid "destructor priorities are not supported"
 msgstr ""
 
-#: c-common.c:5605
+#: c-common.c:5579
 #, gcc-internal-format
 msgid "constructor priorities are not supported"
 msgstr ""
 
-#: c-common.c:5622
+#: c-common.c:5596
 #, gcc-internal-format
 msgid "destructor priorities from 0 to %d are reserved for the implementation"
 msgstr ""
 
-#: c-common.c:5627
+#: c-common.c:5601
 #, gcc-internal-format
 msgid "constructor priorities from 0 to %d are reserved for the implementation"
 msgstr ""
 
-#: c-common.c:5635
+#: c-common.c:5609
 #, gcc-internal-format
 msgid "destructor priorities must be integers from 0 to %d inclusive"
 msgstr ""
 
-#: c-common.c:5638
+#: c-common.c:5612
 #, gcc-internal-format
 msgid "constructor priorities must be integers from 0 to %d inclusive"
 msgstr ""
 
-#: c-common.c:5759
+#: c-common.c:5733
 #, gcc-internal-format
 msgid "unknown machine mode %qs"
 msgstr ""
 
-#: c-common.c:5788
+#: c-common.c:5762
 #, gcc-internal-format
 msgid "specifying vector types with __attribute__ ((mode)) is deprecated"
 msgstr ""
 
-#: c-common.c:5791
+#: c-common.c:5765
 #, gcc-internal-format
 msgid "use __attribute__ ((vector_size)) instead"
 msgstr ""
 
-#: c-common.c:5800
+#: c-common.c:5774
 #, gcc-internal-format
 msgid "unable to emulate %qs"
 msgstr ""
 
-#: c-common.c:5810
+#: c-common.c:5784
 #, gcc-internal-format
 msgid "invalid pointer mode %qs"
 msgstr ""
 
-#: c-common.c:5827
+#: c-common.c:5801
 #, gcc-internal-format
 msgid "signness of type and machine mode %qs don't match"
 msgstr ""
 
-#: c-common.c:5838
+#: c-common.c:5812
 #, gcc-internal-format
 msgid "no data type for mode %qs"
 msgstr ""
 
-#: c-common.c:5848
+#: c-common.c:5822
 #, gcc-internal-format
 msgid "cannot use mode %qs for enumeral types"
 msgstr ""
 
-#: c-common.c:5875
+#: c-common.c:5849
 #, gcc-internal-format
 msgid "mode %qs applied to inappropriate type"
 msgstr ""
 
-#: c-common.c:5906
+#: c-common.c:5880
 #, gcc-internal-format
 msgid "%Jsection attribute cannot be specified for local variables"
 msgstr ""
 
-#: c-common.c:5917 config/bfin/bfin.c:5329 config/bfin/bfin.c:5380
+#: c-common.c:5891 config/bfin/bfin.c:5329 config/bfin/bfin.c:5380
 #, gcc-internal-format
 msgid "section of %q+D conflicts with previous declaration"
 msgstr ""
 
-#: c-common.c:5925
+#: c-common.c:5899
 #, gcc-internal-format
 msgid "section of %q+D cannot be overridden"
 msgstr ""
 
-#: c-common.c:5933
+#: c-common.c:5907
 #, gcc-internal-format
 msgid "section attribute not allowed for %q+D"
 msgstr ""
 
-#: c-common.c:5939
+#: c-common.c:5913
 #, gcc-internal-format
 msgid "%Jsection attributes are not supported for this target"
 msgstr ""
 
-#: c-common.c:5971
+#: c-common.c:5945
 #, gcc-internal-format
 msgid "requested alignment is not a constant"
 msgstr ""
 
-#: c-common.c:5976
+#: c-common.c:5950
 #, gcc-internal-format
 msgid "requested alignment is not a power of 2"
 msgstr ""
 
-#: c-common.c:5981
+#: c-common.c:5955
 #, gcc-internal-format
 msgid "requested alignment is too large"
 msgstr ""
 
-#: c-common.c:6007
+#: c-common.c:5981
 #, gcc-internal-format
 msgid "alignment may not be specified for %q+D"
 msgstr ""
 
-#: c-common.c:6014
+#: c-common.c:5988
 #, gcc-internal-format
 msgid ""
 "alignment for %q+D was previously specified as %d and may not be decreased"
 msgstr ""
 
-#: c-common.c:6018
+#: c-common.c:5992
 #, gcc-internal-format
 msgid "alignment for %q+D must be at least %d"
 msgstr ""
 
-#: c-common.c:6043
+#: c-common.c:6017
 #, gcc-internal-format
 msgid "inline function %q+D cannot be declared weak"
 msgstr ""
 
-#: c-common.c:6077
+#: c-common.c:6051
 #, gcc-internal-format
 msgid "%q+D defined both normally and as an alias"
 msgstr ""
 
-#: c-common.c:6093
+#: c-common.c:6067
 #, gcc-internal-format
 msgid "alias argument not a string"
 msgstr ""
 
-#: c-common.c:6158
+#: c-common.c:6132
 #, gcc-internal-format
 msgid "%Jweakref attribute must appear before alias attribute"
 msgstr ""
 
-#: c-common.c:6188
+#: c-common.c:6162
 #, gcc-internal-format
 msgid "%qE attribute ignored on non-class types"
 msgstr ""
 
-#: c-common.c:6194
+#: c-common.c:6168
 #, gcc-internal-format
 msgid "%qE attribute ignored because %qT is already defined"
 msgstr ""
 
-#: c-common.c:6207
+#: c-common.c:6181
 #, gcc-internal-format
 msgid "visibility argument not a string"
 msgstr ""
 
-#: c-common.c:6219
+#: c-common.c:6193
 #, gcc-internal-format
 msgid "%qE attribute ignored on types"
 msgstr ""
 
-#: c-common.c:6235
+#: c-common.c:6209
 #, gcc-internal-format
 msgid ""
 "visibility argument must be one of \"default\", \"hidden\", \"protected\" or "
 "\"internal\""
 msgstr ""
 
-#: c-common.c:6246
+#: c-common.c:6220
 #, gcc-internal-format
 msgid "%qD redeclared with different visibility"
 msgstr ""
 
-#: c-common.c:6249 c-common.c:6253
+#: c-common.c:6223 c-common.c:6227
 #, gcc-internal-format
 msgid "%qD was declared %qs which implies default visibility"
 msgstr ""
 
-#: c-common.c:6337
+#: c-common.c:6311
 #, gcc-internal-format
 msgid "tls_model argument not a string"
 msgstr ""
 
-#: c-common.c:6350
+#: c-common.c:6324
 #, gcc-internal-format
 msgid ""
 "tls_model argument must be one of \"local-exec\", \"initial-exec\", \"local-"
 "dynamic\" or \"global-dynamic\""
 msgstr ""
 
-#: c-common.c:6369 c-common.c:6459
+#: c-common.c:6343 c-common.c:6433
 #, gcc-internal-format
 msgid "%J%qE attribute applies only to functions"
 msgstr ""
 
-#: c-common.c:6374 c-common.c:6464
+#: c-common.c:6348 c-common.c:6438
 #, gcc-internal-format
 msgid "%Jcan%'t set %qE attribute after definition"
 msgstr ""
 
-#: c-common.c:6420
+#: c-common.c:6394
 #, gcc-internal-format
 msgid "alloc_size parameter outside range"
 msgstr ""
 
-#: c-common.c:6553
+#: c-common.c:6527
 #, gcc-internal-format
 msgid "%qE attribute ignored for %qE"
 msgstr ""
 
-#: c-common.c:6613
+#: c-common.c:6587
 #, gcc-internal-format
 msgid "invalid vector type for attribute %qE"
 msgstr ""
 
-#: c-common.c:6619
+#: c-common.c:6593
 #, gcc-internal-format
 msgid "vector size not an integral multiple of component size"
 msgstr ""
 
-#: c-common.c:6625
+#: c-common.c:6599
 #, gcc-internal-format
 msgid "zero vector size"
 msgstr ""
 
-#: c-common.c:6633
+#: c-common.c:6607
 #, gcc-internal-format
 msgid "number of components of the vector not a power of two"
 msgstr ""
 
-#: c-common.c:6661
+#: c-common.c:6635 ada/gcc-interface/utils.c:5237
 #, gcc-internal-format
 msgid "nonnull attribute without arguments on a non-prototype"
 msgstr ""
 
-#: c-common.c:6676
+#: c-common.c:6650 ada/gcc-interface/utils.c:5252
 #, gcc-internal-format
 msgid "nonnull argument has invalid operand number (argument %lu)"
 msgstr ""
 
-#: c-common.c:6695
+#: c-common.c:6669 ada/gcc-interface/utils.c:5271
 #, gcc-internal-format
 msgid ""
 "nonnull argument with out-of-range operand number (argument %lu, operand %lu)"
 msgstr ""
 
-#: c-common.c:6703
+#: c-common.c:6677 ada/gcc-interface/utils.c:5279
 #, gcc-internal-format
 msgid ""
 "nonnull argument references non-pointer operand (argument %lu, operand %lu)"
 msgstr ""
 
-#: c-common.c:6779
+#: c-common.c:6753
 #, gcc-internal-format
 msgid "not enough variable arguments to fit a sentinel"
 msgstr ""
 
-#: c-common.c:6793
+#: c-common.c:6767
 #, gcc-internal-format
 msgid "missing sentinel in function call"
 msgstr ""
 
-#: c-common.c:6834
+#: c-common.c:6808
 #, gcc-internal-format
 msgid "null argument where non-null required (argument %lu)"
 msgstr ""
 
-#: c-common.c:6899
+#: c-common.c:6873
 #, gcc-internal-format
 msgid "cleanup argument not an identifier"
 msgstr ""
 
-#: c-common.c:6906
+#: c-common.c:6880
 #, gcc-internal-format
 msgid "cleanup argument not a function"
 msgstr ""
 
-#: c-common.c:6945
+#: c-common.c:6919 ada/gcc-interface/utils.c:5301
 #, gcc-internal-format
 msgid "%qE attribute requires prototypes with named arguments"
 msgstr ""
 
-#: c-common.c:6956
+#: c-common.c:6930 ada/gcc-interface/utils.c:5312
 #, gcc-internal-format
 msgid "%qE attribute only applies to variadic functions"
 msgstr ""
 
-#: c-common.c:6968
+#: c-common.c:6942 ada/gcc-interface/utils.c:5323
 #, gcc-internal-format
 msgid "requested position is not an integer constant"
 msgstr ""
 
-#: c-common.c:6976
+#: c-common.c:6950 ada/gcc-interface/utils.c:5330
 #, gcc-internal-format
 msgid "requested position is less than zero"
 msgstr ""
 
-#: c-common.c:7100
+#: c-common.c:7074
 #, gcc-internal-format
 msgid "Bad option %s to optimize attribute."
 msgstr ""
 
-#: c-common.c:7103
+#: c-common.c:7077
 #, gcc-internal-format
 msgid "Bad option %s to pragma attribute"
 msgstr ""
 
-#: c-common.c:7296
+#: c-common.c:7270
 #, gcc-internal-format
 msgid "not enough arguments to function %qE"
 msgstr ""
 
-#: c-common.c:7301 c-typeck.c:2558
+#: c-common.c:7275 c-typeck.c:2558
 #, gcc-internal-format
 msgid "too many arguments to function %qE"
 msgstr ""
 
-#: c-common.c:7331 c-common.c:7377
+#: c-common.c:7305 c-common.c:7351
 #, gcc-internal-format
 msgid "non-floating-point argument in call to function %qE"
 msgstr ""
 
-#: c-common.c:7354
+#: c-common.c:7328
 #, gcc-internal-format
 msgid "non-floating-point arguments in call to function %qE"
 msgstr ""
 
-#: c-common.c:7370
+#: c-common.c:7344
 #, gcc-internal-format
 msgid "non-const integer argument %u in call to function %qE"
 msgstr ""
 
-#: c-common.c:7596
+#: c-common.c:7570
 #, gcc-internal-format
 msgid ""
 "%Hignoring return value of %qD, declared with attribute warn_unused_result"
 msgstr ""
 
-#: c-common.c:7600
+#: c-common.c:7574
 #, gcc-internal-format
 msgid ""
 "%Hignoring return value of function declared with attribute "
 "warn_unused_result"
 msgstr ""
 
-#: c-common.c:7654
+#: c-common.c:7628
 #, gcc-internal-format
 msgid "cannot apply %<offsetof%> to static data member %qD"
 msgstr ""
 
-#: c-common.c:7659
+#: c-common.c:7633
 #, gcc-internal-format
 msgid "cannot apply %<offsetof%> when %<operator[]%> is overloaded"
 msgstr ""
 
-#: c-common.c:7680 cp/typeck.c:4685
+#: c-common.c:7654 cp/typeck.c:4685
 #, gcc-internal-format
 msgid "attempt to take address of bit-field structure member %qD"
 msgstr ""
 
-#: c-common.c:7733
+#: c-common.c:7707
 #, gcc-internal-format
 msgid "lvalue required as left operand of assignment"
 msgstr ""
 
-#: c-common.c:7736
+#: c-common.c:7710
 #, gcc-internal-format
 msgid "lvalue required as increment operand"
 msgstr ""
 
-#: c-common.c:7739
+#: c-common.c:7713
 #, gcc-internal-format
 msgid "lvalue required as decrement operand"
 msgstr ""
 
-#: c-common.c:7742
+#: c-common.c:7716
 #, gcc-internal-format
 msgid "lvalue required as unary %<&%> operand"
 msgstr ""
 
-#: c-common.c:7745
+#: c-common.c:7719
 #, gcc-internal-format
 msgid "lvalue required in asm statement"
 msgstr ""
 
-#: c-common.c:7874
+#: c-common.c:7848
 #, gcc-internal-format
 msgid "size of array is too large"
 msgstr ""
 
-#: c-common.c:7910 c-common.c:7959 c-typeck.c:2748
+#: c-common.c:7884 c-common.c:7933 c-typeck.c:2748
 #, gcc-internal-format
 msgid "too few arguments to function %qE"
 msgstr ""
 
-#: c-common.c:7927 c-typeck.c:4461
+#: c-common.c:7901 c-typeck.c:4465
 #, gcc-internal-format
 msgid "incompatible type for argument %d of %qE"
 msgstr ""
 
-#: c-common.c:8119
+#: c-common.c:8093
 #, gcc-internal-format
 msgid "array subscript has type %<char%>"
 msgstr ""
 
-#: c-common.c:8154
+#: c-common.c:8128
 #, gcc-internal-format
 msgid "suggest parentheses around %<+%> inside %<<<%>"
 msgstr ""
 
-#: c-common.c:8157
+#: c-common.c:8131
 #, gcc-internal-format
 msgid "suggest parentheses around %<-%> inside %<<<%>"
 msgstr ""
 
-#: c-common.c:8163
+#: c-common.c:8137
 #, gcc-internal-format
 msgid "suggest parentheses around %<+%> inside %<>>%>"
 msgstr ""
 
-#: c-common.c:8166
+#: c-common.c:8140
 #, gcc-internal-format
 msgid "suggest parentheses around %<-%> inside %<>>%>"
 msgstr ""
 
-#: c-common.c:8172
+#: c-common.c:8146
 #, gcc-internal-format
 msgid "suggest parentheses around %<&&%> within %<||%>"
 msgstr ""
 
-#: c-common.c:8181
+#: c-common.c:8155
 #, gcc-internal-format
 msgid "suggest parentheses around arithmetic in operand of %<|%>"
 msgstr ""
 
-#: c-common.c:8186
+#: c-common.c:8160
 #, gcc-internal-format
 msgid "suggest parentheses around comparison in operand of %<|%>"
 msgstr ""
 
-#: c-common.c:8190
+#: c-common.c:8164
 #, gcc-internal-format
 msgid ""
 "suggest parentheses around operand of %<!%> or change %<|%> to %<||%> or %<!%"
 "> to %<~%>"
 msgstr ""
 
-#: c-common.c:8200
+#: c-common.c:8174
 #, gcc-internal-format
 msgid "suggest parentheses around arithmetic in operand of %<^%>"
 msgstr ""
 
-#: c-common.c:8205
+#: c-common.c:8179
 #, gcc-internal-format
 msgid "suggest parentheses around comparison in operand of %<^%>"
 msgstr ""
 
-#: c-common.c:8211
+#: c-common.c:8185
 #, gcc-internal-format
 msgid "suggest parentheses around %<+%> in operand of %<&%>"
 msgstr ""
 
-#: c-common.c:8214
+#: c-common.c:8188
 #, gcc-internal-format
 msgid "suggest parentheses around %<-%> in operand of %<&%>"
 msgstr ""
 
-#: c-common.c:8219
+#: c-common.c:8193
 #, gcc-internal-format
 msgid "suggest parentheses around comparison in operand of %<&%>"
 msgstr ""
 
-#: c-common.c:8223
+#: c-common.c:8197
 #, gcc-internal-format
 msgid ""
 "suggest parentheses around operand of %<!%> or change %<&%> to %<&&%> or %<!%"
 "> to %<~%>"
 msgstr ""
 
-#: c-common.c:8231
+#: c-common.c:8205
 #, gcc-internal-format
 msgid "suggest parentheses around comparison in operand of %<==%>"
 msgstr ""
 
-#: c-common.c:8237
+#: c-common.c:8211
 #, gcc-internal-format
 msgid "suggest parentheses around comparison in operand of %<!=%>"
 msgstr ""
 
-#: c-common.c:8248
+#: c-common.c:8222
 #, gcc-internal-format
 msgid "comparisons like %<X<=Y<=Z%> do not have their mathematical meaning"
 msgstr ""
 
-#: c-common.c:8263
+#: c-common.c:8237
 #, gcc-internal-format
 msgid "label %q+D defined but not used"
 msgstr ""
 
-#: c-common.c:8265
+#: c-common.c:8239
 #, gcc-internal-format
 msgid "label %q+D declared but not defined"
 msgstr ""
 
-#: c-common.c:8285
+#: c-common.c:8259
 #, gcc-internal-format
 msgid "division by zero"
 msgstr ""
 
-#: c-common.c:8317
+#: c-common.c:8291
 #, gcc-internal-format
 msgid "comparison between types %qT and %qT"
 msgstr ""
 
-#: c-common.c:8368
+#: c-common.c:8342
 #, gcc-internal-format
 msgid "comparison between signed and unsigned integer expressions"
 msgstr ""
 
-#: c-common.c:8419
+#: c-common.c:8393
 #, gcc-internal-format
 msgid "promoted ~unsigned is always non-zero"
 msgstr ""
 
-#: c-common.c:8422
+#: c-common.c:8396
 #, gcc-internal-format
 msgid "comparison of promoted ~unsigned with constant"
 msgstr ""
 
-#: c-common.c:8432
+#: c-common.c:8406
 #, gcc-internal-format
 msgid "comparison of promoted ~unsigned with unsigned"
 msgstr ""
@@ -18591,7 +18593,7 @@
 #. an unprototyped function, it is compile-time undefined;
 #. making it a constraint in that case was rejected in
 #. DR#252.
-#: c-convert.c:95 c-typeck.c:1796 c-typeck.c:4096 cp/typeck.c:1619
+#: c-convert.c:95 c-typeck.c:1796 c-typeck.c:4100 cp/typeck.c:1619
 #: cp/typeck.c:5936 cp/typeck.c:6546 fortran/convert.c:88
 #, gcc-internal-format
 msgid "void value not ignored as it ought to be"
@@ -18831,8 +18833,8 @@
 msgid "declaration of %q+D shadows a previous local"
 msgstr ""
 
-#: c-decl.c:1972 cp/name-lookup.c:1041 cp/name-lookup.c:1072
-#: cp/name-lookup.c:1080
+#: c-decl.c:1972 cp/name-lookup.c:1043 cp/name-lookup.c:1074
+#: cp/name-lookup.c:1082
 #, gcc-internal-format
 msgid "%Jshadowed declaration is here"
 msgstr ""
@@ -19015,7 +19017,7 @@
 msgid "variable %qD has initializer but incomplete type"
 msgstr ""
 
-#: c-decl.c:3319 c-decl.c:6138 cp/decl.c:4114 cp/decl.c:11484
+#: c-decl.c:3319 c-decl.c:6138 cp/decl.c:4117 cp/decl.c:11498
 #, gcc-internal-format
 msgid "inline function %q+D given attribute noinline"
 msgstr ""
@@ -19135,7 +19137,7 @@
 msgid "variable length array %qs is used"
 msgstr ""
 
-#: c-decl.c:3932 cp/decl.c:7274
+#: c-decl.c:3932 cp/decl.c:7277
 #, gcc-internal-format
 msgid "variable length array is used"
 msgstr ""
@@ -19190,22 +19192,22 @@
 msgid "storage class specified for structure field %qs"
 msgstr ""
 
-#: c-decl.c:4150 cp/decl.c:8169
+#: c-decl.c:4150 cp/decl.c:8175
 #, gcc-internal-format
 msgid "storage class specified for parameter %qs"
 msgstr ""
 
-#: c-decl.c:4153 cp/decl.c:8171
+#: c-decl.c:4153 cp/decl.c:8177
 #, gcc-internal-format
 msgid "storage class specified for typename"
 msgstr ""
 
-#: c-decl.c:4170 cp/decl.c:9450
+#: c-decl.c:4170 cp/decl.c:9464
 #, gcc-internal-format
 msgid "%qs initialized and declared %<extern%>"
 msgstr ""
 
-#: c-decl.c:4173 cp/decl.c:9454
+#: c-decl.c:4173 cp/decl.c:9468
 #, gcc-internal-format
 msgid "%qs has both %<extern%> and initializer"
 msgstr ""
@@ -19220,12 +19222,12 @@
 msgid "file-scope declaration of %qs specifies %<register%>"
 msgstr ""
 
-#: c-decl.c:4186 cp/decl.c:8182
+#: c-decl.c:4186 cp/decl.c:8188
 #, gcc-internal-format
 msgid "nested function %qs declared %<extern%>"
 msgstr ""
 
-#: c-decl.c:4189 cp/decl.c:8192
+#: c-decl.c:4189 cp/decl.c:8198
 #, gcc-internal-format
 msgid "function-scope %qs implicitly auto and declared %<__thread%>"
 msgstr ""
@@ -19268,7 +19270,7 @@
 msgid "size of array %qs is negative"
 msgstr ""
 
-#: c-decl.c:4382 c-decl.c:4655 cp/decl.c:8694
+#: c-decl.c:4382 c-decl.c:4655 cp/decl.c:8706
 #, gcc-internal-format
 msgid "size of array %qs is too large"
 msgstr ""
@@ -19289,12 +19291,12 @@
 msgid "array type has incomplete element type"
 msgstr ""
 
-#: c-decl.c:4526 cp/decl.c:8288
+#: c-decl.c:4526 cp/decl.c:8294
 #, gcc-internal-format
 msgid "%qs declared as function returning a function"
 msgstr ""
 
-#: c-decl.c:4531 cp/decl.c:8293
+#: c-decl.c:4531 cp/decl.c:8299
 #, gcc-internal-format
 msgid "%qs declared as function returning an array"
 msgstr ""
@@ -19304,7 +19306,7 @@
 msgid "function definition has qualified void return type"
 msgstr ""
 
-#: c-decl.c:4557 cp/decl.c:8277
+#: c-decl.c:4557 cp/decl.c:8283
 #, gcc-internal-format
 msgid "type qualifiers ignored on function return type"
 msgstr ""
@@ -19585,7 +19587,7 @@
 msgid "%q+D was used with no prototype before its definition"
 msgstr ""
 
-#: c-decl.c:6254 cp/decl.c:11625
+#: c-decl.c:6254 cp/decl.c:11639
 #, gcc-internal-format
 msgid "no previous declaration for %q+D"
 msgstr ""
@@ -19700,7 +19702,7 @@
 msgid "argument %qD doesn%'t match prototype"
 msgstr ""
 
-#: c-decl.c:6782 cp/decl.c:12329
+#: c-decl.c:6782 cp/decl.c:12343
 #, gcc-internal-format
 msgid "no return statement in function returning non-void"
 msgstr ""
@@ -20074,7 +20076,7 @@
 msgid "ISO C does not support decimal floating point"
 msgstr ""
 
-#: c-decl.c:7613 c-decl.c:7792 c-parser.c:5101
+#: c-decl.c:7613 c-decl.c:7792 c-parser.c:5107
 #, gcc-internal-format
 msgid "fixed-point types not supported for this target"
 msgstr ""
@@ -20762,12 +20764,12 @@
 msgid "ISO C forbids an empty translation unit"
 msgstr ""
 
-#: c-parser.c:1056 c-parser.c:6109
+#: c-parser.c:1056 c-parser.c:6113
 #, gcc-internal-format
 msgid "ISO C does not allow extra %<;%> outside of a function"
 msgstr ""
 
-#: c-parser.c:1158 c-parser.c:6667
+#: c-parser.c:1158 c-parser.c:6671
 #, gcc-internal-format
 msgid "expected declaration specifiers"
 msgstr ""
@@ -20796,16 +20798,16 @@
 msgstr ""
 
 #: c-parser.c:1641 c-parser.c:2454 c-parser.c:3094 c-parser.c:3352
-#: c-parser.c:4286 c-parser.c:4886 c-parser.c:5308 c-parser.c:5329
-#: c-parser.c:5446 c-parser.c:5598 c-parser.c:5615 c-parser.c:5751
-#: c-parser.c:5763 c-parser.c:5788 c-parser.c:5922 c-parser.c:5951
-#: c-parser.c:5959 c-parser.c:5987 c-parser.c:6001 c-parser.c:6217
-#: c-parser.c:6316 c-parser.c:6837 c-parser.c:7538
+#: c-parser.c:4292 c-parser.c:4892 c-parser.c:5314 c-parser.c:5335
+#: c-parser.c:5452 c-parser.c:5602 c-parser.c:5619 c-parser.c:5755
+#: c-parser.c:5767 c-parser.c:5792 c-parser.c:5926 c-parser.c:5955
+#: c-parser.c:5963 c-parser.c:5991 c-parser.c:6005 c-parser.c:6221
+#: c-parser.c:6320 c-parser.c:6841 c-parser.c:7542
 #, gcc-internal-format
 msgid "expected identifier"
 msgstr ""
 
-#: c-parser.c:1674 cp/parser.c:11972
+#: c-parser.c:1674 cp/parser.c:11977
 #, gcc-internal-format
 msgid "comma at end of enumerator list"
 msgstr ""
@@ -20815,7 +20817,7 @@
 msgid "expected %<,%> or %<}%>"
 msgstr ""
 
-#: c-parser.c:1694 c-parser.c:1877 c-parser.c:6076
+#: c-parser.c:1694 c-parser.c:1877 c-parser.c:6080
 #, gcc-internal-format
 msgid "expected %<{%>"
 msgstr ""
@@ -20830,7 +20832,7 @@
 msgid "expected class name"
 msgstr ""
 
-#: c-parser.c:1831 c-parser.c:5855
+#: c-parser.c:1831 c-parser.c:5859
 #, gcc-internal-format
 msgid "extra semicolon in struct or union specified"
 msgstr ""
@@ -20890,7 +20892,7 @@
 msgid "wide string literal in %<asm%>"
 msgstr ""
 
-#: c-parser.c:2689 c-parser.c:6722
+#: c-parser.c:2689 c-parser.c:6726
 #, gcc-internal-format
 msgid "expected string literal"
 msgstr ""
@@ -20980,12 +20982,12 @@
 msgid "expected statement"
 msgstr ""
 
-#: c-parser.c:3872 cp/parser.c:7296
+#: c-parser.c:3872 cp/parser.c:7301
 #, gcc-internal-format
 msgid "suggest braces around empty body in an %<if%> statement"
 msgstr ""
 
-#: c-parser.c:3898 cp/parser.c:7317
+#: c-parser.c:3898 cp/parser.c:7322
 #, gcc-internal-format
 msgid "suggest braces around empty body in an %<else%> statement"
 msgstr ""
@@ -21000,199 +21002,199 @@
 msgid "%E qualifier ignored on asm"
 msgstr ""
 
-#: c-parser.c:4459
+#: c-parser.c:4465
 #, gcc-internal-format
 msgid "ISO C forbids omitting the middle term of a ?: expression"
 msgstr ""
 
-#: c-parser.c:4855
+#: c-parser.c:4861
 #, gcc-internal-format
 msgid "traditional C rejects the unary plus operator"
 msgstr ""
 
-#: c-parser.c:4972
+#: c-parser.c:4978
 #, gcc-internal-format
 msgid "%<sizeof%> applied to a bit-field"
 msgstr ""
 
-#: c-parser.c:5131 c-parser.c:5488 c-parser.c:5510
+#: c-parser.c:5137 c-parser.c:5494 c-parser.c:5516
 #, gcc-internal-format
 msgid "expected expression"
 msgstr ""
 
-#: c-parser.c:5158
+#: c-parser.c:5164
 #, gcc-internal-format
 msgid "braced-group within expression allowed only inside a function"
 msgstr ""
 
-#: c-parser.c:5172
+#: c-parser.c:5178
 #, gcc-internal-format
 msgid "ISO C forbids braced-groups within expressions"
 msgstr ""
 
-#: c-parser.c:5370
+#: c-parser.c:5376
 #, gcc-internal-format
 msgid "first argument to %<__builtin_choose_expr%> not a constant"
 msgstr ""
 
-#: c-parser.c:5539
+#: c-parser.c:5545
 #, gcc-internal-format
 msgid "compound literal has variable size"
 msgstr ""
 
-#: c-parser.c:5547
+#: c-parser.c:5553
 #, gcc-internal-format
 msgid "ISO C90 forbids compound literals"
 msgstr ""
 
-#: c-parser.c:6072
+#: c-parser.c:6076
 #, gcc-internal-format
 msgid "extra semicolon in method definition specified"
 msgstr ""
 
-#: c-parser.c:6616
+#: c-parser.c:6620
 #, gcc-internal-format
 msgid "%<#pragma omp barrier%> may only be used in compound statements"
 msgstr ""
 
-#: c-parser.c:6627
+#: c-parser.c:6631
 #, gcc-internal-format
 msgid "%<#pragma omp flush%> may only be used in compound statements"
 msgstr ""
 
-#: c-parser.c:6638
+#: c-parser.c:6642
 #, gcc-internal-format
 msgid "%<#pragma omp taskwait%> may only be used in compound statements"
 msgstr ""
 
-#: c-parser.c:6651
+#: c-parser.c:6655
 #, gcc-internal-format
 msgid ""
 "%<#pragma omp section%> may only be used in %<#pragma omp sections%> "
 "construct"
 msgstr ""
 
-#: c-parser.c:6657
+#: c-parser.c:6661
 #, gcc-internal-format
 msgid "%<#pragma GCC pch_preprocess%> must be first"
 msgstr ""
 
-#: c-parser.c:6815
+#: c-parser.c:6819
 #, gcc-internal-format
 msgid "too many %qs clauses"
 msgstr ""
 
-#: c-parser.c:6911
+#: c-parser.c:6915
 #, gcc-internal-format
 msgid "collapse argument needs positive constant integer expression"
 msgstr ""
 
-#: c-parser.c:6976
+#: c-parser.c:6980
 #, gcc-internal-format
 msgid "expected %<none%> or %<shared%>"
 msgstr ""
 
-#: c-parser.c:7019
+#: c-parser.c:7023
 #, gcc-internal-format
 msgid "expected %<(%>"
 msgstr ""
 
-#: c-parser.c:7063 c-parser.c:7247
+#: c-parser.c:7067 c-parser.c:7251
 #, gcc-internal-format
 msgid "expected integer expression"
 msgstr ""
 
-#: c-parser.c:7073
+#: c-parser.c:7077
 #, gcc-internal-format
 msgid "%<num_threads%> value must be positive"
 msgstr ""
 
-#: c-parser.c:7153
+#: c-parser.c:7157
 #, gcc-internal-format
 msgid "expected %<+%>, %<*%>, %<-%>, %<&%>, %<^%>, %<|%>, %<&&%>, or %<||%>"
 msgstr ""
 
-#: c-parser.c:7238
+#: c-parser.c:7242
 #, gcc-internal-format
 msgid "schedule %<runtime%> does not take a %<chunk_size%> parameter"
 msgstr ""
 
-#: c-parser.c:7242
+#: c-parser.c:7246
 #, gcc-internal-format
 msgid "schedule %<auto%> does not take a %<chunk_size%> parameter"
 msgstr ""
 
-#: c-parser.c:7260
+#: c-parser.c:7264
 #, gcc-internal-format
 msgid "invalid schedule kind"
 msgstr ""
 
-#: c-parser.c:7378
+#: c-parser.c:7382
 #, gcc-internal-format
 msgid "expected %<#pragma omp%> clause"
 msgstr ""
 
-#: c-parser.c:7387
+#: c-parser.c:7391
 #, gcc-internal-format
 msgid "%qs is not valid for %qs"
 msgstr ""
 
-#: c-parser.c:7488
+#: c-parser.c:7492
 #, gcc-internal-format
 msgid "invalid operator for %<#pragma omp atomic%>"
 msgstr ""
 
-#: c-parser.c:7541 c-parser.c:7561
+#: c-parser.c:7545 c-parser.c:7565
 #, gcc-internal-format
 msgid "expected %<(%> or end of line"
 msgstr ""
 
-#: c-parser.c:7593
+#: c-parser.c:7597
 #, gcc-internal-format
 msgid "for statement expected"
 msgstr ""
 
-#: c-parser.c:7643
+#: c-parser.c:7647
 #, gcc-internal-format
 msgid "expected iteration declaration or initialization"
 msgstr ""
 
-#: c-parser.c:7722
+#: c-parser.c:7726
 #, gcc-internal-format
 msgid "not enough perfectly nested loops"
 msgstr ""
 
-#: c-parser.c:7770
+#: c-parser.c:7774
 #, gcc-internal-format
 msgid "collapsed loops not perfectly nested"
 msgstr ""
 
-#: c-parser.c:7807 cp/pt.c:10533
+#: c-parser.c:7811 cp/pt.c:10534
 #, gcc-internal-format
 msgid "iteration variable %qD should not be firstprivate"
 msgstr ""
 
-#: c-parser.c:7957
+#: c-parser.c:7961
 #, gcc-internal-format
 msgid "expected %<#pragma omp section%> or %<}%>"
 msgstr ""
 
-#: c-parser.c:8227
+#: c-parser.c:8231
 #, gcc-internal-format
 msgid "%qD is not a variable"
 msgstr ""
 
-#: c-parser.c:8229 cp/semantics.c:3802
+#: c-parser.c:8233 cp/semantics.c:3804
 #, gcc-internal-format
 msgid "%qE declared %<threadprivate%> after first use"
 msgstr ""
 
-#: c-parser.c:8231 cp/semantics.c:3804
+#: c-parser.c:8235 cp/semantics.c:3806
 #, gcc-internal-format
 msgid "automatic variable %qE cannot be %<threadprivate%>"
 msgstr ""
 
-#: c-parser.c:8235 cp/semantics.c:3806
+#: c-parser.c:8239 cp/semantics.c:3808
 #, gcc-internal-format
 msgid "%<threadprivate%> %qE has incomplete type"
 msgstr ""
@@ -21930,109 +21932,109 @@
 msgid "address of register variable %qD requested"
 msgstr ""
 
-#: c-typeck.c:3462
+#: c-typeck.c:3463
 #, gcc-internal-format
 msgid "non-lvalue array in conditional expression"
 msgstr ""
 
-#: c-typeck.c:3510
+#: c-typeck.c:3513
 #, gcc-internal-format
 msgid "signed and unsigned type in conditional expression"
 msgstr ""
 
-#: c-typeck.c:3518
+#: c-typeck.c:3521
 #, gcc-internal-format
 msgid "ISO C forbids conditional expr with only one void side"
 msgstr ""
 
-#: c-typeck.c:3533 c-typeck.c:3542
+#: c-typeck.c:3536 c-typeck.c:3545
 #, gcc-internal-format
 msgid "ISO C forbids conditional expr between %<void *%> and function pointer"
 msgstr ""
 
-#: c-typeck.c:3550
+#: c-typeck.c:3554
 #, gcc-internal-format
 msgid "pointer type mismatch in conditional expression"
 msgstr ""
 
-#: c-typeck.c:3558 c-typeck.c:3569
+#: c-typeck.c:3562 c-typeck.c:3573
 #, gcc-internal-format
 msgid "pointer/integer type mismatch in conditional expression"
 msgstr ""
 
-#: c-typeck.c:3583
+#: c-typeck.c:3587
 #, gcc-internal-format
 msgid "type mismatch in conditional expression"
 msgstr ""
 
-#: c-typeck.c:3624
+#: c-typeck.c:3628
 #, gcc-internal-format
 msgid "left-hand operand of comma expression has no effect"
 msgstr ""
 
-#: c-typeck.c:3661
+#: c-typeck.c:3665
 #, gcc-internal-format
 msgid "cast specifies array type"
 msgstr ""
 
-#: c-typeck.c:3667
+#: c-typeck.c:3671
 #, gcc-internal-format
 msgid "cast specifies function type"
 msgstr ""
 
-#: c-typeck.c:3683
+#: c-typeck.c:3687
 #, gcc-internal-format
 msgid "ISO C forbids casting nonscalar to the same type"
 msgstr ""
 
-#: c-typeck.c:3700
+#: c-typeck.c:3704
 #, gcc-internal-format
 msgid "ISO C forbids casts to union type"
 msgstr ""
 
-#: c-typeck.c:3707
+#: c-typeck.c:3711
 #, gcc-internal-format
 msgid "cast to union type from type not present in union"
 msgstr ""
 
-#: c-typeck.c:3753
+#: c-typeck.c:3757
 #, gcc-internal-format
 msgid "cast adds new qualifiers to function type"
 msgstr ""
 
 #. There are qualifiers present in IN_OTYPE that are not
 #. present in IN_TYPE.
-#: c-typeck.c:3758
+#: c-typeck.c:3762
 #, gcc-internal-format
 msgid "cast discards qualifiers from pointer target type"
 msgstr ""
 
-#: c-typeck.c:3774
+#: c-typeck.c:3778
 #, gcc-internal-format
 msgid "cast increases required alignment of target type"
 msgstr ""
 
-#: c-typeck.c:3785
+#: c-typeck.c:3789
 #, gcc-internal-format
 msgid "cast from pointer to integer of different size"
 msgstr ""
 
-#: c-typeck.c:3789
+#: c-typeck.c:3793
 #, gcc-internal-format
 msgid "cast from function call of type %qT to non-matching type %qT"
 msgstr ""
 
-#: c-typeck.c:3797
+#: c-typeck.c:3801
 #, gcc-internal-format
 msgid "cast to pointer from integer of different size"
 msgstr ""
 
-#: c-typeck.c:3811
+#: c-typeck.c:3815
 #, gcc-internal-format
 msgid "ISO C forbids conversion of function pointer to object pointer type"
 msgstr ""
 
-#: c-typeck.c:3820
+#: c-typeck.c:3824
 #, gcc-internal-format
 msgid "ISO C forbids conversion of object pointer to function pointer type"
 msgstr ""
@@ -22040,458 +22042,458 @@
 #. This macro is used to emit diagnostics to ensure that all format
 #. strings are complete sentences, visible to gettext and checked at
 #. compile time.
-#: c-typeck.c:4031 c-typeck.c:4464
+#: c-typeck.c:4035 c-typeck.c:4468
 #, gcc-internal-format
 msgid "expected %qT but argument is of type %qT"
 msgstr ""
 
-#: c-typeck.c:4110
+#: c-typeck.c:4114
 #, gcc-internal-format
 msgid "cannot pass rvalue to reference parameter"
 msgstr ""
 
-#: c-typeck.c:4224 c-typeck.c:4393
+#: c-typeck.c:4228 c-typeck.c:4397
 #, gcc-internal-format
 msgid ""
 "passing argument %d of %qE makes qualified function pointer from unqualified"
 msgstr ""
 
-#: c-typeck.c:4227 c-typeck.c:4396
+#: c-typeck.c:4231 c-typeck.c:4400
 #, gcc-internal-format
 msgid "assignment makes qualified function pointer from unqualified"
 msgstr ""
 
-#: c-typeck.c:4230 c-typeck.c:4398
+#: c-typeck.c:4234 c-typeck.c:4402
 #, gcc-internal-format
 msgid "initialization makes qualified function pointer from unqualified"
 msgstr ""
 
-#: c-typeck.c:4233 c-typeck.c:4400
+#: c-typeck.c:4237 c-typeck.c:4404
 #, gcc-internal-format
 msgid "return makes qualified function pointer from unqualified"
 msgstr ""
 
-#: c-typeck.c:4238 c-typeck.c:4358
+#: c-typeck.c:4242 c-typeck.c:4362
 #, gcc-internal-format
 msgid "passing argument %d of %qE discards qualifiers from pointer target type"
 msgstr ""
 
-#: c-typeck.c:4240 c-typeck.c:4360
+#: c-typeck.c:4244 c-typeck.c:4364
 #, gcc-internal-format
 msgid "assignment discards qualifiers from pointer target type"
 msgstr ""
 
-#: c-typeck.c:4242 c-typeck.c:4362
+#: c-typeck.c:4246 c-typeck.c:4366
 #, gcc-internal-format
 msgid "initialization discards qualifiers from pointer target type"
 msgstr ""
 
-#: c-typeck.c:4244 c-typeck.c:4364
+#: c-typeck.c:4248 c-typeck.c:4368
 #, gcc-internal-format
 msgid "return discards qualifiers from pointer target type"
 msgstr ""
 
-#: c-typeck.c:4252
+#: c-typeck.c:4256
 #, gcc-internal-format
 msgid "ISO C prohibits argument conversion to union type"
 msgstr ""
 
-#: c-typeck.c:4285
+#: c-typeck.c:4289
 #, gcc-internal-format
 msgid "request for implicit conversion from %qT to %qT not permitted in C++"
 msgstr ""
 
-#: c-typeck.c:4297
+#: c-typeck.c:4301
 #, gcc-internal-format
 msgid "argument %d of %qE might be a candidate for a format attribute"
 msgstr ""
 
-#: c-typeck.c:4303
+#: c-typeck.c:4307
 #, gcc-internal-format
 msgid "assignment left-hand side might be a candidate for a format attribute"
 msgstr ""
 
-#: c-typeck.c:4308
+#: c-typeck.c:4312
 #, gcc-internal-format
 msgid ""
 "initialization left-hand side might be a candidate for a format attribute"
 msgstr ""
 
-#: c-typeck.c:4313
+#: c-typeck.c:4317
 #, gcc-internal-format
 msgid "return type might be a candidate for a format attribute"
 msgstr ""
 
-#: c-typeck.c:4337
+#: c-typeck.c:4341
 #, gcc-internal-format
 msgid ""
 "ISO C forbids passing argument %d of %qE between function pointer and %<void "
 "*%>"
 msgstr ""
 
-#: c-typeck.c:4340
+#: c-typeck.c:4344
 #, gcc-internal-format
 msgid "ISO C forbids assignment between function pointer and %<void *%>"
 msgstr ""
 
-#: c-typeck.c:4342
+#: c-typeck.c:4346
 #, gcc-internal-format
 msgid "ISO C forbids initialization between function pointer and %<void *%>"
 msgstr ""
 
-#: c-typeck.c:4344
+#: c-typeck.c:4348
 #, gcc-internal-format
 msgid "ISO C forbids return between function pointer and %<void *%>"
 msgstr ""
 
-#: c-typeck.c:4375
+#: c-typeck.c:4379
 #, gcc-internal-format
 msgid "pointer targets in passing argument %d of %qE differ in signedness"
 msgstr ""
 
-#: c-typeck.c:4377
+#: c-typeck.c:4381
 #, gcc-internal-format
 msgid "pointer targets in assignment differ in signedness"
 msgstr ""
 
-#: c-typeck.c:4379
+#: c-typeck.c:4383
 #, gcc-internal-format
 msgid "pointer targets in initialization differ in signedness"
 msgstr ""
 
-#: c-typeck.c:4381
+#: c-typeck.c:4385
 #, gcc-internal-format
 msgid "pointer targets in return differ in signedness"
 msgstr ""
 
-#: c-typeck.c:4408
+#: c-typeck.c:4412
 #, gcc-internal-format
 msgid "passing argument %d of %qE from incompatible pointer type"
 msgstr ""
 
-#: c-typeck.c:4410
+#: c-typeck.c:4414
 #, gcc-internal-format
 msgid "assignment from incompatible pointer type"
 msgstr ""
 
-#: c-typeck.c:4411
+#: c-typeck.c:4415
 #, gcc-internal-format
 msgid "initialization from incompatible pointer type"
 msgstr ""
 
-#: c-typeck.c:4413
+#: c-typeck.c:4417
 #, gcc-internal-format
 msgid "return from incompatible pointer type"
 msgstr ""
 
-#: c-typeck.c:4431
+#: c-typeck.c:4435
 #, gcc-internal-format
 msgid "passing argument %d of %qE makes pointer from integer without a cast"
 msgstr ""
 
-#: c-typeck.c:4433
+#: c-typeck.c:4437
 #, gcc-internal-format
 msgid "assignment makes pointer from integer without a cast"
 msgstr ""
 
-#: c-typeck.c:4435
+#: c-typeck.c:4439
 #, gcc-internal-format
 msgid "initialization makes pointer from integer without a cast"
 msgstr ""
 
-#: c-typeck.c:4437
+#: c-typeck.c:4441
 #, gcc-internal-format
 msgid "return makes pointer from integer without a cast"
 msgstr ""
 
-#: c-typeck.c:4445
+#: c-typeck.c:4449
 #, gcc-internal-format
 msgid "passing argument %d of %qE makes integer from pointer without a cast"
 msgstr ""
 
-#: c-typeck.c:4447
+#: c-typeck.c:4451
 #, gcc-internal-format
 msgid "assignment makes integer from pointer without a cast"
 msgstr ""
 
-#: c-typeck.c:4449
+#: c-typeck.c:4453
 #, gcc-internal-format
 msgid "initialization makes integer from pointer without a cast"
 msgstr ""
 
-#: c-typeck.c:4451
+#: c-typeck.c:4455
 #, gcc-internal-format
 msgid "return makes integer from pointer without a cast"
 msgstr ""
 
-#: c-typeck.c:4467
+#: c-typeck.c:4471
 #, gcc-internal-format
 msgid "incompatible types when assigning to type %qT from type %qT"
 msgstr ""
 
-#: c-typeck.c:4471
+#: c-typeck.c:4475
 #, gcc-internal-format
 msgid "incompatible types when initializing type %qT using type %qT"
 msgstr ""
 
-#: c-typeck.c:4475
+#: c-typeck.c:4479
 #, gcc-internal-format
 msgid "incompatible types when returning type %qT but %qT was expected"
 msgstr ""
 
-#: c-typeck.c:4532
+#: c-typeck.c:4536
 #, gcc-internal-format
 msgid "traditional C rejects automatic aggregate initialization"
 msgstr ""
 
-#: c-typeck.c:4703 c-typeck.c:4719 c-typeck.c:4736
+#: c-typeck.c:4707 c-typeck.c:4723 c-typeck.c:4740
 #, gcc-internal-format
 msgid "(near initialization for %qs)"
 msgstr ""
 
-#: c-typeck.c:5291 cp/decl.c:5158
+#: c-typeck.c:5295 cp/decl.c:5161
 #, gcc-internal-format
 msgid "opaque vector types cannot be initialized"
 msgstr ""
 
-#: c-typeck.c:5916
+#: c-typeck.c:5920
 #, gcc-internal-format
 msgid "unknown field %qE specified in initializer"
 msgstr ""
 
-#: c-typeck.c:6836
+#: c-typeck.c:6840
 #, gcc-internal-format
 msgid "traditional C rejects initialization of unions"
 msgstr ""
 
-#: c-typeck.c:7147
+#: c-typeck.c:7151
 #, gcc-internal-format
 msgid "jump into statement expression"
 msgstr ""
 
-#: c-typeck.c:7153
+#: c-typeck.c:7157
 #, gcc-internal-format
 msgid "jump into scope of identifier with variably modified type"
 msgstr ""
 
-#: c-typeck.c:7189
+#: c-typeck.c:7193
 #, gcc-internal-format
 msgid "ISO C forbids %<goto *expr;%>"
 msgstr ""
 
-#: c-typeck.c:7204 cp/typeck.c:6820
+#: c-typeck.c:7208 cp/typeck.c:6820
 #, gcc-internal-format
 msgid "function declared %<noreturn%> has a %<return%> statement"
 msgstr ""
 
-#: c-typeck.c:7213
+#: c-typeck.c:7217
 #, gcc-internal-format
 msgid "%<return%> with no value, in function returning non-void"
 msgstr ""
 
-#: c-typeck.c:7223
+#: c-typeck.c:7227
 #, gcc-internal-format
 msgid "%<return%> with a value, in function returning void"
 msgstr ""
 
-#: c-typeck.c:7225
+#: c-typeck.c:7229
 #, gcc-internal-format
 msgid "ISO C forbids %<return%> with expression, in function returning void"
 msgstr ""
 
-#: c-typeck.c:7284
+#: c-typeck.c:7288
 #, gcc-internal-format
 msgid "function returns address of local variable"
 msgstr ""
 
-#: c-typeck.c:7359 cp/semantics.c:952
+#: c-typeck.c:7363 cp/semantics.c:952
 #, gcc-internal-format
 msgid "switch quantity not an integer"
 msgstr ""
 
-#: c-typeck.c:7371
+#: c-typeck.c:7375
 #, gcc-internal-format
 msgid "%<long%> switch expression not converted to %<int%> in ISO C"
 msgstr ""
 
-#: c-typeck.c:7414
+#: c-typeck.c:7418
 #, gcc-internal-format
 msgid ""
 "case label in statement expression not containing enclosing switch statement"
 msgstr ""
 
-#: c-typeck.c:7417
+#: c-typeck.c:7421
 #, gcc-internal-format
 msgid ""
 "%<default%> label in statement expression not containing enclosing switch "
 "statement"
 msgstr ""
 
-#: c-typeck.c:7423
+#: c-typeck.c:7427
 #, gcc-internal-format
 msgid ""
 "case label in scope of identifier with variably modified type not containing "
 "enclosing switch statement"
 msgstr ""
 
-#: c-typeck.c:7426
+#: c-typeck.c:7430
 #, gcc-internal-format
 msgid ""
 "%<default%> label in scope of identifier with variably modified type not "
 "containing enclosing switch statement"
 msgstr ""
 
-#: c-typeck.c:7430
+#: c-typeck.c:7434
 #, gcc-internal-format
 msgid "case label not within a switch statement"
 msgstr ""
 
-#: c-typeck.c:7432
+#: c-typeck.c:7436
 #, gcc-internal-format
 msgid "%<default%> label not within a switch statement"
 msgstr ""
 
-#: c-typeck.c:7509
+#: c-typeck.c:7513
 #, gcc-internal-format
 msgid "%Hsuggest explicit braces to avoid ambiguous %<else%>"
 msgstr ""
 
-#: c-typeck.c:7618 cp/cp-gimplify.c:92
+#: c-typeck.c:7622 cp/cp-gimplify.c:92
 #, gcc-internal-format
 msgid "break statement not within loop or switch"
 msgstr ""
 
-#: c-typeck.c:7620
+#: c-typeck.c:7624
 #, gcc-internal-format
 msgid "continue statement not within a loop"
 msgstr ""
 
-#: c-typeck.c:7625
+#: c-typeck.c:7629
 #, gcc-internal-format
 msgid "break statement used with OpenMP for loop"
 msgstr ""
 
-#: c-typeck.c:7651
+#: c-typeck.c:7655
 #, gcc-internal-format
 msgid "%Hstatement with no effect"
 msgstr ""
 
-#: c-typeck.c:7673
+#: c-typeck.c:7677
 #, gcc-internal-format
 msgid "expression statement has incomplete type"
 msgstr ""
 
-#: c-typeck.c:8245 cp/typeck.c:3506
+#: c-typeck.c:8249 cp/typeck.c:3506
 #, gcc-internal-format
 msgid "right shift count is negative"
 msgstr ""
 
-#: c-typeck.c:8252 cp/typeck.c:3512
+#: c-typeck.c:8256 cp/typeck.c:3512
 #, gcc-internal-format
 msgid "right shift count >= width of type"
 msgstr ""
 
-#: c-typeck.c:8274 cp/typeck.c:3533
+#: c-typeck.c:8278 cp/typeck.c:3533
 #, gcc-internal-format
 msgid "left shift count is negative"
 msgstr ""
 
-#: c-typeck.c:8277 cp/typeck.c:3538
+#: c-typeck.c:8281 cp/typeck.c:3538
 #, gcc-internal-format
 msgid "left shift count >= width of type"
 msgstr ""
 
-#: c-typeck.c:8296 cp/typeck.c:3584
+#: c-typeck.c:8300 cp/typeck.c:3584
 #, gcc-internal-format
 msgid "comparing floating point with == or != is unsafe"
 msgstr ""
 
-#: c-typeck.c:8320 c-typeck.c:8327
+#: c-typeck.c:8324 c-typeck.c:8331
 #, gcc-internal-format
 msgid "ISO C forbids comparison of %<void *%> with function pointer"
 msgstr ""
 
-#: c-typeck.c:8334 c-typeck.c:8396
+#: c-typeck.c:8338 c-typeck.c:8400
 #, gcc-internal-format
 msgid "comparison of distinct pointer types lacks a cast"
 msgstr ""
 
-#: c-typeck.c:8344 c-typeck.c:8353 cp/typeck.c:3607 cp/typeck.c:3619
+#: c-typeck.c:8348 c-typeck.c:8357 cp/typeck.c:3607 cp/typeck.c:3619
 #, gcc-internal-format
 msgid "the address of %qD will never be NULL"
 msgstr ""
 
-#: c-typeck.c:8360 c-typeck.c:8365 c-typeck.c:8418 c-typeck.c:8423
+#: c-typeck.c:8364 c-typeck.c:8369 c-typeck.c:8422 c-typeck.c:8427
 #, gcc-internal-format
 msgid "comparison between pointer and integer"
 msgstr ""
 
-#: c-typeck.c:8387
+#: c-typeck.c:8391
 #, gcc-internal-format
 msgid "comparison of complete and incomplete pointers"
 msgstr ""
 
-#: c-typeck.c:8389
+#: c-typeck.c:8393
 #, gcc-internal-format
 msgid "ISO C forbids ordered comparisons of pointers to functions"
 msgstr ""
 
-#: c-typeck.c:8404 c-typeck.c:8407 c-typeck.c:8413
+#: c-typeck.c:8408 c-typeck.c:8411 c-typeck.c:8417
 #, gcc-internal-format
 msgid "ordered comparison of pointer with integer zero"
 msgstr ""
 
-#: c-typeck.c:8591
+#: c-typeck.c:8595
 #, gcc-internal-format
 msgid "used array that cannot be converted to pointer where scalar is required"
 msgstr ""
 
-#: c-typeck.c:8595
+#: c-typeck.c:8599
 #, gcc-internal-format
 msgid "used struct type value where scalar is required"
 msgstr ""
 
-#: c-typeck.c:8599
+#: c-typeck.c:8603
 #, gcc-internal-format
 msgid "used union type value where scalar is required"
 msgstr ""
 
-#: c-typeck.c:8735 cp/semantics.c:3685
+#: c-typeck.c:8739 cp/semantics.c:3687
 #, gcc-internal-format
 msgid "%qE has invalid type for %<reduction%>"
 msgstr ""
 
-#: c-typeck.c:8769 cp/semantics.c:3698
+#: c-typeck.c:8773 cp/semantics.c:3700
 #, gcc-internal-format
 msgid "%qE has invalid type for %<reduction(%s)%>"
 msgstr ""
 
-#: c-typeck.c:8785 cp/semantics.c:3708
+#: c-typeck.c:8789 cp/semantics.c:3710
 #, gcc-internal-format
 msgid "%qE must be %<threadprivate%> for %<copyin%>"
 msgstr ""
 
-#: c-typeck.c:8794 cp/semantics.c:3505
+#: c-typeck.c:8798 cp/semantics.c:3507
 #, gcc-internal-format
 msgid "%qE is not a variable in clause %qs"
 msgstr ""
 
-#: c-typeck.c:8801 c-typeck.c:8821 c-typeck.c:8841
+#: c-typeck.c:8805 c-typeck.c:8825 c-typeck.c:8845
 #, gcc-internal-format
 msgid "%qE appears more than once in data clauses"
 msgstr ""
 
-#: c-typeck.c:8815 cp/semantics.c:3528
+#: c-typeck.c:8819 cp/semantics.c:3530
 #, gcc-internal-format
 msgid "%qE is not a variable in clause %<firstprivate%>"
 msgstr ""
 
-#: c-typeck.c:8835 cp/semantics.c:3550
+#: c-typeck.c:8839 cp/semantics.c:3552
 #, gcc-internal-format
 msgid "%qE is not a variable in clause %<lastprivate%>"
 msgstr ""
 
-#: c-typeck.c:8895 cp/semantics.c:3749
+#: c-typeck.c:8899 cp/semantics.c:3751
 #, gcc-internal-format
 msgid "%qE is predetermined %qs for %qs"
 msgstr ""
@@ -23629,18 +23631,18 @@
 "critical region may not be nested inside a critical region with the same name"
 msgstr ""
 
-#: omp-low.c:6629 cp/decl.c:2680
+#: omp-low.c:6682 cp/decl.c:2680
 #, gcc-internal-format
 msgid "invalid exit from OpenMP structured block"
 msgstr ""
 
-#: omp-low.c:6631 omp-low.c:6636
+#: omp-low.c:6684 omp-low.c:6689
 #, gcc-internal-format
 msgid "invalid entry to OpenMP structured block"
 msgstr ""
 
 #. Otherwise, be vague and lazy, but efficient.
-#: omp-low.c:6639
+#: omp-low.c:6692
 #, gcc-internal-format
 msgid "invalid branch to/from an OpenMP structured block"
 msgstr ""
@@ -23663,142 +23665,137 @@
 msgstr ""
 
 #. Eventually this should become a hard error IMO.
-#: opts.c:448
+#: opts.c:442
 #, gcc-internal-format
 msgid "command line option \"%s\" is valid for %s but not for %s"
 msgstr ""
 
-#: opts.c:479 opts.c:807
+#: opts.c:473 opts.c:769
 #, gcc-internal-format
 msgid "unrecognized command line option \"%s\""
 msgstr ""
 
-#: opts.c:540
+#: opts.c:534
 #, gcc-internal-format
 msgid "command line option %qs is not supported by this configuration"
 msgstr ""
 
-#: opts.c:593
+#: opts.c:587
 #, gcc-internal-format
 msgid "missing argument to \"%s\""
 msgstr ""
 
-#: opts.c:603
+#: opts.c:597
 #, gcc-internal-format
 msgid "argument to \"%s\" should be a non-negative integer"
 msgstr ""
 
-#: opts.c:769
-#, gcc-internal-format
-msgid "disallowed call to %qs"
-msgstr ""
-
-#: opts.c:1031
+#: opts.c:993
 #, gcc-internal-format
 msgid "Section anchors must be disabled when unit-at-a-time is disabled."
 msgstr ""
 
-#: opts.c:1035
+#: opts.c:997
 #, gcc-internal-format
 msgid "Toplevel reorder must be disabled when unit-at-a-time is disabled."
 msgstr ""
 
-#: opts.c:1050
+#: opts.c:1012
 #, gcc-internal-format
 msgid "section anchors must be disabled when toplevel reorder is disabled"
 msgstr ""
 
-#: opts.c:1080
+#: opts.c:1042
 #, gcc-internal-format
 msgid "-freorder-blocks-and-partition does not work with exceptions"
 msgstr ""
 
-#: opts.c:1091
+#: opts.c:1053
 #, gcc-internal-format
 msgid "-freorder-blocks-and-partition does not support unwind info"
 msgstr ""
 
-#: opts.c:1105
+#: opts.c:1067
 #, gcc-internal-format
 msgid "-freorder-blocks-and-partition does not work on this architecture"
 msgstr ""
 
-#: opts.c:1119
+#: opts.c:1081
 #, gcc-internal-format
 msgid "-fira-algorithm=CB does not work on this architecture"
 msgstr ""
 
-#: opts.c:1428
+#: opts.c:1390
 #, gcc-internal-format
 msgid "unrecognized include_flags 0x%x passed to print_specific_help"
 msgstr ""
 
-#: opts.c:1809
+#: opts.c:1765
 #, gcc-internal-format
 msgid "structure alignment must be a small power of two, not %d"
 msgstr ""
 
-#: opts.c:1896
+#: opts.c:1852
 #, gcc-internal-format
 msgid "unrecognized visibility value \"%s\""
 msgstr ""
 
-#: opts.c:1954
+#: opts.c:1910
 #, gcc-internal-format
 msgid "unknown stack check parameter \"%s\""
 msgstr ""
 
-#: opts.c:1980
+#: opts.c:1936
 #, gcc-internal-format
 msgid "unrecognized register name \"%s\""
 msgstr ""
 
-#: opts.c:2004
+#: opts.c:1960
 #, gcc-internal-format
 msgid "unknown tls-model \"%s\""
 msgstr ""
 
-#: opts.c:2013
+#: opts.c:1969
 #, gcc-internal-format
 msgid "unknown ira algorithm \"%s\""
 msgstr ""
 
-#: opts.c:2024
+#: opts.c:1980
 #, gcc-internal-format
 msgid "unknown ira region \"%s\""
 msgstr ""
 
-#: opts.c:2127
+#: opts.c:2083
 #, gcc-internal-format
 msgid "%s: --param arguments should be of the form NAME=VALUE"
 msgstr ""
 
-#: opts.c:2132
+#: opts.c:2088
 #, gcc-internal-format
 msgid "invalid --param value %qs"
 msgstr ""
 
-#: opts.c:2250
+#: opts.c:2206
 #, gcc-internal-format
 msgid "target system does not support debug output"
 msgstr ""
 
-#: opts.c:2257
+#: opts.c:2213
 #, gcc-internal-format
 msgid "debug format \"%s\" conflicts with prior selection"
 msgstr ""
 
-#: opts.c:2273
+#: opts.c:2229
 #, gcc-internal-format
 msgid "unrecognised debug output level \"%s\""
 msgstr ""
 
-#: opts.c:2275
+#: opts.c:2231
 #, gcc-internal-format
 msgid "debug output level %s is too high"
 msgstr ""
 
-#: opts.c:2357
+#: opts.c:2313
 #, gcc-internal-format
 msgid "-Werror=%s: No option -%s"
 msgstr ""
@@ -25319,9 +25316,9 @@
 msgstr ""
 
 #: tree.c:4076 tree.c:4088 tree.c:4098 config/darwin.c:1437
-#: config/arm/arm.c:3294 config/arm/arm.c:3322 config/avr/avr.c:4791
+#: config/arm/arm.c:3294 config/arm/arm.c:3322 config/avr/avr.c:4804
 #: config/h8300/h8300.c:5283 config/h8300/h8300.c:5307 config/i386/i386.c:4179
-#: config/i386/i386.c:26410 config/ia64/ia64.c:621
+#: config/i386/i386.c:26447 config/ia64/ia64.c:621
 #: config/m68hc11/m68hc11.c:1118 config/rs6000/rs6000.c:20739
 #: config/sh/symbian.c:408 config/sh/symbian.c:415
 #, gcc-internal-format
@@ -25768,7 +25765,7 @@
 #. coalesced sections.  Weak aliases (or any other kind of aliases) are
 #. not supported.  Weak symbols that aren't visible outside the .s file
 #. are not supported.
-#: config/darwin.h:452
+#: config/darwin.h:456
 #, gcc-internal-format
 msgid "alias definitions not supported in Mach-O; ignored"
 msgstr ""
@@ -26020,9 +26017,9 @@
 msgid "unable to use '%s' for PIC register"
 msgstr ""
 
-#: config/arm/arm.c:3262 config/arm/arm.c:3280 config/avr/avr.c:4811
-#: config/avr/avr.c:4827 config/bfin/bfin.c:5228 config/h8300/h8300.c:5259
-#: config/i386/i386.c:4141 config/i386/i386.c:26355
+#: config/arm/arm.c:3262 config/arm/arm.c:3280 config/avr/avr.c:4824
+#: config/avr/avr.c:4840 config/bfin/bfin.c:5228 config/h8300/h8300.c:5259
+#: config/i386/i386.c:4141 config/i386/i386.c:26392
 #: config/m68hc11/m68hc11.c:1155 config/m68k/m68k.c:783
 #: config/mcore/mcore.c:3034 config/mips/mips.c:1223 config/mips/mips.c:1225
 #: config/rs6000/rs6000.c:20665 config/sh/sh.c:8129 config/sh/sh.c:8147
@@ -26079,27 +26076,42 @@
 msgid "static variable %q+D is marked dllimport"
 msgstr ""
 
-#: config/avr/avr.c:4613
+#: config/avr/avr.c:399
+#, gcc-internal-format
+msgid "the -mno-tablejump switch is deprecated"
+msgstr ""
+
+#: config/avr/avr.c:400
+#, gcc-internal-format
+msgid "GCC 4.4 is the last release with this switch"
+msgstr ""
+
+#: config/avr/avr.c:401
+#, gcc-internal-format
+msgid "use the -fno-jump-tables switch instead"
+msgstr ""
+
+#: config/avr/avr.c:4626
 #, gcc-internal-format
 msgid "%qs appears to be a misspelled interrupt handler"
 msgstr ""
 
-#: config/avr/avr.c:4622
+#: config/avr/avr.c:4635
 #, gcc-internal-format
 msgid "%qs appears to be a misspelled signal handler"
 msgstr ""
 
-#: config/avr/avr.c:4784
+#: config/avr/avr.c:4797
 #, gcc-internal-format
 msgid "only initialized variables can be placed into program memory area"
 msgstr ""
 
-#: config/avr/avr.c:4918
+#: config/avr/avr.c:4931
 #, gcc-internal-format
 msgid "only uninitialized variables can be placed in the .noinit section"
 msgstr ""
 
-#: config/avr/avr.c:4932
+#: config/avr/avr.c:4945
 #, gcc-internal-format
 msgid "MCU %qs supported for assembler only"
 msgstr ""
@@ -26649,127 +26661,139 @@
 msgid "AVX vector argument without AVX enabled changes the ABI"
 msgstr ""
 
-#: config/i386/i386.c:5039
+#: config/i386/i386.c:4942
+#, gcc-internal-format
+msgid ""
+"The ABI of passing struct with a flexible array member has changed in GCC 4.4"
+msgstr ""
+
+#: config/i386/i386.c:5061
 #, gcc-internal-format
 msgid "The ABI of passing union with long double has changed in GCC 4.4"
 msgstr ""
 
-#: config/i386/i386.c:5284
+#: config/i386/i386.c:5176
+#, gcc-internal-format
+msgid ""
+"The ABI of passing structure with complex float member has changed in GCC 4.4"
+msgstr ""
+
+#: config/i386/i386.c:5321
 #, gcc-internal-format
 msgid "SSE register return with SSE disabled"
 msgstr ""
 
-#: config/i386/i386.c:5290
+#: config/i386/i386.c:5327
 #, gcc-internal-format
 msgid "SSE register argument with SSE disabled"
 msgstr ""
 
-#: config/i386/i386.c:5306
+#: config/i386/i386.c:5343
 #, gcc-internal-format
 msgid "x87 register return with x87 disabled"
 msgstr ""
 
-#: config/i386/i386.c:5672
+#: config/i386/i386.c:5709
 #, gcc-internal-format
 msgid "SSE vector argument without SSE enabled changes the ABI"
 msgstr ""
 
-#: config/i386/i386.c:5709
+#: config/i386/i386.c:5746
 #, gcc-internal-format
 msgid "MMX vector argument without MMX enabled changes the ABI"
 msgstr ""
 
-#: config/i386/i386.c:6310
+#: config/i386/i386.c:6347
 #, gcc-internal-format
 msgid "SSE vector return without SSE enabled changes the ABI"
 msgstr ""
 
-#: config/i386/i386.c:6320
+#: config/i386/i386.c:6357
 #, gcc-internal-format
 msgid "MMX vector return without MMX enabled changes the ABI"
 msgstr ""
 
-#: config/i386/i386.c:10587
+#: config/i386/i386.c:10624
 #, gcc-internal-format
 msgid "extended registers have no high halves"
 msgstr ""
 
-#: config/i386/i386.c:10602
+#: config/i386/i386.c:10639
 #, gcc-internal-format
 msgid "unsupported operand size for extended register"
 msgstr ""
 
-#: config/i386/i386.c:23572
+#: config/i386/i386.c:23609
 #, gcc-internal-format
 msgid "last argument must be an immediate"
 msgstr ""
 
-#: config/i386/i386.c:23865
+#: config/i386/i386.c:23902
 #, gcc-internal-format
 msgid "the fifth argument must be a 8-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:23960
+#: config/i386/i386.c:23997
 #, gcc-internal-format
 msgid "the third argument must be a 8-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24300
+#: config/i386/i386.c:24337
 #, gcc-internal-format
 msgid "the last argument must be a 4-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24305
+#: config/i386/i386.c:24342
 #, gcc-internal-format
 msgid "the last argument must be a 2-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24314
+#: config/i386/i386.c:24351
 #, gcc-internal-format
 msgid "the last argument must be a 1-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24323
+#: config/i386/i386.c:24360
 #, gcc-internal-format
 msgid "the last argument must be a 5-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24332
+#: config/i386/i386.c:24369
 #, gcc-internal-format
 msgid "the next to last argument must be an 8-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24336 config/i386/i386.c:24514
+#: config/i386/i386.c:24373 config/i386/i386.c:24551
 #, gcc-internal-format
 msgid "the last argument must be an 8-bit immediate"
 msgstr ""
 
-#: config/i386/i386.c:24572 config/rs6000/rs6000.c:8540
+#: config/i386/i386.c:24609 config/rs6000/rs6000.c:8540
 #, gcc-internal-format
 msgid "selector must be an integer constant in the range 0..%wi"
 msgstr ""
 
-#: config/i386/i386.c:24715
+#: config/i386/i386.c:24752
 #, gcc-internal-format
 msgid "%qE needs unknown isa option"
 msgstr ""
 
-#: config/i386/i386.c:24719
+#: config/i386/i386.c:24756
 #, gcc-internal-format
 msgid "%qE needs isa option %s"
 msgstr ""
 
-#: config/i386/i386.c:26362
+#: config/i386/i386.c:26399
 #, gcc-internal-format
 msgid "%qs attribute only available for 64-bit"
 msgstr ""
 
-#: config/i386/i386.c:26373 config/i386/i386.c:26382
+#: config/i386/i386.c:26410 config/i386/i386.c:26419
 #, gcc-internal-format
 msgid "ms_abi and sysv_abi attributes are not compatible"
 msgstr ""
 
-#: config/i386/i386.c:26420 config/rs6000/rs6000.c:20748
+#: config/i386/i386.c:26457 config/rs6000/rs6000.c:20748
 #, gcc-internal-format
 msgid "%qs incompatible attribute ignored"
 msgstr ""
@@ -26857,22 +26881,32 @@
 msgid "%s-%s is an empty range"
 msgstr ""
 
-#: config/ia64/ia64.c:5223
+#: config/ia64/ia64.c:5225
 #, gcc-internal-format
 msgid "bad value %<%s%> for -mtls-size= switch"
 msgstr ""
 
-#: config/ia64/ia64.c:5251
+#: config/ia64/ia64.c:5254
+#, gcc-internal-format
+msgid "value %<%s%> for -mtune= switch is deprecated"
+msgstr ""
+
+#: config/ia64/ia64.c:5256
+#, gcc-internal-format
+msgid "GCC 4.4 is the last release with Itanium1 tuning support"
+msgstr ""
+
+#: config/ia64/ia64.c:5263
 #, gcc-internal-format
 msgid "bad value %<%s%> for -mtune= switch"
 msgstr ""
 
-#: config/ia64/ia64.c:5270
+#: config/ia64/ia64.c:5282
 #, gcc-internal-format
 msgid "not yet implemented: latency-optimized inline square root"
 msgstr ""
 
-#: config/ia64/ia64.c:10535
+#: config/ia64/ia64.c:10547
 #, gcc-internal-format
 msgid "version attribute is not a string"
 msgstr ""
@@ -27373,37 +27407,37 @@
 msgid "junk at end of #pragma longcall"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:2989
+#: config/rs6000/rs6000-c.c:3001
 #, gcc-internal-format
 msgid "%s only accepts %d arguments"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:2994
+#: config/rs6000/rs6000-c.c:3006
 #, gcc-internal-format
 msgid "%s only accepts 1 argument"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:2999 config/rs6000/rs6000-c.c:3006
+#: config/rs6000/rs6000-c.c:3011 config/rs6000/rs6000-c.c:3018
 #, gcc-internal-format
 msgid "%s only accepts 2 arguments"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:3067
+#: config/rs6000/rs6000-c.c:3079
 #, gcc-internal-format
 msgid "vec_extract only accepts 2 arguments"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:3124
+#: config/rs6000/rs6000-c.c:3136
 #, gcc-internal-format
 msgid "vec_insert only accepts 3 arguments"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:3206
+#: config/rs6000/rs6000-c.c:3218
 #, gcc-internal-format
 msgid "passing arg %d of %qE discards qualifiers frompointer target type"
 msgstr ""
 
-#: config/rs6000/rs6000-c.c:3249
+#: config/rs6000/rs6000-c.c:3261
 #, gcc-internal-format
 msgid "invalid parameter combination for AltiVec intrinsic"
 msgstr ""
@@ -27714,7 +27748,7 @@
 msgid "-m64 not supported in this configuration"
 msgstr ""
 
-#: config/rs6000/linux64.h:108
+#: config/rs6000/linux64.h:113
 #, gcc-internal-format
 msgid "-m64 requires a PowerPC64 cpu"
 msgstr ""
@@ -27731,7 +27765,7 @@
 #. Number of bytes into the frame return addresses can be found.  See
 #. rs6000_stack_info in rs6000.c for more information on how the different
 #. abi's store the return address.
-#: config/rs6000/rs6000.h:1643
+#: config/rs6000/rs6000.h:1648
 #, gcc-internal-format
 msgid "RETURN_ADDRESS_OFFSET not supported"
 msgstr ""
@@ -27744,57 +27778,57 @@
 #.
 #. The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to
 #. get control.
-#: config/rs6000/sysv4.h:129
+#: config/rs6000/sysv4.h:134
 #, gcc-internal-format
 msgid "bad value for -mcall-%s"
 msgstr ""
 
-#: config/rs6000/sysv4.h:145
+#: config/rs6000/sysv4.h:150
 #, gcc-internal-format
 msgid "bad value for -msdata=%s"
 msgstr ""
 
-#: config/rs6000/sysv4.h:162
+#: config/rs6000/sysv4.h:167
 #, gcc-internal-format
 msgid "-mrelocatable and -msdata=%s are incompatible"
 msgstr ""
 
-#: config/rs6000/sysv4.h:171
+#: config/rs6000/sysv4.h:176
 #, gcc-internal-format
 msgid "-f%s and -msdata=%s are incompatible"
 msgstr ""
 
-#: config/rs6000/sysv4.h:180
+#: config/rs6000/sysv4.h:185
 #, gcc-internal-format
 msgid "-msdata=%s and -mcall-%s are incompatible"
 msgstr ""
 
-#: config/rs6000/sysv4.h:189
+#: config/rs6000/sysv4.h:194
 #, gcc-internal-format
 msgid "-mrelocatable and -mno-minimal-toc are incompatible"
 msgstr ""
 
-#: config/rs6000/sysv4.h:195
+#: config/rs6000/sysv4.h:200
 #, gcc-internal-format
 msgid "-mrelocatable and -mcall-%s are incompatible"
 msgstr ""
 
-#: config/rs6000/sysv4.h:202
+#: config/rs6000/sysv4.h:207
 #, gcc-internal-format
 msgid "-fPIC and -mcall-%s are incompatible"
 msgstr ""
 
-#: config/rs6000/sysv4.h:209
+#: config/rs6000/sysv4.h:214
 #, gcc-internal-format
 msgid "-mcall-aixdesc must be big endian"
 msgstr ""
 
-#: config/rs6000/sysv4.h:214
+#: config/rs6000/sysv4.h:219
 #, gcc-internal-format
 msgid "-msecure-plt not supported by your assembler"
 msgstr ""
 
-#: config/rs6000/sysv4.h:232
+#: config/rs6000/sysv4.h:237
 #, gcc-internal-format
 msgid "-m%s not supported in this configuration"
 msgstr ""
@@ -27966,7 +28000,7 @@
 msgid "%s %q+D %s after being referenced with dllimport linkage"
 msgstr ""
 
-#: config/sh/symbian.c:891 cp/tree.c:2843
+#: config/sh/symbian.c:891 cp/tree.c:2842
 #, gcc-internal-format
 msgid "lang_* check: failed in %s, at %s:%d"
 msgstr ""
@@ -28493,76 +28527,91 @@
 msgid "%qT is not an accessible base of %qT"
 msgstr ""
 
-#: cp/call.c:5522
+#: cp/call.c:5538
 #, gcc-internal-format
 msgid "could not find class$ field in java interface type %qT"
 msgstr ""
 
-#: cp/call.c:5765
+#: cp/call.c:5781
 #, gcc-internal-format
 msgid "call to non-function %qD"
 msgstr ""
 
-#: cp/call.c:5904
+#: cp/call.c:5920
 #, gcc-internal-format
 msgid "no matching function for call to %<%T::%s(%A)%#V%>"
 msgstr ""
 
-#: cp/call.c:5925
+#: cp/call.c:5941
 #, gcc-internal-format
 msgid "call of overloaded %<%s(%A)%> is ambiguous"
 msgstr ""
 
-#: cp/call.c:5954
+#: cp/call.c:5970
 #, gcc-internal-format
 msgid "cannot call member function %qD without object"
 msgstr ""
 
-#: cp/call.c:6642
+#: cp/call.c:6658
 #, gcc-internal-format
 msgid "passing %qT chooses %qT over %qT"
 msgstr ""
 
-#: cp/call.c:6644 cp/name-lookup.c:4468 cp/name-lookup.c:4913
+#: cp/call.c:6660 cp/name-lookup.c:4469 cp/name-lookup.c:4914
 #, gcc-internal-format
 msgid "  in call to %qD"
 msgstr ""
 
-#: cp/call.c:6701
+#: cp/call.c:6717
 #, gcc-internal-format
 msgid "choosing %qD over %qD"
 msgstr ""
 
-#: cp/call.c:6702
+#: cp/call.c:6718
 #, gcc-internal-format
 msgid "  for conversion from %qT to %qT"
 msgstr ""
 
-#: cp/call.c:6705
+#: cp/call.c:6721
 #, gcc-internal-format
 msgid "  because conversion sequence for the argument is better"
 msgstr ""
 
-#: cp/call.c:6821
+#: cp/call.c:6839
+#, gcc-internal-format
+msgid "default argument mismatch in overload resolution"
+msgstr ""
+
+#: cp/call.c:6842
+#, gcc-internal-format
+msgid " candidate 1: %q+#F"
+msgstr ""
+
+#: cp/call.c:6844
+#, gcc-internal-format
+msgid " candidate 2: %q+#F"
+msgstr ""
+
+#: cp/call.c:6882
 #, gcc-internal-format
 msgid ""
 "ISO C++ says that these are ambiguous, even though the worst conversion for "
 "the first is better than the worst conversion for the second:"
 msgstr ""
 
-#: cp/call.c:6965
+#: cp/call.c:7026
 #, gcc-internal-format
 msgid "could not convert %qE to %qT"
 msgstr ""
 
-#: cp/call.c:7171
+#: cp/call.c:7232
 #, gcc-internal-format
 msgid ""
 "invalid initialization of non-const reference of type %qT from a temporary "
 "of type %qT"
 msgstr ""
 
-#: cp/call.c:7175
+#: cp/call.c:7236
 #, gcc-internal-format
 msgid ""
 "invalid initialization of reference of type %qT from expression of type %qT"
@@ -28903,27 +28952,27 @@
 msgid "no matches converting function %qD to type %q#T"
 msgstr ""
 
-#: cp/class.c:6161
+#: cp/class.c:6168
 #, gcc-internal-format
 msgid "converting overloaded function %qD to type %q#T is ambiguous"
 msgstr ""
 
-#: cp/class.c:6187
+#: cp/class.c:6195
 #, gcc-internal-format
 msgid "assuming pointer to member %qD"
 msgstr ""
 
-#: cp/class.c:6190
+#: cp/class.c:6198
 #, gcc-internal-format
 msgid "(a pointer to member can only be formed with %<&%E%>)"
 msgstr ""
 
-#: cp/class.c:6252 cp/class.c:6286
+#: cp/class.c:6260 cp/class.c:6294
 #, gcc-internal-format
 msgid "not enough type information"
 msgstr ""
 
-#: cp/class.c:6269
+#: cp/class.c:6277
 #, gcc-internal-format
 msgid "argument of type %qT does not match %qT"
 msgstr ""
@@ -28933,12 +28982,12 @@
 #. A name N used in a class S shall refer to the same declaration
 #. in its context and when re-evaluated in the completed scope of
 #. S.
-#: cp/class.c:6587 cp/decl.c:1193 cp/name-lookup.c:526
+#: cp/class.c:6595 cp/decl.c:1193 cp/name-lookup.c:526
 #, gcc-internal-format
 msgid "declaration of %q#D"
 msgstr ""
 
-#: cp/class.c:6588
+#: cp/class.c:6596
 #, gcc-internal-format
 msgid "changes meaning of %qD from %q+#D"
 msgstr ""
@@ -29473,117 +29522,117 @@
 msgid "attribute for %q+#T must follow the %qs keyword"
 msgstr ""
 
-#: cp/decl.c:3980
+#: cp/decl.c:3983
 #, gcc-internal-format
 msgid "ignoring attributes applied to class type %qT outside of definition"
 msgstr ""
 
 #. A template type parameter or other dependent type.
-#: cp/decl.c:3984
+#: cp/decl.c:3987
 #, gcc-internal-format
 msgid ""
 "ignoring attributes applied to dependent type %qT without an associated "
 "declaration"
 msgstr ""
 
-#: cp/decl.c:4060
+#: cp/decl.c:4063
 #, gcc-internal-format
 msgid "typedef %qD is initialized (use decltype instead)"
 msgstr ""
 
-#: cp/decl.c:4078
+#: cp/decl.c:4081
 #, gcc-internal-format
 msgid "declaration of %q#D has %<extern%> and is initialized"
 msgstr ""
 
-#: cp/decl.c:4103
+#: cp/decl.c:4106
 #, gcc-internal-format
 msgid "definition of %q#D is marked %<dllimport%>"
 msgstr ""
 
-#: cp/decl.c:4122
+#: cp/decl.c:4125
 #, gcc-internal-format
 msgid "%q#D is not a static member of %q#T"
 msgstr ""
 
-#: cp/decl.c:4128
+#: cp/decl.c:4131
 #, gcc-internal-format
 msgid "ISO C++ does not permit %<%T::%D%> to be defined as %<%T::%D%>"
 msgstr ""
 
-#: cp/decl.c:4137
+#: cp/decl.c:4140
 #, gcc-internal-format
 msgid ""
 "template header not allowed in member definition of explicitly specialized "
 "class"
 msgstr ""
 
-#: cp/decl.c:4145
+#: cp/decl.c:4148
 #, gcc-internal-format
 msgid "duplicate initialization of %qD"
 msgstr ""
 
-#: cp/decl.c:4184
+#: cp/decl.c:4187
 #, gcc-internal-format
 msgid "declaration of %q#D outside of class is not definition"
 msgstr ""
 
-#: cp/decl.c:4279
+#: cp/decl.c:4282
 #, gcc-internal-format
 msgid "variable %q#D has initializer but incomplete type"
 msgstr ""
 
-#: cp/decl.c:4285 cp/decl.c:5033
+#: cp/decl.c:4288 cp/decl.c:5036
 #, gcc-internal-format
 msgid "elements of array %q#D have incomplete type"
 msgstr ""
 
-#: cp/decl.c:4292 cp/decl.c:5529
+#: cp/decl.c:4295 cp/decl.c:5532
 #, gcc-internal-format
 msgid "declaration of %q#D has no initializer"
 msgstr ""
 
-#: cp/decl.c:4294
+#: cp/decl.c:4297
 #, gcc-internal-format
 msgid "aggregate %q#D has incomplete type and cannot be defined"
 msgstr ""
 
-#: cp/decl.c:4330
+#: cp/decl.c:4333
 #, gcc-internal-format
 msgid "%qD declared as reference but not initialized"
 msgstr ""
 
-#: cp/decl.c:4336
+#: cp/decl.c:4339
 #, gcc-internal-format
 msgid "ISO C++ forbids use of initializer list to initialize reference %qD"
 msgstr ""
 
-#: cp/decl.c:4362
+#: cp/decl.c:4365
 #, gcc-internal-format
 msgid "cannot initialize %qT from %qT"
 msgstr ""
 
-#: cp/decl.c:4423
+#: cp/decl.c:4426
 #, gcc-internal-format
 msgid "name used in a GNU-style designated initializer for an array"
 msgstr ""
 
-#: cp/decl.c:4428
+#: cp/decl.c:4431
 #, gcc-internal-format
 msgid "name %qD used in a GNU-style designated initializer for an array"
 msgstr ""
 
-#: cp/decl.c:4478
+#: cp/decl.c:4481
 #, gcc-internal-format
 msgid "initializer fails to determine size of %qD"
 msgstr ""
 
-#: cp/decl.c:4485
+#: cp/decl.c:4488
 #, gcc-internal-format
 msgid "array size missing in %qD"
 msgstr ""
 
-#: cp/decl.c:4497
+#: cp/decl.c:4500
 #, gcc-internal-format
 msgid "zero-size array %qD"
 msgstr ""
@@ -29591,273 +29640,273 @@
 #. An automatic variable with an incomplete type: that is an error.
 #. Don't talk about array types here, since we took care of that
 #. message in grokdeclarator.
-#: cp/decl.c:4540
+#: cp/decl.c:4543
 #, gcc-internal-format
 msgid "storage size of %qD isn't known"
 msgstr ""
 
-#: cp/decl.c:4563
+#: cp/decl.c:4566
 #, gcc-internal-format
 msgid "storage size of %qD isn't constant"
 msgstr ""
 
-#: cp/decl.c:4614
+#: cp/decl.c:4617
 #, gcc-internal-format
 msgid ""
 "sorry: semantics of inline function static data %q+#D are wrong (you'll wind "
 "up with multiple copies)"
 msgstr ""
 
-#: cp/decl.c:4617
+#: cp/decl.c:4620
 #, gcc-internal-format
 msgid "%J  you can work around this by removing the initializer"
 msgstr ""
 
-#: cp/decl.c:4644
+#: cp/decl.c:4647
 #, gcc-internal-format
 msgid "uninitialized const %qD"
 msgstr ""
 
-#: cp/decl.c:4756
+#: cp/decl.c:4759
 #, gcc-internal-format
 msgid "invalid type %qT as initializer for a vector of type %qT"
 msgstr ""
 
-#: cp/decl.c:4798
+#: cp/decl.c:4801
 #, gcc-internal-format
 msgid "initializer for %qT must be brace-enclosed"
 msgstr ""
 
-#: cp/decl.c:4816
+#: cp/decl.c:4819
 #, gcc-internal-format
 msgid "%qT has no non-static data member named %qD"
 msgstr ""
 
-#: cp/decl.c:4872
+#: cp/decl.c:4875
 #, gcc-internal-format
 msgid "braces around scalar initializer for type %qT"
 msgstr ""
 
-#: cp/decl.c:4958
+#: cp/decl.c:4961
 #, gcc-internal-format
 msgid "missing braces around initializer for %qT"
 msgstr ""
 
-#: cp/decl.c:5015 cp/typeck2.c:1087 cp/typeck2.c:1110 cp/typeck2.c:1153
+#: cp/decl.c:5018 cp/typeck2.c:1087 cp/typeck2.c:1110 cp/typeck2.c:1153
 #, gcc-internal-format
 msgid "too many initializers for %qT"
 msgstr ""
 
-#: cp/decl.c:5035
+#: cp/decl.c:5038
 #, gcc-internal-format
 msgid "elements of array %q#T have incomplete type"
 msgstr ""
 
-#: cp/decl.c:5044
+#: cp/decl.c:5047
 #, gcc-internal-format
 msgid "variable-sized object %qD may not be initialized"
 msgstr ""
 
-#: cp/decl.c:5046
+#: cp/decl.c:5049
 #, gcc-internal-format
 msgid "variable-sized compound literal"
 msgstr ""
 
-#: cp/decl.c:5100
+#: cp/decl.c:5103
 #, gcc-internal-format
 msgid "%qD has incomplete type"
 msgstr ""
 
-#: cp/decl.c:5120
+#: cp/decl.c:5123
 #, gcc-internal-format
 msgid "scalar object %qD requires one element in initializer"
 msgstr ""
 
-#: cp/decl.c:5151
+#: cp/decl.c:5154
 #, gcc-internal-format
 msgid "in C++98 %qD must be initialized by constructor, not by %<{...}%>"
 msgstr ""
 
-#: cp/decl.c:5183
+#: cp/decl.c:5186
 #, gcc-internal-format
 msgid "array %qD initialized by parenthesized string literal %qE"
 msgstr ""
 
-#: cp/decl.c:5197
+#: cp/decl.c:5200
 #, gcc-internal-format
 msgid "structure %qD with uninitialized const members"
 msgstr ""
 
-#: cp/decl.c:5199
+#: cp/decl.c:5202
 #, gcc-internal-format
 msgid "structure %qD with uninitialized reference members"
 msgstr ""
 
-#: cp/decl.c:5496
+#: cp/decl.c:5499
 #, gcc-internal-format
 msgid "assignment (not initialization) in declaration"
 msgstr ""
 
-#: cp/decl.c:5555 cp/decl2.c:850
+#: cp/decl.c:5558 cp/decl2.c:850
 #, gcc-internal-format
 msgid "%qD cannot be defaulted"
 msgstr ""
 
-#: cp/decl.c:5631
+#: cp/decl.c:5634
 #, gcc-internal-format
 msgid "shadowing previous type declaration of %q#D"
 msgstr ""
 
-#: cp/decl.c:5661
+#: cp/decl.c:5664
 #, gcc-internal-format
 msgid "%qD cannot be thread-local because it has non-POD type %qT"
 msgstr ""
 
-#: cp/decl.c:5693
+#: cp/decl.c:5696
 #, gcc-internal-format
 msgid "Java object %qD not allocated with %<new%>"
 msgstr ""
 
-#: cp/decl.c:5710
+#: cp/decl.c:5713
 #, gcc-internal-format
 msgid "%qD is thread-local and so cannot be dynamically initialized"
 msgstr ""
 
-#: cp/decl.c:5728
+#: cp/decl.c:5731
 #, gcc-internal-format
 msgid ""
 "%qD cannot be initialized by a non-constant expression when being declared"
 msgstr ""
 
-#: cp/decl.c:5768
+#: cp/decl.c:5771
 #, gcc-internal-format
 msgid "non-static data member %qD has Java class type"
 msgstr ""
 
-#: cp/decl.c:5832
+#: cp/decl.c:5835
 #, gcc-internal-format
 msgid "function %q#D is initialized like a variable"
 msgstr ""
 
-#: cp/decl.c:6420
+#: cp/decl.c:6423
 #, gcc-internal-format
 msgid "destructor for alien class %qT cannot be a member"
 msgstr ""
 
-#: cp/decl.c:6422
+#: cp/decl.c:6425
 #, gcc-internal-format
 msgid "constructor for alien class %qT cannot be a member"
 msgstr ""
 
-#: cp/decl.c:6443
+#: cp/decl.c:6446
 #, gcc-internal-format
 msgid "%qD declared as a %<virtual%> %s"
 msgstr ""
 
-#: cp/decl.c:6445
+#: cp/decl.c:6448
 #, gcc-internal-format
 msgid "%qD declared as an %<inline%> %s"
 msgstr ""
 
-#: cp/decl.c:6447
+#: cp/decl.c:6450
 #, gcc-internal-format
 msgid ""
 "%<const%> and %<volatile%> function specifiers on %qD invalid in %s "
 "declaration"
 msgstr ""
 
-#: cp/decl.c:6451
+#: cp/decl.c:6454
 #, gcc-internal-format
 msgid "%q+D declared as a friend"
 msgstr ""
 
-#: cp/decl.c:6457
+#: cp/decl.c:6460
 #, gcc-internal-format
 msgid "%q+D declared with an exception specification"
 msgstr ""
 
-#: cp/decl.c:6491
+#: cp/decl.c:6494
 #, gcc-internal-format
 msgid "definition of %qD is not in namespace enclosing %qT"
 msgstr ""
 
-#: cp/decl.c:6611
+#: cp/decl.c:6614
 #, gcc-internal-format
 msgid "defining explicit specialization %qD in friend declaration"
 msgstr ""
 
 #. Something like `template <class T> friend void f<T>()'.
-#: cp/decl.c:6621
+#: cp/decl.c:6624
 #, gcc-internal-format
 msgid "invalid use of template-id %qD in declaration of primary template"
 msgstr ""
 
-#: cp/decl.c:6651
+#: cp/decl.c:6654
 #, gcc-internal-format
 msgid ""
 "default arguments are not allowed in declaration of friend template "
 "specialization %qD"
 msgstr ""
 
-#: cp/decl.c:6659
+#: cp/decl.c:6662
 #, gcc-internal-format
 msgid ""
 "%<inline%> is not allowed in declaration of friend template specialization %"
 "qD"
 msgstr ""
 
-#: cp/decl.c:6702
+#: cp/decl.c:6705
 #, gcc-internal-format
 msgid "cannot declare %<::main%> to be a template"
 msgstr ""
 
-#: cp/decl.c:6704
+#: cp/decl.c:6707
 #, gcc-internal-format
 msgid "cannot declare %<::main%> to be inline"
 msgstr ""
 
-#: cp/decl.c:6706
+#: cp/decl.c:6709
 #, gcc-internal-format
 msgid "cannot declare %<::main%> to be static"
 msgstr ""
 
-#: cp/decl.c:6734
+#: cp/decl.c:6737
 #, gcc-internal-format
 msgid "non-local function %q#D uses anonymous type"
 msgstr ""
 
-#: cp/decl.c:6737 cp/decl.c:7013
+#: cp/decl.c:6740 cp/decl.c:7016
 #, gcc-internal-format
 msgid ""
 "%q+#D does not refer to the unqualified type, so it is not used for linkage"
 msgstr ""
 
-#: cp/decl.c:6743
+#: cp/decl.c:6746
 #, gcc-internal-format
 msgid "non-local function %q#D uses local type %qT"
 msgstr ""
 
-#: cp/decl.c:6762
+#: cp/decl.c:6765
 #, gcc-internal-format
 msgid "static member function %qD cannot have cv-qualifier"
 msgstr ""
 
-#: cp/decl.c:6763
+#: cp/decl.c:6766
 #, gcc-internal-format
 msgid "non-member function %qD cannot have cv-qualifier"
 msgstr ""
 
-#: cp/decl.c:6811
+#: cp/decl.c:6814
 #, gcc-internal-format
 msgid "%<::main%> must return %<int%>"
 msgstr ""
 
-#: cp/decl.c:6851
+#: cp/decl.c:6854
 #, gcc-internal-format
 msgid "definition of implicitly-declared %qD"
 msgstr ""
 
-#: cp/decl.c:6868 cp/decl2.c:685
+#: cp/decl.c:6871 cp/decl2.c:685
 #, gcc-internal-format
 msgid "no %q#D member function declared in class %qT"
 msgstr ""
@@ -29866,589 +29915,594 @@
 #. no linkage can only be used to declare extern "C"
 #. entities.  Since it's not always an error in the
 #. ISO C++ 90 Standard, we only issue a warning.
-#: cp/decl.c:7010
+#: cp/decl.c:7013
 #, gcc-internal-format
 msgid "non-local variable %q#D uses anonymous type"
 msgstr ""
 
-#: cp/decl.c:7019
+#: cp/decl.c:7022
 #, gcc-internal-format
 msgid "non-local variable %q#D uses local type %qT"
 msgstr ""
 
-#: cp/decl.c:7142
+#: cp/decl.c:7145
 #, gcc-internal-format
 msgid ""
 "invalid in-class initialization of static data member of non-integral type %"
 "qT"
 msgstr ""
 
-#: cp/decl.c:7152
+#: cp/decl.c:7155
 #, gcc-internal-format
 msgid "ISO C++ forbids in-class initialization of non-const static member %qD"
 msgstr ""
 
-#: cp/decl.c:7156
+#: cp/decl.c:7159
 #, gcc-internal-format
 msgid ""
 "ISO C++ forbids initialization of member constant %qD of non-integral type %"
 "qT"
 msgstr ""
 
-#: cp/decl.c:7181
+#: cp/decl.c:7184
 #, gcc-internal-format
 msgid "size of array %qD has non-integral type %qT"
 msgstr ""
 
-#: cp/decl.c:7183
+#: cp/decl.c:7186
 #, gcc-internal-format
 msgid "size of array has non-integral type %qT"
 msgstr ""
 
-#: cp/decl.c:7235
+#: cp/decl.c:7238
 #, gcc-internal-format
 msgid "size of array %qD is negative"
 msgstr ""
 
-#: cp/decl.c:7237
+#: cp/decl.c:7240
 #, gcc-internal-format
 msgid "size of array is negative"
 msgstr ""
 
-#: cp/decl.c:7245
+#: cp/decl.c:7248
 #, gcc-internal-format
 msgid "ISO C++ forbids zero-size array %qD"
 msgstr ""
 
-#: cp/decl.c:7247
+#: cp/decl.c:7250
 #, gcc-internal-format
 msgid "ISO C++ forbids zero-size array"
 msgstr ""
 
-#: cp/decl.c:7254
+#: cp/decl.c:7257
 #, gcc-internal-format
 msgid "size of array %qD is not an integral constant-expression"
 msgstr ""
 
-#: cp/decl.c:7257
+#: cp/decl.c:7260
 #, gcc-internal-format
 msgid "size of array is not an integral constant-expression"
 msgstr ""
 
-#: cp/decl.c:7263
+#: cp/decl.c:7266
 #, gcc-internal-format
 msgid "ISO C++ forbids variable length array %qD"
 msgstr ""
 
-#: cp/decl.c:7265
+#: cp/decl.c:7268
 #, gcc-internal-format
 msgid "ISO C++ forbids variable length array"
 msgstr ""
 
-#: cp/decl.c:7271
+#: cp/decl.c:7274
 #, gcc-internal-format
 msgid "variable length array %qD is used"
 msgstr ""
 
-#: cp/decl.c:7307
+#: cp/decl.c:7310
 #, gcc-internal-format
 msgid "overflow in array dimension"
 msgstr ""
 
-#: cp/decl.c:7388
+#: cp/decl.c:7391
 #, gcc-internal-format
 msgid "declaration of %qD as %s"
 msgstr ""
 
-#: cp/decl.c:7390
+#: cp/decl.c:7393
 #, gcc-internal-format
 msgid "creating %s"
 msgstr ""
 
-#: cp/decl.c:7402
+#: cp/decl.c:7405
 #, gcc-internal-format
 msgid ""
 "declaration of %qD as multidimensional array must have bounds for all "
 "dimensions except the first"
 msgstr ""
 
-#: cp/decl.c:7406
+#: cp/decl.c:7409
 #, gcc-internal-format
 msgid ""
 "multidimensional array must have bounds for all dimensions except the first"
 msgstr ""
 
-#: cp/decl.c:7441
+#: cp/decl.c:7444
 #, gcc-internal-format
 msgid "return type specification for constructor invalid"
 msgstr ""
 
-#: cp/decl.c:7451
+#: cp/decl.c:7454
 #, gcc-internal-format
 msgid "return type specification for destructor invalid"
 msgstr ""
 
-#: cp/decl.c:7464
+#: cp/decl.c:7467
 #, gcc-internal-format
 msgid "return type specified for %<operator %T%>"
 msgstr ""
 
-#: cp/decl.c:7486
+#: cp/decl.c:7489
 #, gcc-internal-format
 msgid "unnamed variable or field declared void"
 msgstr ""
 
-#: cp/decl.c:7490
+#: cp/decl.c:7493
 #, gcc-internal-format
 msgid "variable or field %qE declared void"
 msgstr ""
 
-#: cp/decl.c:7493
+#: cp/decl.c:7496
 #, gcc-internal-format
 msgid "variable or field declared void"
 msgstr ""
 
-#: cp/decl.c:7663
+#: cp/decl.c:7669
 #, gcc-internal-format
 msgid "invalid use of qualified-name %<::%D%>"
 msgstr ""
 
-#: cp/decl.c:7666
+#: cp/decl.c:7672
 #, gcc-internal-format
 msgid "invalid use of qualified-name %<%T::%D%>"
 msgstr ""
 
-#: cp/decl.c:7669
+#: cp/decl.c:7675
 #, gcc-internal-format
 msgid "invalid use of qualified-name %<%D::%D%>"
 msgstr ""
 
-#: cp/decl.c:7681
+#: cp/decl.c:7687
 #, gcc-internal-format
 msgid "type %qT is not derived from type %qT"
 msgstr ""
 
-#: cp/decl.c:7697 cp/decl.c:7789 cp/decl.c:8979
+#: cp/decl.c:7703 cp/decl.c:7795 cp/decl.c:8993
 #, gcc-internal-format
 msgid "declaration of %qD as non-function"
 msgstr ""
 
-#: cp/decl.c:7703
+#: cp/decl.c:7709
 #, gcc-internal-format
 msgid "declaration of %qD as non-member"
 msgstr ""
 
-#: cp/decl.c:7734
+#: cp/decl.c:7740
 #, gcc-internal-format
 msgid "declarator-id missing; using reserved word %qD"
 msgstr ""
 
-#: cp/decl.c:7781
+#: cp/decl.c:7787
 #, gcc-internal-format
 msgid "function definition does not declare parameters"
 msgstr ""
 
-#: cp/decl.c:7823
+#: cp/decl.c:7829
 #, gcc-internal-format
 msgid "two or more data types in declaration of %qs"
 msgstr ""
 
-#: cp/decl.c:7829
+#: cp/decl.c:7835
 #, gcc-internal-format
 msgid "conflicting specifiers in declaration of %qs"
 msgstr ""
 
-#: cp/decl.c:7900 cp/decl.c:7903 cp/decl.c:7906
+#: cp/decl.c:7906 cp/decl.c:7909 cp/decl.c:7912
 #, gcc-internal-format
 msgid "ISO C++ forbids declaration of %qs with no type"
 msgstr ""
 
-#: cp/decl.c:7931 cp/decl.c:7949
+#: cp/decl.c:7937 cp/decl.c:7955
 #, gcc-internal-format
 msgid "%<signed%> or %<unsigned%> invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:7933
+#: cp/decl.c:7939
 #, gcc-internal-format
 msgid "%<signed%> and %<unsigned%> specified together for %qs"
 msgstr ""
 
-#: cp/decl.c:7935
+#: cp/decl.c:7941
 #, gcc-internal-format
 msgid "%<long long%> invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:7937
+#: cp/decl.c:7943
 #, gcc-internal-format
 msgid "%<long%> invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:7939
+#: cp/decl.c:7945
 #, gcc-internal-format
 msgid "%<short%> invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:7941
+#: cp/decl.c:7947
 #, gcc-internal-format
 msgid "%<long%> or %<short%> invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:7943
+#: cp/decl.c:7949
 #, gcc-internal-format
 msgid "%<long%> or %<short%> specified with char for %qs"
 msgstr ""
 
-#: cp/decl.c:7945
+#: cp/decl.c:7951
 #, gcc-internal-format
 msgid "%<long%> and %<short%> specified together for %qs"
 msgstr ""
 
-#: cp/decl.c:7951
+#: cp/decl.c:7957
 #, gcc-internal-format
 msgid "%<short%> or %<long%> invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:7959
+#: cp/decl.c:7965
 #, gcc-internal-format
 msgid "long, short, signed or unsigned used invalidly for %qs"
 msgstr ""
 
-#: cp/decl.c:8023
+#: cp/decl.c:8029
 #, gcc-internal-format
 msgid "complex invalid for %qs"
 msgstr ""
 
-#: cp/decl.c:8052
+#: cp/decl.c:8058
 #, gcc-internal-format
 msgid "qualifiers are not allowed on declaration of %<operator %T%>"
 msgstr ""
 
-#: cp/decl.c:8065 cp/typeck.c:7252
+#: cp/decl.c:8071 cp/typeck.c:7255
 #, gcc-internal-format
 msgid "ignoring %qV qualifiers added to function type %qT"
 msgstr ""
 
-#: cp/decl.c:8088
+#: cp/decl.c:8094
 #, gcc-internal-format
 msgid "member %qD cannot be declared both virtual and static"
 msgstr ""
 
-#: cp/decl.c:8096
+#: cp/decl.c:8102
 #, gcc-internal-format
 msgid "%<%T::%D%> is not a valid declarator"
 msgstr ""
 
-#: cp/decl.c:8105
+#: cp/decl.c:8111
 #, gcc-internal-format
 msgid "typedef declaration invalid in parameter declaration"
 msgstr ""
 
-#: cp/decl.c:8111
+#: cp/decl.c:8117
 #, gcc-internal-format
 msgid "storage class specifiers invalid in parameter declarations"
 msgstr ""
 
-#: cp/decl.c:8115
+#: cp/decl.c:8121
 #, gcc-internal-format
 msgid "parameter declared %<auto%>"
 msgstr ""
 
-#: cp/decl.c:8124
+#: cp/decl.c:8130
 #, gcc-internal-format
 msgid "%<virtual%> outside class declaration"
 msgstr ""
 
-#: cp/decl.c:8142
+#: cp/decl.c:8148
 #, gcc-internal-format
 msgid "multiple storage classes in declaration of %qs"
 msgstr ""
 
-#: cp/decl.c:8165
+#: cp/decl.c:8171
 #, gcc-internal-format
 msgid "storage class specified for %qs"
 msgstr ""
 
-#: cp/decl.c:8186
+#: cp/decl.c:8192
 #, gcc-internal-format
 msgid "top-level declaration of %qs specifies %<auto%>"
 msgstr ""
 
-#: cp/decl.c:8199
+#: cp/decl.c:8205
 #, gcc-internal-format
 msgid "storage class specifiers invalid in friend function declarations"
 msgstr ""
 
-#: cp/decl.c:8314
+#: cp/decl.c:8320
 #, gcc-internal-format
 msgid "%qs function uses %<auto%> type specifier without late return type"
 msgstr ""
 
-#: cp/decl.c:8320
+#: cp/decl.c:8326
 #, gcc-internal-format
 msgid ""
 "%qs function with late return type has %qT as its type rather than plain %"
 "<auto%>"
 msgstr ""
 
-#: cp/decl.c:8328
+#: cp/decl.c:8334
 #, gcc-internal-format
 msgid ""
 "%qs function with late return type not declared with %<auto%> type specifier"
 msgstr ""
 
-#: cp/decl.c:8361
+#: cp/decl.c:8367
 #, gcc-internal-format
 msgid "destructor cannot be static member function"
 msgstr ""
 
-#: cp/decl.c:8366
+#: cp/decl.c:8372
 #, gcc-internal-format
 msgid "destructors may not be cv-qualified"
 msgstr ""
 
-#: cp/decl.c:8384
+#: cp/decl.c:8390
 #, gcc-internal-format
 msgid "constructors cannot be declared virtual"
 msgstr ""
 
-#: cp/decl.c:8397
+#: cp/decl.c:8403
 #, gcc-internal-format
 msgid "can't initialize friend function %qs"
 msgstr ""
 
 #. Cannot be both friend and virtual.
-#: cp/decl.c:8401
+#: cp/decl.c:8407
 #, gcc-internal-format
 msgid "virtual functions cannot be friends"
 msgstr ""
 
-#: cp/decl.c:8405
+#: cp/decl.c:8411
 #, gcc-internal-format
 msgid "friend declaration not in class definition"
 msgstr ""
 
-#: cp/decl.c:8407
+#: cp/decl.c:8413
 #, gcc-internal-format
 msgid "can't define friend function %qs in a local class definition"
 msgstr ""
 
-#: cp/decl.c:8420
+#: cp/decl.c:8426
 #, gcc-internal-format
 msgid "destructors may not have parameters"
 msgstr ""
 
-#: cp/decl.c:8439
+#: cp/decl.c:8445
 #, gcc-internal-format
 msgid "cannot declare pointer to %q#T"
 msgstr ""
 
-#: cp/decl.c:8452 cp/decl.c:8459
+#: cp/decl.c:8458 cp/decl.c:8465
 #, gcc-internal-format
 msgid "cannot declare reference to %q#T"
 msgstr ""
 
-#: cp/decl.c:8461
+#: cp/decl.c:8467
 #, gcc-internal-format
 msgid "cannot declare pointer to %q#T member"
 msgstr ""
 
-#: cp/decl.c:8512
+#: cp/decl.c:8487
+#, gcc-internal-format
+msgid "cannot declare %s to qualified function type %qT"
+msgstr ""
+
+#: cp/decl.c:8524
 #, gcc-internal-format
 msgid ""
 "cannot declare reference to %q#T, which is not a typedef or a template type "
 "argument"
 msgstr ""
 
-#: cp/decl.c:8556
+#: cp/decl.c:8568
 #, gcc-internal-format
 msgid "template-id %qD used as a declarator"
 msgstr ""
 
-#: cp/decl.c:8607
+#: cp/decl.c:8619
 #, gcc-internal-format
 msgid "member functions are implicitly friends of their class"
 msgstr ""
 
-#: cp/decl.c:8612
+#: cp/decl.c:8624
 #, gcc-internal-format
 msgid "extra qualification %<%T::%> on member %qs"
 msgstr ""
 
-#: cp/decl.c:8644
+#: cp/decl.c:8656
 #, gcc-internal-format
 msgid "cannot define member function %<%T::%s%> within %<%T%>"
 msgstr ""
 
-#: cp/decl.c:8661
+#: cp/decl.c:8673
 #, gcc-internal-format
 msgid "cannot declare member %<%T::%s%> within %qT"
 msgstr ""
 
-#: cp/decl.c:8684
+#: cp/decl.c:8696
 #, gcc-internal-format
 msgid "non-parameter %qs cannot be a parameter pack"
 msgstr ""
 
-#: cp/decl.c:8705
+#: cp/decl.c:8717
 #, gcc-internal-format
 msgid "data member may not have variably modified type %qT"
 msgstr ""
 
-#: cp/decl.c:8707
+#: cp/decl.c:8719
 #, gcc-internal-format
 msgid "parameter may not have variably modified type %qT"
 msgstr ""
 
 #. [dcl.fct.spec] The explicit specifier shall only be used in
 #. declarations of constructors within a class definition.
-#: cp/decl.c:8715
+#: cp/decl.c:8727
 #, gcc-internal-format
 msgid "only declarations of constructors can be %<explicit%>"
 msgstr ""
 
-#: cp/decl.c:8723
+#: cp/decl.c:8735
 #, gcc-internal-format
 msgid "non-member %qs cannot be declared %<mutable%>"
 msgstr ""
 
-#: cp/decl.c:8728
+#: cp/decl.c:8740
 #, gcc-internal-format
 msgid "non-object member %qs cannot be declared %<mutable%>"
 msgstr ""
 
-#: cp/decl.c:8734
+#: cp/decl.c:8746
 #, gcc-internal-format
 msgid "function %qs cannot be declared %<mutable%>"
 msgstr ""
 
-#: cp/decl.c:8739
+#: cp/decl.c:8751
 #, gcc-internal-format
 msgid "static %qs cannot be declared %<mutable%>"
 msgstr ""
 
-#: cp/decl.c:8744
+#: cp/decl.c:8756
 #, gcc-internal-format
 msgid "const %qs cannot be declared %<mutable%>"
 msgstr ""
 
-#: cp/decl.c:8781
+#: cp/decl.c:8793
 #, gcc-internal-format
 msgid "%Jtypedef name may not be a nested-name-specifier"
 msgstr ""
 
-#: cp/decl.c:8799
+#: cp/decl.c:8811
 #, gcc-internal-format
 msgid "ISO C++ forbids nested type %qD with same name as enclosing class"
 msgstr ""
 
-#: cp/decl.c:8883
+#: cp/decl.c:8895
 #, gcc-internal-format
 msgid ""
 "qualified function types cannot be used to declare static member functions"
 msgstr ""
 
-#: cp/decl.c:8885
+#: cp/decl.c:8897
 #, gcc-internal-format
 msgid "qualified function types cannot be used to declare free functions"
 msgstr ""
 
-#: cp/decl.c:8911
+#: cp/decl.c:8923
 #, gcc-internal-format
 msgid "type qualifiers specified for friend class declaration"
 msgstr ""
 
-#: cp/decl.c:8916
+#: cp/decl.c:8928
 #, gcc-internal-format
 msgid "%<inline%> specified for friend class declaration"
 msgstr ""
 
-#: cp/decl.c:8924
+#: cp/decl.c:8936
 #, gcc-internal-format
 msgid "template parameters cannot be friends"
 msgstr ""
 
-#: cp/decl.c:8926
+#: cp/decl.c:8938
 #, gcc-internal-format
 msgid "friend declaration requires class-key, i.e. %<friend class %T::%D%>"
 msgstr ""
 
-#: cp/decl.c:8930
+#: cp/decl.c:8942
 #, gcc-internal-format
 msgid "friend declaration requires class-key, i.e. %<friend %#T%>"
 msgstr ""
 
-#: cp/decl.c:8943
+#: cp/decl.c:8955
 #, gcc-internal-format
 msgid "trying to make class %qT a friend of global scope"
 msgstr ""
 
-#: cp/decl.c:8954
+#: cp/decl.c:8973
 #, gcc-internal-format
 msgid "invalid qualifiers on non-member function type"
 msgstr ""
 
-#: cp/decl.c:8969
+#: cp/decl.c:8983
 #, gcc-internal-format
 msgid "abstract declarator %qT used as declaration"
 msgstr ""
 
-#: cp/decl.c:8998
+#: cp/decl.c:9012
 #, gcc-internal-format
 msgid "cannot use %<::%> in parameter declaration"
 msgstr ""
 
 #. Something like struct S { int N::j; };
-#: cp/decl.c:9044
+#: cp/decl.c:9058
 #, gcc-internal-format
 msgid "invalid use of %<::%>"
 msgstr ""
 
-#: cp/decl.c:9059
+#: cp/decl.c:9073
 #, gcc-internal-format
 msgid "can't make %qD into a method -- not in a class"
 msgstr ""
 
-#: cp/decl.c:9068
+#: cp/decl.c:9082
 #, gcc-internal-format
 msgid "function %qD declared virtual inside a union"
 msgstr ""
 
-#: cp/decl.c:9077
+#: cp/decl.c:9091
 #, gcc-internal-format
 msgid "%qD cannot be declared virtual, since it is always static"
 msgstr ""
 
-#: cp/decl.c:9095
+#: cp/decl.c:9109
 #, gcc-internal-format
 msgid "expected qualified name in friend declaration for destructor %qD"
 msgstr ""
 
-#: cp/decl.c:9102
+#: cp/decl.c:9116
 #, gcc-internal-format
 msgid "declaration of %qD as member of %qT"
 msgstr ""
 
-#: cp/decl.c:9109
+#: cp/decl.c:9123
 #, gcc-internal-format
 msgid "expected qualified name in friend declaration for constructor %qD"
 msgstr ""
 
-#: cp/decl.c:9172
+#: cp/decl.c:9186
 #, gcc-internal-format
 msgid "field %qD has incomplete type"
 msgstr ""
 
-#: cp/decl.c:9174
+#: cp/decl.c:9188
 #, gcc-internal-format
 msgid "name %qT has incomplete type"
 msgstr ""
 
-#: cp/decl.c:9183
+#: cp/decl.c:9197
 #, gcc-internal-format
 msgid "  in instantiation of template %qT"
 msgstr ""
 
-#: cp/decl.c:9192
+#: cp/decl.c:9206
 #, gcc-internal-format
 msgid "%qE is neither function nor member function; cannot be declared friend"
 msgstr ""
@@ -30465,117 +30519,117 @@
 #. the rest of the compiler does not correctly
 #. handle the initialization unless the member is
 #. static so we make it static below.
-#: cp/decl.c:9244
+#: cp/decl.c:9258
 #, gcc-internal-format
 msgid "ISO C++ forbids initialization of member %qD"
 msgstr ""
 
-#: cp/decl.c:9246
+#: cp/decl.c:9260
 #, gcc-internal-format
 msgid "making %qD static"
 msgstr ""
 
-#: cp/decl.c:9311
+#: cp/decl.c:9325
 #, gcc-internal-format
 msgid "storage class %<auto%> invalid for function %qs"
 msgstr ""
 
-#: cp/decl.c:9313
+#: cp/decl.c:9327
 #, gcc-internal-format
 msgid "storage class %<register%> invalid for function %qs"
 msgstr ""
 
-#: cp/decl.c:9315
+#: cp/decl.c:9329
 #, gcc-internal-format
 msgid "storage class %<__thread%> invalid for function %qs"
 msgstr ""
 
-#: cp/decl.c:9327
+#: cp/decl.c:9341
 #, gcc-internal-format
 msgid ""
 "%<static%> specified invalid for function %qs declared out of global scope"
 msgstr ""
 
-#: cp/decl.c:9331
+#: cp/decl.c:9345
 #, gcc-internal-format
 msgid ""
 "%<inline%> specifier invalid for function %qs declared out of global scope"
 msgstr ""
 
-#: cp/decl.c:9338
+#: cp/decl.c:9352
 #, gcc-internal-format
 msgid "%q#T is not a class or a namespace"
 msgstr ""
 
-#: cp/decl.c:9346
+#: cp/decl.c:9360
 #, gcc-internal-format
 msgid "virtual non-class function %qs"
 msgstr ""
 
-#: cp/decl.c:9353
+#: cp/decl.c:9367
 #, gcc-internal-format
 msgid "%qs defined in a non-class scope"
 msgstr ""
 
-#: cp/decl.c:9386
+#: cp/decl.c:9400
 #, gcc-internal-format
 msgid "cannot declare member function %qD to have static linkage"
 msgstr ""
 
 #. FIXME need arm citation
-#: cp/decl.c:9393
+#: cp/decl.c:9407
 #, gcc-internal-format
 msgid "cannot declare static function inside another function"
 msgstr ""
 
-#: cp/decl.c:9423
+#: cp/decl.c:9437
 #, gcc-internal-format
 msgid ""
 "%<static%> may not be used when defining (as opposed to declaring) a static "
 "data member"
 msgstr ""
 
-#: cp/decl.c:9430
+#: cp/decl.c:9444
 #, gcc-internal-format
 msgid "static member %qD declared %<register%>"
 msgstr ""
 
-#: cp/decl.c:9436
+#: cp/decl.c:9450
 #, gcc-internal-format
 msgid "cannot explicitly declare member %q#D to have extern linkage"
 msgstr ""
 
-#: cp/decl.c:9580
+#: cp/decl.c:9594
 #, gcc-internal-format
 msgid "default argument for %q#D has type %qT"
 msgstr ""
 
-#: cp/decl.c:9583
+#: cp/decl.c:9597
 #, gcc-internal-format
 msgid "default argument for parameter of type %qT has type %qT"
 msgstr ""
 
-#: cp/decl.c:9599
+#: cp/decl.c:9613
 #, gcc-internal-format
 msgid "default argument %qE uses local variable %qD"
 msgstr ""
 
-#: cp/decl.c:9682
+#: cp/decl.c:9696
 #, gcc-internal-format
 msgid "parameter %qD has Java class type"
 msgstr ""
 
-#: cp/decl.c:9702
+#: cp/decl.c:9716
 #, gcc-internal-format
 msgid "parameter %qD invalidly declared method type"
 msgstr ""
 
-#: cp/decl.c:9726
+#: cp/decl.c:9740
 #, gcc-internal-format
 msgid "parameter %qD includes %s to array of unknown bound %qT"
 msgstr ""
 
-#: cp/decl.c:9741
+#: cp/decl.c:9755
 #, gcc-internal-format
 msgid "parameter packs must be at the end of the parameter list"
 msgstr ""
@@ -30595,139 +30649,139 @@
 #. or implicitly defined), there's no need to worry about their
 #. existence.  Theoretically, they should never even be
 #. instantiated, but that's hard to forestall.
-#: cp/decl.c:9964
+#: cp/decl.c:9978
 #, gcc-internal-format
 msgid "invalid constructor; you probably meant %<%T (const %T&)%>"
 msgstr ""
 
-#: cp/decl.c:10086
+#: cp/decl.c:10100
 #, gcc-internal-format
 msgid "%qD may not be declared within a namespace"
 msgstr ""
 
-#: cp/decl.c:10091
+#: cp/decl.c:10105
 #, gcc-internal-format
 msgid "%qD may not be declared as static"
 msgstr ""
 
-#: cp/decl.c:10117
+#: cp/decl.c:10131
 #, gcc-internal-format
 msgid "%qD must be a nonstatic member function"
 msgstr ""
 
-#: cp/decl.c:10126
+#: cp/decl.c:10140
 #, gcc-internal-format
 msgid ""
 "%qD must be either a non-static member function or a non-member function"
 msgstr ""
 
-#: cp/decl.c:10148
+#: cp/decl.c:10162
 #, gcc-internal-format
 msgid "%qD must have an argument of class or enumerated type"
 msgstr ""
 
-#: cp/decl.c:10189
+#: cp/decl.c:10203
 #, gcc-internal-format
 msgid "conversion to %s%s will never use a type conversion operator"
 msgstr ""
 
 #. 13.4.0.3
-#: cp/decl.c:10197
+#: cp/decl.c:10211
 #, gcc-internal-format
 msgid "ISO C++ prohibits overloading operator ?:"
 msgstr ""
 
-#: cp/decl.c:10202
+#: cp/decl.c:10216
 #, gcc-internal-format
 msgid "%qD must not have variable number of arguments"
 msgstr ""
 
-#: cp/decl.c:10253
+#: cp/decl.c:10267
 #, gcc-internal-format
 msgid "postfix %qD must take %<int%> as its argument"
 msgstr ""
 
-#: cp/decl.c:10256
+#: cp/decl.c:10270
 #, gcc-internal-format
 msgid "postfix %qD must take %<int%> as its second argument"
 msgstr ""
 
-#: cp/decl.c:10264
+#: cp/decl.c:10278
 #, gcc-internal-format
 msgid "%qD must take either zero or one argument"
 msgstr ""
 
-#: cp/decl.c:10266
+#: cp/decl.c:10280
 #, gcc-internal-format
 msgid "%qD must take either one or two arguments"
 msgstr ""
 
-#: cp/decl.c:10288
+#: cp/decl.c:10302
 #, gcc-internal-format
 msgid "prefix %qD should return %qT"
 msgstr ""
 
-#: cp/decl.c:10294
+#: cp/decl.c:10308
 #, gcc-internal-format
 msgid "postfix %qD should return %qT"
 msgstr ""
 
-#: cp/decl.c:10303
+#: cp/decl.c:10317
 #, gcc-internal-format
 msgid "%qD must take %<void%>"
 msgstr ""
 
-#: cp/decl.c:10305 cp/decl.c:10314
+#: cp/decl.c:10319 cp/decl.c:10328
 #, gcc-internal-format
 msgid "%qD must take exactly one argument"
 msgstr ""
 
-#: cp/decl.c:10316
+#: cp/decl.c:10330
 #, gcc-internal-format
 msgid "%qD must take exactly two arguments"
 msgstr ""
 
-#: cp/decl.c:10325
+#: cp/decl.c:10339
 #, gcc-internal-format
 msgid "user-defined %qD always evaluates both arguments"
 msgstr ""
 
-#: cp/decl.c:10339
+#: cp/decl.c:10353
 #, gcc-internal-format
 msgid "%qD should return by value"
 msgstr ""
 
-#: cp/decl.c:10350 cp/decl.c:10355
+#: cp/decl.c:10364 cp/decl.c:10369
 #, gcc-internal-format
 msgid "%qD cannot have default arguments"
 msgstr ""
 
-#: cp/decl.c:10413
+#: cp/decl.c:10427
 #, gcc-internal-format
 msgid "using template type parameter %qT after %qs"
 msgstr ""
 
-#: cp/decl.c:10428
+#: cp/decl.c:10442
 #, gcc-internal-format
 msgid "using typedef-name %qD after %qs"
 msgstr ""
 
-#: cp/decl.c:10429
+#: cp/decl.c:10443
 #, gcc-internal-format
 msgid "%q+D has a previous declaration here"
 msgstr ""
 
-#: cp/decl.c:10437
+#: cp/decl.c:10451
 #, gcc-internal-format
 msgid "%qT referred to as %qs"
 msgstr ""
 
-#: cp/decl.c:10438 cp/decl.c:10445
+#: cp/decl.c:10452 cp/decl.c:10459
 #, gcc-internal-format
 msgid "%q+T has a previous declaration here"
 msgstr ""
 
-#: cp/decl.c:10444
+#: cp/decl.c:10458
 #, gcc-internal-format
 msgid "%qT referred to as enum"
 msgstr ""
@@ -30739,77 +30793,77 @@
 #. void f(class C);		// No template header here
 #.
 #. then the required template argument is missing.
-#: cp/decl.c:10459
+#: cp/decl.c:10473
 #, gcc-internal-format
 msgid "template argument required for %<%s %T%>"
 msgstr ""
 
-#: cp/decl.c:10507 cp/name-lookup.c:2800
+#: cp/decl.c:10521 cp/name-lookup.c:2802
 #, gcc-internal-format
 msgid "%qD has the same name as the class in which it is declared"
 msgstr ""
 
-#: cp/decl.c:10537 cp/name-lookup.c:2308
+#: cp/decl.c:10551 cp/name-lookup.c:2310
 #, gcc-internal-format
 msgid "reference to %qD is ambiguous"
 msgstr ""
 
-#: cp/decl.c:10651
+#: cp/decl.c:10665
 #, gcc-internal-format
 msgid "use of enum %q#D without previous declaration"
 msgstr ""
 
-#: cp/decl.c:10672
+#: cp/decl.c:10686
 #, gcc-internal-format
 msgid "redeclaration of %qT as a non-template"
 msgstr ""
 
-#: cp/decl.c:10673
+#: cp/decl.c:10687
 #, gcc-internal-format
 msgid "previous declaration %q+D"
 msgstr ""
 
-#: cp/decl.c:10784
+#: cp/decl.c:10798
 #, gcc-internal-format
 msgid "derived union %qT invalid"
 msgstr ""
 
-#: cp/decl.c:10793
+#: cp/decl.c:10807
 #, gcc-internal-format
 msgid "Java class %qT cannot have multiple bases"
 msgstr ""
 
-#: cp/decl.c:10804
+#: cp/decl.c:10818
 #, gcc-internal-format
 msgid "Java class %qT cannot have virtual bases"
 msgstr ""
 
-#: cp/decl.c:10824
+#: cp/decl.c:10838
 #, gcc-internal-format
 msgid "base type %qT fails to be a struct or class type"
 msgstr ""
 
-#: cp/decl.c:10857
+#: cp/decl.c:10871
 #, gcc-internal-format
 msgid "recursive type %qT undefined"
 msgstr ""
 
-#: cp/decl.c:10859
+#: cp/decl.c:10873
 #, gcc-internal-format
 msgid "duplicate base type %qT invalid"
 msgstr ""
 
-#: cp/decl.c:10943
+#: cp/decl.c:10957
 #, gcc-internal-format
 msgid "multiple definition of %q#T"
 msgstr ""
 
-#: cp/decl.c:10944
+#: cp/decl.c:10958
 #, gcc-internal-format
 msgid "%Jprevious definition here"
 msgstr ""
 
-#: cp/decl.c:10991
+#: cp/decl.c:11005
 #, gcc-internal-format
 msgid "underlying type %<%T%> of %<%T%> must be an integral type"
 msgstr ""
@@ -30818,62 +30872,62 @@
 #.
 #. IF no integral type can represent all the enumerator values, the
 #. enumeration is ill-formed.
-#: cp/decl.c:11123
+#: cp/decl.c:11137
 #, gcc-internal-format
 msgid "no integral type can represent all of the enumerator values for %qT"
 msgstr ""
 
-#: cp/decl.c:11254
+#: cp/decl.c:11268
 #, gcc-internal-format
 msgid "enumerator value for %qD is not an integer constant"
 msgstr ""
 
-#: cp/decl.c:11286
+#: cp/decl.c:11300
 #, gcc-internal-format
 msgid "overflow in enumeration values at %qD"
 msgstr ""
 
-#: cp/decl.c:11306
+#: cp/decl.c:11320
 #, gcc-internal-format
 msgid "enumerator value %E is too large for underlying type %<%T%>"
 msgstr ""
 
-#: cp/decl.c:11403
+#: cp/decl.c:11417
 #, gcc-internal-format
 msgid "return type %q#T is incomplete"
 msgstr ""
 
-#: cp/decl.c:11405
+#: cp/decl.c:11419
 #, gcc-internal-format
 msgid "return type has Java class type %q#T"
 msgstr ""
 
-#: cp/decl.c:11530 cp/typeck.c:6939
+#: cp/decl.c:11544 cp/typeck.c:6939
 #, gcc-internal-format
 msgid "%<operator=%> should return a reference to %<*this%>"
 msgstr ""
 
-#: cp/decl.c:11845
+#: cp/decl.c:11859
 #, gcc-internal-format
 msgid "invalid function declaration"
 msgstr ""
 
-#: cp/decl.c:11929
+#: cp/decl.c:11943
 #, gcc-internal-format
 msgid "parameter %qD declared void"
 msgstr ""
 
-#: cp/decl.c:12430
+#: cp/decl.c:12444
 #, gcc-internal-format
 msgid "invalid member function declaration"
 msgstr ""
 
-#: cp/decl.c:12445
+#: cp/decl.c:12459
 #, gcc-internal-format
 msgid "%qD is already defined in class %qT"
 msgstr ""
 
-#: cp/decl.c:12692
+#: cp/decl.c:12706
 #, gcc-internal-format
 msgid "static member function %q#D declared with type qualifiers"
 msgstr ""
@@ -31093,7 +31147,7 @@
 #. We really want to suppress this warning in system headers,
 #. because libstdc++ uses variadic templates even when we aren't
 #. in C++0x mode.
-#: cp/error.c:2710
+#: cp/error.c:2711
 #, gcc-internal-format
 msgid "%s only available with -std=c++0x or -std=gnu++0x"
 msgstr ""
@@ -31361,7 +31415,7 @@
 msgid "bad array initializer"
 msgstr ""
 
-#: cp/init.c:1441 cp/semantics.c:2496
+#: cp/init.c:1441 cp/semantics.c:2503
 #, gcc-internal-format
 msgid "%qT is not a class type"
 msgstr ""
@@ -31547,22 +31601,22 @@
 msgid "mangling unknown fixed point type"
 msgstr ""
 
-#: cp/mangle.c:2338
+#: cp/mangle.c:2332
 #, gcc-internal-format
 msgid "mangling %C"
 msgstr ""
 
-#: cp/mangle.c:2375
+#: cp/mangle.c:2387
 #, gcc-internal-format
 msgid "mangling new-expression"
 msgstr ""
 
-#: cp/mangle.c:2395
+#: cp/mangle.c:2407
 #, gcc-internal-format
 msgid "omitted middle operand to %<?:%> operand cannot be mangled"
 msgstr ""
 
-#: cp/mangle.c:2710
+#: cp/mangle.c:2722
 #, gcc-internal-format
 msgid "the mangled name of %qD will change in a future version of GCC"
 msgstr ""
@@ -31645,220 +31699,220 @@
 msgid "global declaration %q+#D"
 msgstr ""
 
-#: cp/name-lookup.c:1030 cp/name-lookup.c:1040
+#: cp/name-lookup.c:1035 cp/name-lookup.c:1042
 #, gcc-internal-format
 msgid "declaration of %q#D shadows a parameter"
 msgstr ""
 
 #. Location of previous decl is not useful in this case.
-#: cp/name-lookup.c:1065
+#: cp/name-lookup.c:1067
 #, gcc-internal-format
 msgid "declaration of %qD shadows a member of 'this'"
 msgstr ""
 
-#: cp/name-lookup.c:1071
+#: cp/name-lookup.c:1073
 #, gcc-internal-format
 msgid "declaration of %qD shadows a previous local"
 msgstr ""
 
-#: cp/name-lookup.c:1078
+#: cp/name-lookup.c:1080
 #, gcc-internal-format
 msgid "declaration of %qD shadows a global declaration"
 msgstr ""
 
-#: cp/name-lookup.c:1201
+#: cp/name-lookup.c:1203
 #, gcc-internal-format
 msgid "name lookup of %qD changed"
 msgstr ""
 
-#: cp/name-lookup.c:1202
+#: cp/name-lookup.c:1204
 #, gcc-internal-format
 msgid "  matches this %q+D under ISO standard rules"
 msgstr ""
 
-#: cp/name-lookup.c:1204
+#: cp/name-lookup.c:1206
 #, gcc-internal-format
 msgid "  matches this %q+D under old rules"
 msgstr ""
 
-#: cp/name-lookup.c:1222 cp/name-lookup.c:1230
+#: cp/name-lookup.c:1224 cp/name-lookup.c:1232
 #, gcc-internal-format
 msgid "name lookup of %qD changed for ISO %<for%> scoping"
 msgstr ""
 
-#: cp/name-lookup.c:1224
+#: cp/name-lookup.c:1226
 #, gcc-internal-format
 msgid "  cannot use obsolete binding at %q+D because it has a destructor"
 msgstr ""
 
-#: cp/name-lookup.c:1233
+#: cp/name-lookup.c:1235
 #, gcc-internal-format
 msgid "  using obsolete binding at %q+D"
 msgstr ""
 
-#: cp/name-lookup.c:1239 cp/parser.c:10154
+#: cp/name-lookup.c:1241 cp/parser.c:10159
 #, gcc-internal-format
 msgid "(if you use %<-fpermissive%> G++ will accept your code)"
 msgstr ""
 
-#: cp/name-lookup.c:1295
+#: cp/name-lookup.c:1297
 #, gcc-internal-format
 msgid "%s %s(%E) %p %d\n"
 msgstr ""
 
-#: cp/name-lookup.c:1298
+#: cp/name-lookup.c:1300
 #, gcc-internal-format
 msgid "%s %s %p %d\n"
 msgstr ""
 
-#: cp/name-lookup.c:1426
+#: cp/name-lookup.c:1428
 #, gcc-internal-format
 msgid "XXX is_class_level != (current_scope == class_scope)\n"
 msgstr ""
 
-#: cp/name-lookup.c:2021
+#: cp/name-lookup.c:2023
 #, gcc-internal-format
 msgid "%q#D hides constructor for %q#T"
 msgstr ""
 
-#: cp/name-lookup.c:2038
+#: cp/name-lookup.c:2040
 #, gcc-internal-format
 msgid "%q#D conflicts with previous using declaration %q#D"
 msgstr ""
 
-#: cp/name-lookup.c:2061
+#: cp/name-lookup.c:2063
 #, gcc-internal-format
 msgid "previous non-function declaration %q+#D"
 msgstr ""
 
-#: cp/name-lookup.c:2062
+#: cp/name-lookup.c:2064
 #, gcc-internal-format
 msgid "conflicts with function declaration %q#D"
 msgstr ""
 
 #. It's a nested name with template parameter dependent scope.
 #. This can only be using-declaration for class member.
-#: cp/name-lookup.c:2140 cp/name-lookup.c:2165
+#: cp/name-lookup.c:2142 cp/name-lookup.c:2167
 #, gcc-internal-format
 msgid "%qT is not a namespace"
 msgstr ""
 
 #. 7.3.3/5
 #. A using-declaration shall not name a template-id.
-#: cp/name-lookup.c:2150
+#: cp/name-lookup.c:2152
 #, gcc-internal-format
 msgid "a using-declaration cannot specify a template-id.  Try %<using %D%>"
 msgstr ""
 
-#: cp/name-lookup.c:2157
+#: cp/name-lookup.c:2159
 #, gcc-internal-format
 msgid "namespace %qD not allowed in using-declaration"
 msgstr ""
 
-#: cp/name-lookup.c:2193
+#: cp/name-lookup.c:2195
 #, gcc-internal-format
 msgid "%qD not declared"
 msgstr ""
 
-#: cp/name-lookup.c:2229 cp/name-lookup.c:2266 cp/name-lookup.c:2300
-#: cp/name-lookup.c:2315
+#: cp/name-lookup.c:2231 cp/name-lookup.c:2268 cp/name-lookup.c:2302
+#: cp/name-lookup.c:2317
 #, gcc-internal-format
 msgid "%qD is already declared in this scope"
 msgstr ""
 
-#: cp/name-lookup.c:2919
+#: cp/name-lookup.c:2921
 #, gcc-internal-format
 msgid "using-declaration for non-member at class scope"
 msgstr ""
 
-#: cp/name-lookup.c:2926
+#: cp/name-lookup.c:2928
 #, gcc-internal-format
 msgid "%<%T::%D%> names destructor"
 msgstr ""
 
-#: cp/name-lookup.c:2931
+#: cp/name-lookup.c:2933
 #, gcc-internal-format
 msgid "%<%T::%D%> names constructor"
 msgstr ""
 
-#: cp/name-lookup.c:2936
+#: cp/name-lookup.c:2938
 #, gcc-internal-format
 msgid "%<%T::%D%> names constructor in %qT"
 msgstr ""
 
-#: cp/name-lookup.c:2986
+#: cp/name-lookup.c:2988
 #, gcc-internal-format
 msgid "no members matching %<%T::%D%> in %q#T"
 msgstr ""
 
-#: cp/name-lookup.c:3054
+#: cp/name-lookup.c:3056
 #, gcc-internal-format
 msgid "declaration of %qD not in a namespace surrounding %qD"
 msgstr ""
 
-#: cp/name-lookup.c:3062
+#: cp/name-lookup.c:3064
 #, gcc-internal-format
 msgid "explicit qualification in declaration of %qD"
 msgstr ""
 
-#: cp/name-lookup.c:3105
+#: cp/name-lookup.c:3107
 #, gcc-internal-format
 msgid "%qD should have been declared inside %qD"
 msgstr ""
 
-#: cp/name-lookup.c:3150
+#: cp/name-lookup.c:3152
 #, gcc-internal-format
 msgid "%qD attribute requires a single NTBS argument"
 msgstr ""
 
-#: cp/name-lookup.c:3157
+#: cp/name-lookup.c:3159
 #, gcc-internal-format
 msgid ""
 "%qD attribute is meaningless since members of the anonymous namespace get "
 "local symbols"
 msgstr ""
 
-#: cp/name-lookup.c:3166 cp/name-lookup.c:3536
+#: cp/name-lookup.c:3168 cp/name-lookup.c:3538
 #, gcc-internal-format
 msgid "%qD attribute directive ignored"
 msgstr ""
 
-#: cp/name-lookup.c:3211
+#: cp/name-lookup.c:3213
 #, gcc-internal-format
 msgid "namespace alias %qD not allowed here, assuming %qD"
 msgstr ""
 
-#: cp/name-lookup.c:3524
+#: cp/name-lookup.c:3526
 #, gcc-internal-format
 msgid "strong using only meaningful at namespace scope"
 msgstr ""
 
-#: cp/name-lookup.c:3528
+#: cp/name-lookup.c:3530
 #, gcc-internal-format
 msgid "current namespace %qD does not enclose strongly used namespace %qD"
 msgstr ""
 
-#: cp/name-lookup.c:4466
+#: cp/name-lookup.c:4467
 #, gcc-internal-format
 msgid "%q+D is not a function,"
 msgstr ""
 
-#: cp/name-lookup.c:4467
+#: cp/name-lookup.c:4468
 #, gcc-internal-format
 msgid "  conflict with %q+D"
 msgstr ""
 
-#: cp/name-lookup.c:4912
+#: cp/name-lookup.c:4913
 #, gcc-internal-format
 msgid "argument dependent lookup finds %q+D"
 msgstr ""
 
-#: cp/name-lookup.c:5353
+#: cp/name-lookup.c:5354
 #, gcc-internal-format
 msgid "XXX entering pop_everything ()\n"
 msgstr ""
 
-#: cp/name-lookup.c:5362
+#: cp/name-lookup.c:5363
 #, gcc-internal-format
 msgid "XXX leaving pop_everything ()\n"
 msgstr ""
@@ -31868,334 +31922,334 @@
 msgid "identifier %<%s%> will become a keyword in C++0x"
 msgstr ""
 
-#: cp/parser.c:2080
+#: cp/parser.c:2084
 #, gcc-internal-format
 msgid "%H%<#pragma%> is not allowed here"
 msgstr ""
 
-#: cp/parser.c:2111
+#: cp/parser.c:2115
 #, gcc-internal-format
 msgid "%H%<%E::%E%> has not been declared"
 msgstr ""
 
-#: cp/parser.c:2114
+#: cp/parser.c:2118
 #, gcc-internal-format
 msgid "%H%<::%E%> has not been declared"
 msgstr ""
 
-#: cp/parser.c:2117
+#: cp/parser.c:2121
 #, gcc-internal-format
 msgid "%Hrequest for member %qE in non-class type %qT"
 msgstr ""
 
-#: cp/parser.c:2120
+#: cp/parser.c:2124
 #, gcc-internal-format
 msgid "%H%<%T::%E%> has not been declared"
 msgstr ""
 
-#: cp/parser.c:2123
+#: cp/parser.c:2127
 #, gcc-internal-format
 msgid "%H%qE has not been declared"
 msgstr ""
 
-#: cp/parser.c:2126
+#: cp/parser.c:2130
 #, gcc-internal-format
 msgid "%H%<%E::%E%> %s"
 msgstr ""
 
-#: cp/parser.c:2128
+#: cp/parser.c:2132
 #, gcc-internal-format
 msgid "%H%<::%E%> %s"
 msgstr ""
 
-#: cp/parser.c:2130
+#: cp/parser.c:2134
 #, gcc-internal-format
 msgid "%H%qE %s"
 msgstr ""
 
-#: cp/parser.c:2165
+#: cp/parser.c:2169
 #, gcc-internal-format
 msgid "%H%<long long long%> is too long for GCC"
 msgstr ""
 
-#: cp/parser.c:2169
+#: cp/parser.c:2173
 #, gcc-internal-format
 msgid "ISO C++ 1998 does not support %<long long%>"
 msgstr ""
 
-#: cp/parser.c:2189
+#: cp/parser.c:2193
 #, gcc-internal-format
 msgid "%Hduplicate %qs"
 msgstr ""
 
-#: cp/parser.c:2233
+#: cp/parser.c:2237
 #, gcc-internal-format
 msgid "%Hnew types may not be defined in a return type"
 msgstr ""
 
-#: cp/parser.c:2235
+#: cp/parser.c:2239
 #, gcc-internal-format
 msgid "(perhaps a semicolon is missing after the definition of %qT)"
 msgstr ""
 
-#: cp/parser.c:2255
+#: cp/parser.c:2259
 #, gcc-internal-format
 msgid "%H%qT is not a template"
 msgstr ""
 
-#: cp/parser.c:2257
+#: cp/parser.c:2261
 #, gcc-internal-format
 msgid "%H%qE is not a template"
 msgstr ""
 
-#: cp/parser.c:2259
+#: cp/parser.c:2263
 #, gcc-internal-format
 msgid "%Hinvalid template-id"
 msgstr ""
 
-#: cp/parser.c:2321
+#: cp/parser.c:2325
 #, gcc-internal-format
 msgid "%Hinvalid use of template-name %qE without an argument list"
 msgstr ""
 
-#: cp/parser.c:2324
+#: cp/parser.c:2328
 #, gcc-internal-format
 msgid "%Hinvalid use of destructor %qD as a type"
 msgstr ""
 
 #. Something like 'unsigned A a;'
-#: cp/parser.c:2327
+#: cp/parser.c:2331
 #, gcc-internal-format
 msgid "%Hinvalid combination of multiple type-specifiers"
 msgstr ""
 
 #. Issue an error message.
-#: cp/parser.c:2332
+#: cp/parser.c:2336
 #, gcc-internal-format
 msgid "%H%qE does not name a type"
 msgstr ""
 
-#: cp/parser.c:2365
+#: cp/parser.c:2369
 #, gcc-internal-format
 msgid "(perhaps %<typename %T::%E%> was intended)"
 msgstr ""
 
-#: cp/parser.c:2380
+#: cp/parser.c:2384
 #, gcc-internal-format
 msgid "%H%qE in namespace %qE does not name a type"
 msgstr ""
 
-#: cp/parser.c:2383
+#: cp/parser.c:2387
 #, gcc-internal-format
 msgid "%H%qE in class %qT does not name a type"
 msgstr ""
 
-#: cp/parser.c:2945
+#: cp/parser.c:2951
 #, gcc-internal-format
 msgid "%Hunsupported non-standard concatenation of string literals"
 msgstr ""
 
-#: cp/parser.c:3148
+#: cp/parser.c:3154
 #, gcc-internal-format
 msgid "%Hfixed-point types not supported in C++"
 msgstr ""
 
-#: cp/parser.c:3229
+#: cp/parser.c:3235
 #, gcc-internal-format
 msgid "ISO C++ forbids braced-groups within expressions"
 msgstr ""
 
-#: cp/parser.c:3240
+#: cp/parser.c:3246
 #, gcc-internal-format
 msgid ""
 "%Hstatement-expressions are not allowed outside functions nor in template-"
 "argument lists"
 msgstr ""
 
-#: cp/parser.c:3299
+#: cp/parser.c:3305
 #, gcc-internal-format
 msgid "%H%<this%> may not be used in this context"
 msgstr ""
 
-#: cp/parser.c:3508
+#: cp/parser.c:3514
 #, gcc-internal-format
 msgid "%Hlocal variable %qD may not appear in this context"
 msgstr ""
 
-#: cp/parser.c:3808
+#: cp/parser.c:3814
 #, gcc-internal-format
 msgid "%Hscope %qT before %<~%> is not a class-name"
 msgstr ""
 
-#: cp/parser.c:3922
+#: cp/parser.c:3928
 #, gcc-internal-format
 msgid "%Hdeclaration of %<~%T%> as member of %qT"
 msgstr ""
 
-#: cp/parser.c:3936
+#: cp/parser.c:3942
 #, gcc-internal-format
 msgid "%Htypedef-name %qD used as destructor declarator"
 msgstr ""
 
-#: cp/parser.c:4150
+#: cp/parser.c:4156
 #, gcc-internal-format
 msgid "%H%qD used without template parameters"
 msgstr ""
 
-#: cp/parser.c:4154 cp/parser.c:14857 cp/parser.c:17154
+#: cp/parser.c:4160 cp/parser.c:14878 cp/parser.c:17175
 #, gcc-internal-format
 msgid "%Hreference to %qD is ambiguous"
 msgstr ""
 
-#: cp/parser.c:4200 cp/pt.c:5659
+#: cp/parser.c:4206 cp/pt.c:5659
 #, gcc-internal-format
 msgid "%qT is not a template"
 msgstr ""
 
 #. Warn the user that a compound literal is not
 #. allowed in standard C++.
-#: cp/parser.c:4624
+#: cp/parser.c:4630
 #, gcc-internal-format
 msgid "ISO C++ forbids compound-literals"
 msgstr ""
 
-#: cp/parser.c:4998
+#: cp/parser.c:5003
 #, gcc-internal-format
 msgid "%H%qE does not have class type"
 msgstr ""
 
-#: cp/parser.c:5082
+#: cp/parser.c:5087
 #, gcc-internal-format
 msgid "%Hinvalid use of %qD"
 msgstr ""
 
-#: cp/parser.c:5661
+#: cp/parser.c:5666
 #, gcc-internal-format
 msgid "%Harray bound forbidden after parenthesized type-id"
 msgstr ""
 
-#: cp/parser.c:5664
+#: cp/parser.c:5669
 #, gcc-internal-format
 msgid "try removing the parentheses around the type-id"
 msgstr ""
 
-#: cp/parser.c:5857
+#: cp/parser.c:5862
 #, gcc-internal-format
 msgid "%Hexpression in new-declarator must have integral or enumeration type"
 msgstr ""
 
-#: cp/parser.c:6113
+#: cp/parser.c:6118
 #, gcc-internal-format
 msgid "use of old-style cast"
 msgstr ""
 
-#: cp/parser.c:6244
+#: cp/parser.c:6249
 #, gcc-internal-format
 msgid "%H%<>>%> operator will be treated as two right angle brackets in C++0x"
 msgstr ""
 
-#: cp/parser.c:6247
+#: cp/parser.c:6252
 #, gcc-internal-format
 msgid "suggest parentheses around %<>>%> expression"
 msgstr ""
 
-#: cp/parser.c:7084
+#: cp/parser.c:7089
 #, gcc-internal-format
 msgid "%Hcase label %qE not within a switch statement"
 msgstr ""
 
-#: cp/parser.c:7096
+#: cp/parser.c:7101
 #, gcc-internal-format
 msgid "%Hcase label not within a switch statement"
 msgstr ""
 
-#: cp/parser.c:7214
+#: cp/parser.c:7219
 #, gcc-internal-format
 msgid "%H%<else%> without a previous %<if%>"
 msgstr ""
 
-#: cp/parser.c:7693
+#: cp/parser.c:7698
 #, gcc-internal-format
 msgid "%Hbreak statement not within loop or switch"
 msgstr ""
 
-#: cp/parser.c:7701 cp/parser.c:7721
+#: cp/parser.c:7706 cp/parser.c:7726
 #, gcc-internal-format
 msgid "%Hinvalid exit from OpenMP structured block"
 msgstr ""
 
-#: cp/parser.c:7704
+#: cp/parser.c:7709
 #, gcc-internal-format
 msgid "%Hbreak statement used with OpenMP for loop"
 msgstr ""
 
-#: cp/parser.c:7714
+#: cp/parser.c:7719
 #, gcc-internal-format
 msgid "%Hcontinue statement not within a loop"
 msgstr ""
 
 #. Issue a warning about this use of a GNU extension.
-#: cp/parser.c:7757
+#: cp/parser.c:7762
 #, gcc-internal-format
 msgid "ISO C++ forbids computed gotos"
 msgstr ""
 
-#: cp/parser.c:7901 cp/parser.c:15736
+#: cp/parser.c:7906 cp/parser.c:15757
 #, gcc-internal-format
 msgid "extra %<;%>"
 msgstr ""
 
-#: cp/parser.c:8122
+#: cp/parser.c:8127
 #, gcc-internal-format
 msgid "%H%<__label__%> not at the beginning of a block"
 msgstr ""
 
-#: cp/parser.c:8259
+#: cp/parser.c:8264
 #, gcc-internal-format
 msgid "%Hmixing declarations and function-definitions is forbidden"
 msgstr ""
 
-#: cp/parser.c:8399
+#: cp/parser.c:8404
 #, gcc-internal-format
 msgid "%H%<friend%> used outside of class"
 msgstr ""
 
-#: cp/parser.c:8455
+#: cp/parser.c:8460
 #, gcc-internal-format
 msgid "%H%<auto%> will change meaning in C++0x; please remove it"
 msgstr ""
 
-#: cp/parser.c:8574
+#: cp/parser.c:8579
 #, gcc-internal-format
 msgid "%Hclass definition may not be declared a friend"
 msgstr ""
 
-#: cp/parser.c:8644 cp/parser.c:16058
+#: cp/parser.c:8649 cp/parser.c:16079
 #, gcc-internal-format
 msgid "%Htemplates may not be %<virtual%>"
 msgstr ""
 
-#: cp/parser.c:9047
+#: cp/parser.c:9052
 #, gcc-internal-format
 msgid "invalid use of %<auto%> in conversion operator"
 msgstr ""
 
-#: cp/parser.c:9131
+#: cp/parser.c:9136
 #, gcc-internal-format
 msgid "%Honly constructors take base initializers"
 msgstr ""
 
-#: cp/parser.c:9153
+#: cp/parser.c:9158
 #, gcc-internal-format
 msgid "%Hcannot expand initializer for member %<%D%>"
 msgstr ""
 
-#: cp/parser.c:9208
+#: cp/parser.c:9213
 #, gcc-internal-format
 msgid "anachronistic old-style base class initializer"
 msgstr ""
 
-#: cp/parser.c:9268
+#: cp/parser.c:9273
 #, gcc-internal-format
 msgid ""
 "%Hkeyword %<typename%> not allowed in this context (a qualified member "
@@ -32203,92 +32257,92 @@
 msgstr ""
 
 #. Warn that we do not support `export'.
-#: cp/parser.c:9614
+#: cp/parser.c:9619
 #, gcc-internal-format
 msgid "keyword %<export%> not implemented, and will be ignored"
 msgstr ""
 
-#: cp/parser.c:9796 cp/parser.c:9894 cp/parser.c:10000
+#: cp/parser.c:9801 cp/parser.c:9899 cp/parser.c:10005
 #, gcc-internal-format
 msgid "%Htemplate parameter pack %qD cannot have a default argument"
 msgstr ""
 
-#: cp/parser.c:9799
+#: cp/parser.c:9804
 #, gcc-internal-format
 msgid "%Htemplate parameter pack cannot have a default argument"
 msgstr ""
 
-#: cp/parser.c:9897 cp/parser.c:10004
+#: cp/parser.c:9902 cp/parser.c:10009
 #, gcc-internal-format
 msgid "%Htemplate parameter packs cannot have default arguments"
 msgstr ""
 
-#: cp/parser.c:10146
+#: cp/parser.c:10151
 #, gcc-internal-format
 msgid "%<<::%> cannot begin a template-argument list"
 msgstr ""
 
-#: cp/parser.c:10150
+#: cp/parser.c:10155
 #, gcc-internal-format
 msgid ""
 "%<<:%> is an alternate spelling for %<[%>. Insert whitespace between %<<%> "
 "and %<::%>"
 msgstr ""
 
-#: cp/parser.c:10228
+#: cp/parser.c:10233
 #, gcc-internal-format
 msgid "%Hparse error in template argument list"
 msgstr ""
 
 #. Explain what went wrong.
-#: cp/parser.c:10343
+#: cp/parser.c:10348
 #, gcc-internal-format
 msgid "%Hnon-template %qD used as template"
 msgstr ""
 
-#: cp/parser.c:10345
+#: cp/parser.c:10350
 #, gcc-internal-format
 msgid "use %<%T::template %D%> to indicate that it is a template"
 msgstr ""
 
-#: cp/parser.c:10882
+#: cp/parser.c:10887
 #, gcc-internal-format
 msgid "%Htemplate specialization with C linkage"
 msgstr ""
 
-#: cp/parser.c:11527
+#: cp/parser.c:11532
 #, gcc-internal-format
 msgid "using %<typename%> outside of template"
 msgstr ""
 
-#: cp/parser.c:11695
+#: cp/parser.c:11700
 #, gcc-internal-format
 msgid "declaration %qD does not declare anything"
 msgstr ""
 
-#: cp/parser.c:11780
+#: cp/parser.c:11785
 #, gcc-internal-format
 msgid "attributes ignored on uninstantiated type"
 msgstr ""
 
-#: cp/parser.c:11784
+#: cp/parser.c:11789
 #, gcc-internal-format
 msgid "attributes ignored on template instantiation"
 msgstr ""
 
-#: cp/parser.c:11789
+#: cp/parser.c:11794
 #, gcc-internal-format
 msgid ""
 "attributes ignored on elaborated-type-specifier that is not a forward "
 "declaration"
 msgstr ""
 
-#: cp/parser.c:12067
+#: cp/parser.c:12077
 #, gcc-internal-format
 msgid "%H%qD is not a namespace-name"
 msgstr ""
 
-#: cp/parser.c:12194
+#: cp/parser.c:12204
 #, gcc-internal-format
 msgid "%H%<namespace%> definition is not allowed here"
 msgstr ""
@@ -32296,166 +32350,166 @@
 #. [namespace.udecl]
 #.
 #. A using declaration shall not name a template-id.
-#: cp/parser.c:12334
+#: cp/parser.c:12344
 #, gcc-internal-format
 msgid "%Ha template-id may not appear in a using-declaration"
 msgstr ""
 
-#: cp/parser.c:12711
+#: cp/parser.c:12721
 #, gcc-internal-format
 msgid "%Han asm-specification is not allowed on a function-definition"
 msgstr ""
 
-#: cp/parser.c:12715
+#: cp/parser.c:12725
 #, gcc-internal-format
 msgid "%Hattributes are not allowed on a function-definition"
 msgstr ""
 
-#: cp/parser.c:12868
+#: cp/parser.c:12878
 #, gcc-internal-format
 msgid "%Hinitializer provided for function"
 msgstr ""
 
-#: cp/parser.c:12890
+#: cp/parser.c:12900
 #, gcc-internal-format
 msgid "attributes after parenthesized initializer ignored"
 msgstr ""
 
-#: cp/parser.c:13295
+#: cp/parser.c:13305
 #, gcc-internal-format
 msgid "%Harray bound is not an integer constant"
 msgstr ""
 
-#: cp/parser.c:13407
+#: cp/parser.c:13417
 #, gcc-internal-format
 msgid "%H%<%T::%E%> is not a type"
 msgstr ""
 
-#: cp/parser.c:13434
+#: cp/parser.c:13444
 #, gcc-internal-format
 msgid "%Hinvalid use of constructor as a template"
 msgstr ""
 
-#: cp/parser.c:13436
+#: cp/parser.c:13446
 #, gcc-internal-format
 msgid ""
 "use %<%T::%D%> instead of %<%T::%D%> to name the constructor in a qualified "
 "name"
 msgstr ""
 
-#: cp/parser.c:13609
+#: cp/parser.c:13619
 #, gcc-internal-format
 msgid "%H%qD is a namespace"
 msgstr ""
 
-#: cp/parser.c:13684
+#: cp/parser.c:13694
 #, gcc-internal-format
 msgid "%Hduplicate cv-qualifier"
 msgstr ""
 
-#: cp/parser.c:13796
+#: cp/parser.c:13806
 #, gcc-internal-format
 msgid "invalid use of %<auto%>"
 msgstr ""
 
-#: cp/parser.c:14370
+#: cp/parser.c:14391
 #, gcc-internal-format
 msgid "%Hfile ends in default argument"
 msgstr ""
 
-#: cp/parser.c:14416
+#: cp/parser.c:14437
 #, gcc-internal-format
 msgid "deprecated use of default argument for parameter of non-function"
 msgstr ""
 
-#: cp/parser.c:14419
+#: cp/parser.c:14440
 #, gcc-internal-format
 msgid "%Hdefault arguments are only permitted for function parameters"
 msgstr ""
 
-#: cp/parser.c:14437
+#: cp/parser.c:14458
 #, gcc-internal-format
 msgid "%H%sparameter pack %qD cannot have a default argument"
 msgstr ""
 
-#: cp/parser.c:14441
+#: cp/parser.c:14462
 #, gcc-internal-format
 msgid "%H%sparameter pack cannot have a default argument"
 msgstr ""
 
-#: cp/parser.c:14704
+#: cp/parser.c:14725
 #, gcc-internal-format
 msgid "ISO C++ does not allow designated initializers"
 msgstr ""
 
-#: cp/parser.c:15329
+#: cp/parser.c:15350
 #, gcc-internal-format
 msgid "%Hinvalid class name in declaration of %qD"
 msgstr ""
 
-#: cp/parser.c:15342
+#: cp/parser.c:15363
 #, gcc-internal-format
 msgid "%Hdeclaration of %qD in namespace %qD which does not enclose %qD"
 msgstr ""
 
-#: cp/parser.c:15347
+#: cp/parser.c:15368
 #, gcc-internal-format
 msgid "%Hdeclaration of %qD in %qD which does not enclose %qD"
 msgstr ""
 
-#: cp/parser.c:15361
+#: cp/parser.c:15382
 #, gcc-internal-format
 msgid "%Hextra qualification not allowed"
 msgstr ""
 
-#: cp/parser.c:15373
+#: cp/parser.c:15394
 #, gcc-internal-format
 msgid "%Han explicit specialization must be preceded by %<template <>%>"
 msgstr ""
 
-#: cp/parser.c:15402
+#: cp/parser.c:15423
 #, gcc-internal-format
 msgid "%Hfunction template %qD redeclared as a class template"
 msgstr ""
 
-#: cp/parser.c:15484
+#: cp/parser.c:15505
 #, gcc-internal-format
 msgid "%Hredefinition of %q#T"
 msgstr ""
 
-#: cp/parser.c:15486
+#: cp/parser.c:15507
 #, gcc-internal-format
 msgid "%Hprevious definition of %q+#T"
 msgstr ""
 
-#: cp/parser.c:15754
+#: cp/parser.c:15775
 #, gcc-internal-format
 msgid "%Ha class-key must be used when declaring a friend"
 msgstr ""
 
-#: cp/parser.c:15769
+#: cp/parser.c:15790
 #, gcc-internal-format
 msgid "%Hfriend declaration does not name a class or function"
 msgstr ""
 
-#: cp/parser.c:15949
+#: cp/parser.c:15970
 #, gcc-internal-format
 msgid "%Hpure-specifier on function-definition"
 msgstr ""
 
-#: cp/parser.c:16262
+#: cp/parser.c:16283
 #, gcc-internal-format
 msgid "%Hkeyword %<typename%> not allowed outside of templates"
 msgstr ""
 
-#: cp/parser.c:16265
+#: cp/parser.c:16286
 #, gcc-internal-format
 msgid ""
 "%Hkeyword %<typename%> not allowed in this context (the base class is "
 "implicitly a type)"
 msgstr ""
 
-#: cp/parser.c:17332
+#: cp/parser.c:17353
 #, gcc-internal-format
 msgid "%Htoo few template-parameter-lists"
 msgstr ""
@@ -32464,13 +32518,13 @@
 #. something like:
 #.
 #. template <class T> template <class U> void S::f();
-#: cp/parser.c:17347
+#: cp/parser.c:17368
 #, gcc-internal-format
 msgid "%Htoo many template-parameter-lists"
 msgstr ""
 
 #. Issue an error message.
-#: cp/parser.c:17621
+#: cp/parser.c:17642
 #, gcc-internal-format
 msgid "%Hnamed return values are no longer supported"
 msgstr ""
@@ -32478,169 +32532,169 @@
 #. 14.5.2.2 [temp.mem]
 #.
 #. A local class shall not have member templates.
-#: cp/parser.c:17696
+#: cp/parser.c:17717
 #, gcc-internal-format
 msgid "%Hinvalid declaration of member template in local class"
 msgstr ""
 
-#: cp/parser.c:17706
+#: cp/parser.c:17727
 #, gcc-internal-format
 msgid "%Htemplate with C linkage"
 msgstr ""
 
-#: cp/parser.c:17853
+#: cp/parser.c:17874
 #, gcc-internal-format
 msgid "%Htemplate declaration of %qs"
 msgstr ""
 
-#: cp/parser.c:17917
+#: cp/parser.c:17938
 #, gcc-internal-format
 msgid "%Hexplicit template specialization cannot have a storage class"
 msgstr ""
 
-#: cp/parser.c:18135
+#: cp/parser.c:18156
 #, gcc-internal-format
 msgid "%H%<>>%> should be %<> >%> within a nested template argument list"
 msgstr ""
 
-#: cp/parser.c:18148
+#: cp/parser.c:18169
 #, gcc-internal-format
 msgid "%Hspurious %<>>%>, use %<>%> to terminate a template argument list"
 msgstr ""
 
-#: cp/parser.c:18482
+#: cp/parser.c:18503
 #, gcc-internal-format
 msgid "%Hinvalid use of %qD in linkage specification"
 msgstr ""
 
-#: cp/parser.c:18495
+#: cp/parser.c:18516
 #, gcc-internal-format
 msgid "%H%<__thread%> before %qD"
 msgstr ""
 
-#: cp/parser.c:18816
+#: cp/parser.c:18837
 #, gcc-internal-format
 msgid "%qs tag used in naming %q#T"
 msgstr ""
 
-#: cp/parser.c:18837
+#: cp/parser.c:18858
 #, gcc-internal-format
 msgid "%H%qD redeclared with different access"
 msgstr ""
 
-#: cp/parser.c:18855
+#: cp/parser.c:18876
 #, gcc-internal-format
 msgid "%H%<template%> (as a disambiguator) is only allowed within templates"
 msgstr ""
 
-#: cp/parser.c:19121 cp/parser.c:20048 cp/parser.c:20180
+#: cp/parser.c:19142 cp/parser.c:20069 cp/parser.c:20201
 #, gcc-internal-format
 msgid "%Hmisplaced %<@%D%> Objective-C++ construct"
 msgstr ""
 
-#: cp/parser.c:19265
+#: cp/parser.c:19286
 #, gcc-internal-format
 msgid "%H%<@encode%> must specify a type as an argument"
 msgstr ""
 
-#: cp/parser.c:19581
+#: cp/parser.c:19602
 #, gcc-internal-format
 msgid "%Hinvalid Objective-C++ selector name"
 msgstr ""
 
-#: cp/parser.c:19912
+#: cp/parser.c:19933
 #, gcc-internal-format
 msgid "%Hidentifier expected after %<@protocol%>"
 msgstr ""
 
-#: cp/parser.c:20273
+#: cp/parser.c:20294
 #, gcc-internal-format
 msgid "%Htoo many %qs clauses"
 msgstr ""
 
-#: cp/parser.c:20387
+#: cp/parser.c:20408
 #, gcc-internal-format
 msgid "%Hcollapse argument needs positive constant integer expression"
 msgstr ""
 
-#: cp/parser.c:20676
+#: cp/parser.c:20697
 #, gcc-internal-format
 msgid "%Hschedule %<runtime%> does not take a %<chunk_size%> parameter"
 msgstr ""
 
-#: cp/parser.c:20679
+#: cp/parser.c:20700
 #, gcc-internal-format
 msgid "%Hschedule %<auto%> does not take a %<chunk_size%> parameter"
 msgstr ""
 
-#: cp/parser.c:20827
+#: cp/parser.c:20848
 #, gcc-internal-format
 msgid "%H%qs is not valid for %qs"
 msgstr ""
 
-#: cp/parser.c:21250
+#: cp/parser.c:21271
 #, gcc-internal-format
 msgid "parenthesized initialization is not allowed in OpenMP %<for%> loop"
 msgstr ""
 
-#: cp/parser.c:21375 cp/parser.c:21413
+#: cp/parser.c:21396 cp/parser.c:21434
 #, gcc-internal-format
 msgid "%Hiteration variable %qD should not be firstprivate"
 msgstr ""
 
-#: cp/parser.c:21417
+#: cp/parser.c:21438
 #, gcc-internal-format
 msgid "%Hiteration variable %qD should not be reduction"
 msgstr ""
 
-#: cp/parser.c:21484
+#: cp/parser.c:21505
 #, gcc-internal-format
 msgid "%Hnot enough collapsed for loops"
 msgstr ""
 
-#: cp/parser.c:21530
+#: cp/parser.c:21551
 #, gcc-internal-format
 msgid "%Hcollapsed loops not perfectly nested"
 msgstr ""
 
-#: cp/parser.c:21941
+#: cp/parser.c:21962
 #, gcc-internal-format
 msgid "%Hjunk at end of %<#pragma GCC pch_preprocess%>"
 msgstr ""
 
-#: cp/parser.c:21945
+#: cp/parser.c:21966
 #, gcc-internal-format
 msgid "%Hexpected string literal"
 msgstr ""
 
-#: cp/parser.c:21978
+#: cp/parser.c:21999
 #, gcc-internal-format
 msgid "%H%<#pragma GCC pch_preprocess%> must be first"
 msgstr ""
 
-#: cp/parser.c:21989
+#: cp/parser.c:22010
 #, gcc-internal-format
 msgid "%H%<#pragma omp barrier%> may only be used in compound statements"
 msgstr ""
 
-#: cp/parser.c:22004
+#: cp/parser.c:22025
 #, gcc-internal-format
 msgid "%H%<#pragma omp flush%> may only be used in compound statements"
 msgstr ""
 
-#: cp/parser.c:22019
+#: cp/parser.c:22040
 #, gcc-internal-format
 msgid "%H%<#pragma omp taskwait%> may only be used in compound statements"
 msgstr ""
 
-#: cp/parser.c:22047
+#: cp/parser.c:22068
 #, gcc-internal-format
 msgid ""
 "%H%<#pragma omp section%> may only be used in %<#pragma omp sections%> "
 "construct"
 msgstr ""
 
-#: cp/parser.c:22105
+#: cp/parser.c:22126
 #, gcc-internal-format
 msgid "inter-module optimizations not implemented for C++"
 msgstr ""
@@ -33172,24 +33226,24 @@
 msgid "for template declaration %q+D"
 msgstr ""
 
-#: cp/pt.c:6375
+#: cp/pt.c:6376
 #, gcc-internal-format
 msgid ""
 "template instantiation depth exceeds maximum of %d (use -ftemplate-depth-NN "
 "to increase the maximum) instantiating %qD"
 msgstr ""
 
-#: cp/pt.c:7572
+#: cp/pt.c:7573
 #, gcc-internal-format
 msgid "mismatched argument pack lengths while expanding %<%T%>"
 msgstr ""
 
-#: cp/pt.c:7576
+#: cp/pt.c:7577
 #, gcc-internal-format
 msgid "mismatched argument pack lengths while expanding %<%E%>"
 msgstr ""
 
-#: cp/pt.c:8548
+#: cp/pt.c:8549
 #, gcc-internal-format
 msgid "instantiation of %q+D as type %qT"
 msgstr ""
@@ -33207,241 +33261,241 @@
 #.
 #. is an attempt to declare a variable with function
 #. type.
-#: cp/pt.c:8688
+#: cp/pt.c:8689
 #, gcc-internal-format
 msgid "variable %qD has function type"
 msgstr ""
 
-#: cp/pt.c:8835
+#: cp/pt.c:8836
 #, gcc-internal-format
 msgid "invalid parameter type %qT"
 msgstr ""
 
-#: cp/pt.c:8837
+#: cp/pt.c:8838
 #, gcc-internal-format
 msgid "in declaration %q+D"
 msgstr ""
 
-#: cp/pt.c:8914
+#: cp/pt.c:8915
 #, gcc-internal-format
 msgid "function returning an array"
 msgstr ""
 
-#: cp/pt.c:8916
+#: cp/pt.c:8917
 #, gcc-internal-format
 msgid "function returning a function"
 msgstr ""
 
-#: cp/pt.c:8943
+#: cp/pt.c:8944
 #, gcc-internal-format
 msgid "creating pointer to member function of non-class type %qT"
 msgstr ""
 
-#: cp/pt.c:9164
+#: cp/pt.c:9165
 #, gcc-internal-format
 msgid "array bound is not an integer constant"
 msgstr ""
 
-#: cp/pt.c:9184
+#: cp/pt.c:9185
 #, gcc-internal-format
 msgid "creating array with negative size (%qE)"
 msgstr ""
 
-#: cp/pt.c:9433
+#: cp/pt.c:9434
 #, gcc-internal-format
 msgid "forming reference to void"
 msgstr ""
 
-#: cp/pt.c:9435
+#: cp/pt.c:9436
 #, gcc-internal-format
 msgid "forming %s to reference type %qT"
 msgstr ""
 
-#: cp/pt.c:9486
+#: cp/pt.c:9487
 #, gcc-internal-format
 msgid "creating pointer to member of non-class type %qT"
 msgstr ""
 
-#: cp/pt.c:9492
+#: cp/pt.c:9493
 #, gcc-internal-format
 msgid "creating pointer to member reference type %qT"
 msgstr ""
 
-#: cp/pt.c:9498
+#: cp/pt.c:9499
 #, gcc-internal-format
 msgid "creating pointer to member of type void"
 msgstr ""
 
-#: cp/pt.c:9565
+#: cp/pt.c:9566
 #, gcc-internal-format
 msgid "creating array of %qT"
 msgstr ""
 
-#: cp/pt.c:9571
+#: cp/pt.c:9572
 #, gcc-internal-format
 msgid "creating array of %qT, which is an abstract class type"
 msgstr ""
 
-#: cp/pt.c:9622
+#: cp/pt.c:9623
 #, gcc-internal-format
 msgid "%qT is not a class, struct, or union type"
 msgstr ""
 
-#: cp/pt.c:9657
+#: cp/pt.c:9658
 #, gcc-internal-format
 msgid "%qT resolves to %qT, which is not an enumeration type"
 msgstr ""
 
-#: cp/pt.c:9660
+#: cp/pt.c:9661
 #, gcc-internal-format
 msgid "%qT resolves to %qT, which is is not a class type"
 msgstr ""
 
-#: cp/pt.c:9766
+#: cp/pt.c:9767
 #, gcc-internal-format
 msgid "use of %qs in template"
 msgstr ""
 
-#: cp/pt.c:9903
+#: cp/pt.c:9904
 #, gcc-internal-format
 msgid ""
 "dependent-name %qE is parsed as a non-type, but instantiation yields a type"
 msgstr ""
 
-#: cp/pt.c:9905
+#: cp/pt.c:9906
 #, gcc-internal-format
 msgid "say %<typename %E%> if a type is meant"
 msgstr ""
 
-#: cp/pt.c:10047
+#: cp/pt.c:10048
 #, gcc-internal-format
 msgid "using invalid field %qD"
 msgstr ""
 
-#: cp/pt.c:10377 cp/pt.c:11040
+#: cp/pt.c:10378 cp/pt.c:11041
 #, gcc-internal-format
 msgid "invalid use of pack expansion expression"
 msgstr ""
 
-#: cp/pt.c:10381 cp/pt.c:11044
+#: cp/pt.c:10382 cp/pt.c:11045
 #, gcc-internal-format
 msgid "use %<...%> to expand argument pack"
 msgstr ""
 
-#: cp/pt.c:10536
+#: cp/pt.c:10537
 #, gcc-internal-format
 msgid "iteration variable %qD should not be reduction"
 msgstr ""
 
-#: cp/pt.c:11204
+#: cp/pt.c:11205
 #, gcc-internal-format
 msgid ""
 "a cast to a type other than an integral or enumeration type cannot appear in "
 "a constant-expression"
 msgstr ""
 
-#: cp/pt.c:11671
+#: cp/pt.c:11673
 #, gcc-internal-format
 msgid "%qT is not a class or namespace"
 msgstr ""
 
-#: cp/pt.c:11674
+#: cp/pt.c:11676
 #, gcc-internal-format
 msgid "%qD is not a class or namespace"
 msgstr ""
 
-#: cp/pt.c:11894
+#: cp/pt.c:11896
 #, gcc-internal-format
 msgid "%qT is/uses anonymous type"
 msgstr ""
 
-#: cp/pt.c:11896
+#: cp/pt.c:11898
 #, gcc-internal-format
 msgid "template argument for %qD uses local type %qT"
 msgstr ""
 
-#: cp/pt.c:11906
+#: cp/pt.c:11908
 #, gcc-internal-format
 msgid "%qT is a variably modified type"
 msgstr ""
 
-#: cp/pt.c:11917
+#: cp/pt.c:11919
 #, gcc-internal-format
 msgid "integral expression %qE is not constant"
 msgstr ""
 
-#: cp/pt.c:11935
+#: cp/pt.c:11937
 #, gcc-internal-format
 msgid "  trying to instantiate %qD"
 msgstr ""
 
-#: cp/pt.c:14723
+#: cp/pt.c:14754
 #, gcc-internal-format
 msgid "ambiguous class template instantiation for %q#T"
 msgstr ""
 
-#: cp/pt.c:14726
+#: cp/pt.c:14757
 #, gcc-internal-format
 msgid "%s %+#T"
 msgstr ""
 
-#: cp/pt.c:14749 cp/pt.c:14832
+#: cp/pt.c:14780 cp/pt.c:14863
 #, gcc-internal-format
 msgid "explicit instantiation of non-template %q#D"
 msgstr ""
 
-#: cp/pt.c:14764
+#: cp/pt.c:14795
 #, gcc-internal-format
 msgid "%qD is not a static data member of a class template"
 msgstr ""
 
-#: cp/pt.c:14770 cp/pt.c:14827
+#: cp/pt.c:14801 cp/pt.c:14858
 #, gcc-internal-format
 msgid "no matching template for %qD found"
 msgstr ""
 
-#: cp/pt.c:14775
+#: cp/pt.c:14806
 #, gcc-internal-format
 msgid ""
 "type %qT for explicit instantiation %qD does not match declared type %qT"
 msgstr ""
 
-#: cp/pt.c:14783
+#: cp/pt.c:14814
 #, gcc-internal-format
 msgid "explicit instantiation of %q#D"
 msgstr ""
 
-#: cp/pt.c:14819
+#: cp/pt.c:14850
 #, gcc-internal-format
 msgid "duplicate explicit instantiation of %q#D"
 msgstr ""
 
-#: cp/pt.c:14842 cp/pt.c:14934
+#: cp/pt.c:14873 cp/pt.c:14965
 #, gcc-internal-format
 msgid "ISO C++ 1998 forbids the use of %<extern%> on explicit instantiations"
 msgstr ""
 
-#: cp/pt.c:14847 cp/pt.c:14951
+#: cp/pt.c:14878 cp/pt.c:14982
 #, gcc-internal-format
 msgid "storage class %qD applied to template instantiation"
 msgstr ""
 
-#: cp/pt.c:14912
+#: cp/pt.c:14943
 #, gcc-internal-format
 msgid "explicit instantiation of non-template type %qT"
 msgstr ""
 
-#: cp/pt.c:14921
+#: cp/pt.c:14952
 #, gcc-internal-format
 msgid "explicit instantiation of %q#T before definition of template"
 msgstr ""
 
-#: cp/pt.c:14939
+#: cp/pt.c:14970
 #, gcc-internal-format
 msgid "ISO C++ forbids the use of %qE on explicit instantiations"
 msgstr ""
 
-#: cp/pt.c:14985
+#: cp/pt.c:15016
 #, gcc-internal-format
 msgid "duplicate explicit instantiation of %q#T"
 msgstr ""
@@ -33453,12 +33507,12 @@
 #. member function or static data member of a class template
 #. shall be present in every translation unit in which it is
 #. explicitly instantiated.
-#: cp/pt.c:15435
+#: cp/pt.c:15466
 #, gcc-internal-format
 msgid "explicit instantiation of %qD but no definition available"
 msgstr ""
 
-#: cp/pt.c:15601
+#: cp/pt.c:15632
 #, gcc-internal-format
 msgid ""
 "template instantiation depth exceeds maximum of %d instantiating %q+D, "
@@ -33466,19 +33520,19 @@
 "the maximum)"
 msgstr ""
 
-#: cp/pt.c:15956
+#: cp/pt.c:15987
 #, gcc-internal-format
 msgid "%q#T is not a valid type for a template constant parameter"
 msgstr ""
 
-#: cp/pt.c:16932
+#: cp/pt.c:16977
 #, gcc-internal-format
 msgid ""
 "deducing auto from brace-enclosed initializer list requires #include "
 "<initializer_list>"
 msgstr ""
 
-#: cp/pt.c:16973
+#: cp/pt.c:17018
 #, gcc-internal-format
 msgid "unable to deduce %qT from %qE"
 msgstr ""
@@ -33617,338 +33671,338 @@
 msgid "__label__ declarations are only allowed in function scopes"
 msgstr ""
 
-#: cp/semantics.c:1429
+#: cp/semantics.c:1439
 #, gcc-internal-format
 msgid "invalid use of member %q+D in static member function"
 msgstr ""
 
-#: cp/semantics.c:1431
+#: cp/semantics.c:1441
 #, gcc-internal-format
 msgid "invalid use of non-static data member %q+D"
 msgstr ""
 
-#: cp/semantics.c:1432 cp/semantics.c:1471
+#: cp/semantics.c:1442 cp/semantics.c:1484
 #, gcc-internal-format
 msgid "from this location"
 msgstr ""
 
-#: cp/semantics.c:1470
+#: cp/semantics.c:1483
 #, gcc-internal-format
 msgid "object missing in reference to %q+D"
 msgstr ""
 
-#: cp/semantics.c:1964
+#: cp/semantics.c:1973
 #, gcc-internal-format
 msgid "arguments to destructor are not allowed"
 msgstr ""
 
-#: cp/semantics.c:2016
+#: cp/semantics.c:2023
 #, gcc-internal-format
 msgid "%<this%> is unavailable for static member functions"
 msgstr ""
 
-#: cp/semantics.c:2022
+#: cp/semantics.c:2029
 #, gcc-internal-format
 msgid "invalid use of %<this%> in non-member function"
 msgstr ""
 
-#: cp/semantics.c:2024
+#: cp/semantics.c:2031
 #, gcc-internal-format
 msgid "invalid use of %<this%> at top level"
 msgstr ""
 
-#: cp/semantics.c:2048
+#: cp/semantics.c:2055
 #, gcc-internal-format
 msgid "invalid qualifying scope in pseudo-destructor name"
 msgstr ""
 
-#: cp/semantics.c:2053 cp/typeck.c:2130
+#: cp/semantics.c:2060 cp/typeck.c:2130
 #, gcc-internal-format
 msgid "qualified type %qT does not match destructor name ~%qT"
 msgstr ""
 
-#: cp/semantics.c:2075
+#: cp/semantics.c:2082
 #, gcc-internal-format
 msgid "%qE is not of type %qT"
 msgstr ""
 
-#: cp/semantics.c:2119
+#: cp/semantics.c:2126
 #, gcc-internal-format
 msgid "compound literal of non-object type %qT"
 msgstr ""
 
-#: cp/semantics.c:2203
+#: cp/semantics.c:2210
 #, gcc-internal-format
 msgid "template type parameters must use the keyword %<class%> or %<typename%>"
 msgstr ""
 
-#: cp/semantics.c:2244
+#: cp/semantics.c:2251
 #, gcc-internal-format
 msgid ""
 "invalid use of type %qT as a default value for a template template-parameter"
 msgstr ""
 
-#: cp/semantics.c:2247
+#: cp/semantics.c:2254
 #, gcc-internal-format
 msgid "invalid default argument for a template template parameter"
 msgstr ""
 
-#: cp/semantics.c:2264
+#: cp/semantics.c:2271
 #, gcc-internal-format
 msgid "definition of %q#T inside template parameter list"
 msgstr ""
 
-#: cp/semantics.c:2275
+#: cp/semantics.c:2282
 #, gcc-internal-format
 msgid "invalid definition of qualified type %qT"
 msgstr ""
 
-#: cp/semantics.c:2491
+#: cp/semantics.c:2498
 #, gcc-internal-format
 msgid "invalid base-class specification"
 msgstr ""
 
-#: cp/semantics.c:2503
+#: cp/semantics.c:2510
 #, gcc-internal-format
 msgid "base class %qT has cv qualifiers"
 msgstr ""
 
-#: cp/semantics.c:2528
+#: cp/semantics.c:2535
 #, gcc-internal-format
 msgid "%Hincomplete type %qT used in nested name specifier"
 msgstr ""
 
-#: cp/semantics.c:2532
+#: cp/semantics.c:2539
 #, gcc-internal-format
 msgid "%Hreference to %<%T::%D%> is ambiguous"
 msgstr ""
 
-#: cp/semantics.c:2536
+#: cp/semantics.c:2543
 #, gcc-internal-format
 msgid "%H%qD is not a member of %qT"
 msgstr ""
 
-#: cp/semantics.c:2539
+#: cp/semantics.c:2546
 #, gcc-internal-format
 msgid "%H%qD is not a member of %qD"
 msgstr ""
 
-#: cp/semantics.c:2541
+#: cp/semantics.c:2548
 #, gcc-internal-format
 msgid "%H%<::%D%> has not been declared"
 msgstr ""
 
-#: cp/semantics.c:2682
+#: cp/semantics.c:2689
 #, gcc-internal-format
 msgid "use of %<auto%> variable from containing function"
 msgstr ""
 
-#: cp/semantics.c:2684
+#: cp/semantics.c:2691
 #, gcc-internal-format
 msgid "  %q+#D declared here"
 msgstr ""
 
-#: cp/semantics.c:2722
+#: cp/semantics.c:2729
 #, gcc-internal-format
 msgid ""
 "template parameter %qD of type %qT is not allowed in an integral constant "
 "expression because it is not of integral or enumeration type"
 msgstr ""
 
-#: cp/semantics.c:2891
+#: cp/semantics.c:2893
 #, gcc-internal-format
 msgid "%qD cannot appear in a constant-expression"
 msgstr ""
 
-#: cp/semantics.c:2899
+#: cp/semantics.c:2901
 #, gcc-internal-format
 msgid "use of namespace %qD as expression"
 msgstr ""
 
-#: cp/semantics.c:2904
+#: cp/semantics.c:2906
 #, gcc-internal-format
 msgid "use of class template %qT as expression"
 msgstr ""
 
 #. Ambiguous reference to base members.
-#: cp/semantics.c:2910
+#: cp/semantics.c:2912
 #, gcc-internal-format
 msgid "request for member %qD is ambiguous in multiple inheritance lattice"
 msgstr ""
 
-#: cp/semantics.c:3032 cp/semantics.c:4762
+#: cp/semantics.c:3034 cp/semantics.c:4764
 #, gcc-internal-format
 msgid "type of %qE is unknown"
 msgstr ""
 
-#: cp/semantics.c:3047
+#: cp/semantics.c:3049
 #, gcc-internal-format
 msgid "cannot apply %<offsetof%> to destructor %<~%T%>"
 msgstr ""
 
-#: cp/semantics.c:3058
+#: cp/semantics.c:3060
 #, gcc-internal-format
 msgid "cannot apply %<offsetof%> to member function %qD"
 msgstr ""
 
-#: cp/semantics.c:3503
+#: cp/semantics.c:3505
 #, gcc-internal-format
 msgid "%qD is not a variable in clause %qs"
 msgstr ""
 
-#: cp/semantics.c:3512 cp/semantics.c:3534 cp/semantics.c:3556
+#: cp/semantics.c:3514 cp/semantics.c:3536 cp/semantics.c:3558
 #, gcc-internal-format
 msgid "%qD appears more than once in data clauses"
 msgstr ""
 
-#: cp/semantics.c:3526
+#: cp/semantics.c:3528
 #, gcc-internal-format
 msgid "%qD is not a variable in clause %<firstprivate%>"
 msgstr ""
 
-#: cp/semantics.c:3548
+#: cp/semantics.c:3550
 #, gcc-internal-format
 msgid "%qD is not a variable in clause %<lastprivate%>"
 msgstr ""
 
-#: cp/semantics.c:3578
+#: cp/semantics.c:3580
 #, gcc-internal-format
 msgid "num_threads expression must be integral"
 msgstr ""
 
-#: cp/semantics.c:3592
+#: cp/semantics.c:3594
 #, gcc-internal-format
 msgid "schedule chunk size expression must be integral"
 msgstr ""
 
-#: cp/semantics.c:3724
+#: cp/semantics.c:3726
 #, gcc-internal-format
 msgid "%qE has reference type for %qs"
 msgstr ""
 
-#: cp/semantics.c:3795
+#: cp/semantics.c:3797
 #, gcc-internal-format
 msgid "%<threadprivate%> %qD is not file, namespace or block scope variable"
 msgstr ""
 
-#: cp/semantics.c:3809
+#: cp/semantics.c:3811
 #, gcc-internal-format
 msgid "%<threadprivate%> %qE directive not in %qT definition"
 msgstr ""
 
-#: cp/semantics.c:3944
+#: cp/semantics.c:3946
 #, gcc-internal-format
 msgid "%Hinvalid controlling predicate"
 msgstr ""
 
-#: cp/semantics.c:3954
+#: cp/semantics.c:3956
 #, gcc-internal-format
 msgid "%Hdifference between %qE and %qD does not have integer type"
 msgstr ""
 
-#: cp/semantics.c:4049
+#: cp/semantics.c:4051
 #, gcc-internal-format
 msgid "%Hinvalid increment expression"
 msgstr ""
 
-#: cp/semantics.c:4175 cp/semantics.c:4246
+#: cp/semantics.c:4177 cp/semantics.c:4248
 #, gcc-internal-format
 msgid "%Hexpected iteration declaration or initialization"
 msgstr ""
 
-#: cp/semantics.c:4186
+#: cp/semantics.c:4188
 #, gcc-internal-format
 msgid "%Hmissing controlling predicate"
 msgstr ""
 
-#: cp/semantics.c:4192
+#: cp/semantics.c:4194
 #, gcc-internal-format
 msgid "%Hmissing increment expression"
 msgstr ""
 
-#: cp/semantics.c:4272
+#: cp/semantics.c:4274
 #, gcc-internal-format
 msgid "%Hinvalid type for iteration variable %qE"
 msgstr ""
 
 #. Report the error.
-#: cp/semantics.c:4474
+#: cp/semantics.c:4476
 #, gcc-internal-format
 msgid "static assertion failed: %E"
 msgstr ""
 
-#: cp/semantics.c:4476
+#: cp/semantics.c:4478
 #, gcc-internal-format
 msgid "non-constant condition for static assertion"
 msgstr ""
 
-#: cp/semantics.c:4568 cp/semantics.c:4685
+#: cp/semantics.c:4570 cp/semantics.c:4687
 #, gcc-internal-format
 msgid "argument to decltype must be an expression"
 msgstr ""
 
-#: cp/semantics.c:4635
+#: cp/semantics.c:4637
 #, gcc-internal-format
 msgid "%qE refers to a set of overloaded functions"
 msgstr ""
 
-#: cp/semantics.c:4718
+#: cp/semantics.c:4720
 #, gcc-internal-format
 msgid "unable to determine the declared type of expression %<%E%>"
 msgstr ""
 
-#: cp/semantics.c:4949
+#: cp/semantics.c:4951
 #, gcc-internal-format
 msgid "__is_convertible_to"
 msgstr ""
 
-#: cp/semantics.c:4988 cp/semantics.c:4998
+#: cp/semantics.c:4990 cp/semantics.c:5000
 #, gcc-internal-format
 msgid "incomplete type %qT not allowed"
 msgstr ""
 
-#: cp/tree.c:881
+#: cp/tree.c:880
 #, gcc-internal-format
 msgid "%qV qualifiers cannot be applied to %qT"
 msgstr ""
 
-#: cp/tree.c:2215
+#: cp/tree.c:2214
 #, gcc-internal-format
 msgid "%qE attribute can only be applied to Java class definitions"
 msgstr ""
 
-#: cp/tree.c:2244
+#: cp/tree.c:2243
 #, gcc-internal-format
 msgid "%qE attribute can only be applied to class definitions"
 msgstr ""
 
-#: cp/tree.c:2250
+#: cp/tree.c:2249
 #, gcc-internal-format
 msgid "%qE is obsolete; g++ vtables are now COM-compatible by default"
 msgstr ""
 
-#: cp/tree.c:2274
+#: cp/tree.c:2273
 #, gcc-internal-format
 msgid "requested init_priority is not an integer constant"
 msgstr ""
 
-#: cp/tree.c:2295
+#: cp/tree.c:2294
 #, gcc-internal-format
 msgid ""
 "can only use %qE attribute on file-scope definitions of objects of class type"
 msgstr ""
 
-#: cp/tree.c:2303
+#: cp/tree.c:2302
 #, gcc-internal-format
 msgid "requested init_priority is out of range"
 msgstr ""
 
-#: cp/tree.c:2313
+#: cp/tree.c:2312
 #, gcc-internal-format
 msgid "requested init_priority is reserved for internal use"
 msgstr ""
 
-#: cp/tree.c:2324
+#: cp/tree.c:2323
 #, gcc-internal-format
 msgid "%qE attribute is not supported on this platform"
 msgstr ""
@@ -34814,12 +34868,12 @@
 msgid "gfc_conv_constant_to_tree(): invalid type: %s"
 msgstr ""
 
-#: fortran/trans-decl.c:1026
+#: fortran/trans-decl.c:1028
 #, gcc-internal-format
 msgid "intrinsic variable which isn't a procedure"
 msgstr ""
 
-#: fortran/trans-decl.c:3165
+#: fortran/trans-decl.c:3167
 #, gcc-internal-format
 msgid "backend decl for module variable %s already exists"
 msgstr ""
@@ -35540,3 +35594,13 @@
 #, gcc-internal-format
 msgid "local declaration of %qs hides instance variable"
 msgstr ""
+
+#: ada/gcc-interface/misc.c:221
+#, gcc-internal-format
+msgid "missing argument to \"-%s\""
+msgstr ""
+
+#: ada/gcc-interface/misc.c:279
+#, gcc-internal-format
+msgid "%<-gnat%> misspelled as %<-gant%>"
+msgstr ""
diff -Naur gcc-4.4.0.orig/gcc/reg-stack.c gcc-4.4.0/gcc/reg-stack.c
--- gcc-4.4.0.orig/gcc/reg-stack.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/reg-stack.c	2009-05-22 11:59:30.000000000 -0700
@@ -1371,21 +1371,23 @@
 
 	    if (pat != PATTERN (insn))
 	      {
-		/* The fix_truncdi_1 pattern wants to be able to allocate
-		   its own scratch register.  It does this by clobbering
-		   an fp reg so that it is assured of an empty reg-stack
-		   register.  If the register is live, kill it now.
-		   Remove the DEAD/UNUSED note so we don't try to kill it
-		   later too.  */
+		/* The fix_truncdi_1 pattern wants to be able to
+		   allocate its own scratch register.  It does this by
+		   clobbering an fp reg so that it is assured of an
+		   empty reg-stack register.  If the register is live,
+		   kill it now.  Remove the DEAD/UNUSED note so we
+		   don't try to kill it later too.
+
+		   In reality the UNUSED note can be absent in some
+		   complicated cases when the register is reused for
+		   partially set variable.  */
 
 		if (note)
 		  emit_pop_insn (insn, regstack, *dest, EMIT_BEFORE);
 		else
-		  {
-		    note = find_reg_note (insn, REG_UNUSED, *dest);
-		    gcc_assert (note);
-		  }
-		remove_note (insn, note);
+		  note = find_reg_note (insn, REG_UNUSED, *dest);
+		if (note)
+		  remove_note (insn, note);
 		replace_reg (dest, FIRST_STACK_REG + 1);
 	      }
 	    else
diff -Naur gcc-4.4.0.orig/gcc/resource.c gcc-4.4.0/gcc/resource.c
--- gcc-4.4.0.orig/gcc/resource.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/resource.c	2009-05-21 16:17:37.000000000 -0700
@@ -135,8 +135,6 @@
 static int
 find_basic_block (rtx insn, int search_limit)
 {
-  basic_block bb;
-
   /* Scan backwards to the previous BARRIER.  Then see if we can find a
      label that starts a basic block.  Return the basic block number.  */
   for (insn = prev_nonnote_insn (insn);
@@ -157,11 +155,8 @@
   for (insn = next_nonnote_insn (insn);
        insn && LABEL_P (insn);
        insn = next_nonnote_insn (insn))
-    {
-      FOR_EACH_BB (bb)
-	if (insn == BB_HEAD (bb))
-	  return bb->index;
-    }
+    if (BLOCK_FOR_INSN (insn))
+      return BLOCK_FOR_INSN (insn)->index;
 
   return -1;
 }
@@ -848,13 +843,12 @@
    (with no intervening active insns) to see if any of them start a basic
    block.  If we hit the start of the function first, we use block 0.
 
-   Once we have found a basic block and a corresponding first insns, we can
-   accurately compute the live status from basic_block_live_regs and
-   reg_renumber.  (By starting at a label following a BARRIER, we are immune
-   to actions taken by reload and jump.)  Then we scan all insns between
-   that point and our target.  For each CLOBBER (or for call-clobbered regs
-   when we pass a CALL_INSN), mark the appropriate registers are dead.  For
-   a SET, mark them as live.
+   Once we have found a basic block and a corresponding first insn, we can
+   accurately compute the live status (by starting at a label following a
+   BARRIER, we are immune to actions taken by reload and jump.)  Then we
+   scan all insns between that point and our target.  For each CLOBBER (or
+   for call-clobbered regs when we pass a CALL_INSN), mark the appropriate
+   registers are dead.  For a SET, mark them as live.
 
    We have to be careful when using REG_DEAD notes because they are not
    updated by such things as find_equiv_reg.  So keep track of registers
@@ -954,13 +948,10 @@
      TARGET.  Otherwise, we must assume everything is live.  */
   if (b != -1)
     {
-      regset regs_live = DF_LR_IN (BASIC_BLOCK (b));
+      regset regs_live = df_get_live_in (BASIC_BLOCK (b));
       rtx start_insn, stop_insn;
 
-      /* Compute hard regs live at start of block -- this is the real hard regs
-	 marked live, plus live pseudo regs that have been renumbered to
-	 hard regs.  */
-
+      /* Compute hard regs live at start of block.  */
       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
 
       /* Get starting and ending insn, handling the case where each might
@@ -1046,10 +1037,24 @@
 
 	  else if (LABEL_P (real_insn))
 	    {
+	      basic_block bb;
+
 	      /* A label clobbers the pending dead registers since neither
 		 reload nor jump will propagate a value across a label.  */
 	      AND_COMPL_HARD_REG_SET (current_live_regs, pending_dead_regs);
 	      CLEAR_HARD_REG_SET (pending_dead_regs);
+
+	      /* We must conservatively assume that all registers that used
+		 to be live here still are.  The fallthrough edge may have
+		 left a live register uninitialized.  */
+	      bb = BLOCK_FOR_INSN (real_insn);
+	      if (bb)
+		{
+		  HARD_REG_SET extra_live;
+
+		  REG_SET_TO_HARD_REG_SET (extra_live, df_get_live_in (bb));
+		  IOR_HARD_REG_SET (current_live_regs, extra_live);
+		}
 	    }
 
 	  /* The beginning of the epilogue corresponds to the end of the
@@ -1121,6 +1126,7 @@
 init_resource_info (rtx epilogue_insn)
 {
   int i;
+  basic_block bb;
 
   /* Indicate what resources are required to be valid at the end of the current
      function.  The condition code never is and memory always is.  If the
@@ -1189,6 +1195,11 @@
   /* Allocate and initialize the tables used by mark_target_live_regs.  */
   target_hash_table = XCNEWVEC (struct target_info *, TARGET_HASH_PRIME);
   bb_ticks = XCNEWVEC (int, last_basic_block);
+
+  /* Set the BLOCK_FOR_INSN of each label that starts a basic block.  */
+  FOR_EACH_BB (bb)
+    if (LABEL_P (BB_HEAD (bb)))
+      BLOCK_FOR_INSN (BB_HEAD (bb)) = bb;
 }
 
 /* Free up the resources allocated to mark_target_live_regs ().  This
@@ -1197,6 +1208,8 @@
 void
 free_resource_info (void)
 {
+  basic_block bb;
+
   if (target_hash_table != NULL)
     {
       int i;
@@ -1222,6 +1235,10 @@
       free (bb_ticks);
       bb_ticks = NULL;
     }
+
+  FOR_EACH_BB (bb)
+    if (LABEL_P (BB_HEAD (bb)))
+      BLOCK_FOR_INSN (BB_HEAD (bb)) = NULL;
 }
 
 /* Clear any hashed information that we have stored for INSN.  */
diff -Naur gcc-4.4.0.orig/gcc/rtl.h gcc-4.4.0/gcc/rtl.h
--- gcc-4.4.0.orig/gcc/rtl.h	2009-03-18 10:04:26.000000000 -0700
+++ gcc-4.4.0/gcc/rtl.h	2009-04-27 04:55:13.000000000 -0700
@@ -2282,7 +2282,7 @@
 extern int true_dependence (const_rtx, enum machine_mode, const_rtx, bool (*)(const_rtx, bool));
 extern rtx get_addr (rtx);
 extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,
-				  bool (*)(const_rtx, bool));
+				  rtx, bool (*)(const_rtx, bool));
 extern int read_dependence (const_rtx, const_rtx);
 extern int anti_dependence (const_rtx, const_rtx);
 extern int output_dependence (const_rtx, const_rtx);
diff -Naur gcc-4.4.0.orig/gcc/stmt.c gcc-4.4.0/gcc/stmt.c
--- gcc-4.4.0.orig/gcc/stmt.c	2009-02-27 11:49:42.000000000 -0800
+++ gcc-4.4.0/gcc/stmt.c	2009-04-26 11:53:41.000000000 -0700
@@ -1418,6 +1418,7 @@
       goto restart;
 
     case SAVE_EXPR:
+    case NON_LVALUE_EXPR:
       exp = TREE_OPERAND (exp, 0);
       goto restart;
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20000211-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20000211-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20000211-1.c	2000-02-11 11:36:25.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20000211-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef long unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef unsigned char Bufbyte;
 typedef int Bytecount;
 typedef int Charcount;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20010328-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20010328-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20010328-1.c	2001-03-28 09:46:52.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20010328-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef unsigned int __u_int;
 typedef unsigned long __u_long;
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20030320-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20030320-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20030320-1.c	2003-03-20 16:13:41.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20030320-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -2,7 +2,7 @@
    conditional returns without updating dominance info.
    Extracted from glibc's dl-load.c.  */
 
-typedef unsigned long size_t;
+typedef __SIZE_TYPE__ size_t;
 
 static size_t
 is_dst (const char *start, const char *name, const char *str,
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20030405-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20030405-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20030405-1.c	2004-05-12 23:41:07.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20030405-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -6,7 +6,7 @@
    and when the PHI node at the end of the while() is visited the first
    time, CCP will try to assign it a value of UNDEFINED, but the default
    value for *str is a constant.  */
-typedef	unsigned int size_t;
+typedef	__SIZE_TYPE__ size_t;
 size_t strlength (const char * const);
 char foo();
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20030902-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20030902-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20030902-1.c	2004-05-12 23:41:07.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20030902-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef unsigned long int reg_syntax_t;
 struct re_pattern_buffer
 {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20060202-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20060202-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20060202-1.c	2006-02-02 16:24:50.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20060202-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef const struct objc_selector
 {
   void *sel_id;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20080613-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20080613-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20080613-1.c	2008-06-13 03:20:57.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20080613-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,7 +1,7 @@
 /* PR middle-end/36520 */
 /* Testcase by Richard Guenther <rguenth@gcc.gnu.org> */
 
-typedef long unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef unsigned short int sa_family_t;
 struct cmsghdr   {
     size_t cmsg_len;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20090519-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20090519-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/20090519-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/20090519-1.c	2009-05-19 04:54:16.000000000 -0700
@@ -0,0 +1,11 @@
+typedef struct { int licensed;  } __pmPDUInfo;
+void __pmDecodeXtendError (int *);
+void do_handshake(void)
+{
+  __pmPDUInfo *pduinfo;
+  int challenge;
+  __pmDecodeXtendError(&challenge);
+  pduinfo = (__pmPDUInfo *)&challenge;
+  *pduinfo = *pduinfo;
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/920428-2.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/920428-2.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/920428-2.c	1998-12-16 14:24:51.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/920428-2.c	2009-05-28 02:19:37.000000000 -0700
@@ -41,7 +41,7 @@
  short _flag;
  char _file;
 } _iob[];
-typedef unsigned long size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef char *va_list;
 struct _iobuf *fopen(const char *filename, const char *type);
 struct _iobuf *freopen(const char *filename, const char *type, struct _iobuf *stream);
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/980329-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/980329-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/980329-1.c	1998-12-16 14:24:51.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/980329-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned long int size_t;
+typedef __SIZE_TYPE__ size_t;
 struct re_pattern_buffer
   {
     unsigned char *buffer;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/980816-1.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/980816-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/980816-1.c	1998-12-16 14:24:51.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/980816-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef void *XtPointer;
 
 typedef struct _WidgetRec *Widget;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr32584.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr32584.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr32584.c	2007-07-02 11:27:46.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr32584.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,5 +1,8 @@
-typedef long unsigned int size_t;
-typedef long int __ssize_t;
+typedef __SIZE_TYPE__ size_t;
+/* Kludge */
+#define unsigned
+typedef __SIZE_TYPE__ __ssize_t;
+#undef unsigned
 typedef struct
 {
 } __mbstate_t;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr33173.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr33173.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr33173.c	2007-08-27 07:18:36.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr33173.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef long unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef struct
 {
 }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr33382.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr33382.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr33382.c	2007-09-12 01:07:12.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr33382.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef struct {
     int disable;
     char *searchconfig[];
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr34334.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr34334.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr34334.c	2007-12-04 09:20:34.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr34334.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 __extension__ typedef long long int __quad_t;
 __extension__ typedef unsigned int __mode_t;
 __extension__ typedef __quad_t __off64_t;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr34688.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr34688.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr34688.c	2008-01-26 15:08:54.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr34688.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
          typedef struct {
         }
          HashTable;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr35043.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr35043.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr35043.c	2008-02-04 05:30:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr35043.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,4 +1,4 @@
-typedef long unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef struct   {
       long double dat[2];
 } gsl_complex_long_double;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr37669.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr37669.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr37669.c	2008-09-29 14:23:52.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr37669.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,6 +1,6 @@
 /* This testcase used to fail because a miscompiled execute_fold_all_builtins. */
 
-typedef long unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 extern __inline __attribute__ ((__always_inline__)) int __attribute__
 ((__nothrow__)) snprintf (char *__restrict __s, size_t __n, __const char
 *__restrict __fmt, ...)  {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39824.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39824.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39824.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39824.c	2009-04-22 12:55:24.000000000 -0700
@@ -0,0 +1,26 @@
+static const double internalEndianMagic = 7.949928895127363e-275;
+static const unsigned char ieee_754_mantissa_mask[] = { 0x00, 0x0F, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF };
+static inline int 
+trio_isnan (double number)
+{
+  int has_mantissa = 0;
+  unsigned int i;
+  unsigned char current;
+  for (i = 0; i < (unsigned int)sizeof(double); i++)
+    {
+      current = ((unsigned char *)&number)[(((unsigned char
+					      *)&internalEndianMagic)[7-(i)])];
+      has_mantissa |= (current & ieee_754_mantissa_mask[i]);
+    }
+  return has_mantissa;
+}
+void
+xmlXPathEqualNodeSetFloat(int nodeNr, double v)
+{
+  int i;
+  for (i=0; i<nodeNr; i++)
+    if (!trio_isnan(v))
+      break;
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39845.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39845.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39845.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39845.c	2009-04-22 07:14:08.000000000 -0700
@@ -0,0 +1,43 @@
+typedef union tree_node *tree;
+enum tree_code { EXCESS_PRECISION_EXPR };
+enum built_in_function { BUILT_IN_ACOS, BUILT_IN_FPCLASSIFY, BUILT_IN_ISFINITE };
+struct tree_base {
+    __extension__ enum tree_code code : 16;
+    unsigned side_effects_flag : 1;
+};
+struct tree_exp {
+    tree     operands[1];
+};
+struct tree_function_decl {
+    __extension__ enum built_in_function function_code : 11;
+    unsigned static_ctor_flag : 1;
+};
+union tree_node {
+    struct tree_base base;
+    struct tree_function_decl function_decl;
+    struct tree_exp exp;
+};
+static tree
+convert_arguments (tree fundecl)
+{
+  tree val = (void *)0;
+  unsigned int parmnum;
+  unsigned char type_generic_remove_excess_precision = 0;
+  switch (((fundecl)->function_decl.function_code))
+    {
+      case BUILT_IN_ISFINITE:
+      case BUILT_IN_FPCLASSIFY:
+	  type_generic_remove_excess_precision = 1;
+    }
+  for (parmnum = 0;; ++parmnum)
+    if (((enum tree_code) (val)->base.code) == EXCESS_PRECISION_EXPR
+	&& !type_generic_remove_excess_precision)
+      val = ((val)->exp.operands[0]);
+  return val;
+}
+tree
+build_function_call_vec (tree function)
+{
+  return convert_arguments (function);
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39937.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39937.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39937.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39937.c	2009-04-29 08:54:18.000000000 -0700
@@ -0,0 +1,12 @@
+int foo (__const char *__restrict __s);
+static void 
+read_anisou(char line[])
+{
+  foo (line+1);
+}
+void
+read_pdbfile(void)
+{
+  char line[4096];
+  read_anisou (line);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39941.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39941.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39941.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39941.c	2009-04-29 07:54:54.000000000 -0700
@@ -0,0 +1,12 @@
+typedef void (*entry_func) (void) __attribute__ ((noreturn));
+extern entry_func entry_addr;
+static void bsd_boot_entry (void)
+{
+  stop ();
+}   
+void bsd_boot (void)
+{
+  entry_addr = (entry_func) bsd_boot_entry;
+  (*entry_addr) ();
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39983.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39983.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39983.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39983.c	2009-05-06 10:45:40.000000000 -0700
@@ -0,0 +1,17 @@
+typedef struct {
+    int *p;
+} *A;
+
+extern const int a[1];
+extern const int b[1];
+
+void foo()
+{
+  A x;
+  A y;
+  static const int * const c[] = { b };
+
+  x->p = (int*)c[0];
+  y->p = (int*)a;
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39999.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39999.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr39999.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr39999.c	2009-05-18 03:13:43.000000000 -0700
@@ -0,0 +1,18 @@
+void foo(void *);
+void
+MMAPGCD (int *A1, int *A2)
+{
+  int *t;
+
+  do
+    {
+      t = A1;
+      A1 = A2;
+      A2 = t;
+    }
+  while (A2[-1]);
+
+  foo (A1-1);
+  foo (A2-1);
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40023.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40023.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40023.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40023.c	2009-05-06 10:45:40.000000000 -0700
@@ -0,0 +1,11 @@
+typedef __builtin_va_list va_list;
+typedef struct {
+    va_list ap;
+} ScanfState;
+void
+GetInt(ScanfState *state, long llval)
+{
+  *__builtin_va_arg(state->ap,long *) = llval;
+  __builtin_va_end(state->ap);
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40026.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40026.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40026.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40026.c	2009-05-11 09:49:17.000000000 -0700
@@ -0,0 +1,15 @@
+typedef struct {
+    unsigned long bits;
+} S;
+struct T {
+    S span;
+    int flags;
+};
+
+struct T f(int x)
+{
+  return (struct T) {
+      .span = (S) { 0UL },
+      .flags = (x ? 256 : 0),
+  };
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40035.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40035.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40035.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40035.c	2009-05-13 14:42:03.000000000 -0700
@@ -0,0 +1,20 @@
+typedef __SIZE_TYPE__ size_t;
+void *memmove (void *dest, const void *src, size_t count);
+size_t strlen (const char *s);
+
+int
+foo (char *param, char *val)
+{
+  if (val)
+    {
+      if (val == param + strlen (param) + 1)
+        val[-1] = '=';
+      else if (val == param + strlen (param) + 2)
+        {
+          val[-2] = '=';
+          memmove (val - 1, val, strlen (val) + 1);
+          val--;
+        }
+    }
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40080.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40080.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40080.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40080.c	2009-05-11 09:49:17.000000000 -0700
@@ -0,0 +1,44 @@
+extern void *ff(void*,int);
+
+struct lpgl { struct lpgl *next; };
+struct lpgd { struct lpgl *first; };
+
+typedef int (*xfn)( );
+static void xDP_IF_EnumGroupsInGroup ( void *a, int b, xfn fn)
+{
+  struct lpgd *lpGData;
+  struct lpgl *lpGList;
+
+  if( ( lpGData = ff( a, b ) ) == ((void *)0) )
+    return;
+
+  if( lpGData->first  == ((void *)0) )
+    return;
+  lpGList = lpGData->first;
+
+  for( ;; ) {
+    if( !(*fn)( ) )
+      return;
+    if( lpGList->next == ((void *)0) )
+      break;
+    lpGList = lpGList->next;
+  }
+  return;
+}
+
+
+static int 
+xcbDeletePlayerFromAllGroups() {
+  xDP_IF_EnumGroupsInGroup(0, 0, 0);
+  return 1;
+}
+
+void xDP_IF_EnumGroups( xfn fn) {
+  xDP_IF_EnumGroupsInGroup( 0, 0, fn);
+}
+
+static void xDP_IF_DestroyPlayer () {
+  xDP_IF_EnumGroups( xcbDeletePlayerFromAllGroups);
+}
+
+void* foo=xDP_IF_DestroyPlayer;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40204.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40204.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40204.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40204.c	2009-05-20 14:11:10.000000000 -0700
@@ -0,0 +1,14 @@
+/* PR middle-end/40204 */
+
+struct S
+{
+  unsigned int a : 4;
+  unsigned int b : 28;
+} s;
+char c;
+
+void
+f (void)
+{
+  s.a = (c >> 4) & ~(1 << 4);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40233.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40233.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40233.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40233.c	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,10 @@
+typedef int aligned __attribute__((aligned(64)));
+struct Frame {
+  aligned i;
+};
+
+void foo(struct Frame *p)
+{
+  aligned *q = &p->i;
+  *q = 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40252.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40252.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40252.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40252.c	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,6 @@
+typedef unsigned int uint32_t;
+static void IP(uint32_t v[2])
+{
+    v[0] = ((v[0] << 1) | ((v[0] >> 31) & 1L)) & 0xffffffffL;
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40291.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40291.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/compile/pr40291.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/compile/pr40291.c	2009-05-29 08:47:31.000000000 -0700
@@ -0,0 +1,7 @@
+/* PR middle-end/40291 */
+
+int
+foo (void *x, char *y, unsigned long long z)
+{
+  return memcmp (x, y, z);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/execute/pr40022.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/execute/pr40022.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/execute/pr40022.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/execute/pr40022.c	2009-05-06 01:32:24.000000000 -0700
@@ -0,0 +1,51 @@
+extern void abort (void);
+
+struct A
+{
+  struct A *a;
+};
+
+struct B
+{
+  struct A *b;
+};
+
+__attribute__((noinline))
+struct A *
+foo (struct A *x)
+{
+  asm volatile ("" : : "g" (x) : "memory");
+  return x;
+}
+
+__attribute__((noinline))
+void
+bar (struct B *w, struct A *x, struct A *y, struct A *z)
+{
+  struct A **c;
+  c = &w->b;
+  *c = foo (x);
+  while (*c)
+    c = &(*c)->a;
+  *c = foo (y);
+  while (*c)
+    c = &(*c)->a;
+  *c = foo (z);
+}
+
+struct B d;
+struct A e, f, g;
+
+int
+main (void)
+{
+  f.a = &g;
+  bar (&d, &e, &f, 0);
+  if (d.b == 0
+      || d.b->a == 0
+      || d.b->a->a == 0
+      || d.b->a->a->a != 0)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/execute/pr40057.c gcc-4.4.0/gcc/testsuite/gcc.c-torture/execute/pr40057.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.c-torture/execute/pr40057.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.c-torture/execute/pr40057.c	2009-05-07 08:36:23.000000000 -0700
@@ -0,0 +1,37 @@
+/* PR middle-end/40057 */
+
+extern void abort (void);
+
+__attribute__((noinline)) int
+foo (unsigned long long x)
+{
+  unsigned long long y = (x >> 31ULL) & 1ULL;
+  if (y == 0ULL)
+    return 0;
+  return -1;
+}
+
+__attribute__((noinline)) int
+bar (long long x)
+{
+  long long y = (x >> 31LL) & 1LL;
+  if (y == 0LL)
+    return 0;
+  return -1;
+}
+
+int
+main (void)
+{
+  if (sizeof (long long) != 8)
+    return 0;
+  if (foo (0x1682a9aaaULL))
+    abort ();
+  if (!foo (0x1882a9aaaULL))
+    abort ();
+  if (bar (0x1682a9aaaLL))
+    abort ();
+  if (!bar (0x1882a9aaaLL))
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/20050629-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/20050629-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/20050629-1.c	2005-06-29 17:51:17.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/20050629-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -5,7 +5,7 @@
    contains many warnings, but it exposes a copy propagation bug that
    is somewhat difficult to reproduce otherwise.  */
 
-typedef long unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
   extern void fancy_abort (const char *, int, const char *) __attribute__ ((__noreturn__));
   typedef union tree_node *tree;
   enum tree_code {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/dfp/pr39986.c gcc-4.4.0/gcc/testsuite/gcc.dg/dfp/pr39986.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/dfp/pr39986.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/dfp/pr39986.c	2009-05-06 10:14:00.000000000 -0700
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+/* Check that the compiler generates the correct decimal float constants.  */
+
+_Decimal32 a = 100.223df;
+_Decimal32 b = -2.3df;
+_Decimal64 c = 3.4e-4dd;
+_Decimal64 d = -4.500dd;
+_Decimal128 e = 5678901234567.89e+200dl;
+_Decimal128 f = -678901.234e-6dl;
+
+/* The first value is DPD, the second is BID.  The order differs depending
+   on whether the target is big-endian or little-endian.  */
+
+/* { dg-final { scan-assembler ".long\t(572653859|822183807)\n" } } */
+
+/* { dg-final { scan-assembler ".long\t(-1572863965|-1308622825)\n" } } */
+
+/* { dg-final { scan-assembler ".long\t(52|34)\n" } } */
+/* { dg-final { scan-assembler ".long\t(572784640|824180736)\n" } } */
+
+/* { dg-final { scan-assembler ".long\t(4736|4500)\n" } } */
+/* { dg-final { scan-assembler ".long\t(-1574174720|-1319108608)\n" } } */
+
+/* { dg-final { scan-assembler ".long\t(-1975952433|957645077)\n" } } */
+/* { dg-final { scan-assembler ".long\t(190215|132222)\n" } } */
+/* { dg-final { scan-assembler ".long\t(574193664|835452928)\n" } } */
+
+/* { dg-final { scan-assembler ".long\t(931280180|678901234)\n" } } */
+/* { dg-final { scan-assembler ".long\t(-1576681472|-1339162624)\n" } } */
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr33667.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr33667.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr33667.c	2007-10-05 10:56:52.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr33667.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2" } */
 
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 typedef unsigned char uint8_t;
 typedef unsigned short int uint16_t;
 typedef unsigned long long int uint64_t;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39565.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr39565.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39565.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr39565.c	2009-04-29 07:54:54.000000000 -0700
@@ -0,0 +1,48 @@
+/* PR39565: Static variable leaves undefined symbol in object file.
+   Variables codestrs_4 and codestrs_8 should not be undefined,
+   when this program is compiled at -O2. As a basic sanity test,
+   verify that this program compiles into an executable and runs. */
+
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+extern void exit (int);
+extern int strcmp (const char *, const char *);
+
+static const union codestrs_t_4 {
+  struct {
+    char str_2[sizeof ("Illegal opcode")];
+  };
+  char str[0];
+} codestrs_4 = { {"Illegal opcode"} };
+
+static const union codestrs_t_8 {
+  struct {
+    char str_12[sizeof ("Integer divide by zero")];
+  };
+  char str[0];
+} codestrs_8 = { {"Integer divide by zero"} };
+
+const char *
+psiginfo (int pinfo)
+{
+  const char *base = ((void *)0);
+
+  switch (pinfo)
+    {
+    case 4: base = codestrs_4.str; break;
+    case 8: base = codestrs_8.str; break;
+    }
+  return base;
+}
+
+int
+main (void)
+{
+  if (strcmp (psiginfo (4), codestrs_4.str))
+    abort ();
+  if (strcmp (psiginfo (8), codestrs_8.str))
+    abort ();
+  exit (0);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39666-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr39666-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39666-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr39666-1.c	2009-05-12 09:19:29.000000000 -0700
@@ -0,0 +1,22 @@
+/* PR middle-end/39666 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int
+foo (int i)
+{
+  int j;
+  switch (i)
+    {
+    case -__INT_MAX__ - 1 ... -1:
+      j = 6;
+      break;
+    case 0:
+      j = 5;
+      break;
+    case 1 ... __INT_MAX__:
+      j = 4;
+      break;
+    }
+  return j;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39666-2.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr39666-2.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39666-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr39666-2.c	2009-05-12 09:19:29.000000000 -0700
@@ -0,0 +1,22 @@
+/* PR middle-end/39666 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int
+foo (int i)
+{
+  int j;	/* { dg-warning "may be used uninitialized" } */
+  switch (i)
+    {
+    case -__INT_MAX__ - 1 ... -1:
+      j = 6;
+      break;
+    case 0:
+      j = 5;
+      break;
+    case 2 ... __INT_MAX__:
+      j = 4;
+      break;
+    }
+  return j;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39794.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr39794.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39794.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr39794.c	2009-04-27 04:55:13.000000000 -0700
@@ -0,0 +1,33 @@
+/* PR rtl-optimization/39794 */
+/* { dg-do run } */
+/* { dg-options "-O2 -funroll-loops" } */
+
+extern void abort ();
+
+void
+foo (int *a, int n)
+{
+  int i;
+  for (i = 0; i < n; i++)
+    {
+      a[i] *= 2;
+      a[i + 1] = a[i - 1] + a[i - 2];
+    }
+}
+
+int a[16];
+int ref[16] = { 0, 1, 4, 2, 10, 12, 24, 44,
+		72, 136, 232, 416, 736, 1296, 2304, 2032 };
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 16; i++)
+    a[i] = i;
+  foo (a + 2, 16 - 3);
+  for (i = 0; i < 16; i++)
+    if (ref[i] != a[i])
+      abort ();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39867.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr39867.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr39867.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr39867.c	2009-04-24 04:34:59.000000000 -0700
@@ -0,0 +1,12 @@
+/* { dg-do link } */
+/* { dg-options "-O2" } */
+
+int main (void)
+{
+  int exp = -1;
+  /* Wrong folding of the LHS to an unsigned MAX leads to 4294967295 != 2.  */
+  if ((exp < 2 ? 2U : (unsigned int) exp) != 2)
+    link_error ();
+  return 0;
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr40172-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr40172-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr40172-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr40172-1.c	2009-05-19 14:24:23.000000000 -0700
@@ -0,0 +1,31 @@
+/* PR middle-end/40172 */
+/* { dg-do compile } */
+/* { dg-options "-Wall -W -Werror -Wlogical-op" } */
+
+struct rtx_def;
+typedef struct rtx_def *rtx; 
+
+extern int foo;
+extern int bar;
+extern int xxx;
+
+int
+test (void)
+{
+  if (((rtx) 0 != (rtx) 0) && xxx ? foo : bar)
+    return 1;
+  else if ((foo & 0) && xxx)
+    return 2;
+  else if (foo & 0)
+    return 3;
+  else if (0 && xxx)
+    return 4;
+  else if (0)
+    return 5;
+  if (((int) 0 != (int) 0) && bar ? foo : xxx)
+    return 6;
+  else if (0 != 0 && foo ? xxx : bar)
+    return 7;
+  else
+    return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr40172-2.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr40172-2.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr40172-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr40172-2.c	2009-05-19 14:24:23.000000000 -0700
@@ -0,0 +1,16 @@
+/* PR middle-end/40172 */
+/* { dg-do compile } */
+/* { dg-options "-Wall -W -Werror" } */
+
+extern int xxx;
+
+#define XXX xxx
+
+int
+test (void)
+{
+  if (!XXX && xxx)
+    return 4;
+  else
+    return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr40172-3.c gcc-4.4.0/gcc/testsuite/gcc.dg/pr40172-3.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/pr40172-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/pr40172-3.c	2009-05-19 14:24:23.000000000 -0700
@@ -0,0 +1,16 @@
+/* PR middle-end/40172 */
+/* { dg-do compile */
+/* { dg-options "-Wall -W -Werror -Wlogical-op" } */
+
+extern int xxx;
+
+#define XXX xxx
+
+int
+test (void)
+{
+  if (!XXX && xxx)
+    return 4;
+  else
+    return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/prefetch-loop-arrays-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/prefetch-loop-arrays-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/prefetch-loop-arrays-1.c	2006-09-17 18:54:33.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/prefetch-loop-arrays-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -3,7 +3,7 @@
 /* { dg-options "-O2 -fprefetch-loop-arrays -w" } */
 /* { dg-options "-O2 -fprefetch-loop-arrays -march=i686 -msse -w" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */
 
-typedef unsigned long size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 
 struct re_pattern_buffer
 {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tls/alias-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/tls/alias-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tls/alias-1.c	2007-09-18 19:35:29.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tls/alias-1.c	2009-04-28 13:57:42.000000000 -0700
@@ -1,7 +1,7 @@
 /* { dg-do link } */
 /* { dg-require-alias "" } */
 /* { dg-require-visibility "" } */
-/* { dg-require-effective-target tls } */
+/* { dg-require-effective-target tls_runtime } */
 /* Test that encode_section_info handles the change from externally
    defined to locally defined (via hidden).   Extracted from glibc.  */
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tls/opt-2.c gcc-4.4.0/gcc/testsuite/gcc.dg/tls/opt-2.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tls/opt-2.c	2007-09-18 19:35:29.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tls/opt-2.c	2009-04-28 13:57:42.000000000 -0700
@@ -6,6 +6,7 @@
 /* { dg-options "-O2 -ftls-model=initial-exec" } */
 /* { dg-options "-O2 -ftls-model=initial-exec -march=i686" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */
 /* { dg-require-effective-target tls_native } */
+/* { dg-require-effective-target tls_runtime  } */
 
 __thread int thr;
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39204.c gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39204.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39204.c	2009-02-17 07:01:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39204.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-w" } */
 
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 typedef unsigned char __u_char;
 typedef unsigned short int __u_short;
 typedef unsigned int __u_int;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39829.c gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39829.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39829.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39829.c	2009-04-22 07:14:08.000000000 -0700
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-w" } */
+
+void foo (void * DAG_temp117584)
+{
+  char  uA;
+  void* pA;
+  void* pB;
+  void* pC;
+  do {
+      int DAG_temp117585;
+      int DAG_temp117586;
+      void ** __indir_union1 = (void**)DAG_temp117584;
+      DAG_temp117585 = (long)*__indir_union1;
+      DAG_temp117586 = DAG_temp117585;
+      if ( DAG_temp117586 != (int)268435456 )
+	pA = (void*)&uA;
+      pB = (void*)&pA;
+      pC = pB;
+      union __block_indir0_u {  struct {  long val; }  __indir_struct; }
+      * __indir_union = (union __block_indir0_u*)pC;
+      f(__indir_union->__indir_struct.val);
+
+      DAG_temp117584 += 64;
+  } while (1);
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39855.c gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39855.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39855.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39855.c	2009-04-22 15:02:54.000000000 -0700
@@ -0,0 +1,24 @@
+/* PR c/39855 */
+/* { dg-do run { target { int32plus } } } */
+
+extern void abort (void);
+
+int i, j, k;
+
+int
+foo (void)
+{
+  return ++i;
+}
+
+int
+main ()
+{
+  if (__CHAR_BIT__ != 8 || sizeof (int) != 4)
+    return 0;
+  j = foo () << 30 << 2;
+  k = (unsigned) foo () >> 16 >> 16;
+  if (i != 2 || j != 0 || k != 0)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39903-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39903-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39903-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39903-1.c	2009-04-28 07:35:12.000000000 -0700
@@ -0,0 +1,24 @@
+/* PR target/39903 */
+/* { dg-do run } */
+/* { dg-options "-Wno-psabi" } */
+
+struct X {
+  double d;
+  double b[];
+};
+
+struct X __attribute__((noinline))
+foo (double d)
+{
+  struct X x;
+  x.d = d;
+  return x;
+}
+extern void abort (void);
+int main()
+{
+  struct X x = foo(3.0);
+  if (x.d != 3.0)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39903-2.c gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39903-2.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/torture/pr39903-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/torture/pr39903-2.c	2009-04-28 07:35:12.000000000 -0700
@@ -0,0 +1,24 @@
+/* PR target/39903 */
+/* { dg-do run } */
+/* { dg-options "-Wno-psabi" } */
+
+struct X {
+  float d;
+  float b[];
+};
+
+struct X __attribute__((noinline))
+foo (float d)
+{
+  struct X x;
+  x.d = d;
+  return x;
+}
+extern void abort (void);
+int main()
+{
+  struct X x = foo(3.0);
+  if (x.d != 3.0)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c	2008-08-20 05:59:10.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c	2009-05-28 02:19:37.000000000 -0700
@@ -2,7 +2,7 @@
 /* { dg-options "-O1 -fdump-tree-dom2" } */
 
 
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 extern void *xmalloc (size_t) __attribute__ ((__malloc__));
 struct edge_def
 {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/pr36908.c gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/pr36908.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/pr36908.c	2008-11-03 08:35:13.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/pr36908.c	2009-05-28 02:19:37.000000000 -0700
@@ -2,7 +2,7 @@
 /* { dg-options "-O2 -ftree-loop-distribution" } */
 #define NULL ((void *)0)
 
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 extern void *foo(size_t nelem, size_t elsize);
 extern void bar (char*, ...);
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/pr38250.c gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/pr38250.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/pr38250.c	2008-12-03 05:43:12.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/pr38250.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -ftree-loop-distribution" } */
 
-typedef long unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 typedef struct   {
           long dat[2];
 } gsl_complex_long_double;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/pr40087.c gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/pr40087.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/pr40087.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/pr40087.c	2009-05-22 13:43:39.000000000 -0700
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+/* { dg-options "-O1 " } */
+
+extern void abort (void);
+
+static void __attribute__((always_inline))
+reverse(int *first, int *last)
+{
+  if (first == last--) 
+    return;
+  while (first != last)
+    {
+      int t = *first;
+      *first = *last;
+      *last = t;
+      if (++first == last--)
+        break;
+    }
+}
+
+int main()
+{
+  int seq[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
+
+  reverse(seq, seq + 8);
+  if (seq[3] != 5 || seq[4] != 4)
+    abort ();
+
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c	2007-08-16 13:28:43.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c	2009-05-28 02:19:37.000000000 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O -w -fdump-tree-dse-vops" } */
 
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 typedef struct _IO_FILE FILE;
 typedef struct
 {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vect/pr40074.c gcc-4.4.0/gcc/testsuite/gcc.dg/vect/pr40074.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vect/pr40074.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/vect/pr40074.c	2009-05-11 04:54:02.000000000 -0700
@@ -0,0 +1,54 @@
+/* { dg-require-effective-target vect_int } */
+
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 16 
+
+typedef struct {
+   int a;
+   int b;
+   int c;
+   int d;
+} s;
+
+
+s arr[N] = {{7,0,1,5}, {7,2,3,5}, {7,4,5,5}, {7,6,7,5}, {7,8,9,5}, {7,10,11,5}, {7,12,13,5}, {7,14,15,5}, {7,16,17,5}, {7,18,19,5}, {7,20,21,5}, {7,22,23,5}, {7,24,25,5}, {7,26,27,5}, {7,28,29,5}, {7,30,31,5}};
+
+__attribute__ ((noinline)) int
+main1 ()
+{
+  s *p = arr, *q = arr + 1;
+  int res[N];
+  int i;
+
+  for (i = 0; i < N-1; i++)
+    {
+      res[i] = p->b + p->d + q->b;
+      p++;
+      q++;
+    }
+  
+  /* check results:  */
+  for (i = 0; i < N-1; i++)
+    {
+      if (res[i] != arr[i].b + arr[i].d + arr[i+1].b)
+	abort ();
+    }
+
+  return 0;
+}
+
+int main (void)
+{
+  int i;
+  
+  check_vect ();
+
+  main1 ();
+
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+  
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vect/pr40238.c gcc-4.4.0/gcc/testsuite/gcc.dg/vect/pr40238.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vect/pr40238.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/vect/pr40238.c	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+
+extern int xdo_rb_ctr_row( int *pos_code);
+
+int xgp_ahd_interpolate (int tile)
+{
+ int p[4];
+
+ switch (tile) {
+ default:
+ case 0:
+ case 1:
+  p[0] = 0; p[1] = 1; p[2] = 2; p[3] = 3;
+  break;
+ case 2:
+ case 3:
+  p[0] = 1; p[1] = 0; p[2] = 3; p[3] = 2;
+  break;
+ case 4:
+ case 5:
+  p[0] = 3; p[1] = 2; p[2] = 1; p[3] = 0;
+  break;
+ case 6:
+ case 7:
+  p[0] = 2; p[1] = 3; p[2] = 0; p[3] = 1;
+  break;
+ }
+
+ xdo_rb_ctr_row(p);
+ xdo_rb_ctr_row(p);
+ return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vect/pr40254.c gcc-4.4.0/gcc/testsuite/gcc.dg/vect/pr40254.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vect/pr40254.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/vect/pr40254.c	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,39 @@
+#include <stdlib.h>
+#include <stdarg.h>
+#include "tree-vect.h"
+
+struct s
+{
+  int *x;
+  int x1;
+  int x2;
+  int x3;
+  int *y;
+};
+
+struct s arr[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
+
+__attribute__ ((noinline)) void
+foo (int i, int *in_x, int *in_y)
+{
+  arr[i].x = in_x;
+  arr[i].y = in_y;
+}
+
+int
+main (void)
+{
+  int a, b;
+
+  check_vect ();
+
+  foo (5, &a, &b);
+
+  if (arr[5].x != &a || arr[5].y != &b)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vmx/3a-04.c gcc-4.4.0/gcc/testsuite/gcc.dg/vmx/3a-04.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vmx/3a-04.c	2004-04-17 18:01:41.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/vmx/3a-04.c	2009-04-28 12:18:59.000000000 -0700
@@ -10,9 +10,13 @@
 
 static void test()
 {
-  check(vec_all_eq(f(((vector float){2,3,5,7}),
+  check(vec_all_gt(f(((vector float){2,3,5,7}),
 		     ((vector float){11,13,17,19}),
 		     ((vector float){23,29,31,37})),
-		   ((vector float){23.1818085, 29.2307587, 32.2940826, 128.368393})),
+		   ((vector float){23.18, 29.23, 32.29, 128.36}))
+	&& vec_all_lt(f(((vector float){2,3,5,7}),
+			((vector float){11,13,17,19}),
+			((vector float){23,29,31,37})),
+		      ((vector float){23.19, 29.24, 32.30, 128.37})),
 	"f");
 }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vmx/3a-04m.c gcc-4.4.0/gcc/testsuite/gcc.dg/vmx/3a-04m.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vmx/3a-04m.c	2004-04-17 18:01:41.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/vmx/3a-04m.c	2009-04-28 12:18:59.000000000 -0700
@@ -10,9 +10,13 @@
 
 static void test()
 {
-  check(vec_all_eq(f(((vector float){2,3,5,7}),
+  check(vec_all_gt(f(((vector float){2,3,5,7}),
 		     ((vector float){11,13,17,19}),
 		     ((vector float){23,29,31,37})),
-		   ((vector float){23.1818085, 29.2307587, 32.2940826, 128.368393})),
+		   ((vector float){23.18, 29.23, 32.29, 128.36}))
+	&& vec_all_lt(f(((vector float){2,3,5,7}),
+			((vector float){11,13,17,19}),
+			((vector float){23,29,31,37})),
+		      ((vector float){23.19, 29.24, 32.30, 128.37})),
 	"f");
 }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vmx/3a-05.c gcc-4.4.0/gcc/testsuite/gcc.dg/vmx/3a-05.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/vmx/3a-05.c	2004-04-17 18:01:41.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/vmx/3a-05.c	2009-04-28 12:18:59.000000000 -0700
@@ -14,9 +14,13 @@
 
 static void test()
 {
-  check(vec_all_eq(f(((vector float){2,3,5,7}),
+  check(vec_all_gt(f(((vector float){2,3,5,7}),
 		     ((vector float){11,13,17,19}),
 		     ((vector float){23,29,31,37})),
-		   ((vector float){16.9092026, 18.7693329, -2.8233242, -92.9472198})),
-		   "f");
+		   ((vector float){16.90, 18.76, -2.83, -92.95}))
+	&& vec_all_lt(f(((vector float){2,3,5,7}),
+		     ((vector float){11,13,17,19}),
+		     ((vector float){23,29,31,37})),
+		   ((vector float){16.91, 18.77, -2.82, -92.94})),
+	"f");
 }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.dg/Wunused-value-3.c gcc-4.4.0/gcc/testsuite/gcc.dg/Wunused-value-3.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.dg/Wunused-value-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.dg/Wunused-value-3.c	2009-04-26 11:53:41.000000000 -0700
@@ -0,0 +1,9 @@
+/* PR c/39889 */
+/* { dg-do compile } */
+/* { dg-options "-Wunused-value" } */
+
+int x;
+int foo (void)
+{
+  return (1 ? x = 0 : (void) 0), 0; /* { dg-bogus "value computed is not used" } */
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/i386/pr39543-1.c gcc-4.4.0/gcc/testsuite/gcc.target/i386/pr39543-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/i386/pr39543-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.target/i386/pr39543-1.c	2009-04-26 11:58:04.000000000 -0700
@@ -0,0 +1,52 @@
+/* PR inline-asm/39543 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fomit-frame-pointer" } */
+
+float __attribute__ ((aligned (16))) s0[128];
+const float s1 = 0.707;
+float s2[8] __attribute__ ((aligned (16)));
+float s3[8] __attribute__ ((aligned (16)));
+float s4[16] __attribute__ ((aligned (16)));
+float s5[16] __attribute__ ((aligned (16)));
+
+void
+foo (int k, float *x, float *y, const float *d, const float *z)
+{
+  float *a, *b, *c, *e;
+
+  a = x + 2 * k;
+  b = a + 2 * k;
+  c = b + 2 * k;
+  e = y + 2 * k;
+  __asm__ volatile (""
+		    : "=m" (x[0]), "=m" (b[0]), "=m" (a[0]), "=m" (c[0])
+		    : "m" (y[0]), "m" (y[k * 2]), "m" (x[0]), "m" (a[0])
+		    : "memory");
+  for (;;)
+    {
+      __asm__ volatile (""
+			:
+			: "m" (y[2]), "m" (d[2]), "m" (e[2]), "m" (z[2])
+			: "memory");
+      if (!--k)
+	break;
+    }
+  __asm__ volatile (""
+		    : "=m" (x[2]), "=m" (x[10]), "=m" (x[6]), "=m" (x[14])
+		    : "m" (y[2]), "m" (y[6]), "m" (x[2]), "m" (x[6]),
+		      "m" (y[18]), "m" (s1)
+		    : "memory");
+}
+
+void
+bar (float *a)
+{
+  foo (4, a, a + 16, s2, s3);
+  foo (8, a, a + 32, s4, s5);
+}
+
+void
+baz (void)
+{
+  bar (s0);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/i386/pr39543-2.c gcc-4.4.0/gcc/testsuite/gcc.target/i386/pr39543-2.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/i386/pr39543-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.target/i386/pr39543-2.c	2009-05-13 13:24:52.000000000 -0700
@@ -0,0 +1,52 @@
+/* PR inline-asm/39543 */
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+/* { dg-skip-if "" { ilp32 && { ! nonpic } } { "*" } { "" } } */
+
+float __attribute__ ((aligned (16))) s0[128];
+const float s1 = 0.707;
+float s2[8] __attribute__ ((aligned (16)));
+float s3[8] __attribute__ ((aligned (16)));
+float s4[16] __attribute__ ((aligned (16)));
+float s5[16] __attribute__ ((aligned (16)));
+
+void
+foo (int k, float *x, float *y, const float *d, const float *z)
+{
+  float *a, *b, *c, *e;
+
+  a = x + 2 * k;
+  b = a + 2 * k;
+  c = b + 2 * k;
+  e = y + 2 * k;
+  __asm__ volatile (""
+		    : "=m" (x[0]), "=m" (b[0]), "=m" (a[0]), "=m" (c[0])
+		    : "m" (y[0]), "m" (y[k * 2]), "m" (x[0]), "m" (a[0])
+		    : "memory");
+  for (;;)
+    {
+      __asm__ volatile (""
+			:
+			: "m" (y[2]), "m" (d[2]), "m" (e[2]), "m" (z[2])
+			: "memory");
+      if (!--k)
+	break;
+    }
+  __asm__ volatile (""
+		    : "=m" (x[2]), "=m" (x[10]), "=m" (x[6]), "=m" (x[14])
+		    : "m" (y[2]), "m" (y[6]), "m" (x[2]), "m" (x[6]), "m" (s1)
+		    : "memory");
+}
+
+void
+bar (float *a)
+{
+  foo (4, a, a + 16, s2, s3);
+  foo (8, a, a + 32, s4, s5);
+}
+
+void
+baz (void)
+{
+  bar (s0);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/i386/pr39543-3.c gcc-4.4.0/gcc/testsuite/gcc.target/i386/pr39543-3.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/i386/pr39543-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.target/i386/pr39543-3.c	2009-04-26 11:58:04.000000000 -0700
@@ -0,0 +1,42 @@
+/* PR inline-asm/39543 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int s[128];
+
+void
+f1 (void)
+{
+  int i;
+  asm volatile ("# %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12 %13 %14 %15 %16 %17"
+		: "=r" (i)
+		: "m" (s[0]), "m" (s[2]), "m" (s[4]), "m" (s[6]), "m" (s[8]),
+		  "m" (s[10]), "m" (s[12]), "m" (s[14]), "m" (s[16]), "m" (s[18]),
+		  "m" (s[20]), "m" (s[22]), "m" (s[24]), "m" (s[26]), "m" (s[28]),
+		  "m" (s[30]), "m" (s[32]));
+  asm volatile ("# %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12 %13 %14 %15 %16 %17"
+		: "=r" (i)
+		: "m" (s[0]), "m" (s[2]), "m" (s[4]), "m" (s[6]), "m" (s[8]),
+		  "m" (s[10]), "m" (s[12]), "m" (s[14]), "m" (s[16]), "m" (s[18]),
+		  "m" (s[20]), "m" (s[22]), "m" (s[24]), "m" (s[26]), "m" (s[28]),
+		  "m" (s[30]), "m" (s[32]));
+}
+
+void
+f2 (int *q)
+{
+  int i;
+  int *p = q + 32;
+  asm volatile ("# %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12 %13 %14 %15 %16 %17"
+		: "=r" (i)
+		: "m" (p[0]), "m" (p[2]), "m" (p[4]), "m" (p[6]), "m" (p[8]),
+		  "m" (p[10]), "m" (p[12]), "m" (p[14]), "m" (p[16]), "m" (p[18]),
+		  "m" (p[20]), "m" (p[22]), "m" (p[24]), "m" (p[26]), "m" (p[28]),
+		  "m" (p[30]), "m" (p[32]));
+  asm volatile ("# %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12 %13 %14 %15 %16 %17"
+		: "=r" (i)
+		: "m" (p[0]), "m" (p[2]), "m" (p[4]), "m" (p[6]), "m" (p[8]),
+		  "m" (p[10]), "m" (p[12]), "m" (p[14]), "m" (p[16]), "m" (p[18]),
+		  "m" (p[20]), "m" (p[22]), "m" (p[24]), "m" (p[26]), "m" (p[28]),
+		  "m" (p[30]), "m" (p[32]));
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/powerpc/altivec-30.c gcc-4.4.0/gcc/testsuite/gcc.target/powerpc/altivec-30.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/powerpc/altivec-30.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.target/powerpc/altivec-30.c	2009-05-29 00:14:20.000000000 -0700
@@ -0,0 +1,32 @@
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+#include <stdbool.h>
+#include <altivec.h>
+
+#define f0(type) void x0##type (vector bool type x) { }
+f0 (int)
+
+#define f1(v, type) void x1##type (v bool type x) { }
+f1 (vector, int)
+
+#define f2(b, type) void x2##type (vector b type x) { }
+f2 (bool, int)
+
+#define f3(v, b, type) void x3##type (v b type x) { }
+f3 (vector, bool, int)
+
+#define f4(v, b, type) void x4##type (v type b x) { }
+f4 (vector, bool, int)
+
+#define B bool
+#define I int
+#define BI bool int
+#define VBI vector bool int
+
+vector bool int a;
+vector B int b;
+vector B I c;
+vector BI d;
+VBI e;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/powerpc/altivec-31.c gcc-4.4.0/gcc/testsuite/gcc.target/powerpc/altivec-31.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/powerpc/altivec-31.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gcc.target/powerpc/altivec-31.c	2009-05-29 00:14:20.000000000 -0700
@@ -0,0 +1,29 @@
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+#define f0(type) void x0##type (vector _Bool type x) { }
+f0 (int)
+
+#define f1(v, type) void x1##type (v _Bool type x) { }
+f1 (vector, int)
+
+#define f2(b, type) void x2##type (vector b type x) { }
+f2 (_Bool, int)
+
+#define f3(v, b, type) void x3##type (v b type x) { }
+f3 (vector, _Bool, int)
+
+#define f4(v, b, type) void x4##type (v type b x) { }
+f4 (vector, _Bool, int)
+
+#define B _Bool
+#define I int
+#define BI _Bool int
+#define VBI vector _Bool int
+
+vector _Bool int a;
+vector B int b;
+vector B I c;
+vector BI d;
+VBI e;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/powerpc/altivec-types-1.c gcc-4.4.0/gcc/testsuite/gcc.target/powerpc/altivec-types-1.c
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/powerpc/altivec-types-1.c	2008-08-26 14:39:49.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.target/powerpc/altivec-types-1.c	2009-05-29 00:14:20.000000000 -0700
@@ -24,6 +24,7 @@
 __vector signed vsj;
 __vector __bool vbj;
 __vector float vf;
+__vector _Bool vb;
 
 /* These should be rejected as invalid AltiVec types.  */
 
@@ -37,7 +38,6 @@
 __vector __bool long long int vblli;	/* { dg-error "AltiVec types" "" } */
 __vector double vd1;			/* { dg-error "AltiVec types" "" } */
 __vector long double vld;		/* { dg-error "AltiVec types" "" } */
-__vector _Bool vb;			/* { dg-error "AltiVec types" "" } */
 __vector _Complex float vcf;		/* { dg-error "AltiVec types" "" } */
 __vector _Complex double vcd;		/* { dg-error "AltiVec types" "" } */
 __vector _Complex long double vcld;	/* { dg-error "AltiVec types" "" } */
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S gcc-4.4.0/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
--- gcc-4.4.0.orig/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S	2008-08-28 12:36:58.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S	2009-05-18 09:54:31.000000000 -0700
@@ -49,7 +49,9 @@
 	.type	snapshot_ret, @function
 snapshot_ret:
 	movq	%rdi, rdi(%rip)
+	subq	$8, %rsp
 	call	*callthis(%rip)
+	addq	$8, %rsp
 	movq	%rax, rax(%rip)
 	movq	%rdx, rdx(%rip)
 	movdqu	%xmm0, xmm_regs+0(%rip)
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/auto14.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/auto14.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/auto14.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/auto14.C	2009-06-03 11:11:53.000000000 -0700
@@ -0,0 +1,29 @@
+// PR c++/40306, c++/40307
+// { dg-options "-std=c++0x" }
+// { dg-do run }
+
+template< typename T >
+struct test {
+   test run() {
+      auto tmp = *this;
+      return tmp;
+   }
+   test run_pass() {
+      test tmp( *this );
+      return tmp;
+   }
+
+   test run_fail() {
+      auto tmp( *this );
+      return tmp;
+   }
+};
+
+int main()
+{
+   test<int> x;
+   x.run();
+   x.run_pass();
+   x.run_fail();
+   return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/enum3.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/enum3.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/enum3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/enum3.C	2009-05-25 16:07:05.000000000 -0700
@@ -0,0 +1,17 @@
+// PR c++/38064
+// { dg-options "-std=c++0x" }
+// { dg-do run }
+
+enum class E { elem };
+
+template <class T>
+void f (T t);
+
+bool f (bool b) { return b; }
+
+int main()
+{
+  E e = E::elem;
+  if (!f (e == E::elem))
+    return 1;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist13.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist13.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist13.C	2009-02-03 09:23:11.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist13.C	2009-06-03 11:11:53.000000000 -0700
@@ -2,4 +2,7 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 
-__complex__ int i ({0});	// { dg-error "cannot convert" }
+#include <complex>
+
+__complex__ int i ({0});
+std::complex<int> i2 ({0});
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist15.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist15.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist15.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist15.C	2009-05-28 09:09:04.000000000 -0700
@@ -0,0 +1,17 @@
+// { dg-options "-std=c++0x" }
+
+#include <vector>
+#include <typeinfo>
+
+using namespace std;
+
+template< typename ... ArgTypes >
+void test( ArgTypes ... args ) {
+   vector<type_info*> x = { &typeid(ArgTypes)... }; // { dg-error "" }
+}
+
+int main()
+{
+    test( 1, 3.14f, 2.78 );
+    return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist16.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist16.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist16.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist16.C	2009-06-03 11:11:53.000000000 -0700
@@ -0,0 +1,12 @@
+// { dg-options "-std=c++0x" }
+// { dg-do run }
+
+extern "C" void abort();
+
+void f(int i) { if (i != 42) abort(); }
+
+int main()
+{
+  f({42});
+  return {0};
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist17.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist17.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist17.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist17.C	2009-06-03 11:11:53.000000000 -0700
@@ -0,0 +1,9 @@
+// { dg-options "-std=c++0x" }
+
+void f(int i);
+
+int main()
+{
+  f({42.0});			// { dg-error "narrowing" }
+  return {1.0};			// { dg-error "narrowing" }
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist18.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist18.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist18.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist18.C	2009-06-03 11:11:53.000000000 -0700
@@ -0,0 +1,19 @@
+// PR c++/40308, 40311
+// { dg-do run }
+// { dg-options "-std=c++0x" }
+
+template< typename T >
+struct test {
+   test() : data{} {}
+
+   T data;
+};
+
+int main()
+{
+   test<int> x;
+   test<int*> y;
+   int * a = new int{};
+   int * b = new int{5};
+   return 0;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist19.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist19.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/initlist19.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/initlist19.C	2009-06-03 11:11:53.000000000 -0700
@@ -0,0 +1,8 @@
+// { dg-options "-std=c++0x" }
+
+void f(double);
+int main()
+{
+  f({{1}});			// { dg-error "too many braces" }
+  // { dg-error "" "" { target *-*-* } 6 } allow other errors, too
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/pr39639.C gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/pr39639.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/cpp0x/pr39639.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/cpp0x/pr39639.C	2009-04-22 12:16:13.000000000 -0700
@@ -0,0 +1,20 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/39639
+// { dg-options "-std=c++0x" }
+// { dg-do "compile" }
+
+template <class... Types>
+struct S
+  : S<...Types>, // { dg-error "expected parameter pack before '...'" }
+    S<...Types...>, // { dg-error "expected parameter pack before '...'" }
+    S<...> // { dg-error "expected parameter pack before '...'" }
+{
+  static int f () { return 1;}
+};
+
+int
+main ()
+{
+  return S<void>::f ();
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/debug/dwarf2/nested-1.C gcc-4.4.0/gcc/testsuite/g++.dg/debug/dwarf2/nested-1.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/debug/dwarf2/nested-1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/debug/dwarf2/nested-1.C	2009-05-18 12:24:17.000000000 -0700
@@ -0,0 +1,29 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR debug/40109
+// { dg-do compile }
+// { dg-options  "-g -dA -O0" }
+
+namespace A
+{
+
+  class B
+  {
+  };
+  typedef A::B AB;
+};
+
+int
+main()
+{
+  A::AB ab;
+  return 0;
+}
+
+// { dg-final { scan-assembler "DW_TAG_typedef" } }
+//
+// What we want to do here is to be sure that the DIE of A::AB is generated
+// as a child of the DIE of the namespace A declaration.
+// So this test won't catch a regression on this fix yet. To write a proper
+// test for this fix, we would need a dwarf reader written in tcl,
+// or something along those lines.
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/eh/nested-try.C gcc-4.4.0/gcc/testsuite/g++.dg/eh/nested-try.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/eh/nested-try.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/eh/nested-try.C	2009-05-11 09:49:17.000000000 -0700
@@ -0,0 +1,25 @@
+// { dg-do compile }
+// Nested try statements shadowing each other was crashing in EH edge redirection.
+// PR middle-end/40043
+struct A
+{
+  ~A();
+  void foo();
+};
+
+void bar()
+{
+  A a;
+
+  try
+  {
+    A b;
+
+    try
+    {
+      b.foo();
+    }
+    catch (int) {}
+  }
+  catch (int) {}
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/expr/bound-mem-fun.C gcc-4.4.0/gcc/testsuite/g++.dg/expr/bound-mem-fun.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/expr/bound-mem-fun.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/expr/bound-mem-fun.C	2009-04-23 04:13:57.000000000 -0700
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/38228
+// { dg-do "compile" }
+
+struct A
+{
+  A ();
+  template<typename T> A(T);
+};
+
+struct B
+{
+  int foo();
+};
+
+A a = B().*(&B::foo); // { dg-error "invalid use of non-static member function" }
+
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/ext/altivec-15.C gcc-4.4.0/gcc/testsuite/g++.dg/ext/altivec-15.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/ext/altivec-15.C	2008-03-25 20:32:13.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.dg/ext/altivec-15.C	2009-04-30 10:53:23.000000000 -0700
@@ -2,12 +2,15 @@
 /* { dg-require-effective-target powerpc_altivec_ok } */
 /* { dg-options "-maltivec" } */
 
+/* This test was added for an internal compiler error.  The number and
+   content of error messages is irrelevant.  */
+
 struct SubData
 {
     inline const Float Clamp(Float f, Float f0, Float f1) // { dg-error "" }
     }
     inline const void SinCos(Float angle, Float& sine, Float& cosine) // { dg-error "" }
     {
-        C0 = __builtin_vec_splat(_simdCosEstCoefficients, 0); // { dg-error "" }
-        C1 = __builtin_vec_splat(_simdCosEstCoefficients, 1); // { dg-error "" }
+        C0 = __builtin_vec_splat(_simdCosEstCoefficients, 0);
+        C1 = __builtin_vec_splat(_simdCosEstCoefficients, 1);
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/ext/packed6.C gcc-4.4.0/gcc/testsuite/g++.dg/ext/packed6.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/ext/packed6.C	2004-05-31 14:24:31.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.dg/ext/packed6.C	2009-05-28 02:37:31.000000000 -0700
@@ -1,7 +1,7 @@
 // PR c++/15209
 // { dg-options "-w" }
 
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 typedef unsigned char uint8_t;
 typedef unsigned short int uint16_t;
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/ext/vla7.C gcc-4.4.0/gcc/testsuite/g++.dg/ext/vla7.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/ext/vla7.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/ext/vla7.C	2009-05-04 23:41:33.000000000 -0700
@@ -0,0 +1,30 @@
+// PR c++/40013
+// { dg-options "" }
+
+template <class T>
+struct A
+{
+  struct B
+  {
+    struct
+    {
+      int fn () { return 0; }
+    } b;
+  };
+  void test ();
+};
+
+template <class T>
+void
+A <T>::test ()
+{
+  B a;
+  int vla[a.b.fn ()];
+}
+
+int
+main ()
+{
+  A <char> a;
+  a.test ();
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/opt/memcpy1.C gcc-4.4.0/gcc/testsuite/g++.dg/opt/memcpy1.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/opt/memcpy1.C	2007-12-10 14:30:02.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/opt/memcpy1.C	2009-05-28 02:37:31.000000000 -0700
@@ -6,7 +6,7 @@
 
 typedef unsigned char uint8_t;
 typedef uint8_t uint8;
-typedef long unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 class csVector2
 {
 public:float x;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/pr37742.C gcc-4.4.0/gcc/testsuite/g++.dg/pr37742.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/pr37742.C	2008-11-05 04:17:10.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/pr37742.C	2009-05-28 02:37:31.000000000 -0700
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 
-typedef long unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 void*   __valarray_get_memory(size_t __n);
 int*__restrict__
 __valarray_get_storage(size_t __n)
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/call7.C gcc-4.4.0/gcc/testsuite/g++.dg/template/call7.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/call7.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/call7.C	2009-05-06 13:43:41.000000000 -0700
@@ -0,0 +1,19 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/17395
+// { dg-do "compile" }
+
+template<int> struct X { };
+
+void fu(int a, X<sizeof(a)>) { }
+
+template<class T>
+void bhar(T a, X<sizeof(a)>) { }
+
+int
+main()
+{
+  int x;
+  X<sizeof(int)> y;
+  fu(x, y);
+  bhar(x, y);
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-1.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-1.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-1.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+template < typename > struct A ;
+template < typename T , typename = A < T > > struct B { } ;
+template < class W , class > struct D
+{
+  typedef W X ;
+  A<X*> a ;
+};
+
+template < class Y > struct E
+{
+  B<Y*> b ;
+} ;
+E<int> e ;
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-2.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-2.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-2.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+template < typename > struct A ;
+template < typename T , typename = A < T > > struct B { } ;
+template < class W , class > struct D
+{
+  typedef W X ;
+  A< X()> a ;
+};
+
+template < class Y > struct E
+{
+  B< Y()> b ;
+};
+E<int> e ;
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-3.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-3.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-3.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,20 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+template<typename> struct A ;
+template<typename T , typename = A<T> > struct B { } ;
+template<class W , class > struct D
+{
+  typedef W X ;
+  typedef X (FP) ();
+  A<FP&> a ;
+} ;
+
+template < class Y > struct E
+{
+  typedef Y (FP) ();
+  B<FP&> b ;
+} ;
+E < int > e ;
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-4.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-4.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-4.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,22 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+template<typename> struct A ;
+template<typename T ,typename = A<T> > struct B { } ;
+
+template<class W, class>
+struct D
+{
+  typedef W X;
+  A<X[2]> a;
+} ;
+
+template<class Y>
+struct E
+{
+  B<Y[2]> b;
+};
+
+E < int > e;
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-5.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-5.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-5.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-5.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,22 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+struct Foo {};
+template<typename> struct A ;
+template<typename T ,typename = A<T> > struct B { } ;
+
+template<class W, class>
+struct D
+{
+  typedef W X ;
+  A<X Foo::*> a ;
+} ;
+
+template<class Y>
+struct E
+{
+  B<Y Foo::*> b ;
+} ;
+E < int > e ;
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-6.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-6.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-6.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-6.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,22 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+struct Foo {};
+template<typename> struct A ;
+template<typename T ,typename = A<T> > struct B { } ;
+
+template<class W, class>
+struct D
+{
+  typedef W X;
+  A<void (Foo::*) (X)> a;
+} ;
+
+template<class Y>
+struct E
+{
+  B<void (Foo::*) (Y)> b;
+};
+E < int > e ;
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-7.C gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-7.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/canon-type-7.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/canon-type-7.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,21 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/39754
+// { dg-do "compile" }
+
+struct Foo {};
+template<typename> struct A ;
+template<typename T ,typename = A<T> > struct B { } ;
+
+template<class W, class>
+struct D
+{
+  typedef W X;
+  A<X (Foo::*) (X)> a ;
+};
+
+template<class Y>
+struct E
+{
+  B<Y (Foo::*) (Y)> b ;
+};
+E<int> e ;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/dtor6.C gcc-4.4.0/gcc/testsuite/g++.dg/template/dtor6.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/dtor6.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/dtor6.C	2009-05-17 13:34:30.000000000 -0700
@@ -0,0 +1,10 @@
+// PR c++/40139
+
+template<int> struct A
+{
+  static int i;
+};
+
+template<int N> int A<N>::i = { A::~A }; // { dg-error "" }
+
+template class A<0>;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/typedef18.C gcc-4.4.0/gcc/testsuite/g++.dg/template/typedef18.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/typedef18.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/typedef18.C	2009-05-30 06:49:33.000000000 -0700
@@ -0,0 +1,24 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/40007
+// { dg-do compile }
+
+template<typename T>
+struct x
+{
+  protected:
+  typedef int type;
+};
+
+template<typename T>
+struct y : public x<T>
+{
+  typename x<T>::type z;
+};
+
+template<>
+struct y<void> : public x<void>
+{
+  typedef x<void>::type z;
+};
+
+template class y<int>;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/typedef19.C gcc-4.4.0/gcc/testsuite/g++.dg/template/typedef19.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/typedef19.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/typedef19.C	2009-05-30 16:46:31.000000000 -0700
@@ -0,0 +1,21 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/40007
+// { dg-do compile }
+
+class A
+{
+  typedef int mytype; // { dg-error "'typedef int A::mytype' is private" "" { xfail *-*-* } }
+};
+
+template <class T>
+class B : public A
+{
+};
+
+template<class T>
+class B<T*> : public A
+{ // { dg-error "within this context" "" { xfail *-*-* } }
+  mytype mem;
+};
+
+B<int*> b;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/typedef20.C gcc-4.4.0/gcc/testsuite/g++.dg/template/typedef20.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/template/typedef20.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/template/typedef20.C	2009-05-30 16:46:31.000000000 -0700
@@ -0,0 +1,27 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/40007
+// { dg-do compile }
+
+class x
+{
+  typedef int privtype; // { dg-error "is private" "" { xfail *-*-* } }
+
+protected:
+  typedef int type;
+};
+
+template<typename T>
+struct y : public x
+{
+  typename x::type z;
+};
+
+template<typename T>
+struct y<T*> : public x
+{ // { dg-error "within this context" "" { xfail *-*-* } }
+  typedef x::type good;
+  typedef x::privtype bad;
+};
+
+template class y<int>;
+template class y<int*>;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/20070621-1.C gcc-4.4.0/gcc/testsuite/g++.dg/torture/20070621-1.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/20070621-1.C	2007-06-21 05:00:47.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.dg/torture/20070621-1.C	2009-05-28 02:37:31.000000000 -0700
@@ -6,7 +6,7 @@
 
 */
 
-typedef long int ptrdiff_t;
+__extension__ typedef __PTRDIFF_TYPE__ ptrdiff_t;
 namespace std __attribute__ ((__visibility__ ("default"))) {
     template<typename, typename>     struct __are_same     {
         enum {
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/pr34222.C gcc-4.4.0/gcc/testsuite/g++.dg/torture/pr34222.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/pr34222.C	2007-12-04 09:20:34.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/torture/pr34222.C	2009-05-28 02:37:31.000000000 -0700
@@ -3,7 +3,7 @@
 namespace std __attribute__ ((__visibility__ ("default"))) {
     template<class _CharT>     struct char_traits;
   }
-typedef long int ptrdiff_t;
+__extension__ typedef __PTRDIFF_TYPE__ ptrdiff_t;
 namespace std __attribute__ ((__visibility__ ("default"))) {
     typedef ptrdiff_t streamsize;
     template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ifstream;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/pr34850.C gcc-4.4.0/gcc/testsuite/g++.dg/torture/pr34850.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/pr34850.C	2008-01-21 01:34:19.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/torture/pr34850.C	2009-05-28 02:37:31.000000000 -0700
@@ -5,7 +5,7 @@
 typedef unsigned int uint32_t;
 typedef uint8_t byte;
 typedef uint32_t u32bit;
-typedef unsigned int size_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 extern "C" {
     extern void __warn_memset_zero_len (void) __attribute__((__warning__ ("")));
     extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__))
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/pr40335.C gcc-4.4.0/gcc/testsuite/g++.dg/torture/pr40335.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/torture/pr40335.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/torture/pr40335.C	2009-06-04 05:37:48.000000000 -0700
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+extern "C" void abort (void);
+int
+main (void)
+{
+  int i = -1; 
+  switch ((signed char) i)
+    {
+      case 255: /* { dg-bogus "exceeds maximum value" "" { xfail *-*-* } } */
+	abort ();
+      default:
+	break;
+    }
+}
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/tree-ssa/pr22444.C gcc-4.4.0/gcc/testsuite/g++.dg/tree-ssa/pr22444.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/tree-ssa/pr22444.C	2007-03-30 12:45:57.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.dg/tree-ssa/pr22444.C	2009-05-28 02:37:31.000000000 -0700
@@ -4,8 +4,8 @@
 // with the subvars leading to the subvars not being renamed when they should
 // { dg-do compile }
 // { dg-options "-O2" }
-typedef int ptrdiff_t;
-typedef unsigned int size_t;
+__extension__ typedef __PTRDIFF_TYPE__ ptrdiff_t;
+__extension__ typedef __SIZE_TYPE__ size_t;
 namespace std
 {
   template<class _T1, class _T2> struct pair
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/warn/Wuninitialized-4.C gcc-4.4.0/gcc/testsuite/g++.dg/warn/Wuninitialized-4.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/warn/Wuninitialized-4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/warn/Wuninitialized-4.C	2009-05-12 09:19:29.000000000 -0700
@@ -0,0 +1,22 @@
+// PR middle-end/39666
+// { dg-do compile }
+// { dg-options "-O2 -Wuninitialized" }
+
+int
+foo (int i)
+{
+  int j;
+  switch (i)
+    {
+    case -__INT_MAX__ - 1 ... -1:
+      j = 6;
+      break;
+    case 0:
+      j = 5;
+      break;
+    case 1 ... __INT_MAX__:
+      j = 4;
+      break;
+    }
+  return j;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.dg/warn/Wuninitialized-5.C gcc-4.4.0/gcc/testsuite/g++.dg/warn/Wuninitialized-5.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.dg/warn/Wuninitialized-5.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/g++.dg/warn/Wuninitialized-5.C	2009-05-12 09:19:29.000000000 -0700
@@ -0,0 +1,22 @@
+// PR middle-end/39666
+// { dg-do compile }
+// { dg-options "-O2 -Wuninitialized" }
+
+int
+foo (int i)
+{
+  int j;	// { dg-warning "may be used uninitialized" }
+  switch (i)
+    {
+    case -__INT_MAX__ - 1 ... -1:
+      j = 6;
+      break;
+    case 0:
+      j = 5;
+      break;
+    case 2 ... __INT_MAX__:
+      j = 4;
+      break;
+    }
+  return j;
+}
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_assign_10.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/alloc_comp_assign_10.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_assign_10.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/alloc_comp_assign_10.f90	2009-05-10 03:44:22.000000000 -0700
@@ -0,0 +1,61 @@
+! { dg-do run }
+!
+! Test the fix for PR39879, in which gfc gagged on the double
+! defined assignment where the rhs had a default initialiser.
+!
+! Contributed by David Sagan <david.sagan@gmail.com>
+!
+module test_struct
+  interface assignment (=)
+    module procedure tao_lat_equal_tao_lat
+  end interface
+  type bunch_params_struct
+    integer n_live_particle          
+  end type
+  type tao_lattice_struct
+    type (bunch_params_struct), allocatable :: bunch_params(:)
+    type (bunch_params_struct), allocatable :: bunch_params2(:)
+  end type
+  type tao_universe_struct
+    type (tao_lattice_struct), pointer :: model, design
+    character(200), pointer :: descrip => NULL()
+  end type
+  type tao_super_universe_struct
+    type (tao_universe_struct), allocatable :: u(:)          
+  end type
+  type (tao_super_universe_struct), save, target :: s
+  contains
+    subroutine tao_lat_equal_tao_lat (lat1, lat2)
+      implicit none
+      type (tao_lattice_struct), intent(inout) :: lat1
+      type (tao_lattice_struct), intent(in) :: lat2
+      if (allocated(lat2%bunch_params)) then
+        lat1%bunch_params = lat2%bunch_params
+      end if 
+      if (allocated(lat2%bunch_params2)) then
+        lat1%bunch_params2 = lat2%bunch_params2
+      end if 
+    end subroutine
+end module
+
+program tao_program
+  use test_struct
+  implicit none
+  type (tao_universe_struct), pointer :: u
+  integer n, i
+  allocate (s%u(1))
+  u => s%u(1)
+  allocate (u%design, u%model)
+  n = 112
+  allocate (u%model%bunch_params(0:n), u%design%bunch_params(0:n))
+  u%design%bunch_params%n_live_particle = [(i, i = 0, n)]
+  u%model = u%design
+  u%model = u%design ! The double assignment was the cause of the ICE
+  if (.not. allocated (u%model%bunch_params)) call abort
+  if (any (u%model%bunch_params%n_live_particle .ne. [(i, i = 0, n)])) call abort
+  Deallocate (u%model%bunch_params, u%design%bunch_params)
+  deallocate (u%design, u%model)
+  deallocate (s%u)
+end program
+
+! { dg-final { cleanup-modules "test_struct" } }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/array_constructor_31.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/array_constructor_31.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/array_constructor_31.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/array_constructor_31.f90	2009-05-10 09:14:37.000000000 -0700
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! Test the fix for pr40018 in which the elements in the array
+! constructor would be of default type and this would cause an
+! ICE in the backend because of the type mistmatch with 'i'.
+!
+! Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>
+!
+  integer(kind=8) :: i
+  write(*,*) [(i, i = 1, 10)]
+  end
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/assumed_charlen_dummy.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/assumed_charlen_dummy.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/assumed_charlen_dummy.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/assumed_charlen_dummy.f90	2009-06-04 10:01:45.000000000 -0700
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! Test the fix for PR fortran/39893.
+! Original testcase provided by Deji Akingunola.
+! Reduced testcase provided by Dominique d'Humieres.
+!
+      SUBROUTINE XAUTOGET()
+      CHARACTER*(*) DICBA    ! { dg-error "Entity with assumed character" }
+      DATA DICBA /"CLIP" /
+      RETURN
+      END
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/chmod_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/chmod_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/chmod_1.f90	2008-04-30 13:24:46.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/chmod_1.f90	2009-05-09 20:35:53.000000000 -0700
@@ -1,5 +1,6 @@
-! { dg-do run { target { ! *-*-mingw* } } }
+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }
 ! { dg-options "-std=gnu" }
+! See PR38956.  Test fails on cygwin when user has Administrator rights
   implicit none
   character(len=*), parameter :: n = "foobar_file"
   integer :: i
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/chmod_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/chmod_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/chmod_2.f90	2008-04-30 13:24:46.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/chmod_2.f90	2009-05-09 20:35:53.000000000 -0700
@@ -1,5 +1,6 @@
-! { dg-do run { target { ! *-*-mingw* } } }
+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }
 ! { dg-options "-std=gnu" }
+! See PR38956.  Test fails on cygwin when user has Administrator rights
   implicit none
   character(len=*), parameter :: n = "foobar_file"
   integer :: i
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/chmod_3.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/chmod_3.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/chmod_3.f90	2008-04-30 13:24:46.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/chmod_3.f90	2009-05-09 20:35:53.000000000 -0700
@@ -1,5 +1,6 @@
-! { dg-do run { target { ! *-*-mingw* } } }
+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }
 ! { dg-options "-std=gnu -fdefault-integer-8" }
+! See PR38956.  Test fails on cygwin when user has Administrator rights
   implicit none
   character(len=*), parameter :: n = "foobar_file"
   integer :: i
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/default_format_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/default_format_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/default_format_1.f90	2008-05-11 02:55:34.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/default_format_1.f90	2009-05-16 04:01:47.000000000 -0700
@@ -1,4 +1,4 @@
-! { dg-do run }
+! { dg-do run { xfail spu-*-*  } }
 ! Test XFAILed on Darwin because the system's printf() lacks
 ! proper support for denormals.
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/default_format_denormal_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/default_format_denormal_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/default_format_denormal_1.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/default_format_denormal_1.f90	2009-05-16 04:01:47.000000000 -0700
@@ -1,4 +1,4 @@
-! { dg-do run { xfail alpha*-*-* *-*-darwin[89]* *-*-freebsd* *-*-mingw* } }
+! { dg-do run { xfail alpha*-*-* *-*-darwin[89]* *-*-freebsd* *-*-mingw* *-*-cygwin* spu-*-* } }
 ! Test XFAILed on these platforms because the system's printf() lacks
 ! proper support for denormals.
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/dependency_24.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/dependency_24.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/dependency_24.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/dependency_24.f90	2009-05-10 08:34:55.000000000 -0700
@@ -0,0 +1,82 @@
+! { dg-do run }
+! Check the fix for PR38863 comment #1, where defined assignment
+! to derived types was not treating components correctly that were
+! not set explicitly.
+!
+! Contributed by Mikael Morin  <mikael@gcc.gnu.org>
+!
+module m
+  type t
+    integer :: i,j
+  end type t
+  type ti
+    integer :: i,j = 99
+  end type ti
+  interface assignment (=)
+    module procedure i_to_t, i_to_ti
+  end interface
+contains 
+  elemental subroutine i_to_ti (p, q)
+    type(ti), intent(out) :: p
+    integer, intent(in)  :: q
+    p%i = q
+  end subroutine
+  elemental subroutine i_to_t (p, q)
+    type(t), intent(out) :: p
+    integer, intent(in)  :: q
+    p%i = q
+  end subroutine
+end module
+
+  use m
+  call test_t  ! Check original problem
+  call test_ti ! Default initializers were treated wrongly
+contains
+  subroutine test_t
+    type(t), target :: a(3)
+    type(t), target  :: b(3)
+    type(t), dimension(:), pointer :: p
+    logical :: l(3)
+
+    a%i = 1
+    a%j = [101, 102, 103]
+    b%i = 3
+    b%j = 4
+
+    p => b
+    l = .true.
+
+    where (l)
+      a = p%i         ! Comment #1 of PR38863 concerned WHERE assignment
+    end where
+    if (any (a%j .ne. [101, 102, 103])) call abort
+
+    a = p%i           ! Ordinary assignment was wrong too.
+    if (any (a%j .ne. [101, 102, 103])) call abort
+  end subroutine
+
+  subroutine test_ti
+    type(ti), target :: a(3)
+    type(ti), target  :: b(3)
+    type(ti), dimension(:), pointer :: p
+    logical :: l(3)
+
+    a%i = 1
+    a%j = [101, 102, 103]
+    b%i = 3
+    b%j = 4
+
+    p => b
+    l = .true.
+
+    where (l)
+      a = p%i
+    end where
+    if (any (a%j .ne. 99)) call abort
+
+    a = p%i
+    if (any (a%j .ne. 99)) call abort
+  end subroutine
+end
+! { dg-final { cleanup-modules "m" } }
+
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/elemental_subroutine_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/elemental_subroutine_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/elemental_subroutine_1.f90	2007-09-17 23:34:30.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/elemental_subroutine_1.f90	2009-04-22 04:35:25.000000000 -0700
@@ -48,7 +48,7 @@
 ! Test an expression in the INTENT(IN) argument
   x = (/1.0, 2.0/)
   call foobar (cos (x) + u, y)
-  if (any(abs (y + cos (x) + u) .gt. 2.0e-6)) call abort ()
+  if (any(abs (y + cos (x) + u) .gt. 4.0e-6)) call abort ()
 
 contains
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/gamma_5.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/gamma_5.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/gamma_5.f90	2007-11-29 20:18:05.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/gamma_5.f90	2009-04-22 04:35:25.000000000 -0700
@@ -21,7 +21,7 @@
      xd = n + 0.5d0
      td = c(n)*sqrt(pi)
      ts = c(n)*sqrt(pi)
-     if (abs(gamma(xs)-ts)/ts > 3e-6) call abort
+     if (abs(gamma(xs)-ts)/ts > 9e-6) call abort
      if (abs(gamma(xd)-td)/td > 5e-14) call abort
   end do
   call tst_s(2.3, gamma(2.3))
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/init_flag_3.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/init_flag_3.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/init_flag_3.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/init_flag_3.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 ! { dg-do run }
 ! { dg-options "-finit-integer=-1 -finit-logical=false -finit-real=nan" }
 ! { dg-options "-finit-integer=-1 -finit-logical=false -finit-real=nan -mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 
 program init_flag_3
   call real_test
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/int_conv_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/int_conv_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/int_conv_2.f90	2008-10-30 21:51:04.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/int_conv_2.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 ! PR fortran/37930
 program test
   implicit none
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90 gcc-4.4.0/gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90	2007-11-20 13:57:04.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90	2009-04-22 04:35:25.000000000 -0700
@@ -1,4 +1,5 @@
-! { dg-do run }
+! { dg-do run { xfail spu-*-* } }
+! FAILs on SPU because of wrong compile-time rounding mode
 ! { dg-options "" }
 module mod_check
   implicit none
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90 gcc-4.4.0/gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90	2009-04-22 04:35:25.000000000 -0700
@@ -1,4 +1,5 @@
-! { dg-do run }
+! { dg-do run { xfail spu-*-* } }
+! FAILs on SPU because of invalid result of 1.0/0.0 inline code
 ! { dg-options "-fno-range-check" }
 ! { dg-options "-fno-range-check -mieee" { target alpha*-*-* } } */
 module mod_check
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/isnan_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/isnan_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/isnan_1.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/isnan_1.f90	2009-04-22 04:35:25.000000000 -0700
@@ -2,6 +2,7 @@
 !
 ! { dg-do run }
 ! { dg-options "-pedantic-errors -mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
   implicit none
   real :: x
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/isnan_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/isnan_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/isnan_2.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/isnan_2.f90	2009-04-22 04:35:25.000000000 -0700
@@ -3,6 +3,7 @@
 ! { dg-do run }
 ! { dg-options "-fno-range-check" }
 ! { dg-options "-fno-range-check -pedantic-errors -mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
   implicit none
   character(len=1) :: s
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/leadz_trailz_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/leadz_trailz_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/leadz_trailz_1.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/leadz_trailz_1.f90	2009-06-03 12:39:09.000000000 -0700
@@ -0,0 +1,133 @@
+! { dg-do run }
+
+  integer(kind=1) :: i1
+  integer(kind=2) :: i2
+  integer(kind=4) :: i4
+  integer(kind=8) :: i8
+
+  i1 = -1
+  i2 = -1
+  i4 = -1
+  i8 = -1
+
+  if (leadz(i1) /= 0) call abort
+  if (leadz(i2) /= 0) call abort
+  if (leadz(i4) /= 0) call abort
+  if (leadz(i8) /= 0) call abort
+
+  if (trailz(i1) /= 0) call abort
+  if (trailz(i2) /= 0) call abort
+  if (trailz(i4) /= 0) call abort
+  if (trailz(i8) /= 0) call abort
+
+  if (leadz(-1_1) /= 0) call abort
+  if (leadz(-1_2) /= 0) call abort
+  if (leadz(-1_4) /= 0) call abort
+  if (leadz(-1_8) /= 0) call abort
+
+  if (trailz(-1_1) /= 0) call abort
+  if (trailz(-1_2) /= 0) call abort
+  if (trailz(-1_4) /= 0) call abort
+  if (trailz(-1_8) /= 0) call abort
+
+  i1 = -64
+  i2 = -64
+  i4 = -64
+  i8 = -64
+
+  if (leadz(i1) /= 0) call abort
+  if (leadz(i2) /= 0) call abort
+  if (leadz(i4) /= 0) call abort
+  if (leadz(i8) /= 0) call abort
+
+  if (trailz(i1) /= 6) call abort
+  if (trailz(i2) /= 6) call abort
+  if (trailz(i4) /= 6) call abort
+  if (trailz(i8) /= 6) call abort
+
+  if (leadz(-64_1) /= 0) call abort
+  if (leadz(-64_2) /= 0) call abort
+  if (leadz(-64_4) /= 0) call abort
+  if (leadz(-64_8) /= 0) call abort
+
+  if (trailz(-64_1) /= 6) call abort
+  if (trailz(-64_2) /= 6) call abort
+  if (trailz(-64_4) /= 6) call abort
+  if (trailz(-64_8) /= 6) call abort
+
+  i1 = -108
+  i2 = -108
+  i4 = -108
+  i8 = -108
+
+  if (leadz(i1) /= 0) call abort
+  if (leadz(i2) /= 0) call abort
+  if (leadz(i4) /= 0) call abort
+  if (leadz(i8) /= 0) call abort
+
+  if (trailz(i1) /= 2) call abort
+  if (trailz(i2) /= 2) call abort
+  if (trailz(i4) /= 2) call abort
+  if (trailz(i8) /= 2) call abort
+
+  if (leadz(-108_1) /= 0) call abort
+  if (leadz(-108_2) /= 0) call abort
+  if (leadz(-108_4) /= 0) call abort
+  if (leadz(-108_8) /= 0) call abort
+
+  if (trailz(-108_1) /= 2) call abort
+  if (trailz(-108_2) /= 2) call abort
+  if (trailz(-108_4) /= 2) call abort
+  if (trailz(-108_8) /= 2) call abort
+
+  i1 = 1
+  i2 = 1
+  i4 = 1
+  i8 = 1
+
+  if (leadz(i1) /= bit_size(i1) - 1) call abort
+  if (leadz(i2) /= bit_size(i2) - 1) call abort
+  if (leadz(i4) /= bit_size(i4) - 1) call abort
+  if (leadz(i8) /= bit_size(i8) - 1) call abort
+
+  if (trailz(i1) /= 0) call abort
+  if (trailz(i2) /= 0) call abort
+  if (trailz(i4) /= 0) call abort
+  if (trailz(i8) /= 0) call abort
+
+  if (leadz(1_1) /= bit_size(1_1) - 1) call abort
+  if (leadz(1_2) /= bit_size(1_2) - 1) call abort
+  if (leadz(1_4) /= bit_size(1_4) - 1) call abort
+  if (leadz(1_8) /= bit_size(1_8) - 1) call abort
+
+  if (trailz(1_1) /= 0) call abort
+  if (trailz(1_2) /= 0) call abort
+  if (trailz(1_4) /= 0) call abort
+  if (trailz(1_8) /= 0) call abort
+
+  i1 = 64
+  i2 = 64
+  i4 = 64
+  i8 = 64
+
+  if (leadz(i1) /= 1) call abort
+  if (leadz(i2) /= 9) call abort
+  if (leadz(i4) /= 25) call abort
+  if (leadz(i8) /= 57) call abort
+
+  if (trailz(i1) /= 6) call abort
+  if (trailz(i2) /= 6) call abort
+  if (trailz(i4) /= 6) call abort
+  if (trailz(i8) /= 6) call abort
+
+  if (leadz(64_1) /= 1) call abort
+  if (leadz(64_2) /= 9) call abort
+  if (leadz(64_4) /= 25) call abort
+  if (leadz(64_8) /= 57) call abort
+
+  if (trailz(64_1) /= 6) call abort
+  if (trailz(64_2) /= 6) call abort
+  if (trailz(64_4) /= 6) call abort
+  if (trailz(64_8) /= 6) call abort
+
+end
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/leadz_trailz_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/leadz_trailz_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/leadz_trailz_2.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/leadz_trailz_2.f90	2009-06-03 12:39:09.000000000 -0700
@@ -0,0 +1,36 @@
+! { dg-do run }
+! { dg-require-effective-target fortran_large_int }
+
+  integer(kind=16) :: i16
+
+  i16 = -1
+  if (leadz(i16) /= 0) call abort
+  if (trailz(i16) /= 0) call abort
+  if (leadz(-1_16) /= 0) call abort
+  if (trailz(-1_16) /= 0) call abort
+
+  i16 = -64
+  if (leadz(i16) /= 0) call abort
+  if (trailz(i16) /= 6) call abort
+  if (leadz(-64_16) /= 0) call abort
+  if (trailz(-64_16) /= 6) call abort
+
+  i16 = -108
+  if (leadz(i16) /= 0) call abort
+  if (trailz(i16) /= 2) call abort
+  if (leadz(-108_16) /= 0) call abort
+  if (trailz(-108_16) /= 2) call abort
+
+  i16 = 1
+  if (leadz(i16) /= bit_size(i16) - 1) call abort
+  if (trailz(i16) /= 0) call abort
+  if (leadz(1_16) /= bit_size(1_16) - 1) call abort
+  if (trailz(1_16) /= 0) call abort
+
+  i16 = 64
+  if (leadz(i16) /= 121) call abort
+  if (trailz(i16) /= 6) call abort
+  if (leadz(64_16) /= 121) call abort
+  if (trailz(64_16) /= 6) call abort
+
+end
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/module_nan.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/module_nan.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/module_nan.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/module_nan.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 ! { dg-do run }
 ! { dg-options "-fno-range-check" }
 ! { dg-options "-fno-range-check -mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34318
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/namelist_42.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/namelist_42.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/namelist_42.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/namelist_42.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,5 +1,6 @@
 ! { dg-do run { target fd_truncate } }
 ! { dg-options "-mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34427
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/namelist_43.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/namelist_43.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/namelist_43.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/namelist_43.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,5 +1,6 @@
 ! { dg-do run { target fd_truncate } }
 ! { dg-options "-mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34427
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_1.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_1.f90	2009-04-22 04:35:25.000000000 -0700
@@ -3,6 +3,7 @@
 !
 ! { dg-do run }
 ! { dg-options "-pedantic-errors -mieee" { target alpha*-*-* sh*-*-* } } 
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 module aux2
   interface isnan
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_2.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_2.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 ! { dg-do run }
 ! { dg-options "-fno-range-check -pedantic" }
 ! { dg-options "-fno-range-check -pedantic -mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34333
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_3.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_3.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_3.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_3.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 ! { dg-do run }
 ! { dg-options "-fno-range-check" }
 ! { dg-options "-fno-range-check -mieee" { target alpha*-*-* sh*-*-* } }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34319
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_4.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_4.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nan_4.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/nan_4.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 ! { dg-do compile }
 ! { dg-options "-std=gnu" } 
 ! { dg-options "-std=gnu -mieee" { target alpha*-*-* sh*-*-* } } 
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34398.
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nearest_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/nearest_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nearest_1.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/nearest_1.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 ! { dg-do run }
 ! { dg-options "-O0 -ffloat-store" }
 ! { dg-options "-O0 -ffloat-store -mieee" { target alpha*-*-* } }
+! { dg-skip-if "Denormals not supported" { spu-*-* } { "*" } { "" } }
 ! PR fortran/27021
 ! Original code submitted by Dominique d'Humieres
 ! Converted to Dejagnu for the testsuite by Steven G. Kargl
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nearest_3.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/nearest_3.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/nearest_3.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/nearest_3.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,5 +1,6 @@
 ! { dg-do run }
 ! { dg-options "-pedantic-errors -mieee" { target alpha*-*-* sh*-*-* } } 
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 !
 ! PR fortran/34209
 !
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/open_errors.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/open_errors.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/open_errors.f90	2008-04-30 13:24:46.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/open_errors.f90	2009-05-09 20:35:53.000000000 -0700
@@ -1,6 +1,7 @@
-! { dg-do run { target { ! *-*-mingw* } } }
+! { dg-do run { target { ! { *-*-mingw* *-*-cygwin* spu-*-* } } } }
 ! PR30005 Enhanced error messages for OPEN
 ! Submitted by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+! See PR38956.  Test fails on cygwin when user has Administrator rights
 character(60) :: msg
 character(25) :: n = "temptestfile"
 logical :: there
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/pr20257.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/pr20257.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/pr20257.f90	2008-03-04 16:59:34.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/pr20257.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,4 +1,5 @@
 ! { dg-do run { target fd_truncate } }
+! { dg-skip-if "Too big for local store" { spu-*-* } { "*" } { "" } }
   integer,parameter :: n = 10000
   real(8) array(10000)
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/pr39666-1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/pr39666-1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/pr39666-1.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/pr39666-1.f90	2009-05-12 09:19:29.000000000 -0700
@@ -0,0 +1,14 @@
+! PR middle-end/39666
+! { dg-do compile }
+! { dg-options "-O2 -Wuninitialized" }
+
+FUNCTION f(n)
+  INTEGER, INTENT(in) :: n
+  REAL                :: f
+
+  SELECT CASE (n)
+    CASE (:-1); f = -1.0
+    CASE (0);   f =  0.0
+    CASE (1:);  f =  1.0
+  END SELECT
+END FUNCTION
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/pr39666-2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/pr39666-2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/pr39666-2.f90	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/pr39666-2.f90	2009-05-12 09:19:29.000000000 -0700
@@ -0,0 +1,14 @@
+! PR middle-end/39666
+! { dg-do compile }
+! { dg-options "-O2 -Wuninitialized" }
+
+FUNCTION f(n)	! { dg-warning "may be used uninitialized" }
+  INTEGER, INTENT(in) :: n
+  REAL                :: f
+
+  SELECT CASE (n)
+    CASE (:-1); f = -1.0
+    CASE (0);   f =  0.0
+    CASE (2:);  f =  1.0
+  END SELECT
+END FUNCTION
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/real_const_3.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/real_const_3.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/real_const_3.f90	2008-12-09 23:49:40.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/real_const_3.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,6 +1,7 @@
 !{ dg-do run }
 !{ dg-options "-fno-range-check" }
 !{ dg-options "-fno-range-check -mieee" { target alpha*-*-* sh*-*-* } }
+!{ dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 ! PR19310 and PR19904, allow disabling range check during compile.
 ! Contributed by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 program main
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/scalar_mask_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/scalar_mask_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/scalar_mask_2.f90	2006-03-20 13:56:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/scalar_mask_2.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,4 +1,5 @@
-! { dg-do run }
+! { dg-do run { xfail spu-*-* } }
+! FAILs on SPU because of rounding error reading kinds.h
 program main
   ! Test scalar masks for different intrinsics.
   real, dimension(2,2) :: a
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/stat_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/stat_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/stat_1.f90	2008-05-18 10:55:39.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/stat_1.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,5 +1,5 @@
 ! { dg-do run { target fd_truncate } }
-! { dg-skip-if "" { *-*-mingw* } { "*" } { "" } }
+! { dg-skip-if "" { *-*-mingw* spu-*-* } { "*" } { "" } }
 ! { dg-options "-std=gnu" }
   character(len=*), parameter :: f = "testfile"
   integer :: s1(13), r1, s2(13), r2, s3(13), r3
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/stat_2.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/stat_2.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/stat_2.f90	2008-05-18 10:55:39.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/stat_2.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,5 +1,5 @@
 ! { dg-do run { target fd_truncate } }
-! { dg-skip-if "" { *-*-mingw* } { "*" } { "" } }
+! { dg-skip-if "" { *-*-mingw* spu-*-* } { "*" } { "" } }
 ! { dg-options "-std=gnu" }
   character(len=*), parameter :: f = "testfile"
   integer :: s1(13), r1, s2(13), r2, s3(13), r3
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/transfer_simplify_1.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/transfer_simplify_1.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/transfer_simplify_1.f90	2007-05-15 22:40:51.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/transfer_simplify_1.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,5 +1,6 @@
 ! { dg-do run }
 ! { dg-options "-O2" }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
 ! Tests that the PRs caused by the lack of gfc_simplify_transfer are
 ! now fixed. These were brought together in the meta-bug PR31237
 ! (TRANSFER intrinsic).
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/vect/pr39318.f90 gcc-4.4.0/gcc/testsuite/gfortran.dg/vect/pr39318.f90
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.dg/vect/pr39318.f90	2009-03-02 03:52:15.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.dg/vect/pr39318.f90	2009-04-22 04:35:25.000000000 -0700
@@ -1,4 +1,4 @@
-! { dg-do compile } 
+! { dg-do compile { target fopenmp } } 
 ! { dg-options "-c -fopenmp -fexceptions -O2 -ftree-vectorize" } 
 
       subroutine adw_trajsp (F_u,i0,in,j0,jn)
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/compile/pr39937.f gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/compile/pr39937.f
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/compile/pr39937.f	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/compile/pr39937.f	2009-04-29 07:54:54.000000000 -0700
@@ -0,0 +1,28 @@
+      SUBROUTINE DTREVC( SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR,
+     $                   LDVR, MM, M, WORK, INFO )
+      DOUBLE PRECISION   T( LDT, * ), VL( LDVL, * ), VR( LDVR, * ),
+     $                   WORK( * )
+      DOUBLE PRECISION   X( 2, 2 )
+      CALL DLALN2( .FALSE., 1, 1, SMIN, ONE, T( J, J ),
+     $                            ZERO, X, 2, SCALE, XNORM, IERR )
+      CALL DSCAL( KI, SCALE, WORK( 1+N ), 1 )
+      DO 90 J = KI - 2, 1, -1
+      IF( J.GT.JNXT )
+     $               GO TO 90
+      JNXT = J - 1
+      IF( J.GT.1 ) THEN
+          IF( T( J, J-1 ).NE.ZERO ) THEN
+              IF( WORK( J ).GT.BIGNUM / XNORM ) THEN
+                  X( 1, 1 ) = X( 1, 1 ) / XNORM
+              END IF
+          END IF
+          CALL DLALN2( .FALSE., 2, 2, SMIN, ONE,
+     $                            T( J-1, J-1 ), LDT, ONE, ONE,
+     $                            XNORM, IERR )
+          CALL DAXPY( J-2, -X( 1, 1 ), T( 1, J-1 ), 1,
+     $                           WORK( 1+N ), 1 )
+          CALL DAXPY( J-2, -X( 2, 2 ), T( 1, J ), 1,
+     $                           WORK( 1+N2 ), 1 )
+      END IF
+   90          CONTINUE
+      END
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/getarg_1.x gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/getarg_1.x
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/getarg_1.x	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/getarg_1.x	2009-04-22 04:35:25.000000000 -0700
@@ -0,0 +1,5 @@
+if [istarget "spu-*-*"] {
+    # We need -mstdmain to enable argument processing on SPU.
+    lappend additional_flags "-mstdmain"
+}
+return 0
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x	2004-09-12 11:07:28.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_nearest.x	2009-04-22 04:35:25.000000000 -0700
@@ -1,2 +1,6 @@
+if [istarget "spu-*-*"] {
+    # No Inf/NaN support on SPU.
+    return 1
+}
 add-ieee-options
 return 0
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_set_exponent.x gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_set_exponent.x
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_set_exponent.x	2004-09-12 11:07:28.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_set_exponent.x	2009-04-22 04:35:25.000000000 -0700
@@ -1,2 +1,6 @@
+if [istarget "spu-*-*"] {
+    # No denormal support on SPU.
+    return 1
+}
 add-ieee-options
 return 0
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/nan_inf_fmt.x gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/nan_inf_fmt.x
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/nan_inf_fmt.x	2004-09-12 11:07:28.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/nan_inf_fmt.x	2009-04-22 04:35:25.000000000 -0700
@@ -1,2 +1,6 @@
+if [istarget "spu-*-*"] {
+    # No Inf/NaN support on SPU.
+    return 1
+}
 add-ieee-options
 return 0
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/pr40021.f gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/pr40021.f
--- gcc-4.4.0.orig/gcc/testsuite/gfortran.fortran-torture/execute/pr40021.f	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gfortran.fortran-torture/execute/pr40021.f	2009-05-06 10:45:40.000000000 -0700
@@ -0,0 +1,40 @@
+C Derived from lapack
+        PROGRAM test
+        DOUBLE PRECISION DA
+        INTEGER I, N
+        DOUBLE PRECISION DX(9),DY(9)
+
+        EXTERNAL DAXPY
+        N=5
+        DA=1.0
+        DATA DX/-2, -1, -3, -4, 1, 2, 10, 15, 14/
+        DATA DY/0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0/
+        CALL DAXPY (N,DA,DX,DY)
+        DO 10 I = 1, N
+          if (DX(I).ne.DY(I)) call abort
+10      CONTINUE
+        STOP
+        END
+
+      SUBROUTINE DAXPY(N,DA,DX,DY)
+      DOUBLE PRECISION DA
+      INTEGER N
+      DOUBLE PRECISION DX(*),DY(*)
+      INTEGER I,IX,IY,M,MP1
+      INTRINSIC MOD
+      IF (N.LE.0) RETURN
+   20 M = MOD(N,4)
+      IF (M.EQ.0) GO TO 40
+      DO 30 I = 1,M
+          DY(I) = DY(I) + DA*DX(I)
+   30 CONTINUE
+      IF (N.LT.4) RETURN
+   40 MP1 = M + 1
+      DO 50 I = MP1,N,4
+          DY(I) = DY(I) + DA*DX(I)
+          DY(I+1) = DY(I+1) + DA*DX(I+1)
+          DY(I+2) = DY(I+2) + DA*DX(I+2)
+          DY(I+3) = DY(I+3) + DA*DX(I+3)
+   50 CONTINUE
+      RETURN
+      END
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gnat.dg/enum2.adb gcc-4.4.0/gcc/testsuite/gnat.dg/enum2.adb
--- gcc-4.4.0.orig/gcc/testsuite/gnat.dg/enum2.adb	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gnat.dg/enum2.adb	2009-04-22 15:33:59.000000000 -0700
@@ -0,0 +1,11 @@
+-- { dg-do run }
+-- { dg-options "-gnat05 -O2" }
+
+with Enum2_Pkg; use Enum2_Pkg;
+
+procedure Enum2 is
+  type Enum is (A, B, C, D);
+  Table : array (B .. C, 1 .. 1) of F_String := (others => (others => Null_String));
+begin
+  Table := (others => (others => Null_String));
+end;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/gnat.dg/enum2_pkg.ads gcc-4.4.0/gcc/testsuite/gnat.dg/enum2_pkg.ads
--- gcc-4.4.0.orig/gcc/testsuite/gnat.dg/enum2_pkg.ads	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/gnat.dg/enum2_pkg.ads	2009-04-22 15:33:59.000000000 -0700
@@ -0,0 +1,8 @@
+with Ada.Finalization; use Ada.Finalization;
+
+package Enum2_Pkg is
+  type F_String is new Controlled with record
+    Data : access String;
+  end record;
+  Null_String : constant F_String := (Controlled with Data => null);
+end Enum2_Pkg;
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.old-deja/g++.brendan/array1.C gcc-4.4.0/gcc/testsuite/g++.old-deja/g++.brendan/array1.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.old-deja/g++.brendan/array1.C	2003-04-30 19:02:59.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.old-deja/g++.brendan/array1.C	2009-05-26 23:37:45.000000000 -0700
@@ -3,5 +3,5 @@
 // GROUPS passed array-bindings
 
 extern "C" int printf (const char *, ...);
-char array[~(~0ul>>1)|~(0ul>>3)];  // { dg-error "" } overflow in array dimension.*
+char array[~(~((__SIZE_TYPE__)0ul)>>1)|~(((__SIZE_TYPE__)0ul)>>3)];  // { dg-error "" } overflow in array dimension.*
 int main () { printf ("PASS\n"); return 0; }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C gcc-4.4.0/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C	2003-04-30 19:02:59.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C	2009-05-26 23:37:45.000000000 -0700
@@ -1,6 +1,6 @@
 // { dg-do assemble  }
 // GROUPS passed old-abort
-typedef long unsigned int size_t;
+typedef __SIZE_TYPE__ size_t;
 typedef void (*RF_Ptr)(void *);
 
 struct _im_pers_mem_spec {
@@ -9,7 +9,7 @@
 };
 
 struct _type_desc {
-  _type_desc(char *, int , RF_Ptr , int , int ,...);
+  _type_desc(const char *, int , RF_Ptr , int , int ,...);
 };
 
 struct metatype { int base_list; };
diff -Naur gcc-4.4.0.orig/gcc/testsuite/g++.old-deja/g++.jason/new3.C gcc-4.4.0/gcc/testsuite/g++.old-deja/g++.jason/new3.C
--- gcc-4.4.0.orig/gcc/testsuite/g++.old-deja/g++.jason/new3.C	2003-04-30 19:02:59.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/g++.old-deja/g++.jason/new3.C	2009-05-26 23:37:45.000000000 -0700
@@ -1,5 +1,5 @@
 // { dg-do run  }
-// { dg-options "-fcheck-new -pedantic" }
+// { dg-options "-fcheck-new -pedantic -Wno-long-long" }
 // PRMS Id: 6037
 
 extern "C" void * malloc (__SIZE_TYPE__);
diff -Naur gcc-4.4.0.orig/gcc/testsuite/lib/gcc-defs.exp gcc-4.4.0/gcc/testsuite/lib/gcc-defs.exp
--- gcc-4.4.0.orig/gcc/testsuite/lib/gcc-defs.exp	2009-03-19 15:10:22.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/lib/gcc-defs.exp	2009-04-22 04:35:25.000000000 -0700
@@ -155,6 +155,10 @@
     if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $output] {
 	return "memory full"
     }
+    if {[istarget spu-*-*] && \
+            [string match "*exceeds local store*" $output]} {
+	return "memory full"
+    }
     return ""
 }
 
diff -Naur gcc-4.4.0.orig/gcc/testsuite/lib/gcc-dg.exp gcc-4.4.0/gcc/testsuite/lib/gcc-dg.exp
--- gcc-4.4.0.orig/gcc/testsuite/lib/gcc-dg.exp	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/lib/gcc-dg.exp	2009-04-22 04:35:25.000000000 -0700
@@ -186,7 +186,7 @@
     # Likewise, if we see ".text exceeds local store range" or
     # similar.
     if {[string match "spu-*" $system] && \
-	    [string match "*exceeds local store range*" $text]} {
+	    [string match "*exceeds local store*" $text]} {
 	# The format here is important.  See dg.exp.
 	return "::unsupported::memory full"
     }
diff -Naur gcc-4.4.0.orig/gcc/testsuite/lib/gfortran.exp gcc-4.4.0/gcc/testsuite/lib/gfortran.exp
--- gcc-4.4.0.orig/gcc/testsuite/lib/gfortran.exp	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/testsuite/lib/gfortran.exp	2009-04-22 04:35:25.000000000 -0700
@@ -27,6 +27,7 @@
 load_lib gcc-defs.exp
 load_lib timeout.exp
 load_lib target-libpath.exp
+load_lib target-supports.exp
 
 #
 # GFORTRAN_UNDER_TEST is the compiler under test.
@@ -177,6 +178,13 @@
 	lappend ALWAYS_GFORTRANFLAGS "additional_flags=$TOOL_OPTIONS"
     }
 
+    # On the SPU, most of the fortran test cases exceed local store size.
+    # Use automatic overlay support to make them fit.
+    if { [check_effective_target_spu_auto_overlay] } {
+	lappend ALWAYS_GFORTRANFLAGS "ldflags=-Wl,--auto-overlay"
+	lappend ALWAYS_GFORTRANFLAGS "ldflags=-Wl,--reserved-space=131072"
+    }
+
     verbose -log "ALWAYS_GFORTRANFLAGS set to $ALWAYS_GFORTRANFLAGS"
 
     verbose "gfortran is initialized" 3
diff -Naur gcc-4.4.0.orig/gcc/testsuite/lib/target-supports.exp gcc-4.4.0/gcc/testsuite/lib/target-supports.exp
--- gcc-4.4.0.orig/gcc/testsuite/lib/target-supports.exp	2009-03-16 14:11:57.000000000 -0700
+++ gcc-4.4.0/gcc/testsuite/lib/target-supports.exp	2009-05-12 01:41:28.000000000 -0700
@@ -466,6 +466,11 @@
 	return 0
     }
 
+    # cygwin does not support -p.
+    if { [istarget *-*-cygwin*] && [lindex $test_what 1] == "-p" } {
+	return 0
+    }
+
     # uClibc does not have gcrt1.o.
     if { [check_effective_target_uclibc]
 	 && ([lindex $test_what 1] == "-p"
@@ -544,8 +549,6 @@
 }
 
 # Return 1 if thread local storage (TLS) is supported, 0 otherwise.
-#
-# This won't change for different subtargets so cache the result.
 
 proc check_effective_target_tls {} {
     return [check_no_compiler_messages tls assembly {
@@ -556,8 +559,6 @@
 }
 
 # Return 1 if *native* thread local storage (TLS) is supported, 0 otherwise.
-#
-# This won't change for different subtargets so cache the result.
 
 proc check_effective_target_tls_native {} {
     # VxWorks uses emulated TLS machinery, but with non-standard helper
@@ -575,8 +576,6 @@
 }
 
 # Return 1 if TLS executables can run correctly, 0 otherwise.
-#
-# This won't change for different subtargets so cache the result.
 
 proc check_effective_target_tls_runtime {} {
     return [check_runtime tls_runtime {
diff -Naur gcc-4.4.0.orig/gcc/toplev.c gcc-4.4.0/gcc/toplev.c
--- gcc-4.4.0.orig/gcc/toplev.c	2008-12-09 13:25:11.000000000 -0800
+++ gcc-4.4.0/gcc/toplev.c	2009-04-28 21:57:17.000000000 -0700
@@ -1128,10 +1128,14 @@
 	   indent, __VERSION__);
 
   /* We need to stringify the GMP macro values.  Ugh, gmp_version has
-     two string formats, "i.j.k" and "i.j" when k is zero.  */
+     two string formats, "i.j.k" and "i.j" when k is zero.  As of
+     gmp-4.3.0, GMP always uses the 3 number format.  */
 #define GCC_GMP_STRINGIFY_VERSION3(X) #X
 #define GCC_GMP_STRINGIFY_VERSION2(X) GCC_GMP_STRINGIFY_VERSION3(X)
-#if __GNU_MP_VERSION_PATCHLEVEL == 0
+#define GCC_GMP_VERSION_NUM(X,Y,Z) (((X) << 16L) | ((Y) << 8) | (Z))
+#define GCC_GMP_VERSION \
+  GCC_GMP_VERSION_NUM(__GNU_MP_VERSION, __GNU_MP_VERSION_MINOR, __GNU_MP_VERSION_PATCHLEVEL)
+#if GCC_GMP_VERSION < GCC_GMP_VERSION_NUM(4,3,0) && __GNU_MP_VERSION_PATCHLEVEL == 0
 #define GCC_GMP_STRINGIFY_VERSION GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION) "." \
   GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION_MINOR)
 #else
diff -Naur gcc-4.4.0.orig/gcc/tree.h gcc-4.4.0/gcc/tree.h
--- gcc-4.4.0.orig/gcc/tree.h	2009-03-23 09:29:33.000000000 -0700
+++ gcc-4.4.0/gcc/tree.h	2009-06-02 00:18:16.000000000 -0700
@@ -5088,7 +5088,7 @@
 
 /* Generate a new label for the CFI info to refer to.  */
 
-extern char *dwarf2out_cfi_label (void);
+extern char *dwarf2out_cfi_label (bool);
 
 /* Entry point to update the canonical frame address (CFA).  */
 
@@ -5256,6 +5256,9 @@
 
 void init_inline_once (void);
 
+/* In ipa-reference.c.  Used for parsing attributes of asm code.  */
+extern GTY(()) tree memory_identifier_string;
+
 /* Compute the number of operands in an expression node NODE.  For 
    tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,
    otherwise it is looked up from the node's code.  */
diff -Naur gcc-4.4.0.orig/gcc/tree-inline.c gcc-4.4.0/gcc/tree-inline.c
--- gcc-4.4.0.orig/gcc/tree-inline.c	2009-03-08 15:37:26.000000000 -0700
+++ gcc-4.4.0/gcc/tree-inline.c	2009-05-27 23:52:15.000000000 -0700
@@ -501,7 +501,7 @@
 	      && (var_ann (old_var) || !gimple_in_ssa_p (cfun)))
 	    cfun->local_decls = tree_cons (NULL_TREE, old_var,
 						   cfun->local_decls);
-	  if (debug_info_level > DINFO_LEVEL_TERSE
+	  if ((!optimize || debug_info_level > DINFO_LEVEL_TERSE)
 	      && !DECL_IGNORED_P (old_var)
 	      && nonlocalized_list)
 	    VEC_safe_push (tree, gc, *nonlocalized_list, origin_var);
@@ -519,7 +519,7 @@
 	;
       else if (!new_var)
         {
-	  if (debug_info_level > DINFO_LEVEL_TERSE
+	  if ((!optimize || debug_info_level > DINFO_LEVEL_TERSE)
 	      && !DECL_IGNORED_P (old_var)
 	      && nonlocalized_list)
 	    VEC_safe_push (tree, gc, *nonlocalized_list, origin_var);
diff -Naur gcc-4.4.0.orig/gcc/tree-scalar-evolution.c gcc-4.4.0/gcc/tree-scalar-evolution.c
--- gcc-4.4.0.orig/gcc/tree-scalar-evolution.c	2009-03-04 09:50:20.000000000 -0800
+++ gcc-4.4.0/gcc/tree-scalar-evolution.c	2009-05-08 05:28:01.000000000 -0700
@@ -1320,11 +1320,7 @@
 
   *evolution_of_loop = evolution_of_branch;
 
-  /* If the phi node is just a copy, do not increase the limit.  */
   n = gimple_phi_num_args (condition_phi);
-  if (n > 1)
-    limit++;
-
   for (i = 1; i < n; i++)
     {
       /* Quickly give up when the evolution of one of the branches is
@@ -1332,10 +1328,12 @@
       if (*evolution_of_loop == chrec_dont_know)
 	return t_true;
 
+      /* Increase the limit by the PHI argument number to avoid exponential
+	 time and memory complexity.  */
       res = follow_ssa_edge_in_condition_phi_branch (i, loop, condition_phi,
 						     halting_phi,
 						     &evolution_of_branch,
-						     init, limit);
+						     init, limit + i);
       if (res == t_false || res == t_dont_know)
 	return res;
 
diff -Naur gcc-4.4.0.orig/gcc/tree-ssa-ccp.c gcc-4.4.0/gcc/tree-ssa-ccp.c
--- gcc-4.4.0.orig/gcc/tree-ssa-ccp.c	2009-04-16 02:39:20.000000000 -0700
+++ gcc-4.4.0/gcc/tree-ssa-ccp.c	2009-04-22 12:55:24.000000000 -0700
@@ -1290,7 +1290,9 @@
 	if (TREE_CODE (base) == SSA_NAME
 	    && (value = get_value (base))
 	    && value->lattice_val == CONSTANT
-	    && TREE_CODE (value->value) == ADDR_EXPR)
+	    && TREE_CODE (value->value) == ADDR_EXPR
+	    && useless_type_conversion_p (TREE_TYPE (t),
+					  TREE_TYPE (TREE_TYPE (value->value))))
 	  return fold_const_aggregate_ref (TREE_OPERAND (value->value, 0));
 	break;
       }
diff -Naur gcc-4.4.0.orig/gcc/tree-ssa-forwprop.c gcc-4.4.0/gcc/tree-ssa-forwprop.c
--- gcc-4.4.0.orig/gcc/tree-ssa-forwprop.c	2009-02-20 07:20:38.000000000 -0800
+++ gcc-4.4.0/gcc/tree-ssa-forwprop.c	2009-05-19 04:54:16.000000000 -0700
@@ -683,6 +683,7 @@
   tree *rhsp, *lhsp;
   gimple use_stmt = gsi_stmt (*use_stmt_gsi);
   enum tree_code rhs_code;
+  bool res = true;
 
   gcc_assert (TREE_CODE (def_rhs) == ADDR_EXPR);
 
@@ -726,19 +727,26 @@
   /* Now see if the LHS node is an INDIRECT_REF using NAME.  If so, 
      propagate the ADDR_EXPR into the use of NAME and fold the result.  */
   if (TREE_CODE (lhs) == INDIRECT_REF
-      && TREE_OPERAND (lhs, 0) == name
-      && may_propagate_address_into_dereference (def_rhs, lhs)
-      && (lhsp != gimple_assign_lhs_ptr (use_stmt)
-	  || useless_type_conversion_p (TREE_TYPE (TREE_OPERAND (def_rhs, 0)),
-					TREE_TYPE (rhs))))
+      && TREE_OPERAND (lhs, 0) == name)
     {
-      *lhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));
-      fold_stmt_inplace (use_stmt);
-      tidy_after_forward_propagate_addr (use_stmt);
+      if (may_propagate_address_into_dereference (def_rhs, lhs)
+	  && (lhsp != gimple_assign_lhs_ptr (use_stmt)
+	      || useless_type_conversion_p
+	           (TREE_TYPE (TREE_OPERAND (def_rhs, 0)), TREE_TYPE (rhs))))
+	{
+	  *lhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));
+	  fold_stmt_inplace (use_stmt);
+	  tidy_after_forward_propagate_addr (use_stmt);
 
-      /* Continue propagating into the RHS if this was not the only use.  */
-      if (single_use_p)
-	return true;
+	  /* Continue propagating into the RHS if this was not the only use.  */
+	  if (single_use_p)
+	    return true;
+	}
+      else
+	/* We can have a struct assignment dereferencing our name twice.
+	   Note that we didn't propagate into the lhs to not falsely
+	   claim we did when propagating into the rhs.  */
+	res = false;
     }
 
   /* Strip away any outer COMPONENT_REF, ARRAY_REF or ADDR_EXPR
@@ -758,7 +766,7 @@
       *rhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));
       fold_stmt_inplace (use_stmt);
       tidy_after_forward_propagate_addr (use_stmt);
-      return true;
+      return res;
     }
 
   /* Now see if the RHS node is an INDIRECT_REF using NAME.  If so, 
@@ -789,7 +797,7 @@
 					     true, GSI_NEW_STMT);
 	 gimple_assign_set_rhs1 (use_stmt, new_rhs);
 	 tidy_after_forward_propagate_addr (use_stmt);
-	 return true;
+	 return res;
        }
      /* If the defining rhs comes from an indirect reference, then do not
         convert into a VIEW_CONVERT_EXPR.  */
@@ -803,7 +811,7 @@
 	 *rhsp = new_rhs;
 	 fold_stmt_inplace (use_stmt);
 	 tidy_after_forward_propagate_addr (use_stmt);
-	 return true;
+	 return res;
        }
    }
 
diff -Naur gcc-4.4.0.orig/gcc/tree-ssa-live.c gcc-4.4.0/gcc/tree-ssa-live.c
--- gcc-4.4.0.orig/gcc/tree-ssa-live.c	2009-03-17 10:53:01.000000000 -0700
+++ gcc-4.4.0/gcc/tree-ssa-live.c	2009-05-27 23:49:43.000000000 -0700
@@ -595,6 +595,8 @@
    /* Verfify that only blocks with source location set
       are entry points to the inlined functions.  */
      gcc_assert (BLOCK_SOURCE_LOCATION (scope) == UNKNOWN_LOCATION);
+
+   TREE_USED (scope) = !unused;
    return unused;
 }
 
@@ -678,6 +680,12 @@
   var_ann_t ann;
   bitmap global_unused_vars = NULL;
 
+  /* Removing declarations from lexical blocks when not optimizing is
+     not only a waste of time, it actually causes differences in stack
+     layout.  */
+  if (!optimize)
+    return;
+
   mark_scope_block_unused (DECL_INITIAL (current_function_decl));
 
   /* Assume all locals are unused.  */
@@ -740,8 +748,7 @@
 
       if (TREE_CODE (var) != FUNCTION_DECL
 	  && (!(ann = var_ann (var))
-	      || !ann->used)
-	  && (optimize || DECL_ARTIFICIAL (var)))
+	      || !ann->used))
 	{
 	  if (is_global_var (var))
 	    {
@@ -802,8 +809,7 @@
 	&& TREE_CODE (t) != RESULT_DECL
 	&& !(ann = var_ann (t))->used
 	&& !ann->symbol_mem_tag
-	&& !TREE_ADDRESSABLE (t)
-	&& (optimize || DECL_ARTIFICIAL (t)))
+	&& !TREE_ADDRESSABLE (t))
       remove_referenced_var (t);
   remove_unused_scope_block_p (DECL_INITIAL (current_function_decl));
   if (dump_file && (dump_flags & TDF_DETAILS))
diff -Naur gcc-4.4.0.orig/gcc/tree-ssa-loop-niter.c gcc-4.4.0/gcc/tree-ssa-loop-niter.c
--- gcc-4.4.0.orig/gcc/tree-ssa-loop-niter.c	2009-03-16 09:07:07.000000000 -0700
+++ gcc-4.4.0/gcc/tree-ssa-loop-niter.c	2009-05-22 13:43:39.000000000 -0700
@@ -534,7 +534,7 @@
 }
 
 /* Derives the upper bound BND on the number of executions of loop with exit
-   condition S * i <> C, assuming that the loop is not infinite.  If
+   condition S * i <> C, assuming that this exit is taken.  If
    NO_OVERFLOW is true, then the control variable of the loop does not
    overflow.  If NO_OVERFLOW is true or BNDS.below >= 0, then BNDS.up
    contains the upper bound on the value of C.  */
@@ -574,7 +574,7 @@
 
 /* Determines number of iterations of loop whose ending condition
    is IV <> FINAL.  TYPE is the type of the iv.  The number of
-   iterations is stored to NITER.  NEVER_INFINITE is true if
+   iterations is stored to NITER.  EXIT_MUST_BE_TAKEN is true if
    we know that the exit must be taken eventually, i.e., that the IV
    ever reaches the value FINAL (we derived this earlier, and possibly set
    NITER->assumptions to make sure this is the case).  BNDS contains the
@@ -582,7 +582,7 @@
 
 static bool
 number_of_iterations_ne (tree type, affine_iv *iv, tree final,
-			 struct tree_niter_desc *niter, bool never_infinite,
+			 struct tree_niter_desc *niter, bool exit_must_be_taken,
 			 bounds *bnds)
 {
   tree niter_type = unsigned_type_for (type);
@@ -639,9 +639,9 @@
 			       build_int_cst (niter_type, 1), bits);
   s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, s, bits);
 
-  if (!never_infinite)
+  if (!exit_must_be_taken)
     {
-      /* If we cannot assume that the loop is not infinite, record the
+      /* If we cannot assume that the exit is taken eventually, record the
 	 assumptions for divisibility of c.  */
       assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, c, d);
       assumption = fold_build2 (EQ_EXPR, boolean_type_node,
@@ -664,20 +664,21 @@
    of the final value does not overflow are recorded in NITER.  If we
    find the final value, we adjust DELTA and return TRUE.  Otherwise
    we return false.  BNDS bounds the value of IV1->base - IV0->base,
-   and will be updated by the same amount as DELTA.  */
+   and will be updated by the same amount as DELTA.  EXIT_MUST_BE_TAKEN is
+   true if we know that the exit must be taken eventually.  */
 
 static bool
 number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,
 			       struct tree_niter_desc *niter,
 			       tree *delta, tree step,
-			       bounds *bnds)
+			       bool exit_must_be_taken, bounds *bnds)
 {
   tree niter_type = TREE_TYPE (step);
   tree mod = fold_build2 (FLOOR_MOD_EXPR, niter_type, *delta, step);
   tree tmod;
   mpz_t mmod;
   tree assumption = boolean_true_node, bound, noloop;
-  bool ret = false;
+  bool ret = false, fv_comp_no_overflow;
   tree type1 = type;
   if (POINTER_TYPE_P (type))
     type1 = sizetype;
@@ -692,17 +693,31 @@
   mpz_set_double_int (mmod, tree_to_double_int (mod), true);
   mpz_neg (mmod, mmod);
 
+  /* If the induction variable does not overflow and the exit is taken,
+     then the computation of the final value does not overflow.  This is
+     also obviously the case if the new final value is equal to the
+     current one.  Finally, we postulate this for pointer type variables,
+     as the code cannot rely on the object to that the pointer points being
+     placed at the end of the address space (and more pragmatically,
+     TYPE_{MIN,MAX}_VALUE is not defined for pointers).  */
+  if (integer_zerop (mod) || POINTER_TYPE_P (type))
+    fv_comp_no_overflow = true;
+  else if (!exit_must_be_taken)
+    fv_comp_no_overflow = false;
+  else
+    fv_comp_no_overflow =
+	    (iv0->no_overflow && integer_nonzerop (iv0->step))
+	    || (iv1->no_overflow && integer_nonzerop (iv1->step));
+
   if (integer_nonzerop (iv0->step))
     {
       /* The final value of the iv is iv1->base + MOD, assuming that this
 	 computation does not overflow, and that
 	 iv0->base <= iv1->base + MOD.  */
-      if (!iv0->no_overflow && !integer_zerop (mod))
+      if (!fv_comp_no_overflow)
 	{
 	  bound = fold_build2 (MINUS_EXPR, type1,
 			       TYPE_MAX_VALUE (type1), tmod);
-	  if (POINTER_TYPE_P (type))
-	    bound = fold_convert (type, bound);
 	  assumption = fold_build2 (LE_EXPR, boolean_type_node,
 				    iv1->base, bound);
 	  if (integer_zerop (assumption))
@@ -726,12 +741,10 @@
       /* The final value of the iv is iv0->base - MOD, assuming that this
 	 computation does not overflow, and that
 	 iv0->base - MOD <= iv1->base. */
-      if (!iv1->no_overflow && !integer_zerop (mod))
+      if (!fv_comp_no_overflow)
 	{
 	  bound = fold_build2 (PLUS_EXPR, type1,
 			       TYPE_MIN_VALUE (type1), tmod);
-	  if (POINTER_TYPE_P (type))
-	    bound = fold_convert (type, bound);
 	  assumption = fold_build2 (GE_EXPR, boolean_type_node,
 				    iv0->base, bound);
 	  if (integer_zerop (assumption))
@@ -969,13 +982,13 @@
 /* Determines number of iterations of loop whose ending condition
    is IV0 < IV1.  TYPE is the type of the iv.  The number of
    iterations is stored to NITER.  BNDS bounds the difference
-   IV1->base - IV0->base.  */
+   IV1->base - IV0->base.  EXIT_MUST_BE_TAKEN is true if we know
+   that the exit must be taken eventually.  */
 
 static bool
 number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,
 			 struct tree_niter_desc *niter,
-			 bool never_infinite ATTRIBUTE_UNUSED,
-			 bounds *bnds)
+			 bool exit_must_be_taken, bounds *bnds)
 {
   tree niter_type = unsigned_type_for (type);
   tree delta, step, s;
@@ -1034,7 +1047,7 @@
      transform the condition to != comparison.  In particular, this will be
      the case if DELTA is constant.  */
   if (number_of_iterations_lt_to_ne (type, iv0, iv1, niter, &delta, step,
-				     bnds))
+				     exit_must_be_taken, bnds))
     {
       affine_iv zps;
 
@@ -1076,14 +1089,14 @@
 
 /* Determines number of iterations of loop whose ending condition
    is IV0 <= IV1.  TYPE is the type of the iv.  The number of
-   iterations is stored to NITER.  NEVER_INFINITE is true if
+   iterations is stored to NITER.  EXIT_MUST_BE_TAKEN is true if
    we know that this condition must eventually become false (we derived this
    earlier, and possibly set NITER->assumptions to make sure this
    is the case).  BNDS bounds the difference IV1->base - IV0->base.  */
 
 static bool
 number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,
-			 struct tree_niter_desc *niter, bool never_infinite,
+			 struct tree_niter_desc *niter, bool exit_must_be_taken,
 			 bounds *bnds)
 {
   tree assumption;
@@ -1094,9 +1107,13 @@
   /* Say that IV0 is the control variable.  Then IV0 <= IV1 iff
      IV0 < IV1 + 1, assuming that IV1 is not equal to the greatest
      value of the type.  This we must know anyway, since if it is
-     equal to this value, the loop rolls forever.  */
+     equal to this value, the loop rolls forever.  We do not check
+     this condition for pointer type ivs, as the code cannot rely on 
+     the object to that the pointer points being placed at the end of
+     the address space (and more pragmatically, TYPE_{MIN,MAX}_VALUE is
+     not defined for pointers).  */
 
-  if (!never_infinite)
+  if (!exit_must_be_taken && !POINTER_TYPE_P (type))
     {
       if (integer_nonzerop (iv0->step))
 	assumption = fold_build2 (NE_EXPR, boolean_type_node,
@@ -1131,7 +1148,8 @@
 
   bounds_add (bnds, double_int_one, type1);
 
-  return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite, bnds);
+  return number_of_iterations_lt (type, iv0, iv1, niter, exit_must_be_taken,
+				  bnds);
 }
 
 /* Dumps description of affine induction variable IV to FILE.  */
@@ -1177,7 +1195,7 @@
 			   affine_iv *iv1, struct tree_niter_desc *niter,
 			   bool only_exit)
 {
-  bool never_infinite, ret;
+  bool exit_must_be_taken = false, ret;
   bounds bnds;
 
   /* The meaning of these assumptions is this:
@@ -1202,42 +1220,27 @@
       code = swap_tree_comparison (code);
     }
 
-  if (!only_exit)
-    {
-      /* If this is not the only possible exit from the loop, the information
-	 that the induction variables cannot overflow as derived from
-	 signedness analysis cannot be relied upon.  We use them e.g. in the
-	 following way:  given loop for (i = 0; i <= n; i++), if i is
-	 signed, it cannot overflow, thus this loop is equivalent to
-	 for (i = 0; i < n + 1; i++);  however, if n == MAX, but the loop
-	 is exited in some other way before i overflows, this transformation
-	 is incorrect (the new loop exits immediately).  */
-      iv0->no_overflow = false;
-      iv1->no_overflow = false;
-    }
-
   if (POINTER_TYPE_P (type))
     {
       /* Comparison of pointers is undefined unless both iv0 and iv1 point
 	 to the same object.  If they do, the control variable cannot wrap
 	 (as wrap around the bounds of memory will never return a pointer
 	 that would be guaranteed to point to the same object, even if we
-	 avoid undefined behavior by casting to size_t and back).  The
-	 restrictions on pointer arithmetics and comparisons of pointers
-	 ensure that using the no-overflow assumptions is correct in this
-	 case even if ONLY_EXIT is false.  */
+	 avoid undefined behavior by casting to size_t and back).  */
       iv0->no_overflow = true;
       iv1->no_overflow = true;
     }
 
-  /* If the control induction variable does not overflow, the loop obviously
-     cannot be infinite.  */
-  if (!integer_zerop (iv0->step) && iv0->no_overflow)
-    never_infinite = true;
-  else if (!integer_zerop (iv1->step) && iv1->no_overflow)
-    never_infinite = true;
-  else
-    never_infinite = false;
+  /* If the control induction variable does not overflow and the only exit
+     from the loop is the one that we analyze, we know it must be taken
+     eventually.  */
+  if (only_exit)
+    {
+      if (!integer_zerop (iv0->step) && iv0->no_overflow)
+	exit_must_be_taken = true;
+      else if (!integer_zerop (iv1->step) && iv1->no_overflow)
+	exit_must_be_taken = true;
+    }
 
   /* We can handle the case when neither of the sides of the comparison is
      invariant, provided that the test is NE_EXPR.  This rarely occurs in
@@ -1308,16 +1311,16 @@
     case NE_EXPR:
       gcc_assert (integer_zerop (iv1->step));
       ret = number_of_iterations_ne (type, iv0, iv1->base, niter,
-				     never_infinite, &bnds);
+				     exit_must_be_taken, &bnds);
       break;
 
     case LT_EXPR:
-      ret = number_of_iterations_lt (type, iv0, iv1, niter, never_infinite,
+      ret = number_of_iterations_lt (type, iv0, iv1, niter, exit_must_be_taken,
 				     &bnds);
       break;
 
     case LE_EXPR:
-      ret = number_of_iterations_le (type, iv0, iv1, niter, never_infinite,
+      ret = number_of_iterations_le (type, iv0, iv1, niter, exit_must_be_taken,
 				     &bnds);
       break;
 
diff -Naur gcc-4.4.0.orig/gcc/tree-ssa-phiprop.c gcc-4.4.0/gcc/tree-ssa-phiprop.c
--- gcc-4.4.0.orig/gcc/tree-ssa-phiprop.c	2008-09-11 14:48:11.000000000 -0700
+++ gcc-4.4.0/gcc/tree-ssa-phiprop.c	2009-05-06 01:32:24.000000000 -0700
@@ -119,8 +119,7 @@
       FOR_EACH_IMM_USE_STMT (use_stmt, ui2, vuse)
 	{
 	  /* If BB does not dominate a VDEF, the value is invalid.  */
-	  if (((is_gimple_assign (use_stmt)
-	        && !ZERO_SSA_OPERANDS (use_stmt, SSA_OP_VDEF))
+	  if ((!ZERO_SSA_OPERANDS (use_stmt, SSA_OP_VDEF)
 	       || gimple_code (use_stmt) == GIMPLE_PHI)
 	      && !dominated_by_p (CDI_DOMINATORS, gimple_bb (use_stmt), bb))
 	    {
diff -Naur gcc-4.4.0.orig/gcc/tree-ssa-sccvn.c gcc-4.4.0/gcc/tree-ssa-sccvn.c
--- gcc-4.4.0.orig/gcc/tree-ssa-sccvn.c	2009-04-11 00:42:52.000000000 -0700
+++ gcc-4.4.0/gcc/tree-ssa-sccvn.c	2009-05-18 03:13:43.000000000 -0700
@@ -1293,7 +1293,7 @@
     *vnresult = NULL;
   vno1.opcode = gimple_assign_rhs_code (stmt);
   vno1.length = gimple_num_ops (stmt) - 1;
-  vno1.type = TREE_TYPE (gimple_assign_lhs (stmt));
+  vno1.type = gimple_expr_type (stmt);
   for (i = 0; i < vno1.length; ++i)
     vno1.op[i] = gimple_op (stmt, i + 1);
   if (vno1.opcode == REALPART_EXPR
@@ -1401,7 +1401,7 @@
   vno1->value_id = VN_INFO (result)->value_id;
   vno1->opcode = gimple_assign_rhs_code (stmt);
   vno1->length = length;
-  vno1->type = TREE_TYPE (gimple_assign_lhs (stmt));
+  vno1->type = gimple_expr_type (stmt);
   for (i = 0; i < vno1->length; ++i)
     vno1->op[i] = gimple_op (stmt, i + 1);
   if (vno1->opcode == REALPART_EXPR
@@ -2142,7 +2142,7 @@
   fold_defer_overflow_warnings ();
 
   result = fold_binary (gimple_assign_rhs_code (stmt),
-		        TREE_TYPE (gimple_get_lhs (stmt)), op0, op1);
+		        gimple_expr_type (stmt), op0, op1);
   if (result)
     STRIP_USELESS_TYPE_CONVERSION (result);
 
diff -Naur gcc-4.4.0.orig/gcc/tree-vect-analyze.c gcc-4.4.0/gcc/tree-vect-analyze.c
--- gcc-4.4.0.orig/gcc/tree-vect-analyze.c	2009-04-02 11:08:10.000000000 -0700
+++ gcc-4.4.0/gcc/tree-vect-analyze.c	2009-05-11 06:55:36.000000000 -0700
@@ -2187,7 +2187,7 @@
       tree next_step;
       tree prev_init = DR_INIT (data_ref);
       gimple prev = stmt;
-      HOST_WIDE_INT diff, count_in_bytes;
+      HOST_WIDE_INT diff, count_in_bytes, gaps = 0;
 
       while (next)
         {
@@ -2249,6 +2249,8 @@
 		    fprintf (vect_dump, "interleaved store with gaps");
 		  return false;
 		}
+
+              gaps += diff - 1;
 	    }
 
           /* Store the gap from the previous member of the group. If there is no
@@ -2265,8 +2267,9 @@
          the type to get COUNT_IN_BYTES.  */
       count_in_bytes = type_size * count;
 
-      /* Check that the size of the interleaving is not greater than STEP.  */
-      if (dr_step < count_in_bytes)
+      /* Check that the size of the interleaving (including gaps) is not greater
+         than STEP.  */
+      if (dr_step && dr_step < count_in_bytes + gaps * type_size)
         {
           if (vect_print_dump_info (REPORT_DETAILS))
             {
diff -Naur gcc-4.4.0.orig/gcc/version.c gcc-4.4.0/gcc/version.c
--- gcc-4.4.0.orig/gcc/version.c	2007-08-21 08:35:30.000000000 -0700
+++ gcc-4.4.0/gcc/version.c	2009-06-05 09:55:18.000000000 -0700
@@ -14,4 +14,4 @@
    Makefile.  */
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
-const char pkgversion_string[] = PKGVERSION;
+const char pkgversion_string[] = "(GCC for Cross-LFS 4.4.0.20090605) ";
diff -Naur gcc-4.4.0.orig/gnattools/Makefile.in gcc-4.4.0/gnattools/Makefile.in
--- gcc-4.4.0.orig/gnattools/Makefile.in	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/gnattools/Makefile.in	2009-05-18 00:41:14.000000000 -0700
@@ -164,7 +164,7 @@
 	-(cd $(GCC_DIR)/ada/tools; $(LN_S) ../sdefault.adb .)
 	-$(foreach PAIR,$(TOOLS_TARGET_PAIRS), \
 	          rm -f $(GCC_DIR)/ada/tools/$(word 1,$(subst <, ,$(PAIR)));\
-	          $(LN_S) $(fsrcdir)/$(word 2,$(subst <, ,$(PAIR))) \
+	          $(LN_S) $(fsrcdir)/ada/$(word 2,$(subst <, ,$(PAIR))) \
 	                $(GCC_DIR)/ada/tools/$(word 1,$(subst <, ,$(PAIR)));)
 	touch $(GCC_DIR)/stamp-tools
 
diff -Naur gcc-4.4.0.orig/libcpp/po/cpplib.pot gcc-4.4.0/libcpp/po/cpplib.pot
--- gcc-4.4.0.orig/libcpp/po/cpplib.pot	2009-03-28 00:26:17.000000000 -0700
+++ gcc-4.4.0/libcpp/po/cpplib.pot	2009-04-22 09:35:05.000000000 -0700
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
-"POT-Creation-Date: 2009-03-28 07:24+0000\n"
+"POT-Creation-Date: 2009-04-22 16:32+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -74,7 +74,7 @@
 msgstr ""
 
 #: charset.c:1039
-#: lex.c:485
+#: lex.c:486
 msgid "'$' in identifier or number"
 msgstr ""
 
@@ -398,8 +398,8 @@
 msgstr ""
 
 #: directives-only.c:222
-#: lex.c:1148
-#: traditional.c:162
+#: lex.c:1149
+#: traditional.c:163
 msgid "unterminated comment"
 msgstr ""
 
@@ -424,203 +424,203 @@
 msgid "%s: %s"
 msgstr ""
 
-#: expr.c:262
+#: expr.c:261
 msgid "too many decimal points in number"
 msgstr ""
 
-#: expr.c:291
-#: expr.c:366
+#: expr.c:290
+#: expr.c:365
 msgid "fixed-point constants are a GCC extension"
 msgstr ""
 
-#: expr.c:304
+#: expr.c:303
 #, c-format
 msgid "invalid digit \"%c\" in binary constant"
 msgstr ""
 
-#: expr.c:306
+#: expr.c:305
 #, c-format
 msgid "invalid digit \"%c\" in octal constant"
 msgstr ""
 
-#: expr.c:314
+#: expr.c:313
 msgid "invalid prefix \"0b\" for floating constant"
 msgstr ""
 
-#: expr.c:320
+#: expr.c:319
 msgid "use of C99 hexadecimal floating constant"
 msgstr ""
 
-#: expr.c:329
+#: expr.c:328
 msgid "exponent has no digits"
 msgstr ""
 
-#: expr.c:336
+#: expr.c:335
 msgid "hexadecimal floating constants require an exponent"
 msgstr ""
 
-#: expr.c:342
+#: expr.c:341
 #, c-format
 msgid "invalid suffix \"%.*s\" on floating constant"
 msgstr ""
 
-#: expr.c:352
-#: expr.c:394
+#: expr.c:351
+#: expr.c:393
 #, c-format
 msgid "traditional C rejects the \"%.*s\" suffix"
 msgstr ""
 
-#: expr.c:359
+#: expr.c:358
 #, c-format
 msgid "invalid suffix \"%.*s\" with hexadecimal floating constant"
 msgstr ""
 
-#: expr.c:370
+#: expr.c:369
 msgid "decimal float constants are a GCC extension"
 msgstr ""
 
-#: expr.c:380
+#: expr.c:379
 #, c-format
 msgid "invalid suffix \"%.*s\" on integer constant"
 msgstr ""
 
-#: expr.c:402
+#: expr.c:401
 msgid "use of C99 long long integer constant"
 msgstr ""
 
-#: expr.c:410
+#: expr.c:409
 msgid "imaginary constants are a GCC extension"
 msgstr ""
 
-#: expr.c:413
+#: expr.c:412
 msgid "binary constants are a GCC extension"
 msgstr ""
 
-#: expr.c:506
+#: expr.c:505
 msgid "integer constant is too large for its type"
 msgstr ""
 
-#: expr.c:518
+#: expr.c:517
 msgid "integer constant is so large that it is unsigned"
 msgstr ""
 
-#: expr.c:613
+#: expr.c:612
 msgid "missing ')' after \"defined\""
 msgstr ""
 
-#: expr.c:620
+#: expr.c:619
 msgid "operator \"defined\" requires an identifier"
 msgstr ""
 
-#: expr.c:628
+#: expr.c:627
 #, c-format
 msgid "(\"%s\" is an alternative token for \"%s\" in C++)"
 msgstr ""
 
-#: expr.c:638
+#: expr.c:637
 msgid "this use of \"defined\" may not be portable"
 msgstr ""
 
-#: expr.c:691
+#: expr.c:690
 msgid "floating constant in preprocessor expression"
 msgstr ""
 
-#: expr.c:697
+#: expr.c:696
 msgid "imaginary number in preprocessor expression"
 msgstr ""
 
-#: expr.c:744
+#: expr.c:743
 #, c-format
 msgid "\"%s\" is not defined"
 msgstr ""
 
-#: expr.c:756
+#: expr.c:755
 msgid "assertions are a GCC extension"
 msgstr ""
 
-#: expr.c:759
+#: expr.c:758
 msgid "assertions are a deprecated extension"
 msgstr ""
 
-#: expr.c:892
-#: expr.c:921
+#: expr.c:891
+#: expr.c:920
 #, c-format
 msgid "missing binary operator before token \"%s\""
 msgstr ""
 
-#: expr.c:912
+#: expr.c:911
 #, c-format
 msgid "token \"%s\" is not valid in preprocessor expressions"
 msgstr ""
 
-#: expr.c:929
+#: expr.c:928
 msgid "missing expression between '(' and ')'"
 msgstr ""
 
-#: expr.c:932
+#: expr.c:931
 #, c-format
 msgid "%s with no expression"
 msgstr ""
 
-#: expr.c:935
+#: expr.c:934
 #, c-format
 msgid "operator '%s' has no right operand"
 msgstr ""
 
-#: expr.c:940
+#: expr.c:939
 #, c-format
 msgid "operator '%s' has no left operand"
 msgstr ""
 
-#: expr.c:966
+#: expr.c:965
 msgid " ':' without preceding '?'"
 msgstr ""
 
-#: expr.c:994
+#: expr.c:993
 #, c-format
 msgid "unbalanced stack in %s"
 msgstr ""
 
-#: expr.c:1014
+#: expr.c:1013
 #, c-format
 msgid "impossible operator '%u'"
 msgstr ""
 
-#: expr.c:1115
+#: expr.c:1114
 msgid "missing ')' in expression"
 msgstr ""
 
-#: expr.c:1144
+#: expr.c:1143
 msgid "'?' without following ':'"
 msgstr ""
 
-#: expr.c:1154
+#: expr.c:1153
 msgid "integer overflow in preprocessor expression"
 msgstr ""
 
-#: expr.c:1159
+#: expr.c:1158
 msgid "missing '(' in expression"
 msgstr ""
 
-#: expr.c:1191
+#: expr.c:1190
 #, c-format
 msgid "the left operand of \"%s\" changes sign when promoted"
 msgstr ""
 
-#: expr.c:1196
+#: expr.c:1195
 #, c-format
 msgid "the right operand of \"%s\" changes sign when promoted"
 msgstr ""
 
-#: expr.c:1455
+#: expr.c:1454
 msgid "traditional C rejects the unary plus operator"
 msgstr ""
 
-#: expr.c:1538
+#: expr.c:1537
 msgid "comma operator in operand of #if"
 msgstr ""
 
-#: expr.c:1670
+#: expr.c:1669
 msgid "division by zero in #if"
 msgstr ""
 
@@ -660,116 +660,116 @@
 msgid "Multiple include guards may be useful for:\n"
 msgstr ""
 
-#: init.c:451
+#: init.c:452
 msgid "cppchar_t must be an unsigned type"
 msgstr ""
 
-#: init.c:455
+#: init.c:456
 #, c-format
 msgid ""
 "preprocessor arithmetic has maximum precision of %lu bits; target requires %"
 "lu bits"
 msgstr ""
 
-#: init.c:462
+#: init.c:463
 msgid "CPP arithmetic must be at least as precise as a target int"
 msgstr ""
 
-#: init.c:465
+#: init.c:466
 msgid "target char is less than 8 bits wide"
 msgstr ""
 
-#: init.c:469
+#: init.c:470
 msgid "target wchar_t is narrower than target char"
 msgstr ""
 
-#: init.c:473
+#: init.c:474
 msgid "target int is narrower than target char"
 msgstr ""
 
-#: init.c:478
+#: init.c:479
 msgid "CPP half-integer narrower than CPP character"
 msgstr ""
 
-#: init.c:482
+#: init.c:483
 #, c-format
 msgid ""
 "CPP on this host cannot handle wide character constants over %lu bits, but "
 "the target requires %lu bits"
 msgstr ""
 
-#: lex.c:284
+#: lex.c:285
 msgid "backslash and newline separated by space"
 msgstr ""
 
-#: lex.c:289
+#: lex.c:290
 msgid "backslash-newline at end of file"
 msgstr ""
 
-#: lex.c:304
+#: lex.c:305
 #, c-format
 msgid "trigraph ??%c converted to %c"
 msgstr ""
 
-#: lex.c:311
+#: lex.c:312
 #, c-format
 msgid "trigraph ??%c ignored, use -trigraphs to enable"
 msgstr ""
 
-#: lex.c:357
+#: lex.c:358
 msgid "\"/*\" within comment"
 msgstr ""
 
-#: lex.c:415
+#: lex.c:416
 #, c-format
 msgid "%s in preprocessing directive"
 msgstr ""
 
-#: lex.c:424
+#: lex.c:425
 msgid "null character(s) ignored"
 msgstr ""
 
-#: lex.c:461
+#: lex.c:462
 #, c-format
 msgid "`%.*s' is not in NFKC"
 msgstr ""
 
-#: lex.c:464
+#: lex.c:465
 #, c-format
 msgid "`%.*s' is not in NFC"
 msgstr ""
 
-#: lex.c:552
+#: lex.c:553
 #, c-format
 msgid "attempt to use poisoned \"%s\""
 msgstr ""
 
-#: lex.c:560
+#: lex.c:561
 msgid "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro"
 msgstr ""
 
-#: lex.c:674
+#: lex.c:675
 msgid "null character(s) preserved in literal"
 msgstr ""
 
-#: lex.c:677
+#: lex.c:678
 #, c-format
 msgid "missing terminating %c character"
 msgstr ""
 
-#: lex.c:1159
+#: lex.c:1160
 msgid "C++ style comments are not allowed in ISO C90"
 msgstr ""
 
-#: lex.c:1161
+#: lex.c:1162
 msgid "(this will be reported only once per input file)"
 msgstr ""
 
-#: lex.c:1166
+#: lex.c:1167
 msgid "multi-line comment"
 msgstr ""
 
-#: lex.c:1480
+#: lex.c:1481
 #, c-format
 msgid "unspellable token %s"
 msgstr ""
@@ -833,7 +833,7 @@
 msgstr ""
 
 #: macro.c:731
-#: traditional.c:680
+#: traditional.c:681
 #, c-format
 msgid "unterminated argument list invoking macro \"%s\""
 msgstr ""
@@ -850,67 +850,67 @@
 "C90 and ISO C++98"
 msgstr ""
 
-#: macro.c:1453
+#: macro.c:1479
 #, c-format
 msgid "duplicate macro parameter \"%s\""
 msgstr ""
 
-#: macro.c:1499
+#: macro.c:1525
 #, c-format
 msgid "\"%s\" may not appear in macro parameter list"
 msgstr ""
 
-#: macro.c:1507
+#: macro.c:1533
 msgid "macro parameters must be comma-separated"
 msgstr ""
 
-#: macro.c:1524
+#: macro.c:1550
 msgid "parameter name missing"
 msgstr ""
 
-#: macro.c:1541
+#: macro.c:1567
 msgid "anonymous variadic macros were introduced in C99"
 msgstr ""
 
-#: macro.c:1546
+#: macro.c:1572
 msgid "ISO C does not permit named variadic macros"
 msgstr ""
 
-#: macro.c:1555
+#: macro.c:1581
 msgid "missing ')' in macro parameter list"
 msgstr ""
 
-#: macro.c:1604
+#: macro.c:1630
 msgid "'##' cannot appear at either end of a macro expansion"
 msgstr ""
 
-#: macro.c:1638
+#: macro.c:1664
 msgid "ISO C99 requires whitespace after the macro name"
 msgstr ""
 
-#: macro.c:1662
+#: macro.c:1688
 msgid "missing whitespace after the macro name"
 msgstr ""
 
-#: macro.c:1692
+#: macro.c:1718
 msgid "'#' is not followed by a macro parameter"
 msgstr ""
 
-#: macro.c:1811
+#: macro.c:1837
 #, c-format
 msgid "\"%s\" redefined"
 msgstr ""
 
-#: macro.c:1816
+#: macro.c:1842
 msgid "this is the location of the previous definition"
 msgstr ""
 
-#: macro.c:1877
+#: macro.c:1903
 #, c-format
 msgid "macro argument \"%s\" would be stringified in traditional C"
 msgstr ""
 
-#: macro.c:1900
+#: macro.c:1926
 #, c-format
 msgid "invalid hash type %d in cpp_macro_definition"
 msgstr ""
@@ -954,11 +954,11 @@
 msgid "while reading precompiled header"
 msgstr ""
 
-#: traditional.c:750
+#: traditional.c:751
 #, c-format
 msgid "detected recursion whilst expanding macro \"%s\""
 msgstr ""
 
-#: traditional.c:968
+#: traditional.c:969
 msgid "syntax error in macro parameter list"
 msgstr ""
diff -Naur gcc-4.4.0.orig/libgfortran/gfortran.map gcc-4.4.0/libgfortran/gfortran.map
--- gcc-4.4.0.orig/libgfortran/gfortran.map	2008-07-27 03:45:44.000000000 -0700
+++ gcc-4.4.0/libgfortran/gfortran.map	2009-06-03 12:39:09.000000000 -0700
@@ -1090,6 +1090,13 @@
     _gfortran_unpack1_char4;
 } GFORTRAN_1.0; 
 
+
+GFORTRAN_1.2 {
+  global:
+    _gfortran_clz128;
+    _gfortran_ctz128;
+} GFORTRAN_1.1; 
+
 F2C_1.0 {
   global:
     _gfortran_f2c_specific__abs_c4;
diff -Naur gcc-4.4.0.orig/libgfortran/intrinsics/bit_intrinsics.c gcc-4.4.0/libgfortran/intrinsics/bit_intrinsics.c
--- gcc-4.4.0.orig/libgfortran/intrinsics/bit_intrinsics.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libgfortran/intrinsics/bit_intrinsics.c	2009-06-03 12:39:09.000000000 -0700
@@ -0,0 +1,138 @@
+/* Implementation of the bit intrinsics not implemented as GCC builtins.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+
+This file is part of the GNU Fortran runtime library (libgfortran).
+
+Libgfortran is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public
+License as published by the Free Software Foundation; either
+version 3 of the License, or (at your option) any later version.
+
+Libgfortran is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#include "libgfortran.h"
+
+
+#ifdef HAVE_GFC_INTEGER_16
+extern int clz128 (GFC_INTEGER_16);
+export_proto(clz128);
+
+int
+clz128 (GFC_INTEGER_16 x)
+{
+  int res = 127;
+
+  // We can't write 0xFFFFFFFFFFFFFFFF0000000000000000, so we work around it
+  if (x & ((__uint128_t) 0xFFFFFFFFFFFFFFFF << 64))
+    {
+      res -= 64;
+      x >>= 64;
+    }
+
+  if (x & 0xFFFFFFFF00000000)
+    {
+      res -= 32;
+      x >>= 32;
+    }
+
+  if (x & 0xFFFF0000)
+    {
+      res -= 16;
+      x >>= 16;
+    }
+
+  if (x & 0xFF00)
+    {
+      res -= 8;
+      x >>= 8;
+    }
+
+  if (x & 0xF0)
+    {
+      res -= 4;
+      x >>= 4;
+    }
+
+  if (x & 0xC)
+    {
+      res -= 2;
+      x >>= 2;
+    }
+
+  if (x & 0x2)
+    {
+      res -= 1;
+      x >>= 1;
+    }
+
+  return res;
+}
+#endif
+
+
+#ifdef HAVE_GFC_INTEGER_16
+extern int ctz128 (GFC_INTEGER_16);
+export_proto(ctz128);
+
+int
+ctz128 (GFC_INTEGER_16 x)
+{
+  int res = 0;
+
+  if ((x & 0xFFFFFFFFFFFFFFFF) == 0)
+    {
+      res += 64;
+      x >>= 64;
+    }
+
+  if ((x & 0xFFFFFFFF) == 0)
+    {
+      res += 32;
+      x >>= 32;
+    }
+
+  if ((x & 0xFFFF) == 0)
+    {
+      res += 16;
+      x >>= 16;
+    }
+
+  if ((x & 0xFF) == 0)
+    {
+      res += 8;
+      x >>= 8;
+    }
+
+  if ((x & 0xF) == 0)
+    {
+      res += 4;
+      x >>= 4;
+    }
+
+  if ((x & 0x3) == 0)
+    {
+      res += 2;
+      x >>= 2;
+    }
+
+  if ((x & 0x1) == 0)
+    {
+      res += 1;
+      x >>= 1;
+    }
+
+  return res;
+}
+#endif
diff -Naur gcc-4.4.0.orig/libgfortran/io/fbuf.c gcc-4.4.0/libgfortran/io/fbuf.c
--- gcc-4.4.0.orig/libgfortran/io/fbuf.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/fbuf.c	2009-05-26 18:21:22.000000000 -0700
@@ -28,8 +28,11 @@
 #include <stdlib.h>
 
 
+//#define FBUF_DEBUG
+
+
 void
-fbuf_init (gfc_unit * u, size_t len)
+fbuf_init (gfc_unit * u, int len)
 {
   if (len == 0)
     len = 512;			/* Default size.  */
@@ -37,14 +40,7 @@
   u->fbuf = get_mem (sizeof (fbuf));
   u->fbuf->buf = get_mem (len);
   u->fbuf->len = len;
-  u->fbuf->act = u->fbuf->flushed = u->fbuf->pos = 0;
-}
-
-
-void
-fbuf_reset (gfc_unit * u)
-{
-  u->fbuf->act = u->fbuf->flushed = u->fbuf->pos = 0;
+  u->fbuf->act = u->fbuf->pos = 0;
 }
 
 
@@ -56,58 +52,79 @@
   if (u->fbuf->buf)
     free_mem (u->fbuf->buf);
   free_mem (u->fbuf);
+  u->fbuf = NULL;
+}
+
+
+static void
+#ifdef FBUF_DEBUG
+fbuf_debug (gfc_unit * u, const char * format, ...)
+{
+  va_list args;
+  va_start(args, format);
+  vfprintf(stderr, format, args);
+  va_end(args);
+  fprintf (stderr, "fbuf_debug pos: %d, act: %d, buf: ''", 
+           u->fbuf->pos, u->fbuf->act);
+  for (int ii = 0; ii < u->fbuf->act; ii++)
+    {
+      putc (u->fbuf->buf[ii], stderr);
+    }
+  fprintf (stderr, "''\n");
+}
+#else
+fbuf_debug (gfc_unit * u __attribute__ ((unused)),
+            const char * format __attribute__ ((unused)),
+            ...) {}
+#endif
+
+  
+
+/* You should probably call this before doing a physical seek on the
+   underlying device.  Returns how much the physical position was
+   modified.  */
+
+int
+fbuf_reset (gfc_unit * u)
+{
+  int seekval = 0;
+
+  if (!u->fbuf)
+    return 0;
+
+  fbuf_debug (u, "fbuf_reset: ");
+  fbuf_flush (u, u->mode);
+  /* If we read past the current position, seek the underlying device
+     back.  */
+  if (u->mode == READING && u->fbuf->act > u->fbuf->pos)
+    {
+      seekval = - (u->fbuf->act - u->fbuf->pos);
+      fbuf_debug (u, "fbuf_reset seekval %d, ", seekval);
+    }
+  u->fbuf->act = u->fbuf->pos = 0;
+  return seekval;
 }
 
 
 /* Return a pointer to the current position in the buffer, and increase
    the pointer by len. Makes sure that the buffer is big enough, 
-   reallocating if necessary. If the buffer is not big enough, there are
-   three cases to consider:
-   1. If we haven't flushed anything, realloc
-   2. If we have flushed enough that by discarding the flushed bytes
-      the request fits into the buffer, do that.
-   3. Else allocate a new buffer, memcpy unflushed active bytes from old
-      buffer. */
+   reallocating if necessary.  */
 
 char *
-fbuf_alloc (gfc_unit * u, size_t len)
+fbuf_alloc (gfc_unit * u, int len)
 {
-  size_t newlen;
+  int newlen;
   char *dest;
+  fbuf_debug (u, "fbuf_alloc len %d, ", len);
   if (u->fbuf->pos + len > u->fbuf->len)
     {
-      if (u->fbuf->flushed == 0)
-	{
-	  /* Round up to nearest multiple of the current buffer length.  */
-	  newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) * u->fbuf->len;
-	  dest = realloc (u->fbuf->buf, newlen);
-	  if (dest == NULL)
-	    return NULL;
-	  u->fbuf->buf = dest;
-	  u->fbuf->len = newlen;
-	}
-      else if (u->fbuf->act - u->fbuf->flushed + len < u->fbuf->len)
-	{
-	  memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->flushed,
-		   u->fbuf->act - u->fbuf->flushed);
-	  u->fbuf->act -= u->fbuf->flushed;
-	  u->fbuf->pos -= u->fbuf->flushed;
-	  u->fbuf->flushed = 0;
-	}
-      else
-	{
-	  /* Most general case, flushed != 0, request doesn't fit.  */
-	  newlen = ((u->fbuf->pos - u->fbuf->flushed + len)
-		    / u->fbuf->len + 1) * u->fbuf->len;
-	  dest = get_mem (newlen);
-	  memcpy (dest, u->fbuf->buf + u->fbuf->flushed,
-		  u->fbuf->act - u->fbuf->flushed);
-	  u->fbuf->act -= u->fbuf->flushed;
-	  u->fbuf->pos -= u->fbuf->flushed;
-	  u->fbuf->flushed = 0;
-	  u->fbuf->buf = dest;
-	  u->fbuf->len = newlen;
-	}
+      /* Round up to nearest multiple of the current buffer length.  */
+      newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) * u->fbuf->len;
+      dest = realloc (u->fbuf->buf, newlen);
+      if (dest == NULL)
+	return NULL;
+      u->fbuf->buf = dest;
+      u->fbuf->len = newlen;
     }
 
   dest = u->fbuf->buf + u->fbuf->pos;
@@ -118,42 +135,134 @@
 }
 
 
-
+/* mode argument is WRITING for write mode and READING for read
+   mode. Return value is 0 for success, -1 on failure.  */
 
 int
-fbuf_flush (gfc_unit * u, int record_done)
+fbuf_flush (gfc_unit * u, unit_mode mode)
 {
-  int status;
-  size_t nbytes;
+  int nwritten;
 
   if (!u->fbuf)
     return 0;
-  if (u->fbuf->act - u->fbuf->flushed != 0)
+
+  fbuf_debug (u, "fbuf_flush with mode %d: ", mode);
+
+  if (mode == WRITING)
     {
-      if (record_done)
-        nbytes = u->fbuf->act - u->fbuf->flushed;
-      else	
-        nbytes = u->fbuf->pos - u->fbuf->flushed;	
-      status = swrite (u->s, u->fbuf->buf + u->fbuf->flushed, &nbytes);
-      u->fbuf->flushed += nbytes;
+      if (u->fbuf->pos > 0)
+	{
+	  nwritten = swrite (u->s, u->fbuf->buf, u->fbuf->pos);
+	  if (nwritten < 0)
+	    return -1;
+	}
     }
-  else
-    status = 0;
-  if (record_done)
-    fbuf_reset (u);
-  return status;
+  /* Salvage remaining bytes for both reading and writing. This
+     happens with the combination of advance='no' and T edit
+     descriptors leaving the final position somewhere not at the end
+     of the record. For reading, this also happens if we sread() past
+     the record boundary.  */ 
+  if (u->fbuf->act > u->fbuf->pos && u->fbuf->pos > 0)
+    memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->pos, 
+             u->fbuf->act - u->fbuf->pos);
+
+  u->fbuf->act -= u->fbuf->pos;
+  u->fbuf->pos = 0;
+
+  return 0;
 }
 
 
 int
-fbuf_seek (gfc_unit * u, gfc_offset off)
+fbuf_seek (gfc_unit * u, int off, int whence)
 {
-  gfc_offset pos = u->fbuf->pos + off;
-  /* Moving to the left past the flushed marked would imply moving past
-     the left tab limit, which is never allowed. So return error if
-     that is attempted.  */
-  if (pos < (gfc_offset) u->fbuf->flushed)
+  if (!u->fbuf)
     return -1;
-  u->fbuf->pos = pos;
-  return 0;
+
+  switch (whence)
+    {
+    case SEEK_SET:
+      break;
+    case SEEK_CUR:
+      off += u->fbuf->pos;
+      break;
+    case SEEK_END:
+      off += u->fbuf->act;
+      break;
+    default:
+      return -1;
+    }
+
+  fbuf_debug (u, "fbuf_seek, off %d ", off);
+  /* The start of the buffer is always equal to the left tab
+     limit. Moving to the left past the buffer is illegal in C and
+     would also imply moving past the left tab limit, which is never
+     allowed in Fortran. Similarly, seeking past the end of the buffer
+     is not possible, in that case the user must make sure to allocate
+     space with fbuf_alloc().  So return error if that is
+     attempted.  */
+  if (off < 0 || off > u->fbuf->act)
+    return -1;
+  u->fbuf->pos = off;
+  return off;
+}
+
+
+/* Fill the buffer with bytes for reading.  Returns a pointer to start
+   reading from. If we hit EOF, returns a short read count. If any
+   other error occurs, return NULL.  After reading, the caller is
+   expected to call fbuf_seek to update the position with the number
+   of bytes actually processed. */
+
+char *
+fbuf_read (gfc_unit * u, int * len)
+{
+  char *ptr;
+  int oldact, oldpos;
+  int readlen = 0;
+
+  fbuf_debug (u, "fbuf_read, len %d: ", *len);
+  oldact = u->fbuf->act;
+  oldpos = u->fbuf->pos;
+  ptr = fbuf_alloc (u, *len);
+  u->fbuf->pos = oldpos;
+  if (oldpos + *len > oldact)
+    {
+      fbuf_debug (u, "reading %d bytes starting at %d ", 
+                  oldpos + *len - oldact, oldact);
+      readlen = sread (u->s, u->fbuf->buf + oldact, oldpos + *len - oldact);
+      if (readlen < 0)
+	return NULL;
+      *len = oldact - oldpos + readlen;
+    }
+  u->fbuf->act = oldact + readlen;
+  fbuf_debug (u, "fbuf_read done: ");
+  return ptr;
+}
+
+
+/* When the fbuf_getc() inline function runs out of buffer space, it
+   calls this function to fill the buffer with bytes for
+   reading. Never call this function directly.  */
+
+int
+fbuf_getc_refill (gfc_unit * u)
+{
+  int nread;
+  char *p;
+
+  fbuf_debug (u, "fbuf_getc_refill ");
+
+  /* Read 80 bytes (average line length?).  This is a compromise
+     between not needing to call the read() syscall all the time and
+     not having to memmove unnecessary stuff when switching to the
+     next record.  */
+  nread = 80;
+
+  p = fbuf_read (u, &nread);
+
+  if (p && nread > 0)
+    return (unsigned char) u->fbuf->buf[u->fbuf->pos++];
+  else
+    return EOF;
 }
diff -Naur gcc-4.4.0.orig/libgfortran/io/file_pos.c gcc-4.4.0/libgfortran/io/file_pos.c
--- gcc-4.4.0.orig/libgfortran/io/file_pos.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/file_pos.c	2009-05-26 18:21:22.000000000 -0700
@@ -41,17 +41,17 @@
 {
   gfc_offset base;
   char p[READ_CHUNK];
-  size_t n;
+  ssize_t n;
 
-  base = file_position (u->s) - 1;
+  base = stell (u->s) - 1;
 
   do
     {
       n = (base < READ_CHUNK) ? base : READ_CHUNK;
       base -= n;
-      if (sseek (u->s, base) == FAILURE)
+      if (sseek (u->s, base, SEEK_SET) < 0)
         goto io_error;
-      if (sread (u->s, p, &n) != 0)
+      if (sread (u->s, p, n) != n)
 	goto io_error;
 
       /* We have moved backwards from the current position, it should
@@ -76,7 +76,7 @@
 
   /* base is the new pointer.  Seek to it exactly.  */
  done:
-  if (sseek (u->s, base) == FAILURE)
+  if (sseek (u->s, base, SEEK_SET) < 0)
     goto io_error;
   u->last_record--;
   u->endfile = NO_ENDFILE;
@@ -95,10 +95,10 @@
 static void
 unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)
 {
-  gfc_offset m, new;
+  gfc_offset m, slen;
   GFC_INTEGER_4 m4;
   GFC_INTEGER_8 m8;
-  size_t length;
+  ssize_t length;
   int continued;
   char p[sizeof (GFC_INTEGER_8)];
 
@@ -109,9 +109,10 @@
 
   do
     {
-      if (sseek (u->s, file_position (u->s) - length) == FAILURE)
+      slen = - (gfc_offset) length;
+      if (sseek (u->s, slen, SEEK_CUR) < 0)
         goto io_error;
-      if (sread (u->s, p, &length) != 0)
+      if (sread (u->s, p, length) != length)
         goto io_error;
 
       /* Only GFC_CONVERT_NATIVE and GFC_CONVERT_SWAP are valid here.  */
@@ -159,10 +160,7 @@
       if (continued)
 	m = -m;
 
-      if ((new = file_position (u->s) - m - 2*length) < 0)
-	new = 0;
-
-      if (sseek (u->s, new) == FAILURE)
+      if (sseek (u->s, -m -2 * length, SEEK_CUR) < 0)
 	goto io_error;
     } while (continued);
 
@@ -201,15 +199,21 @@
       goto done;
     }
 
-    if (u->flags.access == ACCESS_STREAM && u->flags.form == FORM_UNFORMATTED)
-      {
-	generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,
-			"Cannot BACKSPACE an unformatted stream file");
-	goto done;
-      }
+  if (u->flags.access == ACCESS_STREAM && u->flags.form == FORM_UNFORMATTED)
+    {
+      generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,
+                      "Cannot BACKSPACE an unformatted stream file");
+      goto done;
+    }
+
+  /* Make sure format buffer is flushed and reset.  */
+  if (u->flags.form == FORM_FORMATTED)
+    {
+      int pos = fbuf_reset (u);
+      if (pos != 0)
+        sseek (u->s, pos, SEEK_CUR);
+    }
 
-  /* Make sure format buffer is flushed.  */
-  fbuf_flush (u, 1);
   
   /* Check for special cases involving the ENDFILE record first.  */
 
@@ -217,11 +221,11 @@
     {
       u->endfile = AT_ENDFILE;
       u->flags.position = POSITION_APPEND;
-      flush (u->s);
+      sflush (u->s);
     }
   else
     {
-      if (file_position (u->s) == 0)
+      if (stell (u->s) == 0)
 	{
 	  u->flags.position = POSITION_REWIND;
 	  goto done;		/* Common special case */
@@ -238,8 +242,7 @@
 
 	  u->previous_nonadvancing_write = 0;
 
-	  flush (u->s);
-	  struncate (u->s);
+	  unit_truncate (u, stell (u->s), &fpp->common);
 	  u->mode = READING;
         }
 
@@ -248,7 +251,7 @@
       else
 	unformatted_backspace (fpp, u);
 
-      update_position (u);
+      u->flags.position = POSITION_UNSPECIFIED;
       u->endfile = NO_ENDFILE;
       u->current_record = 0;
       u->bytes_left = 0;
@@ -300,10 +303,10 @@
 	  next_record (&dtp, 1);
 	}
 
-      flush (u->s);
-      struncate (u->s);
+      unit_truncate (u, stell (u->s), &fpp->common);
       u->endfile = AFTER_ENDFILE;
-      update_position (u);
+      if (0 == stell (u->s))
+        u->flags.position = POSITION_REWIND;
     done:
       unlock_unit (u);
     }
@@ -338,18 +341,11 @@
 
 	  u->previous_nonadvancing_write = 0;
 
-	  /* Flush the buffers.  If we have been writing to the file, the last
-	       written record is the last record in the file, so truncate the
-	       file now.  Reset to read mode so two consecutive rewind
-	       statements do not delete the file contents.  */
-	  flush (u->s);
-	  if (u->mode == WRITING && u->flags.access != ACCESS_STREAM)
-	    struncate (u->s);
+	  fbuf_reset (u);
 
-	  u->mode = READING;
 	  u->last_record = 0;
 
-	  if (file_position (u->s) != 0 && sseek (u->s, 0) == FAILURE)
+	  if (sseek (u->s, 0, SEEK_SET) < 0)
 	    generate_error (&fpp->common, LIBERROR_OS, NULL);
 
 	  /* Handle special files like /dev/null differently.  */
@@ -361,7 +357,7 @@
 	  else
 	    {
 	      /* Set this for compatibilty with g77 for /dev/null.  */
-	      if (file_length (u->s) == 0  && file_position (u->s) == 0)
+	      if (file_length (u->s) == 0  && stell (u->s) == 0)
 		u->endfile = AT_ENDFILE;
 	      /* Future refinements on special files can go here.  */
 	    }
@@ -392,7 +388,11 @@
   u = find_unit (fpp->common.unit);
   if (u != NULL)
     {
-      flush (u->s);
+      /* Make sure format buffer is flushed.  */
+      if (u->flags.form == FORM_FORMATTED)
+        fbuf_flush (u, u->mode);
+
+      sflush (u->s);
       unlock_unit (u);
     }
   else
diff -Naur gcc-4.4.0.orig/libgfortran/io/format.c gcc-4.4.0/libgfortran/io/format.c
--- gcc-4.4.0.orig/libgfortran/io/format.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/format.c	2009-05-26 18:21:22.000000000 -0700
@@ -31,6 +31,7 @@
 #include "io.h"
 #include <ctype.h>
 #include <string.h>
+#include <stdbool.h>
 
 #define FARRAY_SIZE 64
 
@@ -58,7 +59,7 @@
 static const fnode colon_node = { FMT_COLON, 0, NULL, NULL, {{ 0, 0, 0 }}, 0,
 				  NULL };
 
-/* Error messages */
+/* Error messages. */
 
 static const char posint_required[] = "Positive width required in format",
   period_required[] = "Period required in format",
@@ -70,6 +71,129 @@
   reversion_error[] = "Exhausted data descriptors in format",
   zero_width[] = "Zero width in format descriptor";
 
+/* The following routines support caching format data from parsed format strings
+   into a hash table.  This avoids repeatedly parsing duplicate format strings
+   or format strings in I/O statements that are repeated in loops.  */
+
+
+/* Traverse the table and free all data.  */
+
+void
+free_format_hash_table (gfc_unit *u)
+{
+  size_t i;
+
+  /* free_format_data handles any NULL pointers.  */
+  for (i = 0; i < FORMAT_HASH_SIZE; i++)
+    {
+      if (u->format_hash_table[i].hashed_fmt != NULL)
+	free_format_data (u->format_hash_table[i].hashed_fmt);
+      u->format_hash_table[i].hashed_fmt = NULL;
+    }
+}
+
+/* Traverse the format_data structure and reset the fnode counters.  */
+
+static void
+reset_node (fnode *fn)
+{
+  fnode *f;
+
+  fn->count = 0;
+  fn->current = NULL;
+  
+  if (fn->format != FMT_LPAREN)
+    return;
+
+  for (f = fn->u.child; f; f = f->next)
+    {
+      if (f->format == FMT_RPAREN)
+	break;
+      reset_node (f);
+    }
+}
+
+static void
+reset_fnode_counters (st_parameter_dt *dtp)
+{
+  fnode *f;
+  format_data *fmt;
+
+  fmt = dtp->u.p.fmt;
+
+  /* Clear this pointer at the head so things start at the right place.  */
+  fmt->array.array[0].current = NULL;
+
+  for (f = fmt->last->array[0].u.child; f; f = f->next)
+    reset_node (f);
+}
+
+
+/* A simple hashing function to generate an index into the hash table.  */
+
+static inline
+uint32_t format_hash (st_parameter_dt *dtp)
+{
+  char *key;
+  gfc_charlen_type key_len;
+  uint32_t hash = 0;
+  gfc_charlen_type i;
+
+  /* Hash the format string. Super simple, but what the heck!  */
+  key = dtp->format;
+  key_len = dtp->format_len;
+  for (i = 0; i < key_len; i++)
+    hash ^= key[i];
+  hash &= (FORMAT_HASH_SIZE - 1);
+  return hash;
+}
+
+
+static void
+save_parsed_format (st_parameter_dt *dtp)
+{
+  uint32_t hash;
+  gfc_unit *u;
+
+  hash = format_hash (dtp);
+  u = dtp->u.p.current_unit;
+
+  /* Index into the hash table.  We are simply replacing whatever is there
+     relying on probability.  */
+  if (u->format_hash_table[hash].hashed_fmt != NULL)
+    free_format_data (u->format_hash_table[hash].hashed_fmt);
+  u->format_hash_table[hash].hashed_fmt = NULL;
+
+  u->format_hash_table[hash].key = dtp->format;
+  u->format_hash_table[hash].key_len = dtp->format_len;
+  u->format_hash_table[hash].hashed_fmt = dtp->u.p.fmt;
+}
+
+
+static format_data *
+find_parsed_format (st_parameter_dt *dtp)
+{
+  uint32_t hash;
+  gfc_unit *u;
+
+  hash = format_hash (dtp);
+  u = dtp->u.p.current_unit;
+
+  if (u->format_hash_table[hash].key != NULL)
+    {
+      /* See if it matches.  */
+      if (u->format_hash_table[hash].key_len == dtp->format_len)
+	{
+	  /* So far so good.  */
+	  if (strncmp (u->format_hash_table[hash].key,
+	      dtp->format, dtp->format_len) == 0)
+	    return u->format_hash_table[hash].hashed_fmt;
+	}
+    }
+  return NULL;
+}
+
+
 /* next_char()-- Return the next character in the format string.
  * Returns -1 when the string is done.  If the literal flag is set,
  * spaces are significant, otherwise they are not. */
@@ -85,7 +209,8 @@
 	return -1;
 
       fmt->format_string_len--;
-      fmt->error_element = c = toupper (*fmt->format_string++);
+      c = toupper (*fmt->format_string++);
+      fmt->error_element = c;
     }
   while ((c == ' ' || c == '\t') && !literal);
 
@@ -136,10 +261,10 @@
 /* free_format_data()-- Free all allocated format data.  */
 
 void
-free_format_data (st_parameter_dt *dtp)
+free_format_data (format_data *fmt)
 {
   fnode_array *fa, *fa_next;
-  format_data *fmt = dtp->u.p.fmt;
+
 
   if (fmt == NULL)
     return;
@@ -151,7 +276,7 @@
     }
 
   free_mem (fmt);
-  dtp->u.p.fmt = NULL;
+  fmt = NULL;
 }
 
 
@@ -179,6 +304,14 @@
 
   switch (c)
     {
+    case '(':
+      token = FMT_LPAREN;
+      break;
+
+    case ')':
+      token = FMT_RPAREN;
+      break;
+
     case '-':
       negative_flag = 1;
       /* Fall Through */
@@ -271,14 +404,6 @@
 
       break;
 
-    case '(':
-      token = FMT_LPAREN;
-      break;
-
-    case ')':
-      token = FMT_RPAREN;
-      break;
-
     case 'X':
       token = FMT_X;
       break;
@@ -450,8 +575,10 @@
   format_token t, u, t2;
   int repeat;
   format_data *fmt = dtp->u.p.fmt;
+  bool save_format;
 
   head = tail = NULL;
+  save_format = !is_internal_unit (dtp);
 
   /* Get the next format item */
  format_item:
@@ -562,6 +689,7 @@
     case FMT_DP:
       notify_std (&dtp->common, GFC_STD_F2003, "Fortran 2003: DC or DP "
 		  "descriptor not allowed");
+      save_format = true;
     /* Fall through.  */
     case FMT_S:
     case FMT_SS:
@@ -587,6 +715,7 @@
       get_fnode (fmt, &head, &tail, FMT_DOLLAR);
       tail->repeat = 1;
       notify_std (&dtp->common, GFC_STD_GNU, "Extension: $ descriptor");
+      save_format = false;
       goto between_desc;
 
 
@@ -684,6 +813,7 @@
 	      fmt->saved_token = t;
 	      fmt->value = 1;	/* Default width */
 	      notify_std (&dtp->common, GFC_STD_GNU, posint_required);
+	      save_format = false;
 	    }
 	}
 
@@ -994,6 +1124,33 @@
 }
 
 
+/* revert()-- Do reversion of the format.  Control reverts to the left
+ * parenthesis that matches the rightmost right parenthesis.  From our
+ * tree structure, we are looking for the rightmost parenthesis node
+ * at the second level, the first level always being a single
+ * parenthesis node.  If this node doesn't exit, we use the top
+ * level. */
+
+static void
+revert (st_parameter_dt *dtp)
+{
+  fnode *f, *r;
+  format_data *fmt = dtp->u.p.fmt;
+
+  dtp->u.p.reversion_flag = 1;
+
+  r = NULL;
+
+  for (f = fmt->array.array[0].u.child; f; f = f->next)
+    if (f->format == FMT_LPAREN)
+      r = f;
+
+  /* If r is NULL because no node was found, the whole tree will be used */
+
+  fmt->array.array[0].current = r;
+  fmt->array.array[0].count = 0;
+}
+
 /* parse_format()-- Parse a format string.  */
 
 void
@@ -1001,6 +1158,21 @@
 {
   format_data *fmt;
 
+  /* Lookup format string to see if it has already been parsed.  */
+
+  dtp->u.p.fmt = find_parsed_format (dtp);
+
+  if (dtp->u.p.fmt != NULL)
+    {
+      dtp->u.p.fmt->reversion_ok = 0;
+      dtp->u.p.fmt->saved_token = FMT_NONE;
+      dtp->u.p.fmt->saved_format = NULL;
+      reset_fnode_counters (dtp);
+      return;
+    }
+
+  /* Not found so proceed as follows.  */
+
   dtp->u.p.fmt = fmt = get_mem (sizeof (format_data));
   fmt->format_string = dtp->format;
   fmt->format_string_len = dtp->format_len;
@@ -1032,35 +1204,12 @@
     fmt->error = "Missing initial left parenthesis in format";
 
   if (fmt->error)
-    format_error (dtp, NULL, fmt->error);
-}
-
-
-/* revert()-- Do reversion of the format.  Control reverts to the left
- * parenthesis that matches the rightmost right parenthesis.  From our
- * tree structure, we are looking for the rightmost parenthesis node
- * at the second level, the first level always being a single
- * parenthesis node.  If this node doesn't exit, we use the top
- * level. */
-
-static void
-revert (st_parameter_dt *dtp)
-{
-  fnode *f, *r;
-  format_data *fmt = dtp->u.p.fmt;
-
-  dtp->u.p.reversion_flag = 1;
-
-  r = NULL;
-
-  for (f = fmt->array.array[0].u.child; f; f = f->next)
-    if (f->format == FMT_LPAREN)
-      r = f;
-
-  /* If r is NULL because no node was found, the whole tree will be used */
-
-  fmt->array.array[0].current = r;
-  fmt->array.array[0].count = 0;
+    {
+      format_error (dtp, NULL, fmt->error);
+      free_format_hash_table (dtp->u.p.current_unit);
+      return;
+    }
+  save_parsed_format (dtp);
 }
 
 
diff -Naur gcc-4.4.0.orig/libgfortran/io/intrinsics.c gcc-4.4.0/libgfortran/io/intrinsics.c
--- gcc-4.4.0.orig/libgfortran/io/intrinsics.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/intrinsics.c	2009-05-26 18:21:22.000000000 -0700
@@ -41,21 +41,26 @@
 PREFIX(fgetc) (const int * unit, char * c, gfc_charlen_type c_len)
 {
   int ret;
-  size_t s;
   gfc_unit * u = find_unit (*unit);
 
   if (u == NULL)
     return -1;
 
-  s = 1;
+  fbuf_reset (u);
+  if (u->mode == WRITING)
+    {
+      sflush (u->s);
+      u->mode = READING;
+    }
+
   memset (c, ' ', c_len);
-  ret = sread (u->s, c, &s);
+  ret = sread (u->s, c, 1);
   unlock_unit (u);
 
-  if (ret != 0)
+  if (ret < 0)
     return ret;
 
-  if (s != 1)
+  if (ret != 1)
     return -1;
   else
     return 0;
@@ -114,17 +119,24 @@
 PREFIX(fputc) (const int * unit, char * c,
 	       gfc_charlen_type c_len __attribute__((unused)))
 {
-  size_t s;
-  int ret;
+  ssize_t s;
   gfc_unit * u = find_unit (*unit);
 
   if (u == NULL)
     return -1;
 
-  s = 1;
-  ret = swrite (u->s, c, &s);
+  fbuf_reset (u);
+  if (u->mode == READING)
+    {
+      sflush (u->s);
+      u->mode = WRITING;
+    }
+
+  s = swrite (u->s, c, 1);
   unlock_unit (u);
-  return ret;
+  if (s < 0)
+    return -1;
+  return 0;
 }
 
 
@@ -191,7 +203,7 @@
       us = find_unit (*unit);
       if (us != NULL)
 	{
-	  flush (us->s);
+	  sflush (us->s);
 	  unlock_unit (us);
 	}
     }
@@ -214,7 +226,7 @@
       us = find_unit (*unit);
       if (us != NULL)
 	{
-	  flush (us->s);
+	  sflush (us->s);
 	  unlock_unit (us);
 	}
     }
@@ -229,22 +241,17 @@
 fseek_sub (int * unit, GFC_IO_INT * offset, int * whence, int * status)
 {
   gfc_unit * u = find_unit (*unit);
-  try result = FAILURE;
+  ssize_t result = -1;
 
   if (u != NULL && is_seekable(u->s))
     {
-      if (*whence == 0)
-        result = sseek(u->s, *offset);                       /* SEEK_SET */
-      else if (*whence == 1)
-        result = sseek(u->s, file_position(u->s) + *offset); /* SEEK_CUR */
-      else if (*whence == 2)
-        result = sseek(u->s, file_length(u->s) + *offset);   /* SEEK_END */
+      result = sseek(u->s, *offset, *whence);
 
       unlock_unit (u);
     }
 
   if (status)
-    *status = (result == FAILURE ? -1 : 0);
+    *status = (result < 0 ? -1 : 0);
 }
 
 
@@ -261,7 +268,7 @@
   size_t ret;
   if (u == NULL)
     return ((size_t) -1);
-  ret = (size_t) stream_offset (u->s);
+  ret = (size_t) stell (u->s);
   unlock_unit (u);
   return ret;
 }
@@ -277,7 +284,7 @@
       *offset = -1; \
     else \
       { \
-	*offset = stream_offset (u->s); \
+	*offset = stell (u->s); \
 	unlock_unit (u); \
       } \
   }
diff -Naur gcc-4.4.0.orig/libgfortran/io/io.h gcc-4.4.0/libgfortran/io/io.h
--- gcc-4.4.0.orig/libgfortran/io/io.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/io.h	2009-05-26 18:21:22.000000000 -0700
@@ -46,34 +46,60 @@
 
 typedef struct stream
 {
-  char *(*alloc_w_at) (struct stream *, int *);
-  try (*sfree) (struct stream *);
-  try (*close) (struct stream *);
-  try (*seek) (struct stream *, gfc_offset);
-  try (*trunc) (struct stream *);
-  int (*read) (struct stream *, void *, size_t *);
-  int (*write) (struct stream *, const void *, size_t *);
-  try (*set) (struct stream *, int, size_t);
+  ssize_t (*read) (struct stream *, void *, ssize_t);
+  ssize_t (*write) (struct stream *, const void *, ssize_t);
+  off_t (*seek) (struct stream *, off_t, int);
+  off_t (*tell) (struct stream *);
+  /* Avoid keyword truncate due to AIX namespace collision.  */
+  int (*trunc) (struct stream *, off_t);
+  int (*flush) (struct stream *);
+  int (*close) (struct stream *);
 }
 stream;
 
-typedef enum
-{ SYNC_BUFFERED, SYNC_UNBUFFERED, ASYNC }
-io_mode;
+/* Inline functions for doing file I/O given a stream.  */
+static inline ssize_t
+sread (stream * s, void * buf, ssize_t nbyte)
+{
+  return s->read (s, buf, nbyte);
+}
+
+static inline ssize_t
+swrite (stream * s, const void * buf, ssize_t nbyte)
+{
+  return s->write (s, buf, nbyte);
+}
 
-/* Macros for doing file I/O given a stream.  */
+static inline off_t
+sseek (stream * s, off_t offset, int whence)
+{
+  return s->seek (s, offset, whence);
+}
+
+static inline off_t
+stell (stream * s)
+{
+  return s->tell (s);
+}
 
-#define sfree(s) ((s)->sfree)(s)
-#define sclose(s) ((s)->close)(s)
+static inline int
+struncate (stream * s, off_t length)
+{
+  return s->trunc (s, length);
+}
 
-#define salloc_w(s, len) ((s)->alloc_w_at)(s, len)
+static inline int
+sflush (stream * s)
+{
+  return s->flush (s);
+}
 
-#define sseek(s, pos) ((s)->seek)(s, pos)
-#define struncate(s) ((s)->trunc)(s)
-#define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)
-#define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)
+static inline int
+sclose (stream * s)
+{
+  return s->close (s);
+}
 
-#define sset(s, c, n) ((s)->set)(s, c, n)
 
 /* Macros for testing what kinds of I/O we are doing.  */
 
@@ -103,6 +129,18 @@
 }
 array_loop_spec;
 
+/* A stucture to build a hash table for format data.  */
+
+#define FORMAT_HASH_SIZE 16 
+
+typedef struct format_hash_entry
+{
+  char *key;
+  gfc_charlen_type key_len;
+  struct format_data *hashed_fmt;
+}
+format_hash_entry;
+
 /* Representation of a namelist object in libgfortran
 
    Namelist Records
@@ -124,7 +162,6 @@
 
 typedef struct namelist_type
 {
-
   /* Object type, stored as GFC_DTYPE_xxxx.  */
   bt type;
 
@@ -461,9 +498,9 @@
 	  /* A flag used to identify when a non-standard expanded namelist read
 	     has occurred.  */
 	  int expanded_read;
-	  /* Storage area for values except for strings.  Must be large
-	     enough to hold a complex value (two reals) of the largest
-	     kind.  */
+	  /* Storage area for values except for strings.  Must be
+	     large enough to hold a complex value (two reals) of the
+	     largest kind.  */
 	  char value[32];
 	  GFC_IO_INT size_used;
 	} p;
@@ -535,10 +572,9 @@
 typedef struct fbuf
 {
   char *buf;			/* Start of buffer.  */
-  size_t len;			/* Length of buffer.  */
-  size_t act;			/* Active bytes in buffer.  */
-  size_t flushed;		/* Flushed bytes from beginning of buffer.  */
-  size_t pos;			/* Current position in buffer.  */
+  int len;			/* Length of buffer.  */
+  int act;			/* Active bytes in buffer.  */
+  int pos;			/* Current position in buffer.  */
 }
 fbuf;
 
@@ -596,6 +632,9 @@
 
   int file_len;
   char *file;
+
+  /* The format hash table.  */
+  struct format_hash_entry format_hash_table[FORMAT_HASH_SIZE];
   
   /* Formatting buffer.  */
   struct fbuf *fbuf;
@@ -668,9 +707,6 @@
 
 /* unix.c */
 
-extern int move_pos_offset (stream *, int);
-internal_proto(move_pos_offset);
-
 extern int compare_files (stream *, stream *);
 internal_proto(compare_files);
 
@@ -680,6 +716,12 @@
 extern stream *open_internal (char *, int, gfc_offset);
 internal_proto(open_internal);
 
+extern char * mem_alloc_w (stream *, int *);
+internal_proto(mem_alloc_w);
+
+extern char * mem_alloc_r (stream *, int *);
+internal_proto(mem_alloc_w);
+
 extern stream *input_stream (void);
 internal_proto(input_stream);
 
@@ -695,12 +737,6 @@
 extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);
 internal_proto(find_file);
 
-extern int stream_at_bof (stream *);
-internal_proto(stream_at_bof);
-
-extern int stream_at_eof (stream *);
-internal_proto(stream_at_eof);
-
 extern int delete_file (gfc_unit *);
 internal_proto(delete_file);
 
@@ -731,36 +767,24 @@
 extern gfc_offset file_length (stream *);
 internal_proto(file_length);
 
-extern gfc_offset file_position (stream *);
-internal_proto(file_position);
-
 extern int is_seekable (stream *);
 internal_proto(is_seekable);
 
 extern int is_special (stream *);
 internal_proto(is_special);
 
-extern int is_preconnected (stream *);
-internal_proto(is_preconnected);
-
 extern void flush_if_preconnected (stream *);
 internal_proto(flush_if_preconnected);
 
 extern void empty_internal_buffer(stream *);
 internal_proto(empty_internal_buffer);
 
-extern try flush (stream *);
-internal_proto(flush);
-
 extern int stream_isatty (stream *);
 internal_proto(stream_isatty);
 
 extern char * stream_ttyname (stream *);
 internal_proto(stream_ttyname);
 
-extern gfc_offset stream_offset (stream *s);
-internal_proto(stream_offset);
-
 extern int unpack_filename (char *, const char *, int);
 internal_proto(unpack_filename);
 
@@ -804,6 +828,9 @@
 extern void finish_last_advance_record (gfc_unit *u);
 internal_proto (finish_last_advance_record);
 
+extern int unit_truncate (gfc_unit *, gfc_offset, st_parameter_common *);
+internal_proto (unit_truncate);
+
 /* open.c */
 
 extern gfc_unit *new_unit (st_parameter_open *, gfc_unit *, unit_flags *);
@@ -823,9 +850,18 @@
 extern void format_error (st_parameter_dt *, const fnode *, const char *);
 internal_proto(format_error);
 
-extern void free_format_data (st_parameter_dt *);
+extern void free_format_data (struct format_data *);
 internal_proto(free_format_data);
 
+extern void free_format_hash_table (gfc_unit *);
+internal_proto(free_format_hash_table);
+
+extern void init_format_hash (st_parameter_dt *);
+internal_proto(init_format_hash);
+
+extern void free_format_hash (st_parameter_dt *);
+internal_proto(free_format_hash);
+
 /* transfer.c */
 
 #define SCRATCH_SIZE 300
@@ -833,7 +869,7 @@
 extern const char *type_name (bt);
 internal_proto(type_name);
 
-extern try read_block_form (st_parameter_dt *, void *, size_t *);
+extern void * read_block_form (st_parameter_dt *, int *);
 internal_proto(read_block_form);
 
 extern char *read_sf (st_parameter_dt *, int *, int);
@@ -859,6 +895,9 @@
 extern void st_wait (st_parameter_wait *);
 export_proto(st_wait);
 
+extern void hit_eof (st_parameter_dt *);
+internal_proto(hit_eof);
+
 /* read.c */
 
 extern void set_integer (void *, GFC_INTEGER_LARGEST, int);
@@ -965,24 +1004,39 @@
 internal_proto(size_from_complex_kind);
 
 /* fbuf.c */
-extern void fbuf_init (gfc_unit *, size_t);
+extern void fbuf_init (gfc_unit *, int);
 internal_proto(fbuf_init);
 
 extern void fbuf_destroy (gfc_unit *);
 internal_proto(fbuf_destroy);
 
-extern void fbuf_reset (gfc_unit *);
+extern int fbuf_reset (gfc_unit *);
 internal_proto(fbuf_reset);
 
-extern char * fbuf_alloc (gfc_unit *, size_t);
+extern char * fbuf_alloc (gfc_unit *, int);
 internal_proto(fbuf_alloc);
 
-extern int fbuf_flush (gfc_unit *, int);
+extern int fbuf_flush (gfc_unit *, unit_mode);
 internal_proto(fbuf_flush);
 
-extern int fbuf_seek (gfc_unit *, gfc_offset);
+extern int fbuf_seek (gfc_unit *, int, int);
 internal_proto(fbuf_seek);
 
+extern char * fbuf_read (gfc_unit *, int *);
+internal_proto(fbuf_read);
+
+/* Never call this function, only use fbuf_getc().  */
+extern int fbuf_getc_refill (gfc_unit *);
+internal_proto(fbuf_getc_refill);
+
+static inline int
+fbuf_getc (gfc_unit * u)
+{
+  if (u->fbuf->pos < u->fbuf->act)
+    return (unsigned char) u->fbuf->buf[u->fbuf->pos++];
+  return fbuf_getc_refill (u);
+}
+
 /* lock.c */
 extern void free_ionml (st_parameter_dt *);
 internal_proto(free_ionml);
diff -Naur gcc-4.4.0.orig/libgfortran/io/list_read.c gcc-4.4.0/libgfortran/io/list_read.c
--- gcc-4.4.0.orig/libgfortran/io/list_read.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/list_read.c	2009-05-26 18:21:22.000000000 -0700
@@ -28,6 +28,7 @@
 
 #include "io.h"
 #include <string.h>
+#include <stdlib.h>
 #include <ctype.h>
 
 
@@ -74,9 +75,8 @@
 
   if (dtp->u.p.saved_string == NULL)
     {
-      if (dtp->u.p.scratch == NULL)
-	dtp->u.p.scratch = get_mem (SCRATCH_SIZE);
-      dtp->u.p.saved_string = dtp->u.p.scratch;
+      dtp->u.p.saved_string = get_mem (SCRATCH_SIZE);
+      // memset below should be commented out.
       memset (dtp->u.p.saved_string, 0, SCRATCH_SIZE);
       dtp->u.p.saved_length = SCRATCH_SIZE;
       dtp->u.p.saved_used = 0;
@@ -85,15 +85,15 @@
   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)
     {
       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;
-      new = get_mem (2 * dtp->u.p.saved_length);
-
-      memset (new, 0, 2 * dtp->u.p.saved_length);
-
-      memcpy (new, dtp->u.p.saved_string, dtp->u.p.saved_used);
-      if (dtp->u.p.saved_string != dtp->u.p.scratch)
-	free_mem (dtp->u.p.saved_string);
-
+      new = realloc (dtp->u.p.saved_string, dtp->u.p.saved_length);
+      if (new == NULL)
+	generate_error (&dtp->common, LIBERROR_OS, NULL);
       dtp->u.p.saved_string = new;
+      
+      // Also this should not be necessary.
+      memset (new + dtp->u.p.saved_used, 0, 
+	      dtp->u.p.saved_length - dtp->u.p.saved_used);
+
     }
 
   dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;
@@ -108,8 +108,7 @@
   if (dtp->u.p.saved_string == NULL)
     return;
 
-  if (dtp->u.p.saved_string != dtp->u.p.scratch)
-    free_mem (dtp->u.p.saved_string);
+  free_mem (dtp->u.p.saved_string);
 
   dtp->u.p.saved_string = NULL;
   dtp->u.p.saved_used = 0;
@@ -135,9 +134,10 @@
 static char
 next_char (st_parameter_dt *dtp)
 {
-  size_t length;
+  ssize_t length;
   gfc_offset record;
   char c;
+  int cc;
 
   if (dtp->u.p.last_char != '\0')
     {
@@ -189,7 +189,7 @@
 	    }
 
 	  record *= dtp->u.p.current_unit->recl;
-	  if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)
+	  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)
 	    longjmp (*dtp->u.p.eof_jump, 1);
 
 	  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;
@@ -199,19 +199,15 @@
 
   /* Get the next character and handle end-of-record conditions.  */
 
-  length = 1;
-
-  if (sread (dtp->u.p.current_unit->s, &c, &length) != 0)
-    {
-	generate_error (&dtp->common, LIBERROR_OS, NULL);
-	return '\0';
-    }
-  
-  if (is_stream_io (dtp) && length == 1)
-    dtp->u.p.current_unit->strm_pos++;
-
   if (is_internal_unit (dtp))
     {
+      length = sread (dtp->u.p.current_unit->s, &c, 1);
+      if (length < 0)
+	{
+	  generate_error (&dtp->common, LIBERROR_OS, NULL);
+	  return '\0';
+	}
+  
       if (is_array_io (dtp))
 	{
 	  /* Check whether we hit EOF.  */ 
@@ -235,13 +231,20 @@
     }
   else
     {
-      if (length == 0)
+      cc = fbuf_getc (dtp->u.p.current_unit);
+
+      if (cc == EOF)
 	{
 	  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)
 	    longjmp (*dtp->u.p.eof_jump, 1);
 	  dtp->u.p.current_unit->endfile = AT_ENDFILE;
 	  c = '\n';
 	}
+      else
+	c = (char) cc;
+      if (is_stream_io (dtp) && cc != EOF)
+	dtp->u.p.current_unit->strm_pos++;
+
     }
 done:
   dtp->u.p.at_eol = (c == '\n' || c == '\r');
@@ -1216,7 +1219,7 @@
    what it is right away.  */
 
 static void
-read_complex (st_parameter_dt *dtp, int kind, size_t size)
+read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)
 {
   char message[100];
   char c;
@@ -1240,7 +1243,7 @@
     }
 
   eat_spaces (dtp);
-  if (parse_real (dtp, dtp->u.p.value, kind))
+  if (parse_real (dtp, dest, kind))
     return;
 
 eol_1:
@@ -1263,7 +1266,7 @@
   else
     unget_char (dtp, c);
 
-  if (parse_real (dtp, dtp->u.p.value + size / 2, kind))
+  if (parse_real (dtp, dest + size / 2, kind))
     return;
 
   eat_spaces (dtp);
@@ -1297,7 +1300,7 @@
 /* Parse a real number with a possible repeat count.  */
 
 static void
-read_real (st_parameter_dt *dtp, int length)
+read_real (st_parameter_dt *dtp, void * dest, int length)
 {
   char c, message[100];
   int seen_dp;
@@ -1510,7 +1513,7 @@
   unget_char (dtp, c);
   eat_separator (dtp);
   push_char (dtp, '\0');
-  if (convert_real (dtp, dtp->u.p.value, dtp->u.p.saved_string, length))
+  if (convert_real (dtp, dest, dtp->u.p.saved_string, length))
     return;
 
   free_saved (dtp);
@@ -1693,7 +1696,7 @@
       dtp->u.p.input_complete = 0;
       dtp->u.p.repeat_count = 1;
       dtp->u.p.at_eol = 0;
-
+      
       c = eat_spaces (dtp);
       if (is_separator (c))
 	{
@@ -1721,6 +1724,9 @@
 	    return;
 	  goto set_value;
 	}
+	
+      if (dtp->u.p.input_complete)
+	goto cleanup;
 
       if (dtp->u.p.input_complete)
 	goto cleanup;
@@ -1751,10 +1757,16 @@
       read_character (dtp, kind);
       break;
     case BT_REAL:
-      read_real (dtp, kind);
+      read_real (dtp, p, kind);
+      /* Copy value back to temporary if needed.  */
+      if (dtp->u.p.repeat_count > 0)
+	memcpy (dtp->u.p.value, p, kind);
       break;
     case BT_COMPLEX:
-      read_complex (dtp, kind, size);
+      read_complex (dtp, p, kind, size);
+      /* Copy value back to temporary if needed.  */
+      if (dtp->u.p.repeat_count > 0)
+	memcpy (dtp->u.p.value, p, size);
       break;
     default:
       internal_error (&dtp->common, "Bad type for list read");
@@ -1770,8 +1782,12 @@
   switch (dtp->u.p.saved_type)
     {
     case BT_COMPLEX:
-    case BT_INTEGER:
     case BT_REAL:
+      if (dtp->u.p.repeat_count > 0)
+	memcpy (p, dtp->u.p.value, size);
+      break;
+
+    case BT_INTEGER:
     case BT_LOGICAL:
       memcpy (p, dtp->u.p.value, size);
       break;
@@ -1848,6 +1864,8 @@
 
   free_saved (dtp);
 
+  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
+
   if (dtp->u.p.at_eol)
     {
       dtp->u.p.at_eol = 0;
@@ -2256,8 +2274,8 @@
 
       /* Flush the stream to force immediate output.  */
 
-      fbuf_flush (dtp->u.p.current_unit, 1);
-      flush (dtp->u.p.current_unit->s);
+      fbuf_flush (dtp->u.p.current_unit, WRITING);
+      sflush (dtp->u.p.current_unit->s);
       unlock_unit (dtp->u.p.current_unit);
     }
 
@@ -2292,7 +2310,7 @@
   int dim;
   index_type dlen;
   index_type m;
-  index_type obj_name_len;
+  size_t obj_name_len;
   void * pdata;
 
   /* This object not touched in name parsing.  */
@@ -2371,12 +2389,17 @@
               break;
 
 	  case GFC_DTYPE_REAL:
-	      read_real (dtp, len);
-              break;
+	    /* Need to copy data back from the real location to the temp in order
+	       to handle nml reads into arrays.  */
+	    read_real (dtp, pdata, len);
+	    memcpy (dtp->u.p.value, pdata, dlen);
+	    break;
 
 	  case GFC_DTYPE_COMPLEX:
-              read_complex (dtp, len, dlen);
-              break;
+	    /* Same as for REAL, copy back to temp.  */
+	    read_complex (dtp, pdata, len, dlen);
+	    memcpy (dtp->u.p.value, pdata, dlen);
+	    break;
 
 	  case GFC_DTYPE_DERIVED:
 	    obj_name_len = strlen (nl->var_name) + 1;
@@ -2898,7 +2921,7 @@
 	  st_printf ("%s\n", nml_err_msg);
 	  if (u != NULL)
 	    {
-	      flush (u->s);
+	      sflush (u->s);
 	      unlock_unit (u);
 	    }
         }
diff -Naur gcc-4.4.0.orig/libgfortran/io/open.c gcc-4.4.0/libgfortran/io/open.c
--- gcc-4.4.0.orig/libgfortran/io/open.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/open.c	2009-05-26 18:21:22.000000000 -0700
@@ -150,7 +150,7 @@
 static void
 test_endfile (gfc_unit * u)
 {
-  if (u->endfile == NO_ENDFILE && file_length (u->s) == file_position (u->s))
+  if (u->endfile == NO_ENDFILE && file_length (u->s) == stell (u->s))
     u->endfile = AT_ENDFILE;
 }
 
@@ -266,7 +266,7 @@
       break;
 
     case POSITION_REWIND:
-      if (sseek (u->s, 0) == FAILURE)
+      if (sseek (u->s, 0, SEEK_SET) != 0)
 	goto seek_error;
 
       u->current_record = 0;
@@ -276,7 +276,7 @@
       break;
 
     case POSITION_APPEND:
-      if (sseek (u->s, file_length (u->s)) == FAILURE)
+      if (sseek (u->s, 0, SEEK_END) < 0)
 	goto seek_error;
 
       if (flags->access != ACCESS_STREAM)
@@ -552,7 +552,7 @@
 
   if (flags->position == POSITION_APPEND)
     {
-      if (sseek (u->s, file_length (u->s)) == FAILURE)
+      if (sseek (u->s, 0, SEEK_END) < 0)
 	generate_error (&opp->common, LIBERROR_OS, NULL);
       u->endfile = AT_ENDFILE;
     }
@@ -606,7 +606,8 @@
     {
       u->maxrec = max_offset;
       u->recl = 1;
-      u->strm_pos = file_position (u->s) + 1;
+      u->bytes_left = 1;
+      u->strm_pos = stell (u->s) + 1;
     }
 
   memmove (u->file, opp->file, opp->file_len);
@@ -622,7 +623,7 @@
   if (flags->status == STATUS_SCRATCH && opp->file != NULL)
     free_mem (opp->file);
     
-  if (flags->form == FORM_FORMATTED && (flags->action != ACTION_READ))
+  if (flags->form == FORM_FORMATTED)
     {
       if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN))
         fbuf_init (u, u->recl);
@@ -676,7 +677,7 @@
 	}
 #endif
 
-      if (sclose (u->s) == FAILURE)
+      if (sclose (u->s) == -1)
 	{
 	  unlock_unit (u);
 	  generate_error (&opp->common, LIBERROR_OS,
diff -Naur gcc-4.4.0.orig/libgfortran/io/read.c gcc-4.4.0/libgfortran/io/read.c
--- gcc-4.4.0.orig/libgfortran/io/read.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/read.c	2009-05-26 18:21:22.000000000 -0700
@@ -28,6 +28,7 @@
 #include <errno.h>
 #include <ctype.h>
 #include <stdlib.h>
+#include <assert.h>
 
 typedef unsigned char uchar;
 
@@ -125,8 +126,10 @@
 
 /* convert_real()-- Convert a character representation of a floating
  * point number to the machine number.  Returns nonzero if there is a
- * range problem during conversion.  TODO: handle not-a-numbers and
- * infinities.  */
+ * range problem during conversion.  Note: many architectures
+ * (e.g. IA-64, HP-PA) require that the storage pointed to by the dest
+ * argument is properly aligned for the type in question.  TODO:
+ * handle not-a-numbers and infinities.  */
 
 int
 convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)
@@ -136,38 +139,30 @@
   switch (length)
     {
     case 4:
-      {
-	GFC_REAL_4 tmp =
+      *((GFC_REAL_4*) dest) =
 #if defined(HAVE_STRTOF)
-	  strtof (buffer, NULL);
+	strtof (buffer, NULL);
 #else
-	  (GFC_REAL_4) strtod (buffer, NULL);
+	(GFC_REAL_4) strtod (buffer, NULL);
 #endif
-	memcpy (dest, (void *) &tmp, length);
-      }
       break;
+
     case 8:
-      {
-	GFC_REAL_8 tmp = strtod (buffer, NULL);
-	memcpy (dest, (void *) &tmp, length);
-      }
+      *((GFC_REAL_8*) dest) = strtod (buffer, NULL);
       break;
+
 #if defined(HAVE_GFC_REAL_10) && defined (HAVE_STRTOLD)
     case 10:
-      {
-	GFC_REAL_10 tmp = strtold (buffer, NULL);
-	memcpy (dest, (void *) &tmp, length);
-      }
+      *((GFC_REAL_10*) dest) = strtold (buffer, NULL);
       break;
 #endif
+
 #if defined(HAVE_GFC_REAL_16) && defined (HAVE_STRTOLD)
     case 16:
-      {
-	GFC_REAL_16 tmp = strtold (buffer, NULL);
-	memcpy (dest, (void *) &tmp, length);
-      }
+      *((GFC_REAL_16*) dest) = strtold (buffer, NULL);
       break;
 #endif
+
     default:
       internal_error (&dtp->common, "Unsupported real kind during IO");
     }
@@ -190,13 +185,13 @@
 read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)
 {
   char *p;
-  size_t w;
+  int w;
 
   w = f->u.w;
 
-  p = gfc_alloca (w);
+  p = read_block_form (dtp, &w);
 
-  if (read_block_form (dtp, p, &w) == FAILURE)
+  if (p == NULL)
     return;
 
   while (*p == ' ')
@@ -233,28 +228,26 @@
 }
 
 
-static inline gfc_char4_t
-read_utf8 (st_parameter_dt *dtp, size_t *nbytes) 
+static gfc_char4_t
+read_utf8 (st_parameter_dt *dtp, int *nbytes) 
 {
   static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };
   static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-  static uchar buffer[6];
-  size_t i, nb, nread;
+  int i, nb, nread;
   gfc_char4_t c;
-  int status;
   char *s;
 
   *nbytes = 1;
-  s = (char *) &buffer[0];
-  status = read_block_form (dtp, s, nbytes);
-  if (status == FAILURE)
+
+  s = read_block_form (dtp, nbytes);
+  if (s == NULL)
     return 0;
 
   /* If this is a short read, just return.  */
   if (*nbytes == 0)
     return 0;
 
-  c = buffer[0];
+  c = (uchar) s[0];
   if (c < 0x80)
     return c;
 
@@ -269,9 +262,8 @@
   c = (c & masks[nb-1]);
   nread = nb - 1;
 
-  s = (char *) &buffer[1];
-  status = read_block_form (dtp, s, &nread);
-  if (status == FAILURE)
+  s = read_block_form (dtp, &nread);
+  if (s == NULL)
     return 0;
   /* Decode the bytes read.  */
   for (i = 1; i < nb; i++)
@@ -304,14 +296,14 @@
 
 
 static void
-read_utf8_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)
+read_utf8_char1 (st_parameter_dt *dtp, char *p, int len, int width)
 {
   gfc_char4_t c;
   char *dest;
-  size_t nbytes;
+  int nbytes;
   int i, j;
 
-  len = ((int) width < len) ? len : (int) width;
+  len = (width < len) ? len : width;
 
   dest = (char *) p;
 
@@ -334,21 +326,19 @@
 }
 
 static void
-read_default_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)
+read_default_char1 (st_parameter_dt *dtp, char *p, int len, int width)
 {
   char *s;
-  int m, n, status;
+  int m, n;
 
-  s = gfc_alloca (width);
-
-  status = read_block_form (dtp, s, &width);
+  s = read_block_form (dtp, &width);
   
-  if (status == FAILURE)
+  if (s == NULL)
     return;
-  if (width > (size_t) len)
+  if (width > len)
      s += (width - len);
 
-  m = ((int) width > len) ? len : (int) width;
+  m = (width > len) ? len : width;
   memcpy (p, s, m);
 
   n = len - width;
@@ -358,13 +348,13 @@
 
 
 static void
-read_utf8_char4 (st_parameter_dt *dtp, void *p, int len, size_t width)
+read_utf8_char4 (st_parameter_dt *dtp, void *p, int len, int width)
 {
   gfc_char4_t *dest;
-  size_t nbytes;
+  int nbytes;
   int i, j;
 
-  len = ((int) width < len) ? len : (int) width;
+  len = (width < len) ? len : width;
 
   dest = (gfc_char4_t *) p;
 
@@ -386,19 +376,17 @@
 
 
 static void
-read_default_char4 (st_parameter_dt *dtp, char *p, int len, size_t width)
+read_default_char4 (st_parameter_dt *dtp, char *p, int len, int width)
 {
   char *s;
   gfc_char4_t *dest;
-  int m, n, status;
-
-  s = gfc_alloca (width);
+  int m, n;
 
-  status = read_block_form (dtp, s, &width);
+  s = read_block_form (dtp, &width);
   
-  if (status == FAILURE)
+  if (s == NULL)
     return;
-  if (width > (size_t) len)
+  if (width > len)
      s += (width - len);
 
   m = ((int) width > len) ? len : (int) width;
@@ -420,7 +408,7 @@
 read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)
 {
   int wi;
-  size_t w;
+  int w;
 
   wi = f->u.w;
   if (wi == -1) /* '(A)' edit descriptor  */
@@ -446,13 +434,11 @@
 void
 read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)
 {
-  int wi;
-  size_t w;
+  int w;
 
-  wi = f->u.w;
-  if (wi == -1) /* '(A)' edit descriptor  */
-    wi = length;
-  w = wi;
+  w = f->u.w;
+  if (w == -1) /* '(A)' edit descriptor  */
+    w = length;
 
   /* Read in w characters, treating comma as not a separator.  */
   dtp->u.p.sf_read_comma = 0;
@@ -527,18 +513,15 @@
   GFC_UINTEGER_LARGEST value, maxv, maxv_10;
   GFC_INTEGER_LARGEST v;
   int w, negative; 
-  size_t wu;
   char c, *p;
 
-  wu = f->u.w;
+  w = f->u.w;
 
-  p = gfc_alloca (wu);
+  p = read_block_form (dtp, &w);
 
-  if (read_block_form (dtp, p, &wu) == FAILURE)
+  if (p == NULL)
     return;
 
-  w = wu;
-
   p = eat_leading_spaces (&w, p);
   if (w == 0)
     {
@@ -631,17 +614,14 @@
   GFC_INTEGER_LARGEST v;
   int w, negative;
   char c, *p;
-  size_t wu;
 
-  wu = f->u.w;
+  w = f->u.w;
 
-  p = gfc_alloca (wu);
+  p = read_block_form (dtp, &w);
 
-  if (read_block_form (dtp, p, &wu) == FAILURE)
+  if (p == NULL)
     return;
 
-  w = wu;
-
   p = eat_leading_spaces (&w, p);
   if (w == 0)
     {
@@ -778,75 +758,83 @@
 void
 read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)
 {
-  size_t wu;
   int w, seen_dp, exponent;
-  int exponent_sign, val_sign;
-  int ndigits;
-  int edigits;
-  int i;
-  char *p, *buffer;
-  char *digits;
-  char scratch[SCRATCH_SIZE];
+  int exponent_sign;
+  const char *p;
+  char *buffer;
+  char *out;
+  int seen_int_digit; /* Seen a digit before the decimal point?  */
+  int seen_dec_digit; /* Seen a digit after the decimal point?  */
 
-  val_sign = 1;
   seen_dp = 0;
-  wu = f->u.w;
-
-  p = gfc_alloca (wu);
+  seen_int_digit = 0;
+  seen_dec_digit = 0;
+  exponent_sign = 1;
+  exponent = 0;
+  w = f->u.w;
 
-  if (read_block_form (dtp, p, &wu) == FAILURE)
+  /* Read in the next block.  */
+  p = read_block_form (dtp, &w);
+  if (p == NULL)
     return;
-
-  w = wu;
-
-  p = eat_leading_spaces (&w, p);
+  p = eat_leading_spaces (&w, (char*) p);
   if (w == 0)
     goto zero;
 
-  /* Optional sign */
+  /* In this buffer we're going to re-format the number cleanly to be parsed
+     by convert_real in the end; this assures we're using strtod from the
+     C library for parsing and thus probably get the best accuracy possible.
+     This process may add a '+0.0' in front of the number as well as change the
+     exponent because of an implicit decimal point or the like.  Thus allocating
+     strlen ("+0.0e-1000") == 10 characters plus one for NUL more than the
+     original buffer had should be enough.  */
+  buffer = gfc_alloca (w + 11);
+  out = buffer;
 
+  /* Optional sign */
   if (*p == '-' || *p == '+')
     {
       if (*p == '-')
-        val_sign = -1;
-      p++;
-      w--;
+	*(out++) = '-';
+      ++p;
+      --w;
     }
 
-  exponent_sign = 1;
-  p = eat_leading_spaces (&w, p);
+  p = eat_leading_spaces (&w, (char*) p);
   if (w == 0)
     goto zero;
 
-  /* A digit, a '.' or a exponent character ('e', 'E', 'd' or 'D')
-     is required at this point */
-
-  if (!isdigit (*p) && *p != '.' && *p != ',' && *p != 'd' && *p != 'D'
-      && *p != 'e' && *p != 'E')
-    goto bad_float;
-
-  /* Remember the position of the first digit.  */
-  digits = p;
-  ndigits = 0;
-
-  /* Scan through the string to find the exponent.  */
+  /* Process the mantissa string.  */
   while (w > 0)
     {
       switch (*p)
 	{
 	case ',':
-	  if (dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA
-               && *p == ',')
-	    *p = '.';
-	  else
+	  if (dtp->u.p.current_unit->decimal_status != DECIMAL_COMMA)
 	    goto bad_float;
-	  /* Fall through */
+	  /* Fall through.  */
 	case '.':
 	  if (seen_dp)
 	    goto bad_float;
+	  if (!seen_int_digit)
+	    *(out++) = '0';
+	  *(out++) = '.';
 	  seen_dp = 1;
-	  /* Fall through */
+	  break;
 
+	case ' ':
+	  if (dtp->u.p.blank_status == BLANK_ZERO)
+	    {
+	      *(out++) = '0';
+	      goto found_digit;
+	    }
+	  else if (dtp->u.p.blank_status == BLANK_NULL)
+	    break;
+	  else
+	    /* TODO: Should we check instead that there are only trailing
+	       blanks here, as is done below for exponents?  */
+	    goto done;
+	  /* Fall through.  */
 	case '0':
 	case '1':
 	case '2':
@@ -857,207 +845,173 @@
 	case '7':
 	case '8':
 	case '9':
-	case ' ':
-	  ndigits++;
-	  p++;
-	  w--;
+	  *(out++) = *p;
+found_digit:
+	  if (!seen_dp)
+	    seen_int_digit = 1;
+	  else
+	    seen_dec_digit = 1;
 	  break;
 
 	case '-':
-	  exponent_sign = -1;
-	  /* Fall through */
-
 	case '+':
-	  p++;
-	  w--;
-	  goto exp2;
+	  goto exponent;
 
-	case 'd':
 	case 'e':
-	case 'D':
 	case 'E':
-	  p++;
-	  w--;
-	  goto exp1;
+	case 'd':
+	case 'D':
+	  ++p;
+	  --w;
+	  goto exponent;
 
 	default:
 	  goto bad_float;
 	}
-    }
 
-  /* No exponent has been seen, so we use the current scale factor */
-  exponent = -dtp->u.p.scale_factor;
-  goto done;
-
- bad_float:
-  generate_error (&dtp->common, LIBERROR_READ_VALUE,
-		  "Bad value during floating point read");
-  next_record (dtp, 1);
-  return;
-
-  /* The value read is zero */
- zero:
-  switch (length)
-    {
-      case 4:
-	*((GFC_REAL_4 *) dest) = 0;
-	break;
-
-      case 8:
-	*((GFC_REAL_8 *) dest) = 0;
-	break;
-
-#ifdef HAVE_GFC_REAL_10
-      case 10:
-	*((GFC_REAL_10 *) dest) = 0;
-	break;
-#endif
-
-#ifdef HAVE_GFC_REAL_16
-      case 16:
-	*((GFC_REAL_16 *) dest) = 0;
-	break;
-#endif
-
-      default:
-	internal_error (&dtp->common, "Unsupported real kind during IO");
+      ++p;
+      --w;
     }
-  return;
+  
+  /* No exponent has been seen, so we use the current scale factor.  */
+  exponent = - dtp->u.p.scale_factor;
+  goto done;
 
-  /* At this point the start of an exponent has been found */
- exp1:
-  while (w > 0 && *p == ' ')
+  /* At this point the start of an exponent has been found.  */
+exponent:
+  p = eat_leading_spaces (&w, (char*) p);
+  if (*p == '-' || *p == '+')
     {
-      w--;
-      p++;
+      if (*p == '-')
+	exponent_sign = -1;
+      ++p;
+      --w;
     }
 
-  switch (*p)
-    {
-    case '-':
-      exponent_sign = -1;
-      /* Fall through */
-
-    case '+':
-      p++;
-      w--;
-      break;
-    }
+  /* At this point a digit string is required.  We calculate the value
+     of the exponent in order to take account of the scale factor and
+     the d parameter before explict conversion takes place.  */
 
   if (w == 0)
     goto bad_float;
 
-  /* At this point a digit string is required.  We calculate the value
-     of the exponent in order to take account of the scale factor and
-     the d parameter before explict conversion takes place. */
- exp2:
-  /* Normal processing of exponent */
-  exponent = 0;
   if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)
     {
       while (w > 0 && isdigit (*p))
-        {
-          exponent = 10 * exponent + *p - '0';
-          p++;
-          w--;
-        }
-        
-      /* Only allow trailing blanks */
-
+	{
+	  exponent *= 10;
+	  exponent += *p - '0';
+	  ++p;
+	  --w;
+	}
+	
+      /* Only allow trailing blanks.  */
       while (w > 0)
-        {
-          if (*p != ' ')
+	{
+	  if (*p != ' ')
 	    goto bad_float;
-          p++;
-          w--;
-        }
+	  ++p;
+	  --w;
+	}
     }    
-  else  /* BZ or BN status is enabled */
+  else  /* BZ or BN status is enabled.  */
     {
       while (w > 0)
-        {
-          if (*p == ' ')
-            {
-	      if (dtp->u.p.blank_status == BLANK_ZERO) *p = '0';
-	      if (dtp->u.p.blank_status == BLANK_NULL)
-                {
-                  p++;
-                  w--;
-                  continue;
-                }
-            }
-          else if (!isdigit (*p))
-            goto bad_float;
-
-          exponent = 10 * exponent + *p - '0';
-          p++;
-          w--;
-        }
+	{
+	  if (*p == ' ')
+	    {
+	      if (dtp->u.p.blank_status == BLANK_ZERO)
+		exponent *= 10;
+	      else
+		assert (dtp->u.p.blank_status == BLANK_NULL);
+	    }
+	  else if (!isdigit (*p))
+	    goto bad_float;
+	  else
+	    {
+	      exponent *= 10;
+	      exponent += *p - '0';
+	    }
+
+	  ++p;
+	  --w;
+	}
     }
 
-  exponent = exponent * exponent_sign;
+  exponent *= exponent_sign;
 
- done:
+done:
   /* Use the precision specified in the format if no decimal point has been
      seen.  */
   if (!seen_dp)
     exponent -= f->u.real.d;
 
-  if (exponent > 0)
+  /* Output a trailing '0' after decimal point if not yet found.  */
+  if (seen_dp && !seen_dec_digit)
+    *(out++) = '0';
+
+  /* Print out the exponent to finish the reformatted number.  Maximum 4
+     digits for the exponent.  */
+  if (exponent != 0)
     {
-      edigits = 2;
-      i = exponent;
-    }
-  else
-    {
-      edigits = 3;
-      i = -exponent;
-    }
+      int dig;
 
-  while (i >= 10)
-    {
-      i /= 10;
-      edigits++;
+      *(out++) = 'e';
+      if (exponent < 0)
+	{
+	  *(out++) = '-';
+	  exponent = - exponent;
+	}
+
+      assert (exponent < 10000);
+      for (dig = 3; dig >= 0; --dig)
+	{
+	  out[dig] = (char) ('0' + exponent % 10);
+	  exponent /= 10;
+	}
+      out += 4;
     }
+  *(out++) = '\0';
 
-  i = ndigits + edigits + 1;
-  if (val_sign < 0)
-    i++;
+  /* Do the actual conversion.  */
+  convert_real (dtp, dest, buffer, length);
 
-  if (i < SCRATCH_SIZE) 
-    buffer = scratch;
-  else
-    buffer = get_mem (i);
+  return;
 
-  /* Reformat the string into a temporary buffer.  As we're using atof it's
-     easiest to just leave the decimal point in place.  */
-  p = buffer;
-  if (val_sign < 0)
-    *(p++) = '-';
-  for (; ndigits > 0; ndigits--)
+  /* The value read is zero.  */
+zero:
+  switch (length)
     {
-      if (*digits == ' ')
-        {
-	  if (dtp->u.p.blank_status == BLANK_ZERO) *digits = '0';
-	  if (dtp->u.p.blank_status == BLANK_NULL)
-            {
-              digits++;
-              continue;
-            } 
-        }
-      *p = *digits;
-      p++;
-      digits++;
-    }
-  *(p++) = 'e';
-  sprintf (p, "%d", exponent);
+      case 4:
+	*((GFC_REAL_4 *) dest) = 0.0;
+	break;
 
-  /* Do the actual conversion.  */
-  convert_real (dtp, dest, buffer, length);
+      case 8:
+	*((GFC_REAL_8 *) dest) = 0.0;
+	break;
 
-  if (buffer != scratch)
-     free_mem (buffer);
+#ifdef HAVE_GFC_REAL_10
+      case 10:
+	*((GFC_REAL_10 *) dest) = 0.0;
+	break;
+#endif
 
+#ifdef HAVE_GFC_REAL_16
+      case 16:
+	*((GFC_REAL_16 *) dest) = 0.0;
+	break;
+#endif
+
+      default:
+	internal_error (&dtp->common, "Unsupported real kind during IO");
+    }
+  return;
+
+bad_float:
+  generate_error (&dtp->common, LIBERROR_READ_VALUE,
+		  "Bad value during floating point read");
+  next_record (dtp, 1);
+  return;
 }
 
 
diff -Naur gcc-4.4.0.orig/libgfortran/io/transfer.c gcc-4.4.0/libgfortran/io/transfer.c
--- gcc-4.4.0.orig/libgfortran/io/transfer.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/transfer.c	2009-05-26 18:21:22.000000000 -0700
@@ -32,6 +32,7 @@
 #include <string.h>
 #include <assert.h>
 #include <stdlib.h>
+#include <errno.h>
 
 
 /* Calling conventions:  Data transfer statements are unlike other
@@ -178,60 +179,58 @@
    heap.  Hopefully this won't happen very often.  */
 
 char *
-read_sf (st_parameter_dt *dtp, int *length, int no_error)
+read_sf (st_parameter_dt *dtp, int * length, int no_error)
 {
+  static char *empty_string[0];
   char *base, *p, q;
-  int n, crlf;
-  gfc_offset pos;
-  size_t readlen;
-
-  if (*length > SCRATCH_SIZE)
-    dtp->u.p.line_buffer = get_mem (*length);
-  p = base = dtp->u.p.line_buffer;
+  int n, lorig, memread, seen_comma;
+
+  /* If we hit EOF previously with the no_error flag set (i.e. X, T,
+     TR edit descriptors), and we now try to read again, this time
+     without setting no_error.  */
+  if (!no_error && dtp->u.p.at_eof)
+    {
+      *length = 0;
+      hit_eof (dtp);
+      return NULL;
+    }
 
   /* If we have seen an eor previously, return a length of 0.  The
      caller is responsible for correctly padding the input field.  */
   if (dtp->u.p.sf_seen_eor)
     {
       *length = 0;
-      return base;
+      /* Just return something that isn't a NULL pointer, otherwise the
+         caller thinks an error occured.  */
+      return (char*) empty_string;
     }
 
   if (is_internal_unit (dtp))
     {
-      readlen = *length;
-      if (unlikely (sread (dtp->u.p.current_unit->s, p, &readlen) != 0
-		    || readlen < (size_t) *length))
+      memread = *length;
+      base = mem_alloc_r (dtp->u.p.current_unit->s, length);
+      if (unlikely (memread > *length))
 	{
-	  generate_error (&dtp->common, LIBERROR_END, NULL);
+          hit_eof (dtp);
 	  return NULL;
 	}
-	
+      n = *length;
       goto done;
     }
 
-  readlen = 1;
-  n = 0;
+  n = seen_comma = 0;
 
-  do
-    {
-      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen) != 0))
-        {
-	  generate_error (&dtp->common, LIBERROR_END, NULL);
-	  return NULL;
-	}
+  /* Read data into format buffer and scan through it.  */
+  lorig = *length;
+  base = p = fbuf_read (dtp->u.p.current_unit, length);
+  if (base == NULL)
+    return NULL;
 
-      /* If we have a line without a terminating \n, drop through to
-	 EOR below.  */
-      if (readlen < 1 && n == 0)
-	{
-	  if (likely (no_error))
-	    break;
-	  generate_error (&dtp->common, LIBERROR_END, NULL);
-	  return NULL;
-	}
+  while (n < *length)
+    {
+      q = *p;
 
-      if (readlen < 1 || q == '\n' || q == '\r')
+      if (q == '\n' || q == '\r')
 	{
 	  /* Unexpected end of line.  */
 
@@ -240,23 +239,14 @@
 	  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)
 	    dtp->u.p.eor_condition = 1;
 
-	  crlf = 0;
 	  /* If we encounter a CR, it might be a CRLF.  */
 	  if (q == '\r') /* Probably a CRLF */
 	    {
-	      readlen = 1;
-	      pos = stream_offset (dtp->u.p.current_unit->s);
-	      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen)
-			    != 0))
-	        {
-		  generate_error (&dtp->common, LIBERROR_END, NULL);
-		  return NULL;
-		}
-	      if (q != '\n' && readlen == 1) /* Not a CRLF after all.  */
-		sseek (dtp->u.p.current_unit->s, pos);
-	      else
-		crlf = 1;
+	      if (n < *length && *(p + 1) == '\n')
+		dtp->u.p.sf_seen_eor = 2;
 	    }
+          else
+            dtp->u.p.sf_seen_eor = 1;
 
 	  /* Without padding, terminate the I/O statement without assigning
 	     the value.  With padding, the value still needs to be assigned,
@@ -270,7 +260,6 @@
 	    }
 
 	  *length = n;
-	  dtp->u.p.sf_seen_eor = (crlf ? 2 : 1);
 	  break;
 	}
       /*  Short circuit the read if a comma is found during numeric input.
@@ -279,6 +268,7 @@
       if (q == ',')
 	if (dtp->u.p.sf_read_comma == 1)
 	  {
+            seen_comma = 1;
 	    notify_std (&dtp->common, GFC_STD_GNU,
 			"Comma in formatted numeric read.");
 	    *length = n;
@@ -286,16 +276,31 @@
 	  }
 
       n++;
-      *p++ = q;
-      dtp->u.p.sf_seen_eor = 0;
+      p++;
+    } 
+
+  fbuf_seek (dtp->u.p.current_unit, n + dtp->u.p.sf_seen_eor + seen_comma, 
+             SEEK_CUR);
+
+  /* A short read implies we hit EOF, unless we hit EOR, a comma, or
+     some other stuff. Set the relevant flags.  */
+  if (lorig > *length && !dtp->u.p.sf_seen_eor && !seen_comma)
+    {
+      if (no_error)
+        dtp->u.p.at_eof = 1;
+      else
+        {
+          hit_eof (dtp);
+          return NULL;
+        }
     }
-  while (n < *length);
 
  done:
-  dtp->u.p.current_unit->bytes_left -= *length;
+
+  dtp->u.p.current_unit->bytes_left -= n;
 
   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)
-    dtp->u.p.size_used += (GFC_IO_INT) *length;
+    dtp->u.p.size_used += (GFC_IO_INT) n;
 
   return base;
 }
@@ -311,12 +316,11 @@
    opened with PAD=YES.  The caller must assume tailing spaces for
    short reads.  */
 
-try
-read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)
+void *
+read_block_form (st_parameter_dt *dtp, int * nbytes)
 {
   char *source;
-  size_t nread;
-  int nb;
+  int norig;
 
   if (!is_stream_io (dtp))
     {
@@ -333,15 +337,14 @@
 		{
 		  /* Not enough data left.  */
 		  generate_error (&dtp->common, LIBERROR_EOR, NULL);
-		  return FAILURE;
+		  return NULL;
 		}
 	    }
 
 	  if (unlikely (dtp->u.p.current_unit->bytes_left == 0))
 	    {
-	      dtp->u.p.current_unit->endfile = AT_ENDFILE;
-	      generate_error (&dtp->common, LIBERROR_END, NULL);
-	      return FAILURE;
+              hit_eof (dtp);
+	      return NULL;
 	    }
 
 	  *nbytes = dtp->u.p.current_unit->bytes_left;
@@ -352,42 +355,36 @@
       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||
        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))
     {
-      nb = *nbytes;
-      source = read_sf (dtp, &nb, 0);
-      *nbytes = nb;
+      source = read_sf (dtp, nbytes, 0);
       dtp->u.p.current_unit->strm_pos +=
 	(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);
-      if (source == NULL)
-	return FAILURE;
-      memcpy (buf, source, *nbytes);
-      return SUCCESS;
+      return source;
     }
+
+  /* If we reach here, we can assume it's direct access.  */
+
   dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;
 
-  nread = *nbytes;
-  if (unlikely (sread (dtp->u.p.current_unit->s, buf, &nread) != 0))
-    {
-      generate_error (&dtp->common, LIBERROR_OS, NULL);
-      return FAILURE;
-    }
+  norig = *nbytes;
+  source = fbuf_read (dtp->u.p.current_unit, nbytes);
+  fbuf_seek (dtp->u.p.current_unit, *nbytes, SEEK_CUR);
 
   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)
-    dtp->u.p.size_used += (GFC_IO_INT) nread;
+    dtp->u.p.size_used += (GFC_IO_INT) *nbytes;
 
-  if (nread != *nbytes)
-    {				/* Short read, this shouldn't happen.  */
-      if (likely (dtp->u.p.current_unit->pad_status == PAD_YES))
-	*nbytes = nread;
-      else
+  if (norig != *nbytes)
+    {				
+      /* Short read, this shouldn't happen.  */
+      if (!dtp->u.p.current_unit->pad_status == PAD_YES)
 	{
 	  generate_error (&dtp->common, LIBERROR_EOR, NULL);
 	  source = NULL;
 	}
     }
 
-  dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;
+  dtp->u.p.current_unit->strm_pos += (gfc_offset) *nbytes;
 
-  return SUCCESS;
+  return source;
 }
 
 
@@ -395,20 +392,19 @@
    unformatted files.  */
 
 static void
-read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)
+read_block_direct (st_parameter_dt *dtp, void *buf, size_t nbytes)
 {
-  size_t to_read_record;
-  size_t have_read_record;
-  size_t to_read_subrecord;
-  size_t have_read_subrecord;
+  ssize_t to_read_record;
+  ssize_t have_read_record;
+  ssize_t to_read_subrecord;
+  ssize_t have_read_subrecord;
   int short_record;
 
   if (is_stream_io (dtp))
     {
-      to_read_record = *nbytes;
-      have_read_record = to_read_record;
-      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &have_read_record)
-		    != 0))
+      have_read_record = sread (dtp->u.p.current_unit->s, buf, 
+				nbytes);
+      if (unlikely (have_read_record < 0))
 	{
 	  generate_error (&dtp->common, LIBERROR_OS, NULL);
 	  return;
@@ -416,52 +412,48 @@
 
       dtp->u.p.current_unit->strm_pos += (gfc_offset) have_read_record; 
 
-      if (unlikely (to_read_record != have_read_record))
+      if (unlikely ((ssize_t) nbytes != have_read_record))
 	{
 	  /* Short read,  e.g. if we hit EOF.  For stream files,
 	   we have to set the end-of-file condition.  */
-	  generate_error (&dtp->common, LIBERROR_END, NULL);
-	  return;
+          hit_eof (dtp);
 	}
       return;
     }
 
   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)
     {
-      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)
+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes)
 	{
 	  short_record = 1;
-	  to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;
-	  *nbytes = to_read_record;
+	  to_read_record = dtp->u.p.current_unit->bytes_left;
+	  nbytes = to_read_record;
 	}
-
       else
 	{
 	  short_record = 0;
-	  to_read_record = *nbytes;
+	  to_read_record = nbytes;
 	}
 
       dtp->u.p.current_unit->bytes_left -= to_read_record;
 
-      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &to_read_record)
-		    != 0))
+      to_read_record = sread (dtp->u.p.current_unit->s, buf, to_read_record);
+      if (unlikely (to_read_record < 0))
 	{
 	  generate_error (&dtp->common, LIBERROR_OS, NULL);
 	  return;
 	}
 
-      if (to_read_record != *nbytes)  
+      if (to_read_record != (ssize_t) nbytes)  
 	{
 	  /* Short read, e.g. if we hit EOF.  Apparently, we read
 	   more than was written to the last record.  */
-	  *nbytes = to_read_record;
 	  return;
 	}
 
       if (unlikely (short_record))
 	{
 	  generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);
-	  return;
 	}
       return;
     }
@@ -470,23 +462,17 @@
      until the request has been fulfilled or the record has run out
      of continuation subrecords.  */
 
-  if (unlikely (dtp->u.p.current_unit->endfile == AT_ENDFILE))
-    {
-      generate_error (&dtp->common, LIBERROR_END, NULL);
-      return;
-    }
-
   /* Check whether we exceed the total record length.  */
 
   if (dtp->u.p.current_unit->flags.has_recl
-      && (*nbytes > (size_t) dtp->u.p.current_unit->bytes_left))
+      && ((gfc_offset) nbytes > dtp->u.p.current_unit->bytes_left))
     {
-      to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;
+      to_read_record = dtp->u.p.current_unit->bytes_left;
       short_record = 1;
     }
   else
     {
-      to_read_record = *nbytes;
+      to_read_record = nbytes;
       short_record = 0;
     }
   have_read_record = 0;
@@ -496,7 +482,7 @@
       if (dtp->u.p.current_unit->bytes_left_subrecord
 	  < (gfc_offset) to_read_record)
 	{
-	  to_read_subrecord = (size_t) dtp->u.p.current_unit->bytes_left_subrecord;
+	  to_read_subrecord = dtp->u.p.current_unit->bytes_left_subrecord;
 	  to_read_record -= to_read_subrecord;
 	}
       else
@@ -507,9 +493,9 @@
 
       dtp->u.p.current_unit->bytes_left_subrecord -= to_read_subrecord;
 
-      have_read_subrecord = to_read_subrecord;
-      if (unlikely (sread (dtp->u.p.current_unit->s, buf + have_read_record,
-			   &have_read_subrecord) != 0))
+      have_read_subrecord = sread (dtp->u.p.current_unit->s, 
+				   buf + have_read_record, to_read_subrecord);
+      if (unlikely (have_read_subrecord) < 0)
 	{
 	  generate_error (&dtp->common, LIBERROR_OS, NULL);
 	  return;
@@ -524,7 +510,6 @@
 	     structure has been corrupted, or the trailing record
 	     marker would still be present.  */
 
-	  *nbytes = have_read_record;
 	  generate_error (&dtp->common, LIBERROR_CORRUPT_FILE, NULL);
 	  return;
 	}
@@ -598,7 +583,7 @@
 
   if (is_internal_unit (dtp))
     {
-    dest = salloc_w (dtp->u.p.current_unit->s, &length);
+    dest = mem_alloc_w (dtp->u.p.current_unit->s, &length);
 
     if (dest == NULL)
       {
@@ -636,20 +621,22 @@
 write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)
 {
 
-  size_t have_written, to_write_subrecord;
+  ssize_t have_written;
+  ssize_t to_write_subrecord;
   int short_record;
 
   /* Stream I/O.  */
 
   if (is_stream_io (dtp))
     {
-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))
+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes);
+      if (unlikely (have_written < 0))
 	{
 	  generate_error (&dtp->common, LIBERROR_OS, NULL);
 	  return FAILURE;
 	}
 
-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; 
+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written; 
 
       return SUCCESS;
     }
@@ -667,14 +654,15 @@
       if (buf == NULL && nbytes == 0)
 	return SUCCESS;
 
-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))
+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes); 
+      if (unlikely (have_written < 0))
 	{
 	  generate_error (&dtp->common, LIBERROR_OS, NULL);
 	  return FAILURE;
 	}
 
-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes;
-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;
+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written;
+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) have_written;
 
       return SUCCESS;
     }
@@ -704,8 +692,9 @@
       dtp->u.p.current_unit->bytes_left_subrecord -=
 	(gfc_offset) to_write_subrecord;
 
-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf + have_written,
-			    &to_write_subrecord) != 0))
+      to_write_subrecord = swrite (dtp->u.p.current_unit->s, 
+				   buf + have_written, to_write_subrecord);
+      if (unlikely (to_write_subrecord < 0))
 	{
 	  generate_error (&dtp->common, LIBERROR_OS, NULL);
 	  return FAILURE;
@@ -737,20 +726,18 @@
 unformatted_read (st_parameter_dt *dtp, bt type,
 		  void *dest, int kind, size_t size, size_t nelems)
 {
-  size_t i, sz;
-
   if (likely (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE)
       || kind == 1)
     {
-      sz = size * nelems;
       if (type == BT_CHARACTER)
-	sz *= GFC_SIZE_OF_CHAR_KIND(kind);
-      read_block_direct (dtp, dest, &sz);
+	size *= GFC_SIZE_OF_CHAR_KIND(kind);
+      read_block_direct (dtp, dest, size * nelems);
     }
   else
     {
       char buffer[16];
       char *p;
+      size_t i;
 
       p = dest;
 
@@ -773,7 +760,7 @@
       
       for (i = 0; i < nelems; i++)
 	{
- 	  read_block_direct (dtp, buffer, &size);
+ 	  read_block_direct (dtp, buffer, size);
  	  reverse_memcpy (p, buffer, size);
  	  p += size;
  	}
@@ -915,19 +902,18 @@
 }
 
 
-/* This subroutine is the main loop for a formatted data transfer
+/* This function is in the main loop for a formatted data transfer
    statement.  It would be natural to implement this as a coroutine
    with the user program, but C makes that awkward.  We loop,
    processing format elements.  When we actually have to transfer
    data instead of just setting flags, we return control to the user
-   program which calls a subroutine that supplies the address and type
+   program which calls a function that supplies the address and type
    of the next element, then comes back here to process it.  */
 
 static void
-formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,
-			   size_t size)
+formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind,
+				size_t size)
 {
-  char scratch[SCRATCH_SIZE];
   int pos, bytes_used;
   const fnode *f;
   format_token t;
@@ -954,7 +940,347 @@
   dtp->u.p.sf_read_comma =
     dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;
 
-  dtp->u.p.line_buffer = scratch;
+  for (;;)
+    {
+      /* If reversion has occurred and there is another real data item,
+	 then we have to move to the next record.  */
+      if (dtp->u.p.reversion_flag && n > 0)
+	{
+	  dtp->u.p.reversion_flag = 0;
+	  next_record (dtp, 0);
+	}
+
+      consume_data_flag = 1;
+      if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)
+	break;
+
+      f = next_format (dtp);
+      if (f == NULL)
+	{
+	  /* No data descriptors left.  */
+	  if (unlikely (n > 0))
+	    generate_error (&dtp->common, LIBERROR_FORMAT,
+		"Insufficient data descriptors in format after reversion");
+	  return;
+	}
+
+      t = f->format;
+
+      bytes_used = (int)(dtp->u.p.current_unit->recl
+		   - dtp->u.p.current_unit->bytes_left);
+
+      if (is_stream_io(dtp))
+	bytes_used = 0;
+
+      switch (t)
+	{
+	case FMT_I:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (require_type (dtp, BT_INTEGER, type, f))
+	    return;
+	  read_decimal (dtp, f, p, kind);
+	  break;
+
+	case FMT_B:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (compile_options.allow_std < GFC_STD_GNU
+              && require_type (dtp, BT_INTEGER, type, f))
+	    return;
+	  read_radix (dtp, f, p, kind, 2);
+	  break;
+
+	case FMT_O:
+	  if (n == 0)
+	    goto need_read_data; 
+	  if (compile_options.allow_std < GFC_STD_GNU
+              && require_type (dtp, BT_INTEGER, type, f))
+	    return;
+	  read_radix (dtp, f, p, kind, 8);
+	  break;
+
+	case FMT_Z:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (compile_options.allow_std < GFC_STD_GNU
+              && require_type (dtp, BT_INTEGER, type, f))
+	    return;
+	  read_radix (dtp, f, p, kind, 16);
+	  break;
+
+	case FMT_A:
+	  if (n == 0)
+	    goto need_read_data;
+
+	  /* It is possible to have FMT_A with something not BT_CHARACTER such
+	     as when writing out hollerith strings, so check both type
+	     and kind before calling wide character routines.  */
+	  if (type == BT_CHARACTER && kind == 4)
+	    read_a_char4 (dtp, f, p, size);
+	  else
+	    read_a (dtp, f, p, size);
+	  break;
+
+	case FMT_L:
+	  if (n == 0)
+	    goto need_read_data;
+	  read_l (dtp, f, p, kind);
+	  break;
+
+	case FMT_D:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (require_type (dtp, BT_REAL, type, f))
+	    return;
+	  read_f (dtp, f, p, kind);
+	  break;
+
+	case FMT_E:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (require_type (dtp, BT_REAL, type, f))
+	    return;
+	  read_f (dtp, f, p, kind);
+	  break;
+
+	case FMT_EN:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (require_type (dtp, BT_REAL, type, f))
+	    return;
+	  read_f (dtp, f, p, kind);
+	  break;
+
+	case FMT_ES:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (require_type (dtp, BT_REAL, type, f))
+	    return;
+	  read_f (dtp, f, p, kind);
+	  break;
+
+	case FMT_F:
+	  if (n == 0)
+	    goto need_read_data;
+	  if (require_type (dtp, BT_REAL, type, f))
+	    return;
+	  read_f (dtp, f, p, kind);
+	  break;
+
+	case FMT_G:
+	  if (n == 0)
+	    goto need_read_data;
+	  switch (type)
+	    {
+	      case BT_INTEGER:
+		read_decimal (dtp, f, p, kind);
+		break;
+	      case BT_LOGICAL:
+		read_l (dtp, f, p, kind);
+		break;
+	      case BT_CHARACTER:
+		if (kind == 4)
+		  read_a_char4 (dtp, f, p, size);
+		else
+		  read_a (dtp, f, p, size);
+		break;
+	      case BT_REAL:
+		read_f (dtp, f, p, kind);
+		break;
+	      default:
+		internal_error (&dtp->common, "formatted_transfer(): Bad type");
+	    }
+	  break;
+
+	case FMT_STRING:
+	  consume_data_flag = 0;
+	  format_error (dtp, f, "Constant string in input format");
+	  return;
+
+	/* Format codes that don't transfer data.  */
+	case FMT_X:
+	case FMT_TR:
+	  consume_data_flag = 0;
+	  dtp->u.p.skips += f->u.n;
+	  pos = bytes_used + dtp->u.p.skips - 1;
+	  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos + 1;
+	  read_x (dtp, f->u.n);
+	  break;
+
+	case FMT_TL:
+	case FMT_T:
+	  consume_data_flag = 0;
+
+	  if (f->format == FMT_TL)
+	    {
+	      /* Handle the special case when no bytes have been used yet.
+	         Cannot go below zero. */
+	      if (bytes_used == 0)
+		{
+		  dtp->u.p.pending_spaces -= f->u.n;
+		  dtp->u.p.skips -= f->u.n;
+		  dtp->u.p.skips = dtp->u.p.skips < 0 ? 0 : dtp->u.p.skips;
+		}
+
+	      pos = bytes_used - f->u.n;
+	    }
+	  else /* FMT_T */
+	    pos = f->u.n - 1;
+
+	  /* Standard 10.6.1.1: excessive left tabbing is reset to the
+	     left tab limit.  We do not check if the position has gone
+	     beyond the end of record because a subsequent tab could
+	     bring us back again.  */
+	  pos = pos < 0 ? 0 : pos;
+
+	  dtp->u.p.skips = dtp->u.p.skips + pos - bytes_used;
+	  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces
+				    + pos - dtp->u.p.max_pos;
+	  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces < 0
+				    ? 0 : dtp->u.p.pending_spaces;
+	  if (dtp->u.p.skips == 0)
+	    break;
+
+	  /* Adjust everything for end-of-record condition */
+	  if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))
+	    {
+              dtp->u.p.current_unit->bytes_left -= dtp->u.p.sf_seen_eor;
+              dtp->u.p.skips -= dtp->u.p.sf_seen_eor;
+	      bytes_used = pos;
+	      dtp->u.p.sf_seen_eor = 0;
+	    }
+	  if (dtp->u.p.skips < 0)
+	    {
+              if (is_internal_unit (dtp))  
+                sseek (dtp->u.p.current_unit->s, dtp->u.p.skips, SEEK_CUR);
+              else
+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);
+	      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;
+	      dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
+	    }
+	  else
+	    read_x (dtp, dtp->u.p.skips);
+	  break;
+
+	case FMT_S:
+	  consume_data_flag = 0;
+	  dtp->u.p.sign_status = SIGN_S;
+	  break;
+
+	case FMT_SS:
+	  consume_data_flag = 0;
+	  dtp->u.p.sign_status = SIGN_SS;
+	  break;
+
+	case FMT_SP:
+	  consume_data_flag = 0;
+	  dtp->u.p.sign_status = SIGN_SP;
+	  break;
+
+	case FMT_BN:
+	  consume_data_flag = 0 ;
+	  dtp->u.p.blank_status = BLANK_NULL;
+	  break;
+
+	case FMT_BZ:
+	  consume_data_flag = 0;
+	  dtp->u.p.blank_status = BLANK_ZERO;
+	  break;
+
+	case FMT_DC:
+	  consume_data_flag = 0;
+	  dtp->u.p.current_unit->decimal_status = DECIMAL_COMMA;
+	  break;
+
+	case FMT_DP:
+	  consume_data_flag = 0;
+	  dtp->u.p.current_unit->decimal_status = DECIMAL_POINT;
+	  break;
+
+	case FMT_P:
+	  consume_data_flag = 0;
+	  dtp->u.p.scale_factor = f->u.k;
+	  break;
+
+	case FMT_DOLLAR:
+	  consume_data_flag = 0;
+	  dtp->u.p.seen_dollar = 1;
+	  break;
+
+	case FMT_SLASH:
+	  consume_data_flag = 0;
+	  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
+	  next_record (dtp, 0);
+	  break;
+
+	case FMT_COLON:
+	  /* A colon descriptor causes us to exit this loop (in
+	     particular preventing another / descriptor from being
+	     processed) unless there is another data item to be
+	     transferred.  */
+	  consume_data_flag = 0;
+	  if (n == 0)
+	    return;
+	  break;
+
+	default:
+	  internal_error (&dtp->common, "Bad format node");
+	}
+
+      /* Adjust the item count and data pointer.  */
+
+      if ((consume_data_flag > 0) && (n > 0))
+	{
+	  n--;
+	  p = ((char *) p) + size;
+	}
+
+      dtp->u.p.skips = 0;
+
+      pos = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);
+      dtp->u.p.max_pos = (dtp->u.p.max_pos > pos) ? dtp->u.p.max_pos : pos;
+    }
+
+  return;
+
+  /* Come here when we need a data descriptor but don't have one.  We
+     push the current format node back onto the input, then return and
+     let the user program call us back with the data.  */
+ need_read_data:
+  unget_format (dtp, f);
+}
+
+
+static void
+formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kind,
+				 size_t size)
+{
+  int pos, bytes_used;
+  const fnode *f;
+  format_token t;
+  int n;
+  int consume_data_flag;
+
+  /* Change a complex data item into a pair of reals.  */
+
+  n = (p == NULL) ? 0 : ((type != BT_COMPLEX) ? 1 : 2);
+  if (type == BT_COMPLEX)
+    {
+      type = BT_REAL;
+      size /= 2;
+    }
+
+  /* If there's an EOR condition, we simulate finalizing the transfer
+     by doing nothing.  */
+  if (dtp->u.p.eor_condition)
+    return;
+
+  /* Set this flag so that commas in reads cause the read to complete before
+     the entire field has been read.  The next read field will start right after
+     the comma in the stream.  (Set to 0 for character reads).  */
+  dtp->u.p.sf_read_comma =
+    dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;
 
   for (;;)
     {
@@ -1003,9 +1329,9 @@
 	  if (dtp->u.p.skips < 0)
 	    {
               if (is_internal_unit (dtp))  
-	        move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);
+	        sseek (dtp->u.p.current_unit->s, dtp->u.p.skips, SEEK_CUR);
               else
-                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips);
+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);
 	      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;
 	    }
 	  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
@@ -1024,57 +1350,34 @@
 	    goto need_data;
 	  if (require_type (dtp, BT_INTEGER, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_decimal (dtp, f, p, kind);
-	  else
-	    write_i (dtp, f, p, kind);
-
+	  write_i (dtp, f, p, kind);
 	  break;
 
 	case FMT_B:
 	  if (n == 0)
 	    goto need_data;
-
 	  if (compile_options.allow_std < GFC_STD_GNU
-              && require_type (dtp, BT_INTEGER, type, f))
-	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_radix (dtp, f, p, kind, 2);
-	  else
-	    write_b (dtp, f, p, kind);
-
+              && require_type (dtp, BT_INTEGER, type, f))
+	    return;
+	  write_b (dtp, f, p, kind);
 	  break;
 
 	case FMT_O:
 	  if (n == 0)
 	    goto need_data; 
-
 	  if (compile_options.allow_std < GFC_STD_GNU
               && require_type (dtp, BT_INTEGER, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_radix (dtp, f, p, kind, 8);
-	  else
-	    write_o (dtp, f, p, kind);
-
+	  write_o (dtp, f, p, kind);
 	  break;
 
 	case FMT_Z:
 	  if (n == 0)
 	    goto need_data;
-
 	  if (compile_options.allow_std < GFC_STD_GNU
               && require_type (dtp, BT_INTEGER, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_radix (dtp, f, p, kind, 16);
-	  else
-	    write_z (dtp, f, p, kind);
-
+	  write_z (dtp, f, p, kind);
 	  break;
 
 	case FMT_A:
@@ -1084,31 +1387,16 @@
 	  /* It is possible to have FMT_A with something not BT_CHARACTER such
 	     as when writing out hollerith strings, so check both type
 	     and kind before calling wide character routines.  */
-	  if (dtp->u.p.mode == READING)
-	    {
-	      if (type == BT_CHARACTER && kind == 4)
-		read_a_char4 (dtp, f, p, size);
-	      else
-		read_a (dtp, f, p, size);
-	    }
+	  if (type == BT_CHARACTER && kind == 4)
+	    write_a_char4 (dtp, f, p, size);
 	  else
-	    {
-	      if (type == BT_CHARACTER && kind == 4)
-		write_a_char4 (dtp, f, p, size);
-	      else
-		write_a (dtp, f, p, size);
-	    }
+	    write_a (dtp, f, p, size);
 	  break;
 
 	case FMT_L:
 	  if (n == 0)
 	    goto need_data;
-
-	  if (dtp->u.p.mode == READING)
-	    read_l (dtp, f, p, kind);
-	  else
-	    write_l (dtp, f, p, kind);
-
+	  write_l (dtp, f, p, kind);
 	  break;
 
 	case FMT_D:
@@ -1116,12 +1404,7 @@
 	    goto need_data;
 	  if (require_type (dtp, BT_REAL, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_f (dtp, f, p, kind);
-	  else
-	    write_d (dtp, f, p, kind);
-
+	  write_d (dtp, f, p, kind);
 	  break;
 
 	case FMT_E:
@@ -1129,11 +1412,7 @@
 	    goto need_data;
 	  if (require_type (dtp, BT_REAL, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_f (dtp, f, p, kind);
-	  else
-	    write_e (dtp, f, p, kind);
+	  write_e (dtp, f, p, kind);
 	  break;
 
 	case FMT_EN:
@@ -1141,12 +1420,7 @@
 	    goto need_data;
 	  if (require_type (dtp, BT_REAL, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_f (dtp, f, p, kind);
-	  else
-	    write_en (dtp, f, p, kind);
-
+	  write_en (dtp, f, p, kind);
 	  break;
 
 	case FMT_ES:
@@ -1154,12 +1428,7 @@
 	    goto need_data;
 	  if (require_type (dtp, BT_REAL, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_f (dtp, f, p, kind);
-	  else
-	    write_es (dtp, f, p, kind);
-
+	  write_es (dtp, f, p, kind);
 	  break;
 
 	case FMT_F:
@@ -1167,41 +1436,14 @@
 	    goto need_data;
 	  if (require_type (dtp, BT_REAL, type, f))
 	    return;
-
-	  if (dtp->u.p.mode == READING)
-	    read_f (dtp, f, p, kind);
-	  else
-	    write_f (dtp, f, p, kind);
-
+	  write_f (dtp, f, p, kind);
 	  break;
 
 	case FMT_G:
 	  if (n == 0)
 	    goto need_data;
-	  if (dtp->u.p.mode == READING)
-	    switch (type)
-	      {
-	      case BT_INTEGER:
-		read_decimal (dtp, f, p, kind);
-		break;
-	      case BT_LOGICAL:
-		read_l (dtp, f, p, kind);
-		break;
-	      case BT_CHARACTER:
-		if (kind == 4)
-		  read_a_char4 (dtp, f, p, size);
-		else
-		  read_a (dtp, f, p, size);
-		break;
-	      case BT_REAL:
-		read_f (dtp, f, p, kind);
-		break;
-	      default:
-		goto bad_type;
-	      }
-	  else
-	    switch (type)
-	      {
+	  switch (type)
+	    {
 	      case BT_INTEGER:
 		write_i (dtp, f, p, kind);
 		break;
@@ -1216,25 +1458,18 @@
 		break;
 	      case BT_REAL:
 		if (f->u.real.w == 0)
-		  write_real_g0 (dtp, p, kind, f->u.real.d);
+                  write_real_g0 (dtp, p, kind, f->u.real.d);
 		else
 		  write_d (dtp, f, p, kind);
 		break;
 	      default:
-	      bad_type:
 		internal_error (&dtp->common,
 				"formatted_transfer(): Bad type");
-	      }
-
+	    }
 	  break;
 
 	case FMT_STRING:
 	  consume_data_flag = 0;
-	  if (dtp->u.p.mode == READING)
-	    {
-	      format_error (dtp, f, "Constant string in input format");
-	      return;
-	    }
 	  write_constant_string (dtp, f);
 	  break;
 
@@ -1246,21 +1481,15 @@
 	  dtp->u.p.skips += f->u.n;
 	  pos = bytes_used + dtp->u.p.skips - 1;
 	  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos + 1;
-
 	  /* Writes occur just before the switch on f->format, above, so
 	     that trailing blanks are suppressed, unless we are doing a
 	     non-advancing write in which case we want to output the blanks
 	     now.  */
-	  if (dtp->u.p.mode == WRITING
-	      && dtp->u.p.advance_status == ADVANCE_NO)
+	  if (dtp->u.p.advance_status == ADVANCE_NO)
 	    {
 	      write_x (dtp, dtp->u.p.skips, dtp->u.p.pending_spaces);
 	      dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
 	    }
-
-	  if (dtp->u.p.mode == READING)
-	    read_x (dtp, f->u.n);
-
 	  break;
 
 	case FMT_TL:
@@ -1282,12 +1511,7 @@
 	      pos = bytes_used - f->u.n;
 	    }
 	  else /* FMT_T */
-	    {
-	      if (dtp->u.p.mode == READING)
-		pos = f->u.n - 1;
-	      else
-		pos = f->u.n - dtp->u.p.pending_spaces - 1;
-	    }
+	    pos = f->u.n - dtp->u.p.pending_spaces - 1;
 
 	  /* Standard 10.6.1.1: excessive left tabbing is reset to the
 	     left tab limit.  We do not check if the position has gone
@@ -1300,43 +1524,6 @@
 				    + pos - dtp->u.p.max_pos;
 	  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces < 0
 				    ? 0 : dtp->u.p.pending_spaces;
-
-	  if (dtp->u.p.skips == 0)
-	    break;
-
-	  /* Writes occur just before the switch on f->format, above, so that
-	     trailing blanks are suppressed.  */
-	  if (dtp->u.p.mode == READING)
-	    {
-	      /* Adjust everything for end-of-record condition */
-	      if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))
-		{
-		  if (dtp->u.p.sf_seen_eor == 2)
-		    {
-		      /* The EOR was a CRLF (two bytes wide).  */
-		      dtp->u.p.current_unit->bytes_left -= 2;
-		      dtp->u.p.skips -= 2;
-		    }
-		  else
-		    {
-		      /* The EOR marker was only one byte wide.  */
-		      dtp->u.p.current_unit->bytes_left--;
-		      dtp->u.p.skips--;
-		    }
-		  bytes_used = pos;
-		  dtp->u.p.sf_seen_eor = 0;
-		}
-	      if (dtp->u.p.skips < 0)
-		{
-		  move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);
-		  dtp->u.p.current_unit->bytes_left
-		    -= (gfc_offset) dtp->u.p.skips;
-		  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
-		}
-	      else
-		read_x (dtp, dtp->u.p.skips);
-	    }
-
 	  break;
 
 	case FMT_S:
@@ -1404,30 +1591,16 @@
 	  internal_error (&dtp->common, "Bad format node");
 	}
 
-      /* Free a buffer that we had to allocate during a sequential
-	 formatted read of a block that was larger than the static
-	 buffer.  */
-
-      if (dtp->u.p.line_buffer != scratch)
-	{
-	  free_mem (dtp->u.p.line_buffer);
-	  dtp->u.p.line_buffer = scratch;
-	}
-
       /* Adjust the item count and data pointer.  */
 
       if ((consume_data_flag > 0) && (n > 0))
-      {
-	n--;
-	p = ((char *) p) + size;
-      }
-
-      if (dtp->u.p.mode == READING)
-	dtp->u.p.skips = 0;
+	{
+	  n--;
+	  p = ((char *) p) + size;
+	}
 
       pos = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);
       dtp->u.p.max_pos = (dtp->u.p.max_pos > pos) ? dtp->u.p.max_pos : pos;
-
     }
 
   return;
@@ -1439,6 +1612,7 @@
   unget_format (dtp, f);
 }
 
+
 static void
 formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,
 		    size_t size, size_t nelems)
@@ -1449,16 +1623,27 @@
   tmp = (char *) p;
   size_t stride = type == BT_CHARACTER ?
 		  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;
-  /* Big loop over all the elements.  */
-  for (elem = 0; elem < nelems; elem++)
+  if (dtp->u.p.mode == READING)
     {
-      dtp->u.p.item_count++;
-      formatted_transfer_scalar (dtp, type, tmp + stride*elem, kind, size);
+      /* Big loop over all the elements.  */
+      for (elem = 0; elem < nelems; elem++)
+	{
+	  dtp->u.p.item_count++;
+	  formatted_transfer_scalar_read (dtp, type, tmp + stride*elem, kind, size);
+	}
+    }
+  else
+    {
+      /* Big loop over all the elements.  */
+      for (elem = 0; elem < nelems; elem++)
+	{
+	  dtp->u.p.item_count++;
+	  formatted_transfer_scalar_write (dtp, type, tmp + stride*elem, kind, size);
+	}
     }
 }
 
 
-
 /* Data transfer entry points.  The type of the data entity is
    implicit in the subroutine call.  This prevents us from having to
    share a common enum with the compiler.  */
@@ -1652,34 +1837,28 @@
 static void
 us_read (st_parameter_dt *dtp, int continued)
 {
-  size_t n, nr;
+  ssize_t n, nr;
   GFC_INTEGER_4 i4;
   GFC_INTEGER_8 i8;
   gfc_offset i;
 
-  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)
-    return;
-
   if (compile_options.record_marker == 0)
     n = sizeof (GFC_INTEGER_4);
   else
     n = compile_options.record_marker;
 
-  nr = n;
-
-  if (unlikely (sread (dtp->u.p.current_unit->s, &i, &n) != 0))
+  nr = sread (dtp->u.p.current_unit->s, &i, n);
+  if (unlikely (nr < 0))
     {
       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);
       return;
     }
-
-  if (n == 0)
+  else if (nr == 0)
     {
-      dtp->u.p.current_unit->endfile = AT_ENDFILE;
+      hit_eof (dtp);
       return;  /* end of file */
     }
-
-  if (unlikely (n != nr))
+  else if (unlikely (n != nr))
     {
       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);
       return;
@@ -1745,7 +1924,7 @@
 static void
 us_write (st_parameter_dt *dtp, int continued)
 {
-  size_t nbytes;
+  ssize_t nbytes;
   gfc_offset dummy;
 
   dummy = 0;
@@ -1755,7 +1934,7 @@
   else
     nbytes = compile_options.record_marker ;
 
-  if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)
+  if (swrite (dtp->u.p.current_unit->s, &dummy, nbytes) != nbytes)
     generate_error (&dtp->common, LIBERROR_OS, NULL);
 
   /* For sequential unformatted, if RECL= was not specified in the OPEN
@@ -1957,7 +2136,7 @@
       return;
     }
 
-  /* Check the record number.  */
+  /* Check the record or position number.  */
 
   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT
       && (cf & IOPARM_DT_HAS_REC) == 0)
@@ -2106,65 +2285,70 @@
   
   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)
 	dtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;
-  
+
+  /* Check to see if we might be reading what we wrote before  */
+
+  if (dtp->u.p.mode != dtp->u.p.current_unit->mode
+      && !is_internal_unit (dtp))
+    {
+      int pos = fbuf_reset (dtp->u.p.current_unit);
+      if (pos != 0)
+        sseek (dtp->u.p.current_unit->s, pos, SEEK_CUR);
+      sflush(dtp->u.p.current_unit->s);
+    }
+
   /* Check the POS= specifier: that it is in range and that it is used with a
      unit that has been connected for STREAM access. F2003 9.5.1.10.  */
   
   if (((cf & IOPARM_DT_HAS_POS) != 0))
     {
       if (is_stream_io (dtp))
-	{
-
-	  if (dtp->pos <= 0)
-	    {
-	      generate_error (&dtp->common, LIBERROR_BAD_OPTION,
-			      "POS=specifier must be positive");
-	      return;
-	    }
-
-	  if (dtp->pos >= dtp->u.p.current_unit->maxrec)
-	    {
-	      generate_error (&dtp->common, LIBERROR_BAD_OPTION,
-			      "POS=specifier too large");
-	      return;
-	    }
-
-	  dtp->rec = dtp->pos;
-
-	  if (dtp->u.p.mode == READING)
-	    {
-	      /* Required for compatibility between 4.3 and 4.4 runtime. Check
-	      to see if we might be reading what we wrote before  */
-	      if (dtp->u.p.current_unit->mode == WRITING)
-		{
-		  fbuf_flush (dtp->u.p.current_unit, 1);      
-		  flush(dtp->u.p.current_unit->s);
-		}
-
-	      if (dtp->pos < file_length (dtp->u.p.current_unit->s))
-		dtp->u.p.current_unit->endfile = NO_ENDFILE;
-	    }
-
-	  if (dtp->pos != dtp->u.p.current_unit->strm_pos)
-	    {
-	      fbuf_flush (dtp->u.p.current_unit, 1);
-	      flush (dtp->u.p.current_unit->s);
-	      if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1) == FAILURE)
-		{
-		  generate_error (&dtp->common, LIBERROR_OS, NULL);
-		  return;
-		}
-	      dtp->u.p.current_unit->strm_pos = dtp->pos;
-	    }
-	}
+        {
+          
+          if (dtp->pos <= 0)
+            {
+              generate_error (&dtp->common, LIBERROR_BAD_OPTION,
+                              "POS=specifier must be positive");
+              return;
+            }
+          
+          if (dtp->pos >= dtp->u.p.current_unit->maxrec)
+            {
+              generate_error (&dtp->common, LIBERROR_BAD_OPTION,
+                              "POS=specifier too large");
+              return;
+            }
+          
+          dtp->rec = dtp->pos;
+          
+          if (dtp->u.p.mode == READING)
+            {
+              /* Reset the endfile flag; if we hit EOF during reading
+                 we'll set the flag and generate an error at that point
+                 rather than worrying about it here.  */
+              dtp->u.p.current_unit->endfile = NO_ENDFILE;
+            }
+         
+          if (dtp->pos != dtp->u.p.current_unit->strm_pos)
+            {
+              fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
+              if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1, SEEK_SET) < 0)
+                {
+                  generate_error (&dtp->common, LIBERROR_OS, NULL);
+                  return;
+                }
+              dtp->u.p.current_unit->strm_pos = dtp->pos;
+            }
+        }
       else
-	{
-	  generate_error (&dtp->common, LIBERROR_BAD_OPTION,
-			  "POS=specifier not allowed, "
-			  "Try OPEN with ACCESS='stream'");
-	  return;
-	}
+        {
+          generate_error (&dtp->common, LIBERROR_BAD_OPTION,
+                          "POS=specifier not allowed, "
+                          "Try OPEN with ACCESS='stream'");
+          return;
+        }
     }
+  
 
   /* Sanity checks on the record number.  */
   if ((cf & IOPARM_DT_HAS_REC) != 0)
@@ -2183,15 +2367,10 @@
 	  return;
 	}
 
-      /* Check to see if we might be reading what we wrote before  */
+      /* Make sure format buffer is reset.  */
+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)
+        fbuf_reset (dtp->u.p.current_unit);
 
-      if (dtp->u.p.mode == READING
-	  && dtp->u.p.current_unit->mode == WRITING
-	  && !is_internal_unit (dtp))
-	{
-	  fbuf_flush (dtp->u.p.current_unit, 1);      
-	  flush(dtp->u.p.current_unit->s);
-	}
 
       /* Check whether the record exists to be read.  Only
 	 a partial record needs to exist.  */
@@ -2206,37 +2385,28 @@
 
       /* Position the file.  */
       if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)
-		 * dtp->u.p.current_unit->recl) == FAILURE)
-	{
-	  generate_error (&dtp->common, LIBERROR_OS, NULL);
-	  return;
-	}
+                 * dtp->u.p.current_unit->recl, SEEK_SET) < 0)
+        {
+          generate_error (&dtp->common, LIBERROR_OS, NULL);
+          return;
+        }
 
       /* TODO: This is required to maintain compatibility between
-	 4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */
+         4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */
 
       if (is_stream_io (dtp))
-	dtp->u.p.current_unit->strm_pos = dtp->rec;
-      
+        dtp->u.p.current_unit->strm_pos = dtp->rec;
+
       /* TODO: Un-comment this code when ABI changes from 4.3.
       if (dtp->u.p.current_unit->flags.access == ACCESS_STREAM)
-	{
-	  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,
-		      "Record number not allowed for stream access "
-		      "data transfer");
-	  return;
-	}  */
-
+       {
+         generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,
+                     "Record number not allowed for stream access "
+                     "data transfer");
+         return;
+       }  */
     }
 
-  /* Overwriting an existing sequential file ?
-     it is always safe to truncate the file on the first write */
-  if (dtp->u.p.mode == WRITING
-      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL
-      && dtp->u.p.current_unit->last_record == 0 
-      && !is_preconnected(dtp->u.p.current_unit->s))
-	struncate(dtp->u.p.current_unit->s);
-
   /* Bugware for badly written mixed C-Fortran I/O.  */
   flush_if_preconnected(dtp->u.p.current_unit->s);
 
@@ -2387,11 +2557,10 @@
    position.  */
 
 static void
-skip_record (st_parameter_dt *dtp, size_t bytes)
+skip_record (st_parameter_dt *dtp, ssize_t bytes)
 {
-  gfc_offset new;
-  size_t rlength;
-  static const size_t MAX_READ = 4096;
+  ssize_t rlength, readb;
+  static const ssize_t MAX_READ = 4096;
   char p[MAX_READ];
 
   dtp->u.p.current_unit->bytes_left_subrecord += bytes;
@@ -2400,12 +2569,10 @@
 
   if (is_seekable (dtp->u.p.current_unit->s))
     {
-      new = file_position (dtp->u.p.current_unit->s)
-	+ dtp->u.p.current_unit->bytes_left_subrecord;
-
       /* Direct access files do not generate END conditions,
 	 only I/O errors.  */
-      if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)
+      if (sseek (dtp->u.p.current_unit->s, 
+		 dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)
 	generate_error (&dtp->common, LIBERROR_OS, NULL);
     }
   else
@@ -2413,16 +2580,17 @@
       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)
 	{
 	  rlength = 
-	    (MAX_READ > (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?
-	    MAX_READ : (size_t) dtp->u.p.current_unit->bytes_left_subrecord;
+	    (MAX_READ < dtp->u.p.current_unit->bytes_left_subrecord) ?
+	    MAX_READ : dtp->u.p.current_unit->bytes_left_subrecord;
 
-	  if (sread (dtp->u.p.current_unit->s, p, &rlength) != 0)
+	  readb = sread (dtp->u.p.current_unit->s, p, rlength);
+	  if (readb < 0)
 	    {
 	      generate_error (&dtp->common, LIBERROR_OS, NULL);
 	      return;
 	    }
 
-	  dtp->u.p.current_unit->bytes_left_subrecord -= rlength;
+	  dtp->u.p.current_unit->bytes_left_subrecord -= readb;
 	}
     }
 
@@ -2470,8 +2638,8 @@
 {
   gfc_offset record;
   int bytes_left;
-  size_t length;
   char p;
+  int cc;
 
   switch (current_mode (dtp))
     {
@@ -2491,11 +2659,12 @@
 
     case FORMATTED_STREAM:
     case FORMATTED_SEQUENTIAL:
-      length = 1;
-      /* sf_read has already terminated input because of an '\n'  */
-      if (dtp->u.p.sf_seen_eor)
+      /* read_sf has already terminated input because of an '\n', or
+         we have hit EOF.  */
+      if (dtp->u.p.sf_seen_eor || dtp->u.p.at_eof)
 	{
 	  dtp->u.p.sf_seen_eor = 0;
+          dtp->u.p.at_eof = 0;
 	  break;
 	}
 
@@ -2510,7 +2679,7 @@
 
 	      /* Now seek to this record.  */
 	      record = record * dtp->u.p.current_unit->recl;
-	      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)
+	      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)
 		{
 		  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 		  break;
@@ -2522,10 +2691,9 @@
 	      bytes_left = (int) dtp->u.p.current_unit->bytes_left;
 	      bytes_left = min_off (bytes_left, 
 		      file_length (dtp->u.p.current_unit->s)
-		      - file_position (dtp->u.p.current_unit->s));
+		      - stell (dtp->u.p.current_unit->s));
 	      if (sseek (dtp->u.p.current_unit->s, 
-			  file_position (dtp->u.p.current_unit->s) 
-			  + bytes_left) == FAILURE)
+			 bytes_left, SEEK_CUR) < 0)
 	        {
 		  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 		  break;
@@ -2535,42 +2703,37 @@
 	    } 
 	  break;
 	}
-      else do
+      else 
 	{
-	  if (sread (dtp->u.p.current_unit->s, &p, &length) != 0) 
-	    {
-	      generate_error (&dtp->common, LIBERROR_OS, NULL);
-	      break;
-	    }
-
-	  if (length == 0)
+	  do
 	    {
-	      dtp->u.p.current_unit->endfile = AT_ENDFILE;
-	      break;
+              errno = 0;
+              cc = fbuf_getc (dtp->u.p.current_unit);
+	      if (cc == EOF) 
+		{
+                  if (errno != 0)
+                    generate_error (&dtp->common, LIBERROR_OS, NULL);
+                  else
+                    hit_eof (dtp);
+		  break;
+                }
+	      
+	      if (is_stream_io (dtp))
+		dtp->u.p.current_unit->strm_pos++;
+              
+              p = (char) cc;
 	    }
-
-	  if (is_stream_io (dtp))
-	    dtp->u.p.current_unit->strm_pos++;
+	  while (p != '\n');
 	}
-      while (p != '\n');
-
       break;
     }
-
-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL
-      && !dtp->u.p.namelist_mode
-      && dtp->u.p.current_unit->endfile == NO_ENDFILE
-      && (file_length (dtp->u.p.current_unit->s) ==
-	 file_position (dtp->u.p.current_unit->s)))
-    dtp->u.p.current_unit->endfile = AT_ENDFILE;
-
 }
 
 
 /* Small utility function to write a record marker, taking care of
    byte swapping and of choosing the correct size.  */
 
-inline static int
+static int
 write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)
 {
   size_t len;
@@ -2590,12 +2753,12 @@
 	{
 	case sizeof (GFC_INTEGER_4):
 	  buf4 = buf;
-	  return swrite (dtp->u.p.current_unit->s, &buf4, &len);
+	  return swrite (dtp->u.p.current_unit->s, &buf4, len);
 	  break;
 
 	case sizeof (GFC_INTEGER_8):
 	  buf8 = buf;
-	  return swrite (dtp->u.p.current_unit->s, &buf8, &len);
+	  return swrite (dtp->u.p.current_unit->s, &buf8, len);
 	  break;
 
 	default:
@@ -2610,13 +2773,13 @@
 	case sizeof (GFC_INTEGER_4):
 	  buf4 = buf;
 	  reverse_memcpy (p, &buf4, sizeof (GFC_INTEGER_4));
-	  return swrite (dtp->u.p.current_unit->s, p, &len);
+	  return swrite (dtp->u.p.current_unit->s, p, len);
 	  break;
 
 	case sizeof (GFC_INTEGER_8):
 	  buf8 = buf;
 	  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_8));
-	  return swrite (dtp->u.p.current_unit->s, p, &len);
+	  return swrite (dtp->u.p.current_unit->s, p, len);
 	  break;
 
 	default:
@@ -2633,13 +2796,11 @@
 static void
 next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)
 {
-  gfc_offset c, m, m_write;
-  size_t record_marker;
+  gfc_offset m, m_write, record_marker;
 
   /* Bytes written.  */
   m = dtp->u.p.current_unit->recl_subrecord
     - dtp->u.p.current_unit->bytes_left_subrecord;
-  c = file_position (dtp->u.p.current_unit->s);
 
   /* Write the length tail.  If we finish a record containing
      subrecords, we write out the negative length.  */
@@ -2649,7 +2810,7 @@
   else
     m_write = m;
 
-  if (unlikely (write_us_marker (dtp, m_write) != 0))
+  if (unlikely (write_us_marker (dtp, m_write) < 0))
     goto io_error;
 
   if (compile_options.record_marker == 0)
@@ -2660,8 +2821,8 @@
   /* Seek to the head and overwrite the bogus length with the real
      length.  */
 
-  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker)
-		== FAILURE))
+  if (unlikely (sseek (dtp->u.p.current_unit->s, - m - 2 * record_marker, 
+		       SEEK_CUR) < 0))
     goto io_error;
 
   if (next_subrecord)
@@ -2669,13 +2830,13 @@
   else
     m_write = m;
 
-  if (unlikely (write_us_marker (dtp, m_write) != 0))
+  if (unlikely (write_us_marker (dtp, m_write) < 0))
     goto io_error;
 
   /* Seek past the end of the current record.  */
 
-  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker)
-		== FAILURE))
+  if (unlikely (sseek (dtp->u.p.current_unit->s, m + record_marker, 
+		       SEEK_CUR) < 0))
     goto io_error;
 
   return;
@@ -2686,6 +2847,35 @@
 
 }
 
+
+/* Utility function like memset() but operating on streams. Return
+   value is same as for POSIX write().  */
+
+static ssize_t
+sset (stream * s, int c, ssize_t nbyte)
+{
+  static const int WRITE_CHUNK = 256;
+  char p[WRITE_CHUNK];
+  ssize_t bytes_left, trans;
+
+  if (nbyte < WRITE_CHUNK)
+    memset (p, c, nbyte);
+  else
+    memset (p, c, WRITE_CHUNK);
+
+  bytes_left = nbyte;
+  while (bytes_left > 0)
+    {
+      trans = (bytes_left < WRITE_CHUNK) ? bytes_left : WRITE_CHUNK;
+      trans = swrite (s, p, trans);
+      if (trans < 0)
+	return trans;
+      bytes_left -= trans;
+    }
+	       
+  return nbyte - bytes_left;
+}
+
 /* Position to the next record in write mode.  */
 
 static void
@@ -2694,9 +2884,6 @@
   gfc_offset m, record, max_pos;
   int length;
 
-  /* Flush and reset the format buffer.  */
-  fbuf_flush (dtp->u.p.current_unit, 1);
-  
   /* Zero counters for X- and T-editing.  */
   max_pos = dtp->u.p.max_pos;
   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
@@ -2711,8 +2898,11 @@
       if (dtp->u.p.current_unit->bytes_left == 0)
 	break;
 
+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);
+      fbuf_flush (dtp->u.p.current_unit, WRITING);
       if (sset (dtp->u.p.current_unit->s, ' ', 
-		dtp->u.p.current_unit->bytes_left) == FAILURE)
+		dtp->u.p.current_unit->bytes_left) 
+	  != dtp->u.p.current_unit->bytes_left)
 	goto io_error;
 
       break;
@@ -2721,7 +2911,7 @@
       if (dtp->u.p.current_unit->bytes_left > 0)
 	{
 	  length = (int) dtp->u.p.current_unit->bytes_left;
-	  if (sset (dtp->u.p.current_unit->s, 0, length) == FAILURE)
+	  if (sset (dtp->u.p.current_unit->s, 0, length) != length)
 	    goto io_error;
 	}
       break;
@@ -2752,8 +2942,7 @@
 		{
 		  length = (int) (max_pos - m);
 		  if (sseek (dtp->u.p.current_unit->s, 
-			      file_position (dtp->u.p.current_unit->s) 
-			      + length) == FAILURE)
+			     length, SEEK_CUR) < 0)
 		    {
 		      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 		      return;
@@ -2761,7 +2950,7 @@
 		  length = (int) (dtp->u.p.current_unit->recl - max_pos);
 		}
 
-	      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)
+	      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)
 		{
 		  generate_error (&dtp->common, LIBERROR_END, NULL);
 		  return;
@@ -2777,7 +2966,7 @@
 	      /* Now seek to this record */
 	      record = record * dtp->u.p.current_unit->recl;
 
-	      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)
+	      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)
 		{
 		  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 		  return;
@@ -2800,8 +2989,7 @@
 		    {
 		      length = (int) (max_pos - m);
 		      if (sseek (dtp->u.p.current_unit->s, 
-				  file_position (dtp->u.p.current_unit->s)
-				  + length) == FAILURE)
+				 length, SEEK_CUR) < 0)
 		        {
 			  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 			  return;
@@ -2812,7 +3000,7 @@
 		    length = (int) dtp->u.p.current_unit->bytes_left;
 		}
 
-	      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)
+	      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)
 		{
 		  generate_error (&dtp->common, LIBERROR_END, NULL);
 		  return;
@@ -2821,23 +3009,27 @@
 	}
       else
 	{
-	  size_t len;
-	  const char crlf[] = "\r\n";
-
 #ifdef HAVE_CRLF
-	  len = 2;
+	  const int len = 2;
 #else
-	  len = 1;
+	  const int len = 1;
 #endif
-	  if (swrite (dtp->u.p.current_unit->s, &crlf[2-len], &len) != 0)
-	    goto io_error;
-	  
+          fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);
+          char * p = fbuf_alloc (dtp->u.p.current_unit, len);
+          if (!p)
+            goto io_error;
+#ifdef HAVE_CRLF
+          *(p++) = '\r';
+#endif
+          *p = '\n';
 	  if (is_stream_io (dtp))
 	    {
 	      dtp->u.p.current_unit->strm_pos += len;
 	      if (dtp->u.p.current_unit->strm_pos
 		  < file_length (dtp->u.p.current_unit->s))
-		struncate (dtp->u.p.current_unit->s);
+		unit_truncate (dtp->u.p.current_unit,
+                               dtp->u.p.current_unit->strm_pos - 1,
+                               &dtp->common);
 	    }
 	}
 
@@ -2875,7 +3067,7 @@
       dtp->u.p.current_unit->current_record = 0;
       if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)
 	{
-	  fp = file_position (dtp->u.p.current_unit->s);
+	  fp = stell (dtp->u.p.current_unit->s);
 	  /* Calculate next record, rounding up partial records.  */
 	  dtp->u.p.current_unit->last_record =
 	    (fp + dtp->u.p.current_unit->recl - 1) /
@@ -2887,6 +3079,8 @@
 
   if (!done)
     pre_position (dtp);
+
+  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
 }
 
 
@@ -2935,7 +3129,6 @@
   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)
     {
       finish_list_read (dtp);
-      sfree (dtp->u.p.current_unit->s);
       return;
     }
 
@@ -2949,12 +3142,6 @@
 	  && dtp->u.p.advance_status != ADVANCE_NO)
 	next_record (dtp, 1);
 
-      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED
-	  && file_position (dtp->u.p.current_unit->s) >= dtp->rec)
-	{
-	  flush (dtp->u.p.current_unit->s);
-	  sfree (dtp->u.p.current_unit->s);
-	}
       return;
     }
 
@@ -2962,9 +3149,8 @@
 
   if (!is_internal_unit (dtp) && dtp->u.p.seen_dollar)
     {
+      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
       dtp->u.p.seen_dollar = 0;
-      fbuf_flush (dtp->u.p.current_unit, 1);
-      sfree (dtp->u.p.current_unit->s);
       return;
     }
 
@@ -2976,15 +3162,16 @@
 	- dtp->u.p.current_unit->bytes_left);
       dtp->u.p.current_unit->saved_pos =
 	dtp->u.p.max_pos > 0 ? dtp->u.p.max_pos - bytes_written : 0;
-      fbuf_flush (dtp->u.p.current_unit, 0);
-      flush (dtp->u.p.current_unit->s);
+      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
       return;
     }
+  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED 
+           && dtp->u.p.mode == WRITING && !is_internal_unit (dtp))
+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);    
 
   dtp->u.p.current_unit->saved_pos = 0;
 
   next_record (dtp, 1);
-  sfree (dtp->u.p.current_unit->s);
 }
 
 /* Transfer function for IOLENGTH. It doesn't actually do any
@@ -2997,7 +3184,7 @@
 		   size_t size, size_t nelems)
 {
   if ((dtp->common.flags & IOPARM_DT_HAS_IOLENGTH) != 0)
-    *dtp->iolength += (GFC_IO_INT) size * nelems;
+    *dtp->iolength += (GFC_IO_INT) (size * nelems);
 }
 
 
@@ -3041,8 +3228,6 @@
 st_iolength_done (st_parameter_dt *dtp __attribute__((unused)))
 {
   free_ionml (dtp);
-  if (dtp->u.p.scratch != NULL)
-    free_mem (dtp->u.p.scratch);
   library_end ();
 }
 
@@ -3058,29 +3243,6 @@
   library_start (&dtp->common);
 
   data_transfer_init (dtp, 1);
-
-  /* Handle complications dealing with the endfile record.  */
-
-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)
-    switch (dtp->u.p.current_unit->endfile)
-      {
-      case NO_ENDFILE:
-	break;
-
-      case AT_ENDFILE:
-	if (!is_internal_unit (dtp))
-	  {
-	    generate_error (&dtp->common, LIBERROR_END, NULL);
-	    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;
-	    dtp->u.p.current_unit->current_record = 0;
-	  }
-	break;
-
-      case AFTER_ENDFILE:
-	generate_error (&dtp->common, LIBERROR_ENDFILE, NULL);
-	dtp->u.p.current_unit->current_record = 0;
-	break;
-      }
 }
 
 extern void st_read_done (st_parameter_dt *);
@@ -3090,10 +3252,9 @@
 st_read_done (st_parameter_dt *dtp)
 {
   finalize_transfer (dtp);
-  free_format_data (dtp);
+  if (is_internal_unit (dtp))
+    free_format_data (dtp->u.p.fmt);
   free_ionml (dtp);
-  if (dtp->u.p.scratch != NULL)
-    free_mem (dtp->u.p.scratch);
   if (dtp->u.p.current_unit != NULL)
     unlock_unit (dtp->u.p.current_unit);
 
@@ -3136,19 +3297,16 @@
       case NO_ENDFILE:
 	/* Get rid of whatever is after this record.  */
         if (!is_internal_unit (dtp))
-	  {
-	    flush (dtp->u.p.current_unit->s);
-	    if (struncate (dtp->u.p.current_unit->s) == FAILURE)
-	      generate_error (&dtp->common, LIBERROR_OS, NULL);
-	  }
+          unit_truncate (dtp->u.p.current_unit, 
+                         stell (dtp->u.p.current_unit->s),
+                         &dtp->common);
 	dtp->u.p.current_unit->endfile = AT_ENDFILE;
 	break;
       }
 
-  free_format_data (dtp);
+  if (is_internal_unit (dtp))
+    free_format_data (dtp->u.p.fmt);
   free_ionml (dtp);
-  if (dtp->u.p.scratch != NULL)
-    free_mem (dtp->u.p.scratch);
   if (dtp->u.p.current_unit != NULL)
     unlock_unit (dtp->u.p.current_unit);
   
@@ -3262,3 +3420,46 @@
   for (i=0; i<n; i++)
       *(d++) = *(s--);
 }
+
+
+/* Once upon a time, a poor innocent Fortran program was reading a
+   file, when suddenly it hit the end-of-file (EOF).  Unfortunately
+   the OS doesn't tell whether we're at the EOF or whether we already
+   went past it.  Luckily our hero, libgfortran, keeps track of this.
+   Call this function when you detect an EOF condition.  See Section
+   9.10.2 in F2003.  */
+
+void
+hit_eof (st_parameter_dt * dtp)
+{
+  dtp->u.p.current_unit->flags.position = POSITION_APPEND;
+
+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)
+    switch (dtp->u.p.current_unit->endfile)
+      {
+      case NO_ENDFILE:
+      case AT_ENDFILE:
+        generate_error (&dtp->common, LIBERROR_END, NULL);
+	if (!is_internal_unit (dtp))
+	  {
+	    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;
+	    dtp->u.p.current_unit->current_record = 0;
+	  }
+        else
+          dtp->u.p.current_unit->endfile = AT_ENDFILE;
+	break;
+        
+      case AFTER_ENDFILE:
+	generate_error (&dtp->common, LIBERROR_ENDFILE, NULL);
+	dtp->u.p.current_unit->current_record = 0;
+	break;
+      }
+  else
+    {
+      /* Non-sequential files don't have an ENDFILE record, so we
+         can't be at AFTER_ENDFILE.  */
+      dtp->u.p.current_unit->endfile = AT_ENDFILE;
+      generate_error (&dtp->common, LIBERROR_END, NULL);
+      dtp->u.p.current_unit->current_record = 0;
+    }
+}
diff -Naur gcc-4.4.0.orig/libgfortran/io/unit.c gcc-4.4.0/libgfortran/io/unit.c
--- gcc-4.4.0.orig/libgfortran/io/unit.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/unit.c	2009-05-26 18:21:22.000000000 -0700
@@ -535,6 +535,8 @@
       u->file_len = strlen (stdin_name);
       u->file = get_mem (u->file_len);
       memmove (u->file, stdin_name, u->file_len);
+
+      fbuf_init (u, 0);
     
       __gthread_mutex_unlock (&u->lock);
     }
@@ -619,7 +621,7 @@
   if (u->previous_nonadvancing_write)
     finish_last_advance_record (u);
 
-  rc = (u->s == NULL) ? 0 : sclose (u->s) == FAILURE;
+  rc = (u->s == NULL) ? 0 : sclose (u->s) == -1;
 
   u->closed = 1;
   if (!locked)
@@ -635,7 +637,8 @@
     free_mem (u->file);
   u->file = NULL;
   u->file_len = 0;
-  
+
+  free_format_hash_table (u);  
   fbuf_destroy (u);
 
   if (!locked)
@@ -692,15 +695,62 @@
 void
 update_position (gfc_unit *u)
 {
-  if (file_position (u->s) == 0)
+  if (stell (u->s) == 0)
     u->flags.position = POSITION_REWIND;
-  else if (file_length (u->s) == file_position (u->s))
+  else if (file_length (u->s) == stell (u->s))
     u->flags.position = POSITION_APPEND;
   else
     u->flags.position = POSITION_ASIS;
 }
 
 
+/* High level interface to truncate a file safely, i.e. flush format
+   buffers, check that it's a regular file, and generate error if that
+   occurs.  Just like POSIX ftruncate, returns 0 on success, -1 on
+   failure.  */
+
+int
+unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)
+{
+  int ret;
+
+  /* Make sure format buffer is flushed.  */
+  if (u->flags.form == FORM_FORMATTED)
+    {
+      if (u->mode == READING)
+	pos += fbuf_reset (u);
+      else
+	fbuf_flush (u, u->mode);
+    }
+  
+  /* Don't try to truncate a special file, just pretend that it
+     succeeds.  */
+  if (is_special (u->s) || !is_seekable (u->s))
+    {
+      sflush (u->s);
+      return 0;
+    }
+
+  /* struncate() should flush the stream buffer if necessary, so don't
+     bother calling sflush() here.  */
+  ret = struncate (u->s, pos);
+
+  if (ret != 0)
+    {
+      generate_error (common, LIBERROR_OS, NULL);
+      u->endfile = NO_ENDFILE;
+      u->flags.position = POSITION_ASIS;
+    }
+  else
+    {
+      u->endfile = AT_ENDFILE;
+      u->flags.position = POSITION_APPEND;
+    }
+
+  return ret;
+}
+
+
 /* filename_from_unit()-- If the unit_number exists, return a pointer to the
    name of the associated file, otherwise return the empty string.  The caller
    must free memory allocated for the filename string.  */
@@ -741,23 +791,25 @@
 {
   
   if (u->saved_pos > 0)
-    fbuf_seek (u, u->saved_pos);
-    
-  fbuf_flush (u, 1);
+    fbuf_seek (u, u->saved_pos, SEEK_CUR);
 
   if (!(u->unit_number == options.stdout_unit
 	|| u->unit_number == options.stderr_unit))
     {
-      size_t len;
-
-      const char crlf[] = "\r\n";
 #ifdef HAVE_CRLF
-      len = 2;
+      const int len = 2;
 #else
-      len = 1;
+      const int len = 1;
 #endif
-      if (swrite (u->s, &crlf[2-len], &len) != 0)
+      char *p = fbuf_alloc (u, len);
+      if (!p)
 	os_error ("Completing record after ADVANCE_NO failed");
+#ifdef HAVE_CRLF
+      *(p++) = '\r';
+#endif
+      *p = '\n';
     }
+
+  fbuf_flush (u, u->mode);
 }
 
diff -Naur gcc-4.4.0.orig/libgfortran/io/unix.c gcc-4.4.0/libgfortran/io/unix.c
--- gcc-4.4.0.orig/libgfortran/io/unix.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/unix.c	2009-05-26 18:21:22.000000000 -0700
@@ -89,10 +89,6 @@
 
 #endif
 
-#ifndef SSIZE_MAX
-#define SSIZE_MAX SHRT_MAX
-#endif
-
 #ifndef PATH_MAX
 #define PATH_MAX 1024
 #endif
@@ -124,128 +120,30 @@
 #endif
 
 
-/* Unix stream I/O module */
+/* Unix and internal stream I/O module */
 
-#define BUFFER_SIZE 8192
+static const int BUFFER_SIZE = 8192;
 
 typedef struct
 {
   stream st;
 
-  int fd;
   gfc_offset buffer_offset;	/* File offset of the start of the buffer */
   gfc_offset physical_offset;	/* Current physical file offset */
   gfc_offset logical_offset;	/* Current logical file offset */
-  gfc_offset dirty_offset;	/* Start of modified bytes in buffer */
   gfc_offset file_length;	/* Length of the file, -1 if not seekable. */
 
-  int len;			/* Physical length of the current buffer */
-  int active;			/* Length of valid bytes in the buffer */
-
-  int prot;
-  int ndirty;			/* Dirty bytes starting at dirty_offset */
-
-  int special_file;		/* =1 if the fd refers to a special file */
-
-  io_mode method;		/* Method of stream I/O being used */
-
-  char *buffer;
-  char small_buffer[BUFFER_SIZE];
-}
-unix_stream;
-
-
-/* Stream structure for internal files. Fields must be kept in sync
-   with unix_stream above, except for the buffer. For internal files
-   we point the buffer pointer directly at the destination memory.  */
-
-typedef struct
-{
-  stream st;
-
-  int fd;
-  gfc_offset buffer_offset;	/* File offset of the start of the buffer */
-  gfc_offset physical_offset;	/* Current physical file offset */
-  gfc_offset logical_offset;	/* Current logical file offset */
-  gfc_offset dirty_offset;	/* Start of modified bytes in buffer */
-  gfc_offset file_length;	/* Length of the file, -1 if not seekable. */
+  char *buffer;                 /* Pointer to the buffer.  */
+  int fd;                       /* The POSIX file descriptor.  */
 
-  int len;			/* Physical length of the current buffer */
   int active;			/* Length of valid bytes in the buffer */
 
   int prot;
-  int ndirty;			/* Dirty bytes starting at dirty_offset */
+  int ndirty;			/* Dirty bytes starting at buffer_offset */
 
   int special_file;		/* =1 if the fd refers to a special file */
-
-  io_mode method;		/* Method of stream I/O being used */
-
-  char *buffer;
-}
-int_stream;
-
-/* This implementation of stream I/O is based on the paper:
- *
- *  "Exploiting the advantages of mapped files for stream I/O",
- *  O. Krieger, M. Stumm and R. Umrau, "Proceedings of the 1992 Winter
- *  USENIX conference", p. 27-42.
- *
- * It differs in a number of ways from the version described in the
- * paper.  First of all, threads are not an issue during I/O and we
- * also don't have to worry about having multiple regions, since
- * fortran's I/O model only allows you to be one place at a time.
- *
- * On the other hand, we have to be able to writing at the end of a
- * stream, read from the start of a stream or read and write blocks of
- * bytes from an arbitrary position.  After opening a file, a pointer
- * to a stream structure is returned, which is used to handle file
- * accesses until the file is closed.
- *
- * salloc_at_r(stream, len, where)-- Given a stream pointer, return a
- * pointer to a block of memory that mirror the file at position
- * 'where' that is 'len' bytes long.  The len integer is updated to
- * reflect how many bytes were actually read.  The only reason for a
- * short read is end of file.  The file pointer is updated.  The
- * pointer is valid until the next call to salloc_*.
- *
- * salloc_at_w(stream, len, where)-- Given the stream pointer, returns
- * a pointer to a block of memory that is updated to reflect the state
- * of the file.  The length of the buffer is always equal to that
- * requested.  The buffer must be completely set by the caller.  When
- * data has been written, the sfree() function must be called to
- * indicate that the caller is done writing data to the buffer.  This
- * may or may not cause a physical write.
- *
- * Short forms of these are salloc_r() and salloc_w() which drop the
- * 'where' parameter and use the current file pointer. */
-
-
-/*move_pos_offset()--  Move the record pointer right or left
- *relative to current position */
-
-int
-move_pos_offset (stream* st, int pos_off)
-{
-  unix_stream * str = (unix_stream*)st;
-  if (pos_off < 0)
-    {
-      str->logical_offset += pos_off;
-
-      if (str->dirty_offset + str->ndirty > str->logical_offset)
-	{
-	  if (str->ndirty + pos_off > 0)
-	    str->ndirty += pos_off;
-	  else
-	    {
-	      str->dirty_offset +=  pos_off + pos_off;
-	      str->ndirty = 0;
-	    }
-	}
-
-    return pos_off;
-  }
-  return 0;
 }
+unix_stream;
 
 
 /* fix_fd()-- Given a file descriptor, make sure it is not one of the
@@ -292,17 +190,6 @@
   return fd;
 }
 
-int
-is_preconnected (stream * s)
-{
-  int fd;
-
-  fd = ((unix_stream *) s)->fd;
-  if (fd == STDIN_FILENO || fd == STDOUT_FILENO || fd == STDERR_FILENO)
-    return 1;
-  else
-    return 0;
-}
 
 /* If the stream corresponds to a preconnected unit, we flush the
    corresponding C stream.  This is bugware for mixed C-Fortran codes
@@ -322,580 +209,335 @@
 }
 
 
-/* Reset a stream after reading/writing. Assumes that the buffers have
-   been flushed.  */
+/* get_oserror()-- Get the most recent operating system error.  For
+ * unix, this is errno. */
 
-inline static void
-reset_stream (unix_stream * s, size_t bytes_rw)
+const char *
+get_oserror (void)
 {
-  s->physical_offset += bytes_rw;
-  s->logical_offset = s->physical_offset;
-  if (s->file_length != -1 && s->physical_offset > s->file_length)
-    s->file_length = s->physical_offset;
+  return strerror (errno);
 }
 
 
-/* Read bytes into a buffer, allowing for short reads.  If the nbytes
- * argument is less on return than on entry, it is because we've hit
- * the end of file. */
+/********************************************************************
+Raw I/O functions (read, write, seek, tell, truncate, close).
+
+These functions wrap the basic POSIX I/O syscalls. Any deviation in
+semantics is a bug, except the following: write restarts in case
+of being interrupted by a signal, and as the first argument the
+functions take the unix_stream struct rather than an integer file
+descriptor. Also, for POSIX read() and write() a nbyte argument larger
+than SSIZE_MAX is undefined; here the type of nbyte is ssize_t rather
+than size_t as for POSIX read/write.
+*********************************************************************/
 
 static int
-do_read (unix_stream * s, void * buf, size_t * nbytes)
+raw_flush (unix_stream * s  __attribute__ ((unused)))
 {
-  ssize_t trans;
-  size_t bytes_left;
-  char *buf_st;
-  int status;
-
-  status = 0;
-  bytes_left = *nbytes;
-  buf_st = (char *) buf;
-
-  /* We must read in a loop since some systems don't restart system
-     calls in case of a signal.  */
-  while (bytes_left > 0)
-    {
-      /* Requests between SSIZE_MAX and SIZE_MAX are undefined by SUSv3,
-	 so we must read in chunks smaller than SSIZE_MAX.  */
-      trans = (bytes_left < SSIZE_MAX) ? bytes_left : SSIZE_MAX;
-      trans = read (s->fd, buf_st, trans);
-      if (trans < 0)
-	{
-	  if (errno == EINTR)
-	    continue;
-	  else
-	    {
-	      status = errno;
-	      break;
-	    }
-	}
-      else if (trans == 0) /* We hit EOF.  */
-	break;
-      buf_st += trans;
-      bytes_left -= trans;
-    }
-
-  *nbytes -= bytes_left;
-  return status;
+  return 0;
 }
 
+static ssize_t
+raw_read (unix_stream * s, void * buf, ssize_t nbyte)
+{
+  /* For read we can't do I/O in a loop like raw_write does, because
+     that will break applications that wait for interactive I/O.  */
+  return read (s->fd, buf, nbyte);
+}
 
-/* Write a buffer to a stream, allowing for short writes.  */
-
-static int
-do_write (unix_stream * s, const void * buf, size_t * nbytes)
+static ssize_t
+raw_write (unix_stream * s, const void * buf, ssize_t nbyte)
 {
-  ssize_t trans;
-  size_t bytes_left;
+  ssize_t trans, bytes_left;
   char *buf_st;
-  int status;
 
-  status = 0;
-  bytes_left = *nbytes;
+  bytes_left = nbyte;
   buf_st = (char *) buf;
 
   /* We must write in a loop since some systems don't restart system
      calls in case of a signal.  */
   while (bytes_left > 0)
     {
-      /* Requests between SSIZE_MAX and SIZE_MAX are undefined by SUSv3,
-	 so we must write in chunks smaller than SSIZE_MAX.  */
-      trans = (bytes_left < SSIZE_MAX) ? bytes_left : SSIZE_MAX;
-      trans = write (s->fd, buf_st, trans);
+      trans = write (s->fd, buf_st, bytes_left);
       if (trans < 0)
 	{
 	  if (errno == EINTR)
 	    continue;
 	  else
-	    {
-	      status = errno;
-	      break;
-	    }
+	    return trans;
 	}
       buf_st += trans;
       bytes_left -= trans;
     }
 
-  *nbytes -= bytes_left;
-  return status;
+  return nbyte - bytes_left;
 }
 
-
-/* get_oserror()-- Get the most recent operating system error.  For
- * unix, this is errno. */
-
-const char *
-get_oserror (void)
+static off_t
+raw_seek (unix_stream * s, off_t offset, int whence)
 {
-  return strerror (errno);
+  return lseek (s->fd, offset, whence);
 }
 
-
-/*********************************************************************
-    File descriptor stream functions
-*********************************************************************/
-
-
-/* fd_flush()-- Write bytes that need to be written */
-
-static try
-fd_flush (unix_stream * s)
+static off_t
+raw_tell (unix_stream * s)
 {
-  size_t writelen;
-
-  if (s->ndirty == 0)
-    return SUCCESS;
-  
-  if (s->file_length != -1 && s->physical_offset != s->dirty_offset &&
-      lseek (s->fd, s->dirty_offset, SEEK_SET) < 0)
-    return FAILURE;
-
-  writelen = s->ndirty;
-  if (do_write (s, s->buffer + (s->dirty_offset - s->buffer_offset),
-		&writelen) != 0)
-    return FAILURE;
-
-  s->physical_offset = s->dirty_offset + writelen;
-
-  /* don't increment file_length if the file is non-seekable */
-  if (s->file_length != -1 && s->physical_offset > s->file_length)
-      s->file_length = s->physical_offset; 
-
-  s->ndirty -= writelen;
-  if (s->ndirty != 0)
-    return FAILURE;
-
-  return SUCCESS;
+  return lseek (s->fd, 0, SEEK_CUR);
 }
 
-
-/* fd_alloc()-- Arrange a buffer such that the salloc() request can be
- * satisfied.  This subroutine gets the buffer ready for whatever is
- * to come next. */
-
-static void
-fd_alloc (unix_stream * s, gfc_offset where,
-	  int *len __attribute__ ((unused)))
+static int
+raw_truncate (unix_stream * s, off_t length)
 {
-  char *new_buffer;
-  int n, read_len;
-
-  if (*len <= BUFFER_SIZE)
-    {
-      new_buffer = s->small_buffer;
-      read_len = BUFFER_SIZE;
-    }
-  else
-    {
-      new_buffer = get_mem (*len);
-      read_len = *len;
-    }
-
-  /* Salvage bytes currently within the buffer.  This is important for
-   * devices that cannot seek. */
-
-  if (s->buffer != NULL && s->buffer_offset <= where &&
-      where <= s->buffer_offset + s->active)
-    {
-
-      n = s->active - (where - s->buffer_offset);
-      memmove (new_buffer, s->buffer + (where - s->buffer_offset), n);
+#ifdef HAVE_FTRUNCATE
+  return ftruncate (s->fd, length);
+#elif defined HAVE_CHSIZE
+  return chsize (s->fd, length);
+#else
+  runtime_error ("required ftruncate or chsize support not present");
+  return -1;
+#endif
+}
 
-      s->active = n;
-    }
+static int
+raw_close (unix_stream * s)
+{
+  int retval;
+  
+  if (s->fd != STDOUT_FILENO
+      && s->fd != STDERR_FILENO
+      && s->fd != STDIN_FILENO)
+    retval = close (s->fd);
   else
-    {				/* new buffer starts off empty */
-      s->active = 0;
-    }
-
-  s->buffer_offset = where;
-
-  /* free the old buffer if necessary */
+    retval = 0;
+  free_mem (s);
+  return retval;
+}
 
-  if (s->buffer != NULL && s->buffer != s->small_buffer)
-    free_mem (s->buffer);
+static int
+raw_init (unix_stream * s)
+{
+  s->st.read = (void *) raw_read;
+  s->st.write = (void *) raw_write;
+  s->st.seek = (void *) raw_seek;
+  s->st.tell = (void *) raw_tell;
+  s->st.trunc = (void *) raw_truncate;
+  s->st.close = (void *) raw_close;
+  s->st.flush = (void *) raw_flush;
 
-  s->buffer = new_buffer;
-  s->len = read_len;
+  s->buffer = NULL;
+  return 0;
 }
 
 
-/* fd_alloc_r_at()-- Allocate a stream buffer for reading.  Either
- * we've already buffered the data or we need to load it.  Returns
- * NULL on I/O error. */
+/*********************************************************************
+Buffered I/O functions. These functions have the same semantics as the
+raw I/O functions above, except that they are buffered in order to
+improve performance. The buffer must be flushed when switching from
+reading to writing and vice versa.
+*********************************************************************/
 
-static char *
-fd_alloc_r_at (unix_stream * s, int *len)
+static int
+buf_flush (unix_stream * s)
 {
-  gfc_offset m;
-  gfc_offset where = s->logical_offset;
+  int writelen;
 
-  if (s->buffer != NULL && s->buffer_offset <= where &&
-      where + *len <= s->buffer_offset + s->active)
-    {
-
-      /* Return a position within the current buffer */
+  /* Flushing in read mode means discarding read bytes.  */
+  s->active = 0;
 
-      s->logical_offset = where + *len;
-      return s->buffer + where - s->buffer_offset;
-    }
+  if (s->ndirty == 0)
+    return 0;
+  
+  if (s->file_length != -1 && s->physical_offset != s->buffer_offset
+      && lseek (s->fd, s->buffer_offset, SEEK_SET) < 0)
+    return -1;
 
-  fd_alloc (s, where, len);
+  writelen = raw_write (s, s->buffer, s->ndirty);
 
-  m = where + s->active;
+  s->physical_offset = s->buffer_offset + writelen;
 
-  if (s->physical_offset != m && lseek (s->fd, m, SEEK_SET) < 0)
-    return NULL;
+  /* Don't increment file_length if the file is non-seekable.  */
+  if (s->file_length != -1 && s->physical_offset > s->file_length)
+      s->file_length = s->physical_offset;
 
-  /* do_read() hangs on read from terminals for *BSD-systems.  Only
-     use read() in that case.  */
+  s->ndirty -= writelen;
+  if (s->ndirty != 0)
+    return -1;
 
-  if (s->special_file)
-    {
-      ssize_t n;
+  return 0;
+}
 
-      n = read (s->fd, s->buffer + s->active, s->len - s->active);
-      if (n < 0)
-	return NULL;
+static ssize_t
+buf_read (unix_stream * s, void * buf, ssize_t nbyte)
+{
+  if (s->active == 0)
+    s->buffer_offset = s->logical_offset;
 
-      s->physical_offset = m + n;
-      s->active += n;
-    }
+  /* Is the data we want in the buffer?  */
+  if (s->logical_offset + nbyte <= s->buffer_offset + s->active
+      && s->buffer_offset <= s->logical_offset)
+    memcpy (buf, s->buffer + (s->logical_offset - s->buffer_offset), nbyte);
   else
     {
-      size_t n;
-
-      n = s->len - s->active;
-      if (do_read (s, s->buffer + s->active, &n) != 0)
-	return NULL;
-
-      s->physical_offset = m + n;
-      s->active += n;
+      /* First copy the active bytes if applicable, then read the rest
+         either directly or filling the buffer.  */
+      char *p;
+      int nread = 0;
+      ssize_t to_read, did_read;
+      gfc_offset new_logical;
+      
+      p = (char *) buf;
+      if (s->logical_offset >= s->buffer_offset 
+          && s->buffer_offset + s->active >= s->logical_offset)
+        {
+          nread = s->active - (s->logical_offset - s->buffer_offset);
+          memcpy (buf, s->buffer + (s->logical_offset - s->buffer_offset), 
+                  nread);
+          p += nread;
+        }
+      /* At this point we consider all bytes in the buffer discarded.  */
+      to_read = nbyte - nread;
+      new_logical = s->logical_offset + nread;
+      if (s->file_length != -1 && s->physical_offset != new_logical
+          && lseek (s->fd, new_logical, SEEK_SET) < 0)
+        return -1;
+      s->buffer_offset = s->physical_offset = new_logical;
+      if (to_read <= BUFFER_SIZE/2)
+        {
+          did_read = raw_read (s, s->buffer, BUFFER_SIZE);
+          s->physical_offset += did_read;
+          s->active = did_read;
+          did_read = (did_read > to_read) ? to_read : did_read;
+          memcpy (p, s->buffer, did_read);
+        }
+      else
+        {
+          did_read = raw_read (s, p, to_read);
+          s->physical_offset += did_read;
+          s->active = 0;
+        }
+      nbyte = did_read + nread;
     }
-
-  if (s->active < *len)
-    *len = s->active;		/* Bytes actually available */
-
-  s->logical_offset = where + *len;
-
-  return s->buffer;
+  s->logical_offset += nbyte;
+  return nbyte;
 }
 
-
-/* fd_alloc_w_at()-- Allocate a stream buffer for writing.  Either
- * we've already buffered the data or we need to load it. */
-
-static char *
-fd_alloc_w_at (unix_stream * s, int *len)
+static ssize_t
+buf_write (unix_stream * s, const void * buf, ssize_t nbyte)
 {
-  gfc_offset n;
-  gfc_offset where = s->logical_offset;
-
-  if (s->buffer == NULL || s->buffer_offset > where ||
-      where + *len > s->buffer_offset + s->len)
-    {
+  if (s->ndirty == 0)
+    s->buffer_offset = s->logical_offset;
 
-      if (fd_flush (s) == FAILURE)
-	return NULL;
-      fd_alloc (s, where, len);
-    }
-
-  /* Return a position within the current buffer */
-  if (s->ndirty == 0 
-      || where > s->dirty_offset + s->ndirty    
-      || s->dirty_offset > where + *len)
-    {  /* Discontiguous blocks, start with a clean buffer.  */  
-	/* Flush the buffer.  */  
-      if (s->ndirty != 0)    
-	fd_flush (s);  
-      s->dirty_offset = where;  
-      s->ndirty = *len;
+  /* Does the data fit into the buffer?  As a special case, if the
+     buffer is empty and the request is bigger than BUFFER_SIZE/2,
+     write directly. This avoids the case where the buffer would have
+     to be flushed at every write.  */
+  if (!(s->ndirty == 0 && nbyte > BUFFER_SIZE/2)
+      && s->logical_offset + nbyte <= s->buffer_offset + BUFFER_SIZE
+      && s->buffer_offset <= s->logical_offset
+      && s->buffer_offset + s->ndirty >= s->logical_offset)
+    {
+      memcpy (s->buffer + (s->logical_offset - s->buffer_offset), buf, nbyte);
+      int nd = (s->logical_offset - s->buffer_offset) + nbyte;
+      if (nd > s->ndirty)
+        s->ndirty = nd;
     }
   else
-    {  
-      gfc_offset start;  /* Merge with the existing data.  */  
-      if (where < s->dirty_offset)    
-	start = where;  
-      else    
-	start = s->dirty_offset;  
-      if (where + *len > s->dirty_offset + s->ndirty)    
-	s->ndirty = where + *len - start;  
-      else    
-	s->ndirty = s->dirty_offset + s->ndirty - start;  
-      s->dirty_offset = start;
+    {
+      /* Flush, and either fill the buffer with the new data, or if
+         the request is bigger than the buffer size, write directly
+         bypassing the buffer.  */
+      buf_flush (s);
+      if (nbyte <= BUFFER_SIZE/2)
+        {
+          memcpy (s->buffer, buf, nbyte);
+          s->buffer_offset = s->logical_offset;
+          s->ndirty += nbyte;
+        }
+      else
+        {
+          if (s->file_length != -1 && s->physical_offset != s->logical_offset
+              && lseek (s->fd, s->logical_offset, SEEK_SET) < 0)
+            return -1;
+          nbyte = raw_write (s, buf, nbyte);
+          s->physical_offset += nbyte;
+        }
     }
-
-  s->logical_offset = where + *len;
-
+  s->logical_offset += nbyte;
   /* Don't increment file_length if the file is non-seekable.  */
-
   if (s->file_length != -1 && s->logical_offset > s->file_length)
-     s->file_length = s->logical_offset;
-
-  n = s->logical_offset - s->buffer_offset;
-  if (n > s->active)
-    s->active = n;
-
-  return s->buffer + where - s->buffer_offset;
-}
-
-
-static try
-fd_sfree (unix_stream * s)
-{
-  if (s->ndirty != 0 &&
-      (s->buffer != s->small_buffer || options.all_unbuffered ||
-       s->method == SYNC_UNBUFFERED))
-    return fd_flush (s);
-
-  return SUCCESS;
+    s->file_length = s->logical_offset;
+  return nbyte;
 }
 
-
-static try
-fd_seek (unix_stream * s, gfc_offset offset)
+static off_t
+buf_seek (unix_stream * s, off_t offset, int whence)
 {
-
-  if (s->file_length == -1)
-    return SUCCESS;
-
-  if (s->physical_offset == offset) /* Are we lucky and avoid syscall?  */
-    {
-      s->logical_offset = offset;
-      return SUCCESS;
-    }
-
-  if (lseek (s->fd, offset, SEEK_SET) >= 0)
+  switch (whence)
     {
-      s->physical_offset = s->logical_offset = offset;
-      s->active = 0;
-      return SUCCESS;
+    case SEEK_SET:
+      break;
+    case SEEK_CUR:
+      offset += s->logical_offset;
+      break;
+    case SEEK_END:
+      offset += s->file_length;
+      break;
+    default:
+      return -1;
     }
-
-  return FAILURE;
-}
-
-
-/* truncate_file()-- Given a unit, truncate the file at the current
- * position.  Sets the physical location to the new end of the file.
- * Returns nonzero on error. */
-
-static try
-fd_truncate (unix_stream * s)
-{
-  /* Non-seekable files, like terminals and fifo's fail the lseek so just
-     return success, there is nothing to truncate.  If its not a pipe there
-     is a real problem.  */
-  if (lseek (s->fd, s->logical_offset, SEEK_SET) == -1)
+  if (offset < 0)
     {
-      if (errno == ESPIPE)
-	return SUCCESS;
-      else
-	return FAILURE;
-    }
-
-  /* Using ftruncate on a seekable special file (like /dev/null)
-     is undefined, so we treat it as if the ftruncate succeeded.  */
-  if (!s->special_file
-      && (
-#ifdef HAVE_FTRUNCATE
-	  ftruncate (s->fd, s->logical_offset) != 0
-#elif defined HAVE_CHSIZE
-	  chsize (s->fd, s->logical_offset) != 0
-#else
-	  /* If we have neither, always fail and exit, noisily.  */
-	  runtime_error ("required ftruncate or chsize support not present"), 1
-#endif
-	  ))
-    {
-      /* The truncation failed and we need to handle this gracefully.
-	 The file length remains the same, but the file-descriptor
-	 offset needs adjustment per the successful lseek above.
-	 (Similarly, the contents of the buffer isn't valid anymore.)
-	 A ftruncate call does not affect the physical (file-descriptor)
-	 offset, according to the ftruncate manual, so neither should a
-	 failed call.  */
-      s->physical_offset = s->logical_offset;
-      s->active = 0;
-      return FAILURE;
+      errno = EINVAL;
+      return -1;
     }
-
-  s->physical_offset = s->file_length = s->logical_offset;
-  s->active = 0;
-  return SUCCESS;
+  s->logical_offset = offset;
+  return offset;
 }
 
-
-/* Similar to memset(), but operating on a stream instead of a string.
-   Takes care of not using too much memory.  */
-
-static try
-fd_sset (unix_stream * s, int c, size_t n)
+static off_t
+buf_tell (unix_stream * s)
 {
-  size_t bytes_left;
-  int trans;
-  void *p;
-
-  bytes_left = n;
-
-  while (bytes_left > 0)
-    {
-      /* memset() in chunks of BUFFER_SIZE.  */
-      trans = (bytes_left < BUFFER_SIZE) ? bytes_left : BUFFER_SIZE;
-
-      p = fd_alloc_w_at (s, &trans);
-      if (p)
-	  memset (p, c, trans);
-      else
-	return FAILURE;
-
-      bytes_left -= trans;
-    }
-
-  return SUCCESS;
+  return s->logical_offset;
 }
 
-
-/* Stream read function. Avoids using a buffer for big reads. The
-   interface is like POSIX read(), but the nbytes argument is a
-   pointer; on return it contains the number of bytes written. The
-   function return value is the status indicator (0 for success).  */
-
 static int
-fd_read (unix_stream * s, void * buf, size_t * nbytes)
+buf_truncate (unix_stream * s, off_t length)
 {
-  void *p;
-  int tmp, status;
+  int r;
 
-  if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)
-    {
-      tmp = *nbytes;
-      p = fd_alloc_r_at (s, &tmp);
-      if (p)
-	{
-	  *nbytes = tmp;
-	  memcpy (buf, p, *nbytes);
-	  return 0;
-	}
-      else
-	{
-	  *nbytes = 0;
-	  return errno;
-	}
-    }
-
-  /* If the request is bigger than BUFFER_SIZE we flush the buffers
-     and read directly.  */
-  if (fd_flush (s) == FAILURE)
-    {
-      *nbytes = 0;
-      return errno;
-    }
-
-  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)
-    {
-      *nbytes = 0;
-      return errno;
-    }
-
-  status = do_read (s, buf, nbytes);
-  reset_stream (s, *nbytes);
-  return status;
+  if (buf_flush (s) != 0)
+    return -1;
+  r = raw_truncate (s, length);
+  if (r == 0)
+    s->file_length = length;
+  return r;
 }
 
-
-/* Stream write function. Avoids using a buffer for big writes. The
-   interface is like POSIX write(), but the nbytes argument is a
-   pointer; on return it contains the number of bytes written. The
-   function return value is the status indicator (0 for success).  */
-
 static int
-fd_write (unix_stream * s, const void * buf, size_t * nbytes)
-{
-  void *p;
-  int tmp, status;
-
-  if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)
-    {
-      tmp = *nbytes;
-      p = fd_alloc_w_at (s, &tmp);
-      if (p)
-	{
-	  *nbytes = tmp;
-	  memcpy (p, buf, *nbytes);
-	  return 0;
-	}
-      else
-	{
-	  *nbytes = 0;
-	  return errno;
-	}
-    }
-
-  /* If the request is bigger than BUFFER_SIZE we flush the buffers
-     and write directly.  */
-  if (fd_flush (s) == FAILURE)
-    {
-      *nbytes = 0;
-      return errno;
-    }
-
-  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)
-    {
-      *nbytes = 0;
-      return errno;
-    }
-
-  status =  do_write (s, buf, nbytes);
-  reset_stream (s, *nbytes);
-  return status;
-}
-
-
-static try
-fd_close (unix_stream * s)
+buf_close (unix_stream * s)
 {
-  if (fd_flush (s) == FAILURE)
-    return FAILURE;
-
-  if (s->buffer != NULL && s->buffer != s->small_buffer)
-    free_mem (s->buffer);
-
-  if (s->fd != STDOUT_FILENO && s->fd != STDERR_FILENO && s->fd != STDIN_FILENO)
-    {
-      if (close (s->fd) < 0)
-	return FAILURE;
-    }
-
-  free_mem (s);
-
-  return SUCCESS;
+  if (buf_flush (s) != 0)
+    return -1;
+  free_mem (s->buffer);
+  return raw_close (s);
 }
 
-
-static void
-fd_open (unix_stream * s)
+static int
+buf_init (unix_stream * s)
 {
-  if (isatty (s->fd))
-    s->method = SYNC_UNBUFFERED;
-  else
-    s->method = SYNC_BUFFERED;
+  s->st.read = (void *) buf_read;
+  s->st.write = (void *) buf_write;
+  s->st.seek = (void *) buf_seek;
+  s->st.tell = (void *) buf_tell;
+  s->st.trunc = (void *) buf_truncate;
+  s->st.close = (void *) buf_close;
+  s->st.flush = (void *) buf_flush;
 
-  s->st.alloc_w_at = (void *) fd_alloc_w_at;
-  s->st.sfree = (void *) fd_sfree;
-  s->st.close = (void *) fd_close;
-  s->st.seek = (void *) fd_seek;
-  s->st.trunc = (void *) fd_truncate;
-  s->st.read = (void *) fd_read;
-  s->st.write = (void *) fd_write;
-  s->st.set = (void *) fd_sset;
-
-  s->buffer = NULL;
+  s->buffer = get_mem (BUFFER_SIZE);
+  return 0;
 }
 
 
-
-
 /*********************************************************************
   memory stream functions - These are used for internal files
 
@@ -907,33 +549,33 @@
 *********************************************************************/
 
 
-static char *
-mem_alloc_r_at (int_stream * s, int *len)
+char *
+mem_alloc_r (stream * strm, int * len)
 {
+  unix_stream * s = (unix_stream *) strm;
   gfc_offset n;
   gfc_offset where = s->logical_offset;
 
   if (where < s->buffer_offset || where > s->buffer_offset + s->active)
     return NULL;
 
-  s->logical_offset = where + *len;
-
   n = s->buffer_offset + s->active - where;
   if (*len > n)
     *len = n;
 
+  s->logical_offset = where + *len;
+
   return s->buffer + (where - s->buffer_offset);
 }
 
 
-static char *
-mem_alloc_w_at (int_stream * s, int *len)
+char *
+mem_alloc_w (stream * strm, int * len)
 {
+  unix_stream * s = (unix_stream *) strm;
   gfc_offset m;
   gfc_offset where = s->logical_offset;
 
-  assert (*len >= 0);  /* Negative values not allowed. */
-  
   m = where + *len;
 
   if (where < s->buffer_offset)
@@ -950,25 +592,20 @@
 
 /* Stream read function for internal units.  */
 
-static int
-mem_read (int_stream * s, void * buf, size_t * nbytes)
+static ssize_t
+mem_read (stream * s, void * buf, ssize_t nbytes)
 {
   void *p;
-  int tmp;
+  int nb = nbytes;
 
-  tmp = *nbytes;
-  p = mem_alloc_r_at (s, &tmp);
+  p = mem_alloc_r (s, &nb);
   if (p)
     {
-      *nbytes = tmp;
-      memcpy (buf, p, *nbytes);
-      return 0;
+      memcpy (buf, p, nb);
+      return (ssize_t) nb;
     }
   else
-    {
-      *nbytes = 0;
-      return 0;
-    }
+    return 0;
 }
 
 
@@ -976,84 +613,90 @@
    at the moment, as all internal IO is formatted and the formatted IO
    routines use mem_alloc_w_at.  */
 
-static int
-mem_write (int_stream * s, const void * buf, size_t * nbytes)
+static ssize_t
+mem_write (stream * s, const void * buf, ssize_t nbytes)
 {
   void *p;
-  int tmp;
+  int nb = nbytes;
 
-  tmp = *nbytes;
-  p = mem_alloc_w_at (s, &tmp);
+  p = mem_alloc_w (s, &nb);
   if (p)
     {
-      *nbytes = tmp;
-      memcpy (p, buf, *nbytes);
-      return 0;
+      memcpy (p, buf, nb);
+      return (ssize_t) nb;
     }
   else
-    {
-      *nbytes = 0;
-      return 0;
-    }
+    return 0;
 }
 
 
-static int
-mem_seek (int_stream * s, gfc_offset offset)
+static off_t
+mem_seek (stream * strm, off_t offset, int whence)
 {
+  unix_stream * s = (unix_stream *) strm;
+  switch (whence)
+    {
+    case SEEK_SET:
+      break;
+    case SEEK_CUR:
+      offset += s->logical_offset;
+      break;
+    case SEEK_END:
+      offset += s->file_length;
+      break;
+    default:
+      return -1;
+    }
+
+  /* Note that for internal array I/O it's actually possible to have a
+     negative offset, so don't check for that.  */
   if (offset > s->file_length)
     {
-      errno = ESPIPE;
-      return FAILURE;
+      errno = EINVAL;
+      return -1;
     }
 
   s->logical_offset = offset;
-  return SUCCESS;
+
+  /* Returning < 0 is the error indicator for sseek(), so return 0 if
+     offset is negative.  Thus if the return value is 0, the caller
+     has to use stell() to get the real value of logical_offset.  */
+  if (offset >= 0)
+    return offset;
+  return 0;
 }
 
 
-static try
-mem_set (int_stream * s, int c, size_t n)
+static off_t
+mem_tell (stream * s)
 {
-  void *p;
-  int len;
-
-  len = n;
-  
-  p = mem_alloc_w_at (s, &len);
-  if (p)
-    {
-      memset (p, c, len);
-      return SUCCESS;
-    }
-  else
-    return FAILURE;
+  return ((unix_stream *)s)->logical_offset;
 }
 
 
 static int
-mem_truncate (int_stream * s __attribute__ ((unused)))
+mem_truncate (unix_stream * s __attribute__ ((unused)), 
+	      off_t length __attribute__ ((unused)))
 {
-  return SUCCESS;
+  return 0;
 }
 
 
-static try
-mem_close (int_stream * s)
+static int
+mem_flush (unix_stream * s __attribute__ ((unused)))
 {
-  if (s != NULL)
-    free_mem (s);
-
-  return SUCCESS;
+  return 0;
 }
 
 
-static try
-mem_sfree (int_stream * s __attribute__ ((unused)))
+static int
+mem_close (unix_stream * s)
 {
-  return SUCCESS;
-}
+  if (s != NULL)
+    free_mem (s);
 
+  return 0;
+}
 
 
 /*********************************************************************
@@ -1066,7 +709,7 @@
 void
 empty_internal_buffer(stream *strm)
 {
-  int_stream * s = (int_stream *) strm;
+  unix_stream * s = (unix_stream *) strm;
   memset(s->buffer, ' ', s->file_length);
 }
 
@@ -1075,10 +718,10 @@
 stream *
 open_internal (char *base, int length, gfc_offset offset)
 {
-  int_stream *s;
+  unix_stream *s;
 
-  s = get_mem (sizeof (int_stream));
-  memset (s, '\0', sizeof (int_stream));
+  s = get_mem (sizeof (unix_stream));
+  memset (s, '\0', sizeof (unix_stream));
 
   s->buffer = base;
   s->buffer_offset = offset;
@@ -1086,14 +729,13 @@
   s->logical_offset = 0;
   s->active = s->file_length = length;
 
-  s->st.alloc_w_at = (void *) mem_alloc_w_at;
-  s->st.sfree = (void *) mem_sfree;
   s->st.close = (void *) mem_close;
   s->st.seek = (void *) mem_seek;
+  s->st.tell = (void *) mem_tell;
   s->st.trunc = (void *) mem_truncate;
   s->st.read = (void *) mem_read;
   s->st.write = (void *) mem_write;
-  s->st.set = (void *) mem_set;
+  s->st.flush = (void *) mem_flush;
 
   return (stream *) s;
 }
@@ -1128,7 +770,14 @@
 
   s->special_file = !S_ISREG (statbuf.st_mode);
 
-  fd_open (s);
+  if (isatty (s->fd) || options.all_unbuffered
+      ||(options.unbuffered_preconnected && 
+         (s->fd == STDIN_FILENO 
+          || s->fd == STDOUT_FILENO 
+          || s->fd == STDERR_FILENO)))
+    raw_init (s);
+  else
+    buf_init (s);
 
   return (stream *) s;
 }
@@ -1412,8 +1061,6 @@
 #endif
 
   s = fd_to_stream (STDOUT_FILENO, PROT_WRITE);
-  if (options.unbuffered_preconnected)
-    ((unix_stream *) s)->method = SYNC_UNBUFFERED;
   return s;
 }
 
@@ -1431,8 +1078,6 @@
 #endif
 
   s = fd_to_stream (STDERR_FILENO, PROT_WRITE);
-  if (options.unbuffered_preconnected)
-    ((unix_stream *) s)->method = SYNC_UNBUFFERED;
   return s;
 }
 
@@ -1663,7 +1308,7 @@
 	  if (__gthread_mutex_trylock (&u->lock))
 	    return u;
 	  if (u->s)
-	    flush (u->s);
+	    sflush (u->s);
 	  __gthread_mutex_unlock (&u->lock);
 	}
       u = u->right;
@@ -1693,7 +1338,7 @@
 
       if (u->closed == 0)
 	{
-	  flush (u->s);
+	  sflush (u->s);
 	  __gthread_mutex_lock (&unit_lock);
 	  __gthread_mutex_unlock (&u->lock);
 	  (void) predec_waiting_locked (u);
@@ -1710,40 +1355,6 @@
 }
 
 
-/* stream_at_bof()-- Returns nonzero if the stream is at the beginning
- * of the file. */
-
-int
-stream_at_bof (stream * s)
-{
-  unix_stream *us;
-
-  if (!is_seekable (s))
-    return 0;
-
-  us = (unix_stream *) s;
-
-  return us->logical_offset == 0;
-}
-
-
-/* stream_at_eof()-- Returns nonzero if the stream is at the end
- * of the file. */
-
-int
-stream_at_eof (stream * s)
-{
-  unix_stream *us;
-
-  if (!is_seekable (s))
-    return 0;
-
-  us = (unix_stream *) s;
-
-  return us->logical_offset == us->dirty_offset;
-}
-
-
 /* delete_file()-- Given a unit structure, delete the file associated
  * with the unit.  Returns nonzero if something went wrong. */
 
@@ -1949,16 +1560,15 @@
 gfc_offset
 file_length (stream * s)
 {
-  return ((unix_stream *) s)->file_length;
-}
-
-
-/* file_position()-- Return the current position of the file */
-
-gfc_offset
-file_position (stream *s)
-{
-  return ((unix_stream *) s)->logical_offset;
+  off_t curr, end;
+  if (!is_seekable (s))
+    return -1;
+  curr = stell (s);
+  if (curr == -1)
+    return curr;
+  end = sseek (s, 0, SEEK_END);
+  sseek (s, curr, SEEK_SET);
+  return end;
 }
 
 
@@ -1983,12 +1593,6 @@
 }
 
 
-try
-flush (stream *s)
-{
-  return fd_flush( (unix_stream *) s);
-}
-
 int
 stream_isatty (stream *s)
 {
@@ -2005,12 +1609,6 @@
 #endif
 }
 
-gfc_offset
-stream_offset (stream *s)
-{
-  return (((unix_stream *) s)->logical_offset);
-}
-
 
 /* How files are stored:  This is an operating-system specific issue,
    and therefore belongs here.  There are three cases to consider.
diff -Naur gcc-4.4.0.orig/libgfortran/io/write.c gcc-4.4.0/libgfortran/io/write.c
--- gcc-4.4.0.orig/libgfortran/io/write.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/write.c	2009-05-26 18:21:22.000000000 -0700
@@ -108,7 +108,7 @@
   gfc_char4_t c;
   static const uchar masks[6] =  { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
   static const uchar limits[6] = { 0x80, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
-  size_t nbytes;
+  int nbytes;
   uchar buf[6], d, *q; 
 
   /* Take care of preceding blanks.  */
@@ -597,7 +597,7 @@
     n = -n;
   nsign = sign == S_NONE ? 0 : 1;
   
-  /* conv calls gfc_itoa which sets the negative sign needed
+  /* conv calls itoa which sets the negative sign needed
      by write_integer. The sign '+' or '-' is set below based on sign
      calculated above, so we just point past the sign in the string
      before proceeding to avoid double signs in corner cases.
@@ -707,6 +707,48 @@
 }
 
 
+/* gfc_itoa()-- Integer to decimal conversion.
+   The itoa function is a widespread non-standard extension to standard
+   C, often declared in <stdlib.h>.  Even though the itoa defined here
+   is a static function we take care not to conflict with any prior
+   non-static declaration.  Hence the 'gfc_' prefix, which is normally
+   reserved for functions with external linkage.  */
+
+static const char *
+gfc_itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)
+{
+  int negative;
+  char *p;
+  GFC_UINTEGER_LARGEST t;
+
+  assert (len >= GFC_ITOA_BUF_SIZE);
+
+  if (n == 0)
+    return "0";
+
+  negative = 0;
+  t = n;
+  if (n < 0)
+    {
+      negative = 1;
+      t = -n; /*must use unsigned to protect from overflow*/
+    }
+
+  p = buffer + GFC_ITOA_BUF_SIZE - 1;
+  *p = '\0';
+
+  while (t != 0)
+    {
+      *--p = '0' + (t % 10);
+      t /= 10;
+    }
+
+  if (negative)
+    *--p = '-';
+  return p;
+}
+
+
 void
 write_i (st_parameter_dt *dtp, const fnode *f, const char *p, int len)
 {
@@ -730,7 +772,7 @@
 void
 write_z (st_parameter_dt *dtp, const fnode *f, const char *p, int len)
 {
-  write_int (dtp, f, p, len, xtoa);
+  write_int (dtp, f, p, len, gfc_xtoa);
 }
 
 
@@ -779,8 +821,7 @@
   p = write_block (dtp, len);
   if (p == NULL)
     return;
-
-  if (nspaces > 0)
+  if (nspaces > 0 && len - nspaces >= 0)
     memset (&p[len - nspaces], ' ', nspaces);
 }
 
@@ -1168,7 +1209,7 @@
 	  /* Now seek to this record */
 	  record = record * dtp->u.p.current_unit->recl;
 
-	  if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)
+	  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)
 	    {
 	      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);
 	      return;
@@ -1189,13 +1230,13 @@
   int rep_ctr;
   int num;
   int nml_carry;
-  index_type len;
+  int len;
   index_type obj_size;
   index_type nelem;
-  index_type dim_i;
-  index_type clen;
+  size_t dim_i;
+  size_t clen;
   index_type elem_ctr;
-  index_type obj_name_len;
+  size_t obj_name_len;
   void * p ;
   char cup;
   char * obj_name;
@@ -1225,14 +1266,16 @@
       len = 0;
       if (base)
 	{
-	  len =strlen (base->var_name);
-	  for (dim_i = 0; dim_i < (index_type) strlen (base_name); dim_i++)
+	  len = strlen (base->var_name);
+	  base_name_len = strlen (base_name);
+	  for (dim_i = 0; dim_i < base_name_len; dim_i++)
             {
 	      cup = toupper (base_name[dim_i]);
 	      write_character (dtp, &cup, 1, 1);
             }
 	}
-      for (dim_i =len; dim_i < (index_type) strlen (obj->var_name); dim_i++)
+      clen = strlen (obj->var_name);
+      for (dim_i = len; dim_i < clen; dim_i++)
 	{
 	  cup = toupper (obj->var_name[dim_i]);
 	  write_character (dtp, &cup, 1, 1);
@@ -1271,7 +1314,7 @@
   /* Set the index vector and count the number of elements.  */
 
   nelem = 1;
-  for (dim_i=0; dim_i < obj->var_rank; dim_i++)
+  for (dim_i = 0; dim_i < (size_t) obj->var_rank; dim_i++)
     {
       obj->ls[dim_i].idx = obj->dim[dim_i].lbound;
       nelem = nelem * (obj->dim[dim_i].ubound + 1 - obj->dim[dim_i].lbound);
@@ -1374,7 +1417,7 @@
 	      /* Append the qualifier.  */
 
 	      tot_len = base_name_len + clen;
-	      for (dim_i = 0; dim_i < obj->var_rank; dim_i++)
+	      for (dim_i = 0; dim_i < (size_t) obj->var_rank; dim_i++)
 		{
 		  if (!dim_i)
 		    {
@@ -1383,7 +1426,7 @@
 		    }
 		  sprintf (ext_name + tot_len, "%d", (int) obj->ls[dim_i].idx);
 		  tot_len += strlen (ext_name + tot_len);
-		  ext_name[tot_len] = (dim_i == obj->var_rank - 1) ? ')' : ',';
+		  ext_name[tot_len] = ((int) dim_i == obj->var_rank - 1) ? ')' : ',';
 		  tot_len++;
 		}
 
@@ -1437,11 +1480,11 @@
 obj_loop:
 
     nml_carry = 1;
-    for (dim_i = 0; nml_carry && (dim_i < obj->var_rank); dim_i++)
+    for (dim_i = 0; nml_carry && (dim_i < (size_t) obj->var_rank); dim_i++)
       {
 	obj->ls[dim_i].idx += nml_carry ;
 	nml_carry = 0;
-	if (obj->ls[dim_i].idx  > (ssize_t)obj->dim[dim_i].ubound)
+	if (obj->ls[dim_i].idx  > (index_type) obj->dim[dim_i].ubound)
 	  {
 	    obj->ls[dim_i].idx = obj->dim[dim_i].lbound;
 	    nml_carry = 1;
diff -Naur gcc-4.4.0.orig/libgfortran/io/write_float.def gcc-4.4.0/libgfortran/io/write_float.def
--- gcc-4.4.0.orig/libgfortran/io/write_float.def	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/io/write_float.def	2009-05-26 18:21:22.000000000 -0700
@@ -603,7 +603,7 @@
   int d = f->u.real.d;\
   int w = f->u.real.w;\
   fnode *newf;\
-  GFC_REAL_ ## x exp_d;\
+  GFC_REAL_ ## x rexp_d;\
   int low, high, mid;\
   int ubound, lbound;\
   char *p;\
@@ -612,8 +612,8 @@
   save_scale_factor = dtp->u.p.scale_factor;\
   newf = (fnode *) get_mem (sizeof (fnode));\
 \
-  exp_d = calculate_exp_ ## x (d);\
-  if ((m > 0.0 && m < 0.1 - 0.05 / exp_d) || (m >= exp_d - 0.5 ) ||\
+  rexp_d = calculate_exp_ ## x (-d);\
+  if ((m > 0.0 && m < 0.1 - 0.05 * rexp_d) || (rexp_d * (m + 0.5) >= 1.0) ||\
       ((m == 0.0) && !(compile_options.allow_std & GFC_STD_F2003)))\
     { \
       newf->format = FMT_E;\
@@ -635,8 +635,7 @@
       GFC_REAL_ ## x temp;\
       mid = (low + high) / 2;\
 \
-      temp = (calculate_exp_ ## x (mid) - \
-	      5 * calculate_exp_ ## x (mid - d - 1)) / 10;\
+      temp = (calculate_exp_ ## x (mid - 1) * (1 - 0.5 * rexp_d));\
 \
       if (m < temp)\
         { \
diff -Naur gcc-4.4.0.orig/libgfortran/libgfortran.h gcc-4.4.0/libgfortran/libgfortran.h
--- gcc-4.4.0.orig/libgfortran/libgfortran.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/libgfortran.h	2009-05-26 18:21:22.000000000 -0700
@@ -631,11 +631,8 @@
 extern void sys_exit (int) __attribute__ ((noreturn));
 internal_proto(sys_exit);
 
-extern const char *gfc_itoa (GFC_INTEGER_LARGEST, char *, size_t);
-internal_proto(gfc_itoa);
-
-extern const char *xtoa (GFC_UINTEGER_LARGEST, char *, size_t);
-internal_proto(xtoa);
+extern const char *gfc_xtoa (GFC_UINTEGER_LARGEST, char *, size_t);
+internal_proto(gfc_xtoa);
 
 extern void os_error (const char *) __attribute__ ((noreturn));
 iexport_proto(os_error);
diff -Naur gcc-4.4.0.orig/libgfortran/Makefile.am gcc-4.4.0/libgfortran/Makefile.am
--- gcc-4.4.0.orig/libgfortran/Makefile.am	2008-08-14 11:31:32.000000000 -0700
+++ gcc-4.4.0/libgfortran/Makefile.am	2009-06-03 12:39:09.000000000 -0700
@@ -58,6 +58,7 @@
 intrinsics/abort.c \
 intrinsics/access.c \
 intrinsics/args.c \
+intrinsics/bit_intrinsics.c \
 intrinsics/c99_functions.c \
 intrinsics/chdir.c \
 intrinsics/chmod.c \
diff -Naur gcc-4.4.0.orig/libgfortran/Makefile.in gcc-4.4.0/libgfortran/Makefile.in
--- gcc-4.4.0.orig/libgfortran/Makefile.in	2009-04-21 02:08:08.000000000 -0700
+++ gcc-4.4.0/libgfortran/Makefile.in	2009-06-03 12:39:09.000000000 -0700
@@ -416,9 +416,9 @@
 	io/size_from_kind.c io/transfer.c io/unit.c io/unix.c \
 	io/write.c io/fbuf.c intrinsics/associated.c \
 	intrinsics/abort.c intrinsics/access.c intrinsics/args.c \
-	intrinsics/c99_functions.c intrinsics/chdir.c \
-	intrinsics/chmod.c intrinsics/clock.c intrinsics/cpu_time.c \
-	intrinsics/cshift0.c intrinsics/ctime.c \
+	intrinsics/bit_intrinsics.c intrinsics/c99_functions.c \
+	intrinsics/chdir.c intrinsics/chmod.c intrinsics/clock.c \
+	intrinsics/cpu_time.c intrinsics/cshift0.c intrinsics/ctime.c \
 	intrinsics/date_and_time.c intrinsics/dtime.c intrinsics/env.c \
 	intrinsics/eoshift0.c intrinsics/eoshift2.c \
 	intrinsics/erfc_scaled.c intrinsics/etime.c intrinsics/exit.c \
@@ -711,9 +711,9 @@
 	intrinsics.lo list_read.lo lock.lo open.lo read.lo \
 	size_from_kind.lo transfer.lo unit.lo unix.lo write.lo fbuf.lo
 am__objects_36 = associated.lo abort.lo access.lo args.lo \
-	c99_functions.lo chdir.lo chmod.lo clock.lo cpu_time.lo \
-	cshift0.lo ctime.lo date_and_time.lo dtime.lo env.lo \
-	eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \
+	bit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \
+	cpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \
+	env.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \
 	fnum.lo gerror.lo getcwd.lo getlog.lo getXid.lo hostnm.lo \
 	ierrno.lo ishftc.lo iso_c_generated_procs.lo iso_c_binding.lo \
 	kill.lo link.lo malloc.lo mvbits.lo move_alloc.lo \
@@ -987,6 +987,7 @@
 intrinsics/abort.c \
 intrinsics/access.c \
 intrinsics/args.c \
+intrinsics/bit_intrinsics.c \
 intrinsics/c99_functions.c \
 intrinsics/chdir.c \
 intrinsics/chmod.c \
@@ -1801,6 +1802,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/args.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/associated.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backtrace.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bit_intrinsics.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/c99_functions.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chdir.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chmod.Plo@am__quote@
@@ -5319,6 +5321,13 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o args.lo `test -f 'intrinsics/args.c' || echo '$(srcdir)/'`intrinsics/args.c
 
+bit_intrinsics.lo: intrinsics/bit_intrinsics.c
+@am__fastdepCC_TRUE@	if $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT bit_intrinsics.lo -MD -MP -MF "$(DEPDIR)/bit_intrinsics.Tpo" -c -o bit_intrinsics.lo `test -f 'intrinsics/bit_intrinsics.c' || echo '$(srcdir)/'`intrinsics/bit_intrinsics.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/bit_intrinsics.Tpo" "$(DEPDIR)/bit_intrinsics.Plo"; else rm -f "$(DEPDIR)/bit_intrinsics.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='intrinsics/bit_intrinsics.c' object='bit_intrinsics.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bit_intrinsics.lo `test -f 'intrinsics/bit_intrinsics.c' || echo '$(srcdir)/'`intrinsics/bit_intrinsics.c
+
 c99_functions.lo: intrinsics/c99_functions.c
 @am__fastdepCC_TRUE@	if $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT c99_functions.lo -MD -MP -MF "$(DEPDIR)/c99_functions.Tpo" -c -o c99_functions.lo `test -f 'intrinsics/c99_functions.c' || echo '$(srcdir)/'`intrinsics/c99_functions.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/c99_functions.Tpo" "$(DEPDIR)/c99_functions.Plo"; else rm -f "$(DEPDIR)/c99_functions.Tpo"; exit 1; fi
diff -Naur gcc-4.4.0.orig/libgfortran/runtime/backtrace.c gcc-4.4.0/libgfortran/runtime/backtrace.c
--- gcc-4.4.0.orig/libgfortran/runtime/backtrace.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/runtime/backtrace.c	2009-05-26 18:21:22.000000000 -0700
@@ -147,7 +147,7 @@
 
     /* Write the list of addresses in hexadecimal format.  */
     for (i = 0; i < depth; i++)
-      addr[i] = xtoa ((GFC_UINTEGER_LARGEST) (intptr_t) trace[i], addr_buf[i],
+      addr[i] = gfc_xtoa ((GFC_UINTEGER_LARGEST) (intptr_t) trace[i], addr_buf[i],
 		      sizeof (addr_buf[i]));
 
     /* Don't output an error message if something goes wrong, we'll simply
diff -Naur gcc-4.4.0.orig/libgfortran/runtime/error.c gcc-4.4.0/libgfortran/runtime/error.c
--- gcc-4.4.0.orig/libgfortran/runtime/error.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgfortran/runtime/error.c	2009-05-26 18:21:22.000000000 -0700
@@ -112,47 +112,10 @@
  * Other error returns are reserved for the STOP statement with a numeric code.
  */
 
-/* gfc_itoa()-- Integer to decimal conversion. */
+/* gfc_xtoa()-- Integer to hexadecimal conversion.  */
 
 const char *
-gfc_itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)
-{
-  int negative;
-  char *p;
-  GFC_UINTEGER_LARGEST t;
-
-  assert (len >= GFC_ITOA_BUF_SIZE);
-
-  if (n == 0)
-    return "0";
-
-  negative = 0;
-  t = n;
-  if (n < 0)
-    {
-      negative = 1;
-      t = -n; /*must use unsigned to protect from overflow*/
-    }
-
-  p = buffer + GFC_ITOA_BUF_SIZE - 1;
-  *p = '\0';
-
-  while (t != 0)
-    {
-      *--p = '0' + (t % 10);
-      t /= 10;
-    }
-
-  if (negative)
-    *--p = '-';
-  return p;
-}
-
-
-/* xtoa()-- Integer to hexadecimal conversion.  */
-
-const char *
-xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)
+gfc_xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)
 {
   int digit;
   char *p;
diff -Naur gcc-4.4.0.orig/libgomp/team.c gcc-4.4.0/libgomp/team.c
--- gcc-4.4.0.orig/libgomp/team.c	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libgomp/team.c	2009-05-20 13:55:25.000000000 -0700
@@ -125,6 +125,7 @@
       while (local_fn);
     }
 
+  gomp_sem_destroy (&thr->release);
   return NULL;
 }
 
@@ -201,6 +202,7 @@
   struct gomp_thread_pool *pool
     = (struct gomp_thread_pool *) thread_pool;
   gomp_barrier_wait_last (&pool->threads_dock);
+  gomp_sem_destroy (&gomp_thread ()->release);
   pthread_exit (NULL);
 }
 
diff -Naur gcc-4.4.0.orig/libjava/configure gcc-4.4.0/libjava/configure
--- gcc-4.4.0.orig/libjava/configure	2009-04-21 02:08:08.000000000 -0700
+++ gcc-4.4.0/libjava/configure	2009-04-26 07:24:38.000000000 -0700
@@ -19141,6 +19141,8 @@
 
 
 # Likewise for natVMSecureRandom.cc
+test -d gnu/java/security || mkdir gnu/java/security
+test -d gnu/java/security/jce || mkdir gnu/java/security/jce
 test -d gnu/java/security/jce/prng || mkdir gnu/java/security/jce/prng
           ac_config_links="$ac_config_links gnu/java/security/jce/prng/natVMSecureRandom.cc:gnu/java/security/jce/prng/natVMSecureRandom${FILE-${PLATFORM}}.cc"
 
@@ -28310,7 +28312,7 @@
 
 fi
 
-                                                                                                              ac_config_files="$ac_config_files Makefile libgcj.pc libgcj.spec libgcj-test.spec gcj/Makefile include/Makefile testsuite/Makefile contrib/aotcompile.py contrib/aot-compile contrib/aot-compile-rpm contrib/rebuild-gcj-db"
+                                                                                                                        ac_config_files="$ac_config_files Makefile libgcj.pc libgcj.spec libgcj-test.spec gcj/Makefile include/Makefile testsuite/Makefile contrib/aotcompile.py contrib/aot-compile contrib/aot-compile-rpm contrib/generate-cacerts.pl contrib/rebuild-gcj-db"
 
 
 if test ${multilib} = yes; then
@@ -29560,6 +29562,7 @@
   "contrib/aotcompile.py" ) CONFIG_FILES="$CONFIG_FILES contrib/aotcompile.py" ;;
   "contrib/aot-compile" ) CONFIG_FILES="$CONFIG_FILES contrib/aot-compile" ;;
   "contrib/aot-compile-rpm" ) CONFIG_FILES="$CONFIG_FILES contrib/aot-compile-rpm" ;;
+  "contrib/generate-cacerts.pl" ) CONFIG_FILES="$CONFIG_FILES contrib/generate-cacerts.pl" ;;
   "contrib/rebuild-gcj-db" ) CONFIG_FILES="$CONFIG_FILES contrib/rebuild-gcj-db" ;;
   "scripts/jar" ) CONFIG_FILES="$CONFIG_FILES scripts/jar" ;;
   "include/platform.h" ) CONFIG_LINKS="$CONFIG_LINKS include/platform.h:include/$PLATFORMH" ;;
diff -Naur gcc-4.4.0.orig/libjava/configure.ac gcc-4.4.0/libjava/configure.ac
--- gcc-4.4.0.orig/libjava/configure.ac	2009-04-09 14:54:28.000000000 -0700
+++ gcc-4.4.0/libjava/configure.ac	2009-04-26 07:24:38.000000000 -0700
@@ -834,6 +834,8 @@
 AC_CONFIG_LINKS(gnu/java/nio/channels/natFileChannelImpl.cc:gnu/java/nio/channels/natFileChannel${FILE-${PLATFORM}}.cc)
 
 # Likewise for natVMSecureRandom.cc
+test -d gnu/java/security || mkdir gnu/java/security
+test -d gnu/java/security/jce || mkdir gnu/java/security/jce
 test -d gnu/java/security/jce/prng || mkdir gnu/java/security/jce/prng
 AC_CONFIG_LINKS(gnu/java/security/jce/prng/natVMSecureRandom.cc:gnu/java/security/jce/prng/natVMSecureRandom${FILE-${PLATFORM}}.cc)
 
@@ -1921,6 +1923,7 @@
 contrib/aotcompile.py
 contrib/aot-compile
 contrib/aot-compile-rpm
+contrib/generate-cacerts.pl
 contrib/rebuild-gcj-db
 ])
 
diff -Naur gcc-4.4.0.orig/libjava/contrib/aotcompile.py.in gcc-4.4.0/libjava/contrib/aotcompile.py.in
--- gcc-4.4.0.orig/libjava/contrib/aotcompile.py.in	2008-07-02 06:17:54.000000000 -0700
+++ gcc-4.4.0/libjava/contrib/aotcompile.py.in	2009-04-26 07:24:38.000000000 -0700
@@ -177,11 +177,14 @@
     
     def __init__(self, path):
         self.path, self.classes, self.blocks = path, {}, None
+        self.classnames = {}
 
-    def addClass(self, bytes):
+    def addClass(self, bytes, name):
         """Subclasses call this from their __init__ method for
         every class they find."""
-        self.classes[md5.new(bytes).digest()] = bytes
+        digest = md5.new(bytes).digest()
+        self.classes[digest] = bytes
+        self.classnames[digest] = name
 
     def __makeBlocks(self):
         """Split self.classes into chunks that can be compiled to
@@ -200,7 +203,12 @@
         if the job is subsetted."""
         names = {}
         for hash, bytes in self.classes.items():
-            name = classname(bytes)
+            try:
+                name = classname(bytes)
+            except:
+                warn("job %s: class %s malformed or not a valid class file" \
+                     % (self.path, self.classnames[hash]))
+                raise
             if not names.has_key(name):
                 names[name] = []
             names[name].append(hash)
@@ -302,7 +310,7 @@
             if bytes.startswith(ZIPMAGIC):
                 self._walk(zipfile.ZipFile(StringIO.StringIO(bytes)))
             elif bytes.startswith(CLASSMAGIC):
-                self.addClass(bytes)
+                self.addClass(bytes, name)
 
 class DirJob(Job):
     """A Job whose origin was a directory of classfiles."""
@@ -319,7 +327,7 @@
             fp = open(path, "r")
             magic = fp.read(4)
             if magic == CLASSMAGIC:
-                self.addClass(magic + fp.read())
+                self.addClass(magic + fp.read(), name)
     
 def weed_jobs(jobs):
     """Remove any jarfiles that are completely contained within
diff -Naur gcc-4.4.0.orig/libjava/contrib/generate-cacerts.pl.in gcc-4.4.0/libjava/contrib/generate-cacerts.pl.in
--- gcc-4.4.0.orig/libjava/contrib/generate-cacerts.pl.in	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libjava/contrib/generate-cacerts.pl.in	2009-04-26 07:24:38.000000000 -0700
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# Copyright (C) 2007, 2009 Free Software Foundation
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# generate-cacerts.pl generates a gkeytool keystore named 'cacerts'
+# from OpenSSL's certificate bundle.
+
+# First extract each of OpenSSL's bundled certificates into its own
+# aliased filename.
+chomp($file=@ARGV[0]);
+$file = "/etc/pki/tls/cert.pem" unless $file ne "";
+open(CERTS, $file);
+@certs = <CERTS>;
+close(CERTS);
+
+$pem_file_number = 0;
+$writing_cert = 0;
+foreach $cert (@certs)
+{
+	 if ($cert eq "-----BEGIN CERTIFICATE-----\n")
+	 {
+		  if ($writing_cert != 0)
+		  {
+				die "$file is malformed.";
+		  }
+		  $pem_file_number++;
+		  # Numbering each file guarantees that cert aliases will be
+		  # unique.
+		  $pem_file_name = "$pem_file_number$cert_alias.pem";
+		  $writing_cert = 1;
+		  open(PEM, ">$pem_file_name");
+		  print PEM $cert;
+	 }
+	 elsif ($cert eq "-----END CERTIFICATE-----\n")
+	 {
+		  $writing_cert = 0;
+		  print PEM $cert;
+		  close(PEM);
+	 }
+	 elsif ($cert =~ /Issuer: /)
+	 {
+		  # Generate an alias using the OU and CN attributes of the
+		  # Issuer field if both are present, otherwise use only the CN
+		  # attribute.  The Issuer field must have either the OU or the
+		  # CN attribute.
+		  $_ = $cert;
+		  if ($cert =~ /OU=/)
+		  {
+				s/Issuer:.*?OU=//;
+				# Remove other occurrences of OU=.
+				s/OU=.*CN=//;
+				# Remove CN= if there were not other occurrences of OU=.
+				s/CN=//;
+		  }
+		  elsif ($cert =~ /CN=/)
+		  {
+				s/Issuer:.*CN=//;
+		  }
+		  s/\W//g;
+		  tr/A-Z/a-z/;
+		  $cert_alias = $_
+	 }
+	 else
+	 {
+		  if ($writing_cert == 1)
+		  {
+				print PEM $cert;
+		  }
+	 }
+}
+
+# Check that the correct number of .pem files were produced.
+@pem_files = <*.pem>;
+if (@pem_files != $pem_file_number)
+{
+	 die "Number of .pem files produced does not match".
+		  " number of certs read from $file.";
+}
+
+# Now store each cert in the 'cacerts' file using gkeytool.
+$certs_written_count = 0;
+foreach $pem_file (@pem_files)
+{
+	 system "yes | gkeytool@gcc_suffix@ -import -alias `basename $pem_file .pem`".
+		  " -keystore cacerts -storepass '' -file $pem_file".
+		  " 2>&1 >/dev/null";
+	 unlink($pem_file);
+	 $certs_written_count++;
+}
+
+# Check that the correct number of certs were added to the keystore.
+if ($certs_written_count != $pem_file_number)
+{
+	 die "Number of certs added to keystore does not match".
+		  " number of certs read from $file.";
+}
diff -Naur gcc-4.4.0.orig/libjava/Makefile.am gcc-4.4.0/libjava/Makefile.am
--- gcc-4.4.0.orig/libjava/Makefile.am	2009-03-03 09:03:51.000000000 -0800
+++ gcc-4.4.0/libjava/Makefile.am	2009-05-11 01:21:39.000000000 -0700
@@ -305,8 +305,15 @@
 ## compiled.
 EXTRA_libgcj_la_SOURCES = java/lang/Object.java
 
+# We compile libgcj_tools with -findirect-dispatch so that they can
+# depend on external classes: in particular, gjdoc uses antlr.  In
+# addition, -fno-bootstrap-classes ensures that the tools are loaded
+# by the system class loader rather than the bootstrap class loader:
+# only core library classes should be loaded by the bootstrap loader.
 libgcj_tools_la_SOURCES = classpath/tools/tools.zip
-libgcj_tools_la_GCJFLAGS = $(AM_GCJFLAGS) -findirect-dispatch -fno-indirect-classes  -fsource-filename=$(here)/classpath/tools/all-classes.lst
+libgcj_tools_la_GCJFLAGS = $(AM_GCJFLAGS) -findirect-dispatch \
+ -fno-bootstrap-classes -fno-indirect-classes \
+ -fsource-filename=$(here)/classpath/tools/all-classes.lst
 libgcj_tools_la_LDFLAGS = -rpath $(toolexeclibdir) \
  -version-info `grep -v '^\#' $(srcdir)/libtool-version` \
  $(LIBGCJ_LD_SYMBOLIC_FUNCTIONS)
@@ -667,7 +674,7 @@
 	ln -sf $$RELATIVE/libgcj-tools-$(gcc_version).jar \
 	  $(DESTDIR)$(SDK_LIB_DIR)/tools.jar; \
 	for headername in jawt jni; do \
-	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/gcj \
+	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/`echo gcj | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` \
 	    -print-file-name=include/$$headername.h)); \
 	  RELATIVE=$$(relative $$DIRECTORY \
 	    $(DESTDIR)$(SDK_INCLUDE_DIR)); \
@@ -675,7 +682,7 @@
 	    $(DESTDIR)$(SDK_INCLUDE_DIR)/$$headername.h; \
 	done; \
 	for headername in jawt_md jni_md; do \
-	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/gcj \
+	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/`echo gcj | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` \
 	    -print-file-name=include/$$headername.h)); \
 	  RELATIVE=$$(relative $$DIRECTORY \
 	    $(DESTDIR)$(SDK_INCLUDE_DIR)/linux); \
diff -Naur gcc-4.4.0.orig/libjava/Makefile.in gcc-4.4.0/libjava/Makefile.in
--- gcc-4.4.0.orig/libjava/Makefile.in	2009-04-21 02:08:08.000000000 -0700
+++ gcc-4.4.0/libjava/Makefile.in	2009-05-11 01:21:39.000000000 -0700
@@ -72,6 +72,7 @@
 	$(top_srcdir)/contrib/aot-compile-rpm.in \
 	$(top_srcdir)/contrib/aot-compile.in \
 	$(top_srcdir)/contrib/aotcompile.py.in \
+	$(top_srcdir)/contrib/generate-cacerts.pl.in \
 	$(top_srcdir)/contrib/rebuild-gcj-db.in \
 	$(top_srcdir)/scripts/jar.in COPYING ChangeLog NEWS THANKS
 @MAINTAINER_MODE_TRUE@@NATIVE_TRUE@am__append_19 = gen-from-JIS
@@ -111,9 +112,10 @@
 	$(top_builddir)/gcj/libgcj-config.h
 CONFIG_CLEAN_FILES = libgcj.pc libgcj.spec libgcj-test.spec \
 	contrib/aotcompile.py contrib/aot-compile \
-	contrib/aot-compile-rpm contrib/rebuild-gcj-db scripts/jar \
-	java/io/natFile.cc java/lang/natConcreteProcess.cc \
-	java/net/natVMInetAddress.cc java/net/natVMNetworkInterface.cc \
+	contrib/aot-compile-rpm contrib/generate-cacerts.pl \
+	contrib/rebuild-gcj-db scripts/jar java/io/natFile.cc \
+	java/lang/natConcreteProcess.cc java/net/natVMInetAddress.cc \
+	java/net/natVMNetworkInterface.cc \
 	gnu/java/net/natPlainSocketImpl.cc \
 	gnu/java/net/natPlainDatagramSocketImpl.cc \
 	gnu/java/nio/natVMPipe.cc gnu/java/nio/natVMSelector.cc \
@@ -1028,8 +1030,17 @@
 	$(libgcj_la_LIBADD) $(am__append_18)
 libgcj_la_LINK = $(LIBLINK)
 EXTRA_libgcj_la_SOURCES = java/lang/Object.java
+
+# We compile libgcj_tools with -findirect-dispatch so that they can
+# depend on external classes: in particular, gjdoc uses antlr.  In
+# addition, -fno-bootstrap-classes ensures that the tools are loaded
+# by the system class loader rather than the bootstrap class loader:
+# only core library classes should be loaded by the bootstrap loader.
 libgcj_tools_la_SOURCES = classpath/tools/tools.zip
-libgcj_tools_la_GCJFLAGS = $(AM_GCJFLAGS) -findirect-dispatch -fno-indirect-classes  -fsource-filename=$(here)/classpath/tools/all-classes.lst
+libgcj_tools_la_GCJFLAGS = $(AM_GCJFLAGS) -findirect-dispatch \
+ -fno-bootstrap-classes -fno-indirect-classes \
+ -fsource-filename=$(here)/classpath/tools/all-classes.lst
+
 libgcj_tools_la_LDFLAGS = -rpath $(toolexeclibdir) \
  -version-info `grep -v '^\#' $(srcdir)/libtool-version` \
  $(LIBGCJ_LD_SYMBOLIC_FUNCTIONS)
@@ -8686,6 +8697,8 @@
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 contrib/aot-compile-rpm: $(top_builddir)/config.status $(top_srcdir)/contrib/aot-compile-rpm.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
+contrib/generate-cacerts.pl: $(top_builddir)/config.status $(top_srcdir)/contrib/generate-cacerts.pl.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
 contrib/rebuild-gcj-db: $(top_builddir)/config.status $(top_srcdir)/contrib/rebuild-gcj-db.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 scripts/jar: $(top_builddir)/config.status $(top_srcdir)/scripts/jar.in
@@ -12514,7 +12527,7 @@
 @CREATE_JAVA_HOME_TRUE@	ln -sf $$RELATIVE/libgcj-tools-$(gcc_version).jar \
 @CREATE_JAVA_HOME_TRUE@	  $(DESTDIR)$(SDK_LIB_DIR)/tools.jar; \
 @CREATE_JAVA_HOME_TRUE@	for headername in jawt jni; do \
-@CREATE_JAVA_HOME_TRUE@	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/gcj \
+@CREATE_JAVA_HOME_TRUE@	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/`echo gcj | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` \
 @CREATE_JAVA_HOME_TRUE@	    -print-file-name=include/$$headername.h)); \
 @CREATE_JAVA_HOME_TRUE@	  RELATIVE=$$(relative $$DIRECTORY \
 @CREATE_JAVA_HOME_TRUE@	    $(DESTDIR)$(SDK_INCLUDE_DIR)); \
@@ -12522,7 +12535,7 @@
 @CREATE_JAVA_HOME_TRUE@	    $(DESTDIR)$(SDK_INCLUDE_DIR)/$$headername.h; \
 @CREATE_JAVA_HOME_TRUE@	done; \
 @CREATE_JAVA_HOME_TRUE@	for headername in jawt_md jni_md; do \
-@CREATE_JAVA_HOME_TRUE@	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/gcj \
+@CREATE_JAVA_HOME_TRUE@	  DIRECTORY=$$(dirname $$($(DESTDIR)$(bindir)/`echo gcj | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` \
 @CREATE_JAVA_HOME_TRUE@	    -print-file-name=include/$$headername.h)); \
 @CREATE_JAVA_HOME_TRUE@	  RELATIVE=$$(relative $$DIRECTORY \
 @CREATE_JAVA_HOME_TRUE@	    $(DESTDIR)$(SDK_INCLUDE_DIR)/linux); \
diff -Naur gcc-4.4.0.orig/libstdc++-v3/config/abi/pre/gnu.ver gcc-4.4.0/libstdc++-v3/config/abi/pre/gnu.ver
--- gcc-4.4.0.orig/libstdc++-v3/config/abi/pre/gnu.ver	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/config/abi/pre/gnu.ver	2009-05-05 14:44:27.000000000 -0700
@@ -958,6 +958,14 @@
 
 } GLIBCXX_3.4.10;
 
+GLIBCXX_3.4.12 {
+
+    # mutex
+    _ZSt27__set_once_functor_lock_ptrPSt11unique_lockISt5mutexE;
+    _ZSt16__get_once_mutexv;
+
+} GLIBCXX_3.4.11;
+
 # Symbols in the support library (libsupc++) have their own tag.
 CXXABI_1.3 {
 
diff -Naur gcc-4.4.0.orig/libstdc++-v3/configure gcc-4.4.0/libstdc++-v3/configure
--- gcc-4.4.0.orig/libstdc++-v3/configure	2009-03-01 09:49:31.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/configure	2009-05-07 03:23:06.000000000 -0700
@@ -1567,7 +1567,7 @@
 ### am handles this now?  ORIGINAL_LD_FOR_MULTILIBS=$LD
 
 # For libtool versioning info, format is CURRENT:REVISION:AGE
-libtool_VERSION=6:11:0
+libtool_VERSION=6:12:0
 
 
 # Find the rest of the source tree framework.
diff -Naur gcc-4.4.0.orig/libstdc++-v3/configure.ac gcc-4.4.0/libstdc++-v3/configure.ac
--- gcc-4.4.0.orig/libstdc++-v3/configure.ac	2009-01-15 12:02:11.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/configure.ac	2009-05-07 03:23:06.000000000 -0700
@@ -12,7 +12,7 @@
 ### am handles this now?  ORIGINAL_LD_FOR_MULTILIBS=$LD
 
 # For libtool versioning info, format is CURRENT:REVISION:AGE
-libtool_VERSION=6:11:0
+libtool_VERSION=6:12:0
 AC_SUBST(libtool_VERSION)
 
 # Find the rest of the source tree framework.
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/authors.xml gcc-4.4.0/libstdc++-v3/doc/xml/authors.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/authors.xml	2008-04-10 15:14:17.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/authors.xml	2009-04-29 12:37:30.000000000 -0700
@@ -21,6 +21,16 @@
 -->
 
   <author>
+    <firstname></firstname>
+    <surname></surname>
+
+    <authorblurb>
+      <para>
+      </para>
+    </authorblurb>
+  </author>
+
+  <author>
     <firstname>Paolo</firstname>
     <surname>Carlini</surname>
 
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/faq.xml gcc-4.4.0/libstdc++-v3/doc/xml/faq.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/faq.xml	2009-03-15 17:09:04.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/faq.xml	2009-04-29 12:37:30.000000000 -0700
@@ -692,9 +692,9 @@
     </para>
     <para>    
     Long answer: See the implementation status pages for 
-    <link linkend="manual.intro.status.standard.1998">C++98</link>,
-    <link linkend="manual.intro.status.standard.tr1">TR1</link>, and 
-    <link linkend="manual.intro.status.standard.200x">C++0x</link>.
+    <link linkend="status.iso.1998">C++98</link>,
+    <link linkend="status.iso.tr1">TR1</link>, and 
+    <link linkend="status.iso.200x">C++0x</link>.
     </para> 
   </answer>
 </qandaentry>
@@ -1123,7 +1123,7 @@
     </para>
     <para>
     The implementation status of TR1 in libstdc++ can be tracked <link
-    linkend="manual.intro.status.standard.tr1">on the TR1 status
+    linkend="status.iso.tr1">on the TR1 status
     page</link>.
     </para>
   </answer>
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/abi.xml gcc-4.4.0/libstdc++-v3/doc/xml/manual/abi.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/abi.xml	2008-09-09 15:42:23.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/manual/abi.xml	2009-04-29 12:37:30.000000000 -0700
@@ -207,6 +207,7 @@
     <listitem><para>gcc-4.1.0: GCC_4.1.0</para></listitem>
     <listitem><para>gcc-4.2.0: GCC_4.2.0</para></listitem>
     <listitem><para>gcc-4.3.0: GCC_4.3.0</para></listitem>
+    <listitem><para>gcc-4.4.0: GCC_4.4.0</para></listitem>
     </itemizedlist>
     </listitem>
 
@@ -264,6 +265,8 @@
     <listitem><para>gcc-4.3.0: libstdc++.so.6.0.10</para></listitem>
     <listitem><para>gcc-4.3.1: libstdc++.so.6.0.10</para></listitem>
     <listitem><para>gcc-4.3.2: libstdc++.so.6.0.10</para></listitem>
+    <listitem><para>gcc-4.3.3: libstdc++.so.6.0.10</para></listitem>
+    <listitem><para>gcc-4.4.0: libstdc++.so.6.0.11</para></listitem>
     </itemizedlist>
     <para>
       Note 1: Error should be libstdc++.so.3.0.3.
@@ -320,6 +323,7 @@
     <listitem><para>gcc-4.1.1: GLIBCXX_3.4.8</para></listitem>
     <listitem><para>gcc-4.2.0: GLIBCXX_3.4.9</para></listitem>
     <listitem><para>gcc-4.3.0: GLIBCXX_3.4.10, CXXABI_1.3.2</para></listitem>
+    <listitem><para>gcc-4.4.0: GLIBCXX_3.4.11, CXXABI_1.3.3</para></listitem>
     </itemizedlist>
     </listitem>
   
@@ -426,6 +430,8 @@
     <listitem><para>gcc-4.3.0: 20080306</para></listitem>
     <listitem><para>gcc-4.3.1: 20080606</para></listitem>
     <listitem><para>gcc-4.3.2: 20080827</para></listitem>
+    <listitem><para>gcc-4.3.3: 20090124</para></listitem>
+    <listitem><para>gcc-4.4.0: 20090421</para></listitem>
     </itemizedlist>
     <para></para>
     </listitem>
@@ -524,7 +530,8 @@
     <listitem><para>gcc-4.2.4: include/c++/4.2.4</para></listitem>
     <listitem><para>gcc-4.3.0: include/c++/4.3.0</para></listitem>
     <listitem><para>gcc-4.3.1: include/c++/4.3.1</para></listitem>
-    <listitem><para>gcc-4.3.2: include/c++/4.3.2</para></listitem>
+    <listitem><para>gcc-4.3.3: include/c++/4.3.3</para></listitem>
+    <listitem><para>gcc-4.4.0: include/c++/4.4.0</para></listitem>
     </itemizedlist>
     <para></para>
     </listitem>
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/appendix_contributing.xml gcc-4.4.0/libstdc++-v3/doc/xml/manual/appendix_contributing.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/appendix_contributing.xml	2009-04-15 20:33:20.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/manual/appendix_contributing.xml	2009-04-29 12:37:30.000000000 -0700
@@ -1102,7 +1102,7 @@
 	For validating the XML document, you'll need
 	something like <command>xmllint</command> and access to the
 	DocBook DTD. These are provided
-	by a vendor package like <filename>lixml2</filename>.
+	by a vendor package like <filename>libxml2</filename>.
       </para>
 
       <para>
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/intro.xml gcc-4.4.0/libstdc++-v3/doc/xml/manual/intro.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/intro.xml	2009-04-15 20:33:20.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/manual/intro.xml	2009-04-29 12:37:30.000000000 -0700
@@ -27,7 +27,7 @@
   <title>Status</title>
 
   <!-- Section 01 : Implementation Status -->
-  <sect1 id="manual.intro.status.standard" xreflabel="Status">
+  <sect1 id="manual.intro.status.iso" xreflabel="Status">
     <title>Implementation Status</title>
 
     <!-- Section 01.1 : Status C++ 1998 -->
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/status_cxx1998.xml gcc-4.4.0/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/status_cxx1998.xml	2009-04-15 20:33:20.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/manual/status_cxx1998.xml	2009-04-29 12:37:30.000000000 -0700
@@ -1,4 +1,4 @@
-<sect2 id="manual.intro.status.standard.1998" xreflabel="ISO C++ 1998">
+<sect2 id="status.iso.1998" xreflabel="ISO C++ 1998">
 <?dbhtml filename="status_iso_cxx1998.html"?>
  
 <sect2info>
@@ -14,7 +14,7 @@
 
 <title>C++ 1998/2003</title>
 
-<sect3 id="standard.1998.status" xreflabel="Implementation Status">
+<sect3 id="iso.1998.status" xreflabel="Implementation Status">
   <title>Implementation Status</title>
 
 <para>
@@ -1032,7 +1032,7 @@
 </table>
 </sect3>
 
-<sect3 id="standard.1998.specific" xreflabel="Implementation Specific">
+<sect3 id="iso.1998.specific" xreflabel="Implementation Specific">
   <title>Implementation Specific Behavior</title>
 
    <para>
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/status_cxx200x.xml gcc-4.4.0/libstdc++-v3/doc/xml/manual/status_cxx200x.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/status_cxx200x.xml	2009-04-15 20:33:20.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/manual/status_cxx200x.xml	2009-04-29 12:37:30.000000000 -0700
@@ -1,4 +1,4 @@
-<sect2 id="manual.intro.status.standard.200x" xreflabel="Status C++ 200x">
+<sect2 id="status.iso.200x" xreflabel="Status C++ 200x">
 <?dbhtml filename="status_iso_cxx200x.html"?>
  
 <sect2info>
diff -Naur gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml gcc-4.4.0/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml
--- gcc-4.4.0.orig/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml	2009-04-15 20:33:20.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/doc/xml/manual/status_cxxtr1.xml	2009-04-29 12:37:30.000000000 -0700
@@ -1,4 +1,4 @@
-<sect2 id="manual.intro.status.standard.tr1" xreflabel="Status C++ TR1">
+<sect2 id="status.iso.tr1" xreflabel="Status C++ TR1">
 <?dbhtml filename="status_iso_cxxtr1.html"?>
  
 <sect2info>
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/bits/locale_facets.tcc gcc-4.4.0/libstdc++-v3/include/bits/locale_facets.tcc
--- gcc-4.4.0.orig/libstdc++-v3/include/bits/locale_facets.tcc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/bits/locale_facets.tcc	2009-04-21 13:26:46.000000000 -0700
@@ -379,8 +379,7 @@
 	if (!__testeof)
 	  {
 	    __c = *__beg;
-	    if (__gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
-	      __negative = __c == __lit[__num_base::_S_iminus];
+	    __negative = __c == __lit[__num_base::_S_iminus];
 	    if ((__negative || __c == __lit[__num_base::_S_iplus])
 		&& !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
 		&& !(__c == __lc->_M_decimal_point))
@@ -449,7 +448,8 @@
 	  __found_grouping.reserve(32);
 	bool __testfail = false;
 	bool __testoverflow = false;
-	const __unsigned_type __max = __negative
+	const __unsigned_type __max =
+	  (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
 	  ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
 	  : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 	const __unsigned_type __smax = __max / __base;
@@ -552,7 +552,8 @@
 	  }
 	else if (__testoverflow)
 	  {
-	    if (__negative)
+	    if (__negative
+		&& __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
 	      __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
 	    else
 	      __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/bits/stl_construct.h gcc-4.4.0/libstdc++-v3/include/bits/stl_construct.h
--- gcc-4.4.0.orig/libstdc++-v3/include/bits/stl_construct.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/bits/stl_construct.h	2009-05-18 16:16:48.000000000 -0700
@@ -82,6 +82,26 @@
     _Destroy(_Tp* __pointer)
     { __pointer->~_Tp(); }
 
+  template<bool>
+    struct _Destroy_aux
+    {
+      template<typename _ForwardIterator>
+        static void
+        __destroy(_ForwardIterator __first, _ForwardIterator __last)
+	{
+	  for (; __first != __last; ++__first)
+	    std::_Destroy(&*__first);
+	}
+    };
+
+  template<>
+    struct _Destroy_aux<true>
+    {
+      template<typename _ForwardIterator>
+        static void
+        __destroy(_ForwardIterator, _ForwardIterator) { }
+    };
+
   /**
    * Destroy a range of objects.  If the value_type of the object has
    * a trivial destructor, the compiler should optimize all of this
@@ -93,9 +113,8 @@
     {
       typedef typename iterator_traits<_ForwardIterator>::value_type
                        _Value_type;
-      if (!__has_trivial_destructor(_Value_type))
-	for (; __first != __last; ++__first)
-	  std::_Destroy(&*__first);
+      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
+	__destroy(__first, __last);
     }
 
   /**
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/ext/memory gcc-4.4.0/libstdc++-v3/include/ext/memory
--- gcc-4.4.0.orig/libstdc++-v3/include/ext/memory	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/ext/memory	2009-06-02 02:06:45.000000000 -0700
@@ -102,9 +102,9 @@
   template<typename _InputIter, typename _Size, typename _ForwardIter>
     inline pair<_InputIter, _ForwardIter>
     __uninitialized_copy_n(_InputIter __first, _Size __count,
-			 _ForwardIter __result)
-    { return __uninitialized_copy_n(__first, __count, __result,
-				    __iterator_category(__first)); }
+			   _ForwardIter __result)
+    { return __gnu_cxx::__uninitialized_copy_n(__first, __count, __result,
+					       __iterator_category(__first)); }
 
   /**
    *  @brief Copies the range [first,last) into result.
@@ -120,8 +120,8 @@
     inline pair<_InputIter, _ForwardIter>
     uninitialized_copy_n(_InputIter __first, _Size __count,
 			 _ForwardIter __result)
-    { return __uninitialized_copy_n(__first, __count, __result,
-				    __iterator_category(__first)); }
+    { return __gnu_cxx::__uninitialized_copy_n(__first, __count, __result,
+					       __iterator_category(__first)); }
 
 
   // An alternative version of uninitialized_copy_n that constructs
@@ -154,7 +154,7 @@
 			     _ForwardIter __result,
 			     std::allocator<_Tp>)
     {
-      return uninitialized_copy_n(__first, __count, __result);
+      return __gnu_cxx::uninitialized_copy_n(__first, __count, __result);
     }
 
   /**
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/Makefile.am gcc-4.4.0/libstdc++-v3/include/Makefile.am
--- gcc-4.4.0.orig/libstdc++-v3/include/Makefile.am	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/Makefile.am	2009-05-12 17:24:16.000000000 -0700
@@ -850,7 +850,7 @@
 	${pch1_output_builddir} ${pch2_output_builddir} ${pch3_output_builddir}
 pch_output_anchors = \
 	${pch1_output_anchor} ${pch2_output_anchor} ${pch3_output_anchor}
-PCHFLAGS=-Winvalid-pch -x c++-header $(CXXFLAGS)
+PCHFLAGS=-x c++-header $(CXXFLAGS)
 if GLIBCXX_BUILD_PCH
 pch_build = ${pch_output}
 else
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/Makefile.in gcc-4.4.0/libstdc++-v3/include/Makefile.in
--- gcc-4.4.0.orig/libstdc++-v3/include/Makefile.in	2009-01-15 12:02:11.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/include/Makefile.in	2009-05-12 17:24:16.000000000 -0700
@@ -1096,7 +1096,7 @@
 pch_output_anchors = \
 	${pch1_output_anchor} ${pch2_output_anchor} ${pch3_output_anchor}
 
-PCHFLAGS = -Winvalid-pch -x c++-header $(CXXFLAGS)
+PCHFLAGS = -x c++-header $(CXXFLAGS)
 @GLIBCXX_BUILD_PCH_FALSE@pch_build = 
 @GLIBCXX_BUILD_PCH_TRUE@pch_build = ${pch_output}
 
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/parallel/algo.h gcc-4.4.0/libstdc++-v3/include/parallel/algo.h
--- gcc-4.4.0.orig/libstdc++-v3/include/parallel/algo.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/parallel/algo.h	2009-05-12 07:57:35.000000000 -0700
@@ -149,8 +149,8 @@
 
       if (_GLIBCXX_PARALLEL_CONDITION(true))
         {
-          binder2nd<__gnu_parallel::equal_to<value_type, T> >
-            comp(__gnu_parallel::equal_to<value_type, T>(), val);
+          binder2nd<__gnu_parallel::equal_to<value_type, const T&> >
+            comp(__gnu_parallel::equal_to<value_type, const T&>(), val);
           return __gnu_parallel::find_template(begin, end, begin, comp,
                                                __gnu_parallel::
                                                find_if_selector()).first;
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/std/mutex gcc-4.4.0/libstdc++-v3/include/std/mutex
--- gcc-4.4.0.orig/libstdc++-v3/include/std/mutex	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/std/mutex	2009-05-05 14:44:27.000000000 -0700
@@ -729,8 +729,11 @@
 #else
   extern function<void()> __once_functor;
 
-  extern unique_lock<mutex>&
-  __get_once_functor_lock();
+  extern void
+  __set_once_functor_lock_ptr(unique_lock<mutex>*);
+
+  extern mutex&
+  __get_once_mutex();
 #endif
 
   extern "C" void __once_proxy();
@@ -745,16 +748,16 @@
       __once_callable = &__bound_functor;
       __once_call = &__once_call_impl<decltype(__bound_functor)>;
 #else
-      unique_lock<mutex>& __functor_lock = __get_once_functor_lock();
-      __functor_lock.lock();
+      unique_lock<mutex> __functor_lock(__get_once_mutex());
       __once_functor = bind(__f, __args...);
+      __set_once_functor_lock_ptr(&__functor_lock);
 #endif
 
       int __e = __gthread_once(&(__once._M_once), &__once_proxy);
 
 #ifndef _GLIBCXX_HAVE_TLS
       if (__functor_lock)
-	__functor_lock.unlock();
+        __set_once_functor_lock_ptr(0);
 #endif
 
       if (__e)
diff -Naur gcc-4.4.0.orig/libstdc++-v3/include/std/system_error gcc-4.4.0/libstdc++-v3/include/std/system_error
--- gcc-4.4.0.orig/libstdc++-v3/include/std/system_error	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/include/std/system_error	2009-04-28 03:32:22.000000000 -0700
@@ -51,10 +51,6 @@
   template<typename _Tp>
     struct is_error_code_enum : public false_type { };
 
-  template<> 
-    struct is_error_code_enum<errc>
-    : public true_type { };
-
   /// is_error_condition_enum
   template<typename _Tp>
     struct is_error_condition_enum : public false_type { };
@@ -108,12 +104,14 @@
   const error_category& system_category();
   const error_category& generic_category();
 
+  error_code make_error_code(errc);
+
   /// error_code
   // Implementation-specific error identification
   struct error_code
   {
     error_code()
-      : _M_value(0), _M_cat(&system_category()) { }
+    : _M_value(0), _M_cat(&system_category()) { }
 
     error_code(int __v, const error_category& __cat)
     : _M_value(__v), _M_cat(&__cat) { }
@@ -121,8 +119,7 @@
     template<typename _ErrorCodeEnum>
       error_code(_ErrorCodeEnum __e,
       typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type* = 0)
-      : _M_value(static_cast<int>(__e)), _M_cat(&generic_category())
-      { }
+      { *this = make_error_code(__e); }
 
     void 
     assign(int __v, const error_category& __cat)
@@ -140,10 +137,7 @@
       typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
 			 error_code&>::type
       operator=(_ErrorCodeEnum __e)
-      {
-	assign(static_cast<int>(__e), generic_category());
-	return *this;
-      }
+      { return *this = make_error_code(__e); }
 
     int
     value() const { return _M_value; }
@@ -192,12 +186,14 @@
     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
     { return (__os << __e.category().name() << ':' << __e.value()); }
 
+  error_condition make_error_condition(errc);
 
   /// error_condition
   // Portable error identification
   struct error_condition 
   {
-    error_condition() : _M_value(0), _M_cat(&generic_category()) { }
+    error_condition()
+    : _M_value(0), _M_cat(&generic_category()) { }
 
     error_condition(int __v, const error_category& __cat)     
     : _M_value(__v), _M_cat(&__cat) { }
@@ -206,7 +202,7 @@
       error_condition(_ErrorConditionEnum __e,
 		      typename enable_if<is_error_condition_enum
 		                      <_ErrorConditionEnum>::value>::type* = 0)
-	: _M_value(static_cast<int>(__e)), _M_cat(&generic_category()) { }
+      { *this = make_error_condition(__e); }
 
     void
     assign(int __v, const error_category& __cat)
@@ -220,10 +216,7 @@
       typename enable_if<is_error_condition_enum
 			 <_ErrorConditionEnum>::value, error_condition&>::type
       operator=(_ErrorConditionEnum __e)
-      {
-	assign(static_cast<int>(__e), generic_category());
-	return *this;
-      }
+      { return *this = make_error_condition(__e); }
 
     void 
     clear()
diff -Naur gcc-4.4.0.orig/libstdc++-v3/libsupc++/eh_ptr.cc gcc-4.4.0/libstdc++-v3/libsupc++/eh_ptr.cc
--- gcc-4.4.0.orig/libstdc++-v3/libsupc++/eh_ptr.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/libsupc++/eh_ptr.cc	2009-06-03 03:37:32.000000000 -0700
@@ -26,6 +26,8 @@
 
 #ifdef _GLIBCXX_ATOMIC_BUILTINS_4
 
+#define _GLIBCXX_EH_PTR_COMPAT
+
 #include <exception>
 #include <exception_ptr.h>
 #include "unwind-cxx.h"
@@ -127,6 +129,7 @@
 }
 
 
+// Retained for compatibility with CXXABI_1.3.
 bool
 std::__exception_ptr::exception_ptr::operator!() const throw()
 {
@@ -134,6 +137,7 @@
 }
 
 
+// Retained for compatibility with CXXABI_1.3.
 std::__exception_ptr::exception_ptr::operator __safe_bool() const throw()
 {
   return _M_exception_object ? &exception_ptr::_M_safe_bool_dummy : 0;
@@ -235,4 +239,6 @@
   std::terminate ();
 }
 
+#undef _GLIBCXX_EH_PTR_COMPAT
+
 #endif
diff -Naur gcc-4.4.0.orig/libstdc++-v3/libsupc++/exception_ptr.h gcc-4.4.0/libstdc++-v3/libsupc++/exception_ptr.h
--- gcc-4.4.0.orig/libstdc++-v3/libsupc++/exception_ptr.h	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/libsupc++/exception_ptr.h	2009-06-03 03:37:32.000000000 -0700
@@ -141,8 +141,11 @@
       }
 #endif
 
+#ifdef _GLIBCXX_EH_PTR_COMPAT
+      // Retained for compatibility with CXXABI_1.3.
       bool operator!() const throw();
       operator __safe_bool() const throw();
+#endif
 
       friend bool 
       operator==(const exception_ptr&, const exception_ptr&) throw();
diff -Naur gcc-4.4.0.orig/libstdc++-v3/scripts/create_testsuite_files gcc-4.4.0/libstdc++-v3/scripts/create_testsuite_files
--- gcc-4.4.0.orig/libstdc++-v3/scripts/create_testsuite_files	2006-10-09 16:53:35.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/scripts/create_testsuite_files	2009-04-30 12:04:31.000000000 -0700
@@ -32,7 +32,7 @@
 # This is the ugly version of "everything but the current directory".  It's
 # what has to happen when find(1) doesn't support -mindepth, or -xtype.
 dlist=`echo [0-9][0-9]*`
-dlist="$dlist abi backward ext performance thread tr1"
+dlist="$dlist abi backward ext performance tr1"
 find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
 find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
 cat  $tmp.01 $tmp.02 | sort > $tmp.1
diff -Naur gcc-4.4.0.orig/libstdc++-v3/scripts/run_doxygen gcc-4.4.0/libstdc++-v3/scripts/run_doxygen
--- gcc-4.4.0.orig/libstdc++-v3/scripts/run_doxygen	2009-02-19 00:15:15.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/scripts/run_doxygen	2009-04-29 12:37:30.000000000 -0700
@@ -1,7 +1,8 @@
 #!/bin/bash
 
 # Runs doxygen and massages the output files.
-# Copyright (C) 2001, 2002, 2003, 2004, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003, 2004, 2008, 2009 
+# Free Software Foundation, Inc.
 #
 # Synopsis:  run_doxygen --mode=[html|man|xml] --host_alias=<alias> \
 #                        v3srcdir  v3builddir
@@ -225,11 +226,9 @@
 
 # man pages are for functions/types/other entities, not source files
 # directly.  who the heck would type "man foo.h" anyhow?
-#find . -name "[a-z]*" -a ! -name "std_*" -print | xargs rm
+find . -name "[a-z]*" -a ! -name "std_*" -print | xargs rm
 rm -f *.h.3 *.hpp.3 *config* *.cc.3 *.tcc.3 *_t.3
-rm ext_*.3
-rm tr1_*.3
-rm debug_*.3
+#rm ext_*.3 tr1_*.3 debug_*.3
 
 # this is used to examine what we would have deleted, for debugging
 #mkdir trash
@@ -254,18 +253,18 @@
 # Some of the pages for generated modules have text that confuses certain
 # implementations of man(1), e.g., Linux's.  We need to have another top-level
 # *roff tag to /stop/ the .SH NAME entry.
-#problematic=`egrep --files-without-match '^\.SH SYNOPSIS' [A-Z]*.3`
-
+problematic=`egrep --files-without-match '^\.SH SYNOPSIS' [A-Z]*.3`
 #problematic='Containers.3 Sequences.3 Assoc_containers.3 Iterator_types.3'
-#for f in $problematic; do
-#    sed '/^\.SH NAME/{
-#n
-#a\
-#\
-#.SH SYNOPSIS
-#    }' $f > TEMP
-#    mv TEMP $f
-#done
+
+for f in $problematic; do
+    sed '/^\.SH NAME/{
+n
+a\
+\
+.SH SYNOPSIS
+    }' $f > TEMP
+    mv TEMP $f
+done
 
 # Also, break this (generated) line up.  It's ugly as sin.
 problematic=`grep -l '[^^]Definition at line' *.3`
@@ -320,7 +319,10 @@
     newname=`echo $f | sed 's/^__atomic2_/std::__atomic2::/'`
     mv $f $newname
 done
-
+for f in __cxxabiv1_*; do
+    newname=`echo $f | sed 's/^__cxxabiv1_/abi::/'`
+    mv $f $newname
+done
 
 # Generic removal bits, where there are things in the generated man
 # pages that need to be killed.
diff -Naur gcc-4.4.0.orig/libstdc++-v3/src/math_stubs_long_double.cc gcc-4.4.0/libstdc++-v3/src/math_stubs_long_double.cc
--- gcc-4.4.0.orig/libstdc++-v3/src/math_stubs_long_double.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/src/math_stubs_long_double.cc	2009-05-07 00:03:17.000000000 -0700
@@ -70,6 +70,14 @@
   }
 #endif
 
+#ifndef _GLIBCXX_HAVE_CEILL
+  long double
+  ceill(long double x)
+  {
+    return ceil((double) x);
+  }
+#endif
+
 #ifndef _GLIBCXX_HAVE_COSL
   long double
   cosl(long double x)
diff -Naur gcc-4.4.0.orig/libstdc++-v3/src/mutex.cc gcc-4.4.0/libstdc++-v3/src/mutex.cc
--- gcc-4.4.0.orig/libstdc++-v3/src/mutex.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/src/mutex.cc	2009-05-05 14:44:27.000000000 -0700
@@ -28,11 +28,11 @@
 #ifndef _GLIBCXX_HAVE_TLS
 namespace
 {
-  std::mutex&
-  get_once_mutex()
+  inline std::unique_lock<std::mutex>*&
+  __get_once_functor_lock_ptr()
   {
-    static std::mutex once_mutex;
-    return once_mutex;
+    static std::unique_lock<std::mutex>* __once_functor_lock_ptr = 0;
+    return __once_functor_lock_ptr;
   }
 }
 #endif
@@ -55,10 +55,25 @@
   template class function<void()>;
   function<void()> __once_functor;
 
+  mutex&
+  __get_once_mutex()
+  {
+    static mutex once_mutex;
+    return once_mutex;
+  }
+
+  // code linked against ABI 3.4.12 and later uses this
+  void
+  __set_once_functor_lock_ptr(unique_lock<mutex>* __ptr)
+  {
+    __get_once_functor_lock_ptr() = __ptr;
+  }
+
+  // unsafe - retained for compatibility with ABI 3.4.11
   unique_lock<mutex>&
   __get_once_functor_lock()
   {
-    static unique_lock<mutex> once_functor_lock(get_once_mutex(), defer_lock);
+    static unique_lock<mutex> once_functor_lock(__get_once_mutex(), defer_lock);
     return once_functor_lock;
   }
 #endif
@@ -69,7 +84,14 @@
     {
 #ifndef _GLIBCXX_HAVE_TLS
       function<void()> __once_call = std::move(__once_functor);
-      __get_once_functor_lock().unlock();
+      if (unique_lock<mutex>* __lock = __get_once_functor_lock_ptr())
+      {
+        // caller is using new ABI and provided lock ptr
+        __get_once_functor_lock_ptr() = 0;
+        __lock->unlock();
+      }
+      else
+        __get_once_functor_lock().unlock();  // global lock
 #endif
       __once_call();
     }
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/18_support/exception_ptr/40296.cc gcc-4.4.0/libstdc++-v3/testsuite/18_support/exception_ptr/40296.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/18_support/exception_ptr/40296.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/18_support/exception_ptr/40296.cc	2009-06-03 03:37:32.000000000 -0700
@@ -0,0 +1,30 @@
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <exception>
+
+// libstdc++/40296
+bool test01()
+{
+  std::exception_ptr p;
+
+  return (p == 0);
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/18_support/exception_ptr/current_exception.cc gcc-4.4.0/libstdc++-v3/testsuite/18_support/exception_ptr/current_exception.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/18_support/exception_ptr/current_exception.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/18_support/exception_ptr/current_exception.cc	2009-06-03 03:37:32.000000000 -0700
@@ -31,7 +31,7 @@
   using namespace std;
 
   exception_ptr ep = current_exception();
-  VERIFY( !ep );
+  VERIFY( ep == 0 );
 }
 
 void test02()
@@ -43,7 +43,7 @@
     throw 0;
   } catch(...) {
     exception_ptr ep = current_exception();
-    VERIFY( ep );
+    VERIFY( ep != 0 );
   }
 }
 
@@ -56,7 +56,7 @@
     throw exception();
   } catch(std::exception&) {
     exception_ptr ep = current_exception();
-    VERIFY( ep );
+    VERIFY( ep != 0 );
   }
 }
 
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_category/cons/copy_neg.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_category/cons/copy_neg.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_category/cons/copy_neg.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_category/cons/copy_neg.cc	2009-04-28 03:32:22.000000000 -0700
@@ -32,7 +32,7 @@
   return 0;
 }
 
-// { dg-error "deleted function" "" { target *-*-* } 76 }
+// { dg-error "deleted function" "" { target *-*-* } 72 }
 // { dg-error "used here" "" { target *-*-* } 31 }
 // { dg-error "first required here" "" { target *-*-* } 30 }
 // { dg-excess-errors "copy constructor" }
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/1.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/1.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/1.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/1.cc	2009-04-28 03:32:22.000000000 -0700
@@ -37,7 +37,7 @@
   VERIFY( e2.category() == cat );
 
   // 3
-  std::error_code e3(std::errc::operation_not_supported);
+  std::error_code e3(std::make_error_code(std::errc::operation_not_supported));
   VERIFY( e3.value() == int(std::errc::operation_not_supported) );
   VERIFY( e3.category() == std::generic_category() );
 
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/39882.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/39882.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/39882.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/cons/39882.cc	2009-04-28 03:32:22.000000000 -0700
@@ -0,0 +1,60 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <system_error>
+#include <testsuite_hooks.h>
+
+enum my_errc { my_err = 0 };
+
+class my_error_category_impl
+: public std::error_category
+{
+public:
+  const char* name() const { return ""; }
+  std::string message(int) const { return ""; }
+} my_error_category_instance;
+
+std::error_code
+make_error_code(my_errc e)
+{
+  return std::error_code(static_cast<int>(e),
+			 my_error_category_instance);
+}
+
+namespace std
+{
+  template<>
+    struct is_error_code_enum<my_errc>
+    : public true_type {};
+}
+
+// libstdc++/39882
+void test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::error_code ec1(my_err);
+  VERIFY( ec1 == make_error_code(my_err) );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/modifiers/39882.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/modifiers/39882.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/modifiers/39882.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/modifiers/39882.cc	2009-04-28 03:32:22.000000000 -0700
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <system_error>
+#include <testsuite_hooks.h>
+
+enum my_errc { my_err = 0 };
+
+class my_error_category_impl
+: public std::error_category
+{
+public:
+  const char* name() const { return ""; }
+  std::string message(int) const { return ""; }
+} my_error_category_instance;
+
+std::error_code
+make_error_code(my_errc e)
+{
+  return std::error_code(static_cast<int>(e),
+			 my_error_category_instance);
+}
+
+namespace std
+{
+  template<>
+    struct is_error_code_enum<my_errc>
+    : public true_type {};
+}
+
+// libstdc++/39882
+void test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::error_code ec2;
+  ec2 = my_err;
+  VERIFY( ec2 == make_error_code(my_err) );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/bool.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/bool.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/bool.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/bool.cc	2009-04-28 03:32:22.000000000 -0700
@@ -34,7 +34,7 @@
     }
 
   // 2
-  std::error_code e2(std::errc::operation_not_supported);
+  std::error_code e2(std::make_error_code(std::errc::operation_not_supported));
   if (e2)
     {
       VERIFY( true );
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/equal.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/equal.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/equal.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/equal.cc	2009-04-28 03:32:22.000000000 -0700
@@ -27,7 +27,7 @@
   bool test __attribute__((unused)) = true;
 
   std::error_code e1;
-  std::error_code e2(std::errc::operation_not_supported);
+  std::error_code e2(std::make_error_code(std::errc::operation_not_supported));
 
   VERIFY( e1 == e1 );
   VERIFY( !(e1 == e2) );
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/not_equal.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/not_equal.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/not_equal.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_code/operators/not_equal.cc	2009-04-28 03:32:22.000000000 -0700
@@ -27,7 +27,7 @@
   bool test __attribute__((unused)) = true;
 
   std::error_code e1;
-  std::error_code e2(std::errc::operation_not_supported);
+  std::error_code e2(std::make_error_code(std::errc::operation_not_supported));
 
   VERIFY( !(e1 != e1) );
   VERIFY( e1 != e2 );
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_condition/cons/39881.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_condition/cons/39881.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_condition/cons/39881.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_condition/cons/39881.cc	2009-04-28 03:32:22.000000000 -0700
@@ -0,0 +1,60 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <system_error>
+#include <testsuite_hooks.h>
+
+enum my_errc { my_err = 0 };
+
+class my_error_category_impl
+: public std::error_category
+{
+public:
+  const char* name() const { return ""; }
+  std::string message(int) const { return ""; }
+} my_error_category_instance;
+
+std::error_condition
+make_error_condition(my_errc e)
+{
+  return std::error_condition(static_cast<int>(e),
+			      my_error_category_instance);
+}
+
+namespace std
+{
+  template<>
+    struct is_error_condition_enum<my_errc>
+    : public true_type { };
+}
+
+// libstdc++/39881
+void test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::error_condition ec1(my_err);
+  VERIFY( ec1 == make_error_condition(my_err) );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_condition/modifiers/39881.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_condition/modifiers/39881.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/error_condition/modifiers/39881.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/error_condition/modifiers/39881.cc	2009-04-28 03:32:22.000000000 -0700
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <system_error>
+#include <testsuite_hooks.h>
+
+enum my_errc { my_err = 0 };
+
+class my_error_category_impl
+: public std::error_category
+{
+public:
+  const char* name() const { return ""; }
+  std::string message(int) const { return ""; }
+} my_error_category_instance;
+
+std::error_condition
+make_error_condition(my_errc e)
+{
+  return std::error_condition(static_cast<int>(e),
+			      my_error_category_instance);
+}
+
+namespace std
+{
+  template<>
+    struct is_error_condition_enum<my_errc>
+    : public true_type { };
+}
+
+// libstdc++/39881
+void test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::error_condition ec2;
+  ec2 = my_err;
+  VERIFY( ec2 == make_error_condition(my_err) );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/system_error/39880.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/system_error/39880.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/system_error/39880.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/system_error/39880.cc	2009-04-28 03:32:22.000000000 -0700
@@ -0,0 +1,29 @@
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <system_error>
+
+// libstdc++/39880
+void test01()
+{
+  std::error_code ec;
+  if (ec == std::errc::not_supported)
+    { }
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc	2009-04-28 03:32:22.000000000 -0700
@@ -26,7 +26,8 @@
 {
   bool test __attribute__((unused)) = true;
   const std::string s("too late: boulangerie out of pain au raisin");
-  const std::error_code e(std::errc::operation_not_supported);
+  const std::error_code
+    e(std::make_error_code(std::errc::operation_not_supported));
 
   // 1
   {
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/system_error/what-4.cc gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/system_error/what-4.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/19_diagnostics/system_error/what-4.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/19_diagnostics/system_error/what-4.cc	2009-04-28 03:32:22.000000000 -0700
@@ -31,7 +31,8 @@
   bool test __attribute__((unused)) = true;
   std::string s("after nine thirty, this request cannot be met");
 
-  std::system_error obj = std::system_error(std::errc::invalid_argument, s);
+  std::system_error obj =
+    std::system_error(std::make_error_code(std::errc::invalid_argument), s);
   std::string s1(obj.what());
   std::string s2(obj.what());
   VERIFY( s1 == s2 );
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/22_locale/num_get/get/char/39802.cc gcc-4.4.0/libstdc++-v3/testsuite/22_locale/num_get/get/char/39802.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/22_locale/num_get/get/char/39802.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/22_locale/num_get/get/char/39802.cc	2009-04-21 13:26:46.000000000 -0700
@@ -0,0 +1,77 @@
+// Copyright (C) 2009 Free Software Foundation
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 22.2.2.1.1  num_get members
+
+#include <locale>
+#include <sstream>
+#include <limits>
+#include <testsuite_hooks.h>
+
+// libstdc++/39802
+void test01()
+{
+  using namespace std;
+  typedef istreambuf_iterator<char> iterator_type;
+  
+  bool test __attribute__((unused)) = true;
+
+  stringstream ss;
+  const num_get<char>& ng = use_facet<num_get<char> >(ss.getloc()); 
+  ios_base::iostate err;
+  iterator_type end;
+  const string empty;
+
+  unsigned long ul0 = 1;
+  const unsigned long ul1 = numeric_limits<unsigned long>::max();
+
+  ss << "-0";
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == ios_base::eofbit );
+  VERIFY( ul0 == 0 );
+
+  ss.clear();
+  ss.str(empty);
+  ss << "-1";
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == ios_base::eofbit );
+  VERIFY( ul0 == ul1 );
+
+  ss.clear();
+  ss.str(empty);
+  ss << '-' << ul1;
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == ios_base::eofbit );
+  VERIFY( ul0 == 1 );
+
+  ss.clear();
+  ss.str(empty);
+  ss << '-' << ul1 << '0';
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == (ios_base::eofbit | ios_base::failbit) );
+  VERIFY( ul0 == ul1 );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/39802.cc gcc-4.4.0/libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/39802.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/39802.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/39802.cc	2009-04-21 13:26:46.000000000 -0700
@@ -0,0 +1,77 @@
+// Copyright (C) 2009 Free Software Foundation
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 22.2.2.1.1  num_get members
+
+#include <locale>
+#include <sstream>
+#include <limits>
+#include <testsuite_hooks.h>
+
+// libstdc++/39802
+void test01()
+{
+  using namespace std;
+  typedef istreambuf_iterator<wchar_t> iterator_type;
+  
+  bool test __attribute__((unused)) = true;
+
+  wstringstream ss;
+  const num_get<wchar_t>& ng = use_facet<num_get<wchar_t> >(ss.getloc()); 
+  ios_base::iostate err;
+  iterator_type end;
+  const wstring empty;
+
+  unsigned long ul0 = 1;
+  const unsigned long ul1 = numeric_limits<unsigned long>::max();
+
+  ss << L"-0";
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == ios_base::eofbit );
+  VERIFY( ul0 == 0 );
+
+  ss.clear();
+  ss.str(empty);
+  ss << L"-1";
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == ios_base::eofbit );
+  VERIFY( ul0 == ul1 );
+
+  ss.clear();
+  ss.str(empty);
+  ss << L'-' << ul1;
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == ios_base::eofbit );
+  VERIFY( ul0 == 1 );
+
+  ss.clear();
+  ss.str(empty);
+  ss << L'-' << ul1 << L'0';
+  err = ios_base::goodbit;
+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);
+  VERIFY( err == (ios_base::eofbit | ios_base::failbit) );
+  VERIFY( ul0 == ul1 );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/23_containers/vector/40192.cc gcc-4.4.0/libstdc++-v3/testsuite/23_containers/vector/40192.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/23_containers/vector/40192.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/23_containers/vector/40192.cc	2009-05-18 16:16:48.000000000 -0700
@@ -0,0 +1,28 @@
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+
+// libstdc++/40192
+
+#include <vector>
+
+void test01()
+{
+  typedef float float4[4];
+  std::vector<float4> vals;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/25_algorithms/find/39546.cc gcc-4.4.0/libstdc++-v3/testsuite/25_algorithms/find/39546.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/25_algorithms/find/39546.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/25_algorithms/find/39546.cc	2009-05-12 07:57:35.000000000 -0700
@@ -0,0 +1,43 @@
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 25.3.1 algorithms, find()
+
+#include <vector>
+#include <string>
+#include <algorithm>
+#include <testsuite_hooks.h>
+
+// libstdc++/39546
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::vector<std::string> dict;
+  dict.push_back("one");
+  dict.push_back("two");
+  dict.push_back("three");
+
+  VERIFY( std::find(dict.begin(), dict.end(), "two") == dict.begin() + 1 );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/error_code.cc gcc-4.4.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/error_code.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/error_code.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/error_code.cc	2009-04-28 03:32:22.000000000 -0700
@@ -32,7 +32,7 @@
 
   char buf[64];
   error_code e1;
-  error_code e2(errc::bad_address);
+  error_code e2(make_error_code(errc::bad_address));
   string s, s1, s2;
 
   {
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc gcc-4.4.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc	2009-04-28 03:32:22.000000000 -0700
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++0x" }
 
-// Copyright (C) 2007, 2009 Free Software Foundation
+// Copyright (C) 2007, 2008, 2009 Free Software Foundation
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -32,7 +32,7 @@
 
   wchar_t buf[64];
   error_code e1;
-  error_code e2(errc::bad_address);
+  error_code e2(make_error_code(errc::bad_address));
   wstring s, s1, s2;
 
   {
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/30_threads/call_once/39909.cc gcc-4.4.0/libstdc++-v3/testsuite/30_threads/call_once/39909.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/30_threads/call_once/39909.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/30_threads/call_once/39909.cc	2009-05-05 14:44:27.000000000 -0700
@@ -0,0 +1,56 @@
+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }
+// { dg-options " -std=gnu++0x -pthread" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }
+// { dg-options " -std=gnu++0x -pthreads" { target *-*-solaris* } }
+// { dg-options " -std=gnu++0x " { target *-*-cygwin *-*-darwin* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+
+#include <mutex>
+#include <thread>
+#include <testsuite_hooks.h>
+
+std::once_flag flag;
+int value = 0;
+
+struct Inc { void operator()() const { ++value; } };
+
+struct Func
+{
+   void operator()() const
+   {
+       Inc inc;
+       for (int i = 0; i < 10000;  ++i)
+           std::call_once(flag, inc);
+   }
+};
+
+int main()
+{
+   Func f;
+   std::thread t1(f);
+   std::thread t2(f);
+   std::thread t3(f);
+   t1.join();
+   t2.join();
+   t3.join();
+   VERIFY( value == 1 );
+   return 0;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/30_threads/unique_lock/locking/2.cc gcc-4.4.0/libstdc++-v3/testsuite/30_threads/unique_lock/locking/2.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/30_threads/unique_lock/locking/2.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/30_threads/unique_lock/locking/2.cc	2009-04-28 03:32:22.000000000 -0700
@@ -44,7 +44,8 @@
         }
       catch (const std::system_error& ex)
         {
-	  VERIFY( ex.code() == std::error_code(std::errc::operation_not_permitted) );
+	  VERIFY( ex.code() == std::make_error_code
+		  (std::errc::operation_not_permitted) );
         }
       catch (...)
         {
@@ -80,8 +81,8 @@
 	}
       catch (const std::system_error& ex)
 	{
-	  VERIFY( ex.code() == std::error_code(
-		    std::errc::resource_deadlock_would_occur) );
+	  VERIFY( ex.code() == std::make_error_code
+		  (std::errc::resource_deadlock_would_occur) );
 	}
       catch (...)
 	{
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/ext/rope/40299.cc gcc-4.4.0/libstdc++-v3/testsuite/ext/rope/40299.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/ext/rope/40299.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-4.4.0/libstdc++-v3/testsuite/ext/rope/40299.cc	2009-06-02 02:06:45.000000000 -0700
@@ -0,0 +1,27 @@
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <ext/rope>
+
+// libstdc++/40299
+void test01()
+{
+  __gnu_cxx::crope asdf;
+}
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/lib/libstdc++.exp gcc-4.4.0/libstdc++-v3/testsuite/lib/libstdc++.exp
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/lib/libstdc++.exp	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/lib/libstdc++.exp	2009-05-21 04:30:55.000000000 -0700
@@ -402,8 +402,7 @@
     # Flag setting based on type argument.
     if { $type == "executable" } {
 	# Link the support objects into executables.
-        set cxx_final [concat $cxx_final $cxxldflags]
-	lappend options "additional_flags=./libtestc++.a"
+	lappend options "additional_flags=./libtestc++.a $cxxldflags"
     } else {
 	if { $type == "sharedlib" } {
 	    # Don't link in anything.
diff -Naur gcc-4.4.0.orig/libstdc++-v3/testsuite/util/testsuite_abi.cc gcc-4.4.0/libstdc++-v3/testsuite/util/testsuite_abi.cc
--- gcc-4.4.0.orig/libstdc++-v3/testsuite/util/testsuite_abi.cc	2009-04-09 16:23:07.000000000 -0700
+++ gcc-4.4.0/libstdc++-v3/testsuite/util/testsuite_abi.cc	2009-05-05 14:44:27.000000000 -0700
@@ -183,6 +183,7 @@
       known_versions.push_back("GLIBCXX_3.4.9");
       known_versions.push_back("GLIBCXX_3.4.10");
       known_versions.push_back("GLIBCXX_3.4.11");
+      known_versions.push_back("GLIBCXX_3.4.12");
       known_versions.push_back("GLIBCXX_LDBL_3.4");
       known_versions.push_back("GLIBCXX_LDBL_3.4.7");
       known_versions.push_back("GLIBCXX_LDBL_3.4.10");
